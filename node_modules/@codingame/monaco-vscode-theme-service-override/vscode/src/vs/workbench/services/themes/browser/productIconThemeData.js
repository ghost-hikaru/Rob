import * as nls from 'monaco-editor/esm/vs/nls.js';
import * as path from 'monaco-editor/esm/vs/base/common/path.js';
import * as resources from 'monaco-editor/esm/vs/base/common/resources.js';
import * as json from 'monaco-editor/esm/vs/base/common/json.js';
import { ThemeSettingDefaults, ExtensionData } from 'vscode/vscode/vs/workbench/services/themes/common/workbenchThemeService';
import { getParseErrorMessage } from 'vscode/vscode/vs/base/common/jsonErrorMessages';
import { fontIdRegex, fontWeightRegex, fontStyleRegex, fontFormatRegex } from '../common/productIconThemeSchema.js';
import { isObject, isString } from 'monaco-editor/esm/vs/base/common/types.js';
import { IconFontDefinition, getIconRegistry } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';

const DEFAULT_PRODUCT_ICON_THEME_ID = '';
class ProductIconThemeData {
    static { this.STORAGE_KEY = 'productIconThemeData'; }
    constructor(id, label, settingsId) {
        this.iconThemeDocument = { iconDefinitions: ( new Map()) };
        this.id = id;
        this.label = label;
        this.settingsId = settingsId;
        this.isLoaded = false;
    }
    getIcon(iconContribution) {
        return _resolveIconDefinition(iconContribution, this.iconThemeDocument);
    }
    ensureLoaded(fileService, logService) {
        return !this.isLoaded ? this.load(fileService, logService) : Promise.resolve(this.styleSheetContent);
    }
    reload(fileService, logService) {
        return this.load(fileService, logService);
    }
    async load(fileService, logService) {
        const location = this.location;
        if (!location) {
            return Promise.resolve(this.styleSheetContent);
        }
        const warnings = [];
        this.iconThemeDocument = await _loadProductIconThemeDocument(fileService, location, warnings);
        this.isLoaded = true;
        if (warnings.length) {
            logService.error(( nls.localizeWithPath(
                'vs/workbench/services/themes/browser/productIconThemeData',
                'error.parseicondefs',
                "Problems processing product icons definitions in {0}:\n{1}",
                ( location.toString()),
                warnings.join('\n')
            )));
        }
        return this.styleSheetContent;
    }
    static fromExtensionTheme(iconTheme, iconThemeLocation, extensionData) {
        const id = extensionData.extensionId + '-' + iconTheme.id;
        const label = iconTheme.label || path.basename(iconTheme.path);
        const settingsId = iconTheme.id;
        const themeData = ( new ProductIconThemeData(id, label, settingsId));
        themeData.description = iconTheme.description;
        themeData.location = iconThemeLocation;
        themeData.extensionData = extensionData;
        themeData.watch = iconTheme._watch;
        themeData.isLoaded = false;
        return themeData;
    }
    static createUnloadedTheme(id) {
        const themeData = ( new ProductIconThemeData(id, '', '__' + id));
        themeData.isLoaded = false;
        themeData.extensionData = undefined;
        themeData.watch = false;
        return themeData;
    }
    static { this._defaultProductIconTheme = null; }
    static get defaultTheme() {
        let themeData = ProductIconThemeData._defaultProductIconTheme;
        if (!themeData) {
            themeData = ProductIconThemeData._defaultProductIconTheme = ( new ProductIconThemeData(DEFAULT_PRODUCT_ICON_THEME_ID, ( nls.localizeWithPath(
                'vs/workbench/services/themes/browser/productIconThemeData',
                'defaultTheme',
                'Default'
            )), ThemeSettingDefaults.PRODUCT_ICON_THEME));
            themeData.isLoaded = true;
            themeData.extensionData = undefined;
            themeData.watch = false;
        }
        return themeData;
    }
    static fromStorageData(storageService) {
        const input = storageService.get(ProductIconThemeData.STORAGE_KEY, 0 );
        if (!input) {
            return undefined;
        }
        try {
            const data = JSON.parse(input);
            const theme = ( new ProductIconThemeData('', '', ''));
            for (const key in data) {
                switch (key) {
                    case 'id':
                    case 'label':
                    case 'description':
                    case 'settingsId':
                    case 'styleSheetContent':
                    case 'watch':
                        theme[key] = data[key];
                        break;
                    case 'location':
                        break;
                    case 'extensionData':
                        theme.extensionData = ExtensionData.fromJSONObject(data.extensionData);
                        break;
                }
            }
            const { iconDefinitions, iconFontDefinitions } = data;
            if (Array.isArray(iconDefinitions) && isObject(iconFontDefinitions)) {
                const restoredIconDefinitions = ( new Map());
                for (const entry of iconDefinitions) {
                    const { id, fontCharacter, fontId } = entry;
                    if (isString(id) && isString(fontCharacter)) {
                        if (isString(fontId)) {
                            const iconFontDefinition = IconFontDefinition.fromJSONObject(iconFontDefinitions[fontId]);
                            if (iconFontDefinition) {
                                restoredIconDefinitions.set(id, { fontCharacter, font: { id: fontId, definition: iconFontDefinition } });
                            }
                        }
                        else {
                            restoredIconDefinitions.set(id, { fontCharacter });
                        }
                    }
                }
                theme.iconThemeDocument = { iconDefinitions: restoredIconDefinitions };
            }
            return theme;
        }
        catch (e) {
            return undefined;
        }
    }
    toStorage(storageService) {
        const iconDefinitions = [];
        const iconFontDefinitions = {};
        for (const entry of this.iconThemeDocument.iconDefinitions.entries()) {
            const font = entry[1].font;
            iconDefinitions.push({ id: entry[0], fontCharacter: entry[1].fontCharacter, fontId: font?.id });
            if (font && iconFontDefinitions[font.id] === undefined) {
                iconFontDefinitions[font.id] = IconFontDefinition.toJSONObject(font.definition);
            }
        }
        const data = JSON.stringify({
            id: this.id,
            label: this.label,
            description: this.description,
            settingsId: this.settingsId,
            styleSheetContent: this.styleSheetContent,
            watch: this.watch,
            extensionData: ExtensionData.toJSONObject(this.extensionData),
            iconDefinitions,
            iconFontDefinitions
        });
        storageService.store(ProductIconThemeData.STORAGE_KEY, data, 0 , 1 );
    }
}
function _loadProductIconThemeDocument(fileService, location, warnings) {
    return fileService.readExtensionResource(location).then((content) => {
        const parseErrors = [];
        const contentValue = json.parse(content, parseErrors);
        if (parseErrors.length > 0) {
            return Promise.reject(( new Error(( nls.localizeWithPath(
                'vs/workbench/services/themes/browser/productIconThemeData',
                'error.cannotparseicontheme',
                "Problems parsing product icons file: {0}",
                ( parseErrors.map(e => getParseErrorMessage(e.error))).join(', ')
            )))));
        }
        else if (json.getNodeType(contentValue) !== 'object') {
            return Promise.reject(( new Error(( nls.localizeWithPath(
                'vs/workbench/services/themes/browser/productIconThemeData',
                'error.invalidformat',
                "Invalid format for product icons theme file: Object expected."
            )))));
        }
        else if (!contentValue.iconDefinitions || !Array.isArray(contentValue.fonts) || !contentValue.fonts.length) {
            return Promise.reject(( new Error(( nls.localizeWithPath(
                'vs/workbench/services/themes/browser/productIconThemeData',
                'error.missingProperties',
                "Invalid format for product icons theme file: Must contain iconDefinitions and fonts."
            )))));
        }
        const iconThemeDocumentLocationDirname = resources.dirname(location);
        const sanitizedFonts = ( new Map());
        for (const font of contentValue.fonts) {
            if (isString(font.id) && font.id.match(fontIdRegex)) {
                const fontId = font.id;
                let fontWeight = undefined;
                if (isString(font.weight) && font.weight.match(fontWeightRegex)) {
                    fontWeight = font.weight;
                }
                else {
                    warnings.push(( nls.localizeWithPath(
                        'vs/workbench/services/themes/browser/productIconThemeData',
                        'error.fontWeight',
                        'Invalid font weight in font \'{0}\'. Ignoring setting.',
                        font.id
                    )));
                }
                let fontStyle = undefined;
                if (isString(font.style) && font.style.match(fontStyleRegex)) {
                    fontStyle = font.style;
                }
                else {
                    warnings.push(( nls.localizeWithPath(
                        'vs/workbench/services/themes/browser/productIconThemeData',
                        'error.fontStyle',
                        'Invalid font style in font \'{0}\'. Ignoring setting.',
                        font.id
                    )));
                }
                const sanitizedSrc = [];
                if (Array.isArray(font.src)) {
                    for (const s of font.src) {
                        if (isString(s.path) && isString(s.format) && s.format.match(fontFormatRegex)) {
                            const iconFontLocation = resources.joinPath(iconThemeDocumentLocationDirname, s.path);
                            sanitizedSrc.push({ location: iconFontLocation, format: s.format });
                        }
                        else {
                            warnings.push(( nls.localizeWithPath(
                                'vs/workbench/services/themes/browser/productIconThemeData',
                                'error.fontSrc',
                                'Invalid font source in font \'{0}\'. Ignoring source.',
                                font.id
                            )));
                        }
                    }
                }
                if (sanitizedSrc.length) {
                    sanitizedFonts.set(fontId, { weight: fontWeight, style: fontStyle, src: sanitizedSrc });
                }
                else {
                    warnings.push(( nls.localizeWithPath(
                        'vs/workbench/services/themes/browser/productIconThemeData',
                        'error.noFontSrc',
                        'No valid font source in font \'{0}\'. Ignoring font definition.',
                        font.id
                    )));
                }
            }
            else {
                warnings.push(( nls.localizeWithPath(
                    'vs/workbench/services/themes/browser/productIconThemeData',
                    'error.fontId',
                    'Missing or invalid font id \'{0}\'. Skipping font definition.',
                    font.id
                )));
            }
        }
        const iconDefinitions = ( new Map());
        const primaryFontId = contentValue.fonts[0].id;
        for (const iconId in contentValue.iconDefinitions) {
            const definition = contentValue.iconDefinitions[iconId];
            if (isString(definition.fontCharacter)) {
                const fontId = definition.fontId ?? primaryFontId;
                const fontDefinition = sanitizedFonts.get(fontId);
                if (fontDefinition) {
                    const font = { id: `pi-${fontId}`, definition: fontDefinition };
                    iconDefinitions.set(iconId, { fontCharacter: definition.fontCharacter, font });
                }
                else {
                    warnings.push(( nls.localizeWithPath(
                        'vs/workbench/services/themes/browser/productIconThemeData',
                        'error.icon.font',
                        'Skipping icon definition \'{0}\'. Unknown font.',
                        iconId
                    )));
                }
            }
            else {
                warnings.push(( nls.localizeWithPath(
                    'vs/workbench/services/themes/browser/productIconThemeData',
                    'error.icon.fontCharacter',
                    'Skipping icon definition \'{0}\'. Unknown fontCharacter.',
                    iconId
                )));
            }
        }
        return { iconDefinitions };
    });
}
const iconRegistry = getIconRegistry();
function _resolveIconDefinition(iconContribution, iconThemeDocument) {
    const iconDefinitions = iconThemeDocument.iconDefinitions;
    let definition = iconDefinitions.get(iconContribution.id);
    let defaults = iconContribution.defaults;
    while (!definition && ThemeIcon.isThemeIcon(defaults)) {
        const ic = iconRegistry.getIcon(defaults.id);
        if (ic) {
            definition = iconDefinitions.get(ic.id);
            defaults = ic.defaults;
        }
        else {
            return undefined;
        }
    }
    if (definition) {
        return definition;
    }
    if (!ThemeIcon.isThemeIcon(defaults)) {
        return defaults;
    }
    return undefined;
}

export { DEFAULT_PRODUCT_ICON_THEME_ID, ProductIconThemeData };

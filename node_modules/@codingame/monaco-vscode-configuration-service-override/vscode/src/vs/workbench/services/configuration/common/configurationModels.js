import { equals } from 'monaco-editor/esm/vs/base/common/objects.js';
import { toValuesTree } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { Configuration as Configuration$1, ConfigurationModelParser, ConfigurationModel } from 'monaco-editor/esm/vs/platform/configuration/common/configurationModels.js';
import { isBoolean } from 'monaco-editor/esm/vs/base/common/types.js';
import { distinct } from 'monaco-editor/esm/vs/base/common/arrays.js';

class WorkspaceConfigurationModelParser extends ConfigurationModelParser {
    constructor(name) {
        super(name);
        this._folders = [];
        this._transient = false;
        this._settingsModelParser = ( new ConfigurationModelParser(name));
        this._launchModel = ( new ConfigurationModel());
        this._tasksModel = ( new ConfigurationModel());
    }
    get folders() {
        return this._folders;
    }
    get transient() {
        return this._transient;
    }
    get settingsModel() {
        return this._settingsModelParser.configurationModel;
    }
    get launchModel() {
        return this._launchModel;
    }
    get tasksModel() {
        return this._tasksModel;
    }
    reparseWorkspaceSettings(configurationParseOptions) {
        this._settingsModelParser.reparse(configurationParseOptions);
    }
    getRestrictedWorkspaceSettings() {
        return this._settingsModelParser.restrictedConfigurations;
    }
    doParseRaw(raw, configurationParseOptions) {
        this._folders = (raw['folders'] || []);
        this._transient = isBoolean(raw['transient']) && raw['transient'];
        this._settingsModelParser.parseRaw(raw['settings'], configurationParseOptions);
        this._launchModel = this.createConfigurationModelFrom(raw, 'launch');
        this._tasksModel = this.createConfigurationModelFrom(raw, 'tasks');
        return super.doParseRaw(raw, configurationParseOptions);
    }
    createConfigurationModelFrom(raw, key) {
        const data = raw[key];
        if (data) {
            const contents = toValuesTree(data, message => console.error(`Conflict in settings file ${this._name}: ${message}`));
            const scopedContents = Object.create(null);
            scopedContents[key] = contents;
            const keys = ( ( Object.keys(data)).map(k => `${key}.${k}`));
            return ( new ConfigurationModel(scopedContents, keys, []));
        }
        return ( new ConfigurationModel());
    }
}
class StandaloneConfigurationModelParser extends ConfigurationModelParser {
    constructor(name, scope) {
        super(name);
        this.scope = scope;
    }
    doParseRaw(raw, configurationParseOptions) {
        const contents = toValuesTree(raw, message => console.error(`Conflict in settings file ${this._name}: ${message}`));
        const scopedContents = Object.create(null);
        scopedContents[this.scope] = contents;
        const keys = ( ( Object.keys(raw)).map(key => `${this.scope}.${key}`));
        return { contents: scopedContents, keys, overrides: [] };
    }
}
class Configuration extends Configuration$1 {
    constructor(defaults, policy, application, localUser, remoteUser, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource, _workspace) {
        super(defaults, policy, application, localUser, remoteUser, workspaceConfiguration, folders, memoryConfiguration, memoryConfigurationByResource);
        this._workspace = _workspace;
    }
    getValue(key, overrides = {}) {
        return super.getValue(key, overrides, this._workspace);
    }
    inspect(key, overrides = {}) {
        return super.inspect(key, overrides, this._workspace);
    }
    keys() {
        return ( super.keys(this._workspace));
    }
    compareAndDeleteFolderConfiguration(folder) {
        if (this._workspace && this._workspace.folders.length > 0 && ( this._workspace.folders[0].uri.toString()) === ( folder.toString())) {
            return { keys: [], overrides: [] };
        }
        return super.compareAndDeleteFolderConfiguration(folder);
    }
    compare(other) {
        const compare = (fromKeys, toKeys, overrideIdentifier) => {
            const keys = [];
            keys.push(...toKeys.filter(key => fromKeys.indexOf(key) === -1));
            keys.push(...fromKeys.filter(key => toKeys.indexOf(key) === -1));
            keys.push(...fromKeys.filter(key => {
                if (toKeys.indexOf(key) === -1) {
                    return false;
                }
                if (!equals(this.getValue(key, { overrideIdentifier }), other.getValue(key, { overrideIdentifier }))) {
                    return true;
                }
                return this._workspace && ( this._workspace.folders.some(
                    folder => !equals(this.getValue(key, { resource: folder.uri, overrideIdentifier }), other.getValue(key, { resource: folder.uri, overrideIdentifier }))
                ));
            }));
            return keys;
        };
        const keys = compare(this.allKeys(), other.allKeys());
        const overrides = [];
        const allOverrideIdentifiers = distinct([...this.allOverrideIdentifiers(), ...other.allOverrideIdentifiers()]);
        for (const overrideIdentifier of allOverrideIdentifiers) {
            const keys = compare(this.getAllKeysForOverrideIdentifier(overrideIdentifier), other.getAllKeysForOverrideIdentifier(overrideIdentifier), overrideIdentifier);
            if (keys.length) {
                overrides.push([overrideIdentifier, keys]);
            }
        }
        return { keys, overrides };
    }
}

export { Configuration, StandaloneConfigurationModelParser, WorkspaceConfigurationModelParser };

import { __decorate, __param } from './external/tslib/tslib.es6.js';
import { StandaloneServices, StandaloneKeybindingService } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { ITextResourceConfigurationService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { StandaloneDiffEditor2, StandaloneEditor } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneCodeEditor.js';
import { isObject } from 'monaco-editor/esm/vs/base/common/types.js';
import { distinct, deepClone } from 'monaco-editor/esm/vs/base/common/objects.js';
export { errorHandler } from 'monaco-editor/esm/vs/base/common/errors.js';
export { FoldingModel, setCollapseStateForMatchingLines } from 'monaco-editor/esm/vs/editor/contrib/folding/browser/foldingModel.js';
export { FoldingController } from 'monaco-editor/esm/vs/editor/contrib/folding/browser/folding.js';
export { DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
export { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions as Extensions$2 } from 'monaco-editor/esm/vs/platform/jsonschemas/common/jsonContributionRegistry.js';
import { ICommandService } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
export { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
export { MenuId, MenuRegistry } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
export { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { Extensions as Extensions$3 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { EditorOptionsUtil } from './vscode/src/vs/editor/browser/config/editorConfiguration.js';
export { registerColor } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { VSBuffer } from 'monaco-editor/esm/vs/base/common/buffer.js';
import { JSONValidationExtensionPoint } from './vscode/src/vs/workbench/api/common/jsonValidationExtensionPoint.js';
import { Extensions as Extensions$1 } from './vscode/src/vs/workbench/common/contributions.js';
import { ColorExtensionPoint } from './vscode/src/vs/workbench/services/themes/common/colorExtensionPoint.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { StandaloneQuickInputService } from 'monaco-editor/esm/vs/editor/standalone/browser/quickInput/standaloneQuickInputService.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
export { ContextKeyExpr, RawContextKey } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { Emitter } from 'monaco-editor';
import { createInjectedClass } from './tools/injection.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/workbenchReferenceSearch.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/menuPreventer.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/diffEditorHelper.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/largeFileOptimizations.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/inspectEditorTokens/inspectEditorTokens.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/saveParticipants.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/toggleMinimap.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/toggleMultiCursorModifier.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/toggleRenderControlCharacter.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/toggleWordWrap.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/toggleRenderWhitespace.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/editorLineNumberMenu.js';
import './vscode/src/vs/workbench/contrib/folding/browser/folding.contribution.js';
import './vscode/src/vs/workbench/contrib/inlayHints/browser/inlayHintsAccessibilty.js';
import './vscode/src/vs/workbench/contrib/codeActions/browser/codeActions.contribution.js';
import './vscode/src/vs/workbench/contrib/list/browser/list.contribution.js';
import './vscode/src/vs/workbench/contrib/codeEditor/browser/editorFeatures.js';
let ExtensionPoints = class ExtensionPoints {
    constructor(instantiationService) {
        this.instantiationService = instantiationService;
        this.instantiationService.createInstance(JSONValidationExtensionPoint);
        this.instantiationService.createInstance(ColorExtensionPoint);
    }
};
ExtensionPoints = __decorate([
    ( __param(0, IInstantiationService))
], ExtensionPoints);
( Registry.as(Extensions$1.Workbench)).registerWorkbenchContribution(ExtensionPoints, 1 );
function computeConfiguration(configuration, isDiffEditor, overrides) {
    const editorConfiguration = isObject(configuration.editor) ? deepClone(configuration.editor) : Object.create(null);
    if (isDiffEditor && isObject(configuration.diffEditor)) {
        Object.assign(editorConfiguration, deepClone(configuration.diffEditor));
    }
    Object.assign(editorConfiguration, deepClone(overrides));
    return editorConfiguration;
}
let ConfiguredStandaloneEditor = class ConfiguredStandaloneEditor extends createInjectedClass(StandaloneEditor) {
    constructor(domElement, isDiffEditor, _options = {}, instantiationService, textResourceConfigurationService) {
        const { theme, autoDetectHighContrast, model, value, language, accessibilityHelpUrl, ariaContainerElement, overflowWidgetsDomNode, dimension, ...options } = _options;
        const computedOptions = computeConfiguration(textResourceConfigurationService.getValue(_options.model?.uri), isDiffEditor, options);
        super(instantiationService, domElement, { ...computedOptions, overflowWidgetsDomNode, dimension, theme, autoDetectHighContrast, model, value, language, accessibilityHelpUrl, ariaContainerElement });
        this.isDiffEditor = isDiffEditor;
        this.textResourceConfigurationService = textResourceConfigurationService;
        this.optionsOverrides = {};
        this.lastAppliedEditorOptions = computedOptions;
        this.optionsOverrides = options;
        this._register(textResourceConfigurationService.onDidChangeConfiguration(() => this.updateEditorConfiguration()));
        this._register(this.onDidChangeModelLanguage(() => this.updateEditorConfiguration()));
        this._register(this.onDidChangeModel(() => this.updateEditorConfiguration()));
        this.updateEditorConfiguration();
    }
    updateEditorConfiguration() {
        if (!this.hasModel() || this.textResourceConfigurationService == null) {
            return;
        }
        const resource = this.getModel().uri;
        const configuration = this.textResourceConfigurationService.getValue(resource);
        if (configuration == null) {
            return;
        }
        const editorConfiguration = computeConfiguration(configuration, this.isDiffEditor, this.optionsOverrides);
        let editorSettingsToApply = editorConfiguration;
        if (this.lastAppliedEditorOptions != null) {
            editorSettingsToApply = distinct(this.lastAppliedEditorOptions, editorSettingsToApply);
        }
        if (( Object.keys(editorSettingsToApply)).length > 0) {
            this.lastAppliedEditorOptions = editorConfiguration;
            super.updateOptions(editorSettingsToApply);
        }
    }
    updateOptions(newOptions) {
        this.optionsOverrides ?? (this.optionsOverrides = {});
        const didChange = EditorOptionsUtil.applyUpdate(this.optionsOverrides, newOptions);
        if (!didChange) {
            return;
        }
        this.updateEditorConfiguration();
    }
};
ConfiguredStandaloneEditor = __decorate([
    ( __param(3, IInstantiationService)),
    ( __param(4, ITextResourceConfigurationService))
], ConfiguredStandaloneEditor);
class ConfiguredStandaloneDiffEditor extends StandaloneDiffEditor2 {
    _createInnerEditor(instantiationService, container, options) {
        return instantiationService.createInstance(ConfiguredStandaloneEditor, container, true, options);
    }
}
async function writeFile(uri, content) {
    await StandaloneServices.get(IFileService).writeFile(uri, VSBuffer.fromString(content));
}
async function deleteFile(uri, options) {
    await StandaloneServices.get(IFileService).del(uri, options);
}
async function createModelReference(resource, content) {
    if (content != null) {
        await writeFile(resource, content);
    }
    return (await StandaloneServices.get(ITextModelService).createModelReference(resource));
}
function isDynamicKeybindingService(keybindingService) {
    return keybindingService.registerKeybindingProvider != null;
}
let DelegateStandaloneKeybindingService = class DelegateStandaloneKeybindingService extends StandaloneKeybindingService {
    constructor(delegate, contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService) {
        super(contextKeyService, commandService, telemetryService, notificationService, logService, codeEditorService);
        this.delegate = delegate;
        this._onDidChangeKeybindings = new Emitter();
        this._register(delegate.registerKeybindingProvider({
            provideKeybindings: () => {
                return this.getUserKeybindingItems();
            },
            onDidChangeKeybindings: this._onDidChangeKeybindings.event
        }));
    }
    _getResolver() {
        return this.delegate._getResolver();
    }
    updateResolver() {
        super.updateResolver();
        this._onDidChangeKeybindings.fire();
    }
    resolveKeyboardEvent(keyboardEvent) {
        return this.delegate.resolveKeyboardEvent(keyboardEvent);
    }
    resolveKeybinding(keybinding) {
        return this.delegate.resolveKeybinding(keybinding);
    }
};
DelegateStandaloneKeybindingService = __decorate([
    ( __param(1, IContextKeyService)),
    ( __param(2, ICommandService)),
    ( __param(3, ITelemetryService)),
    ( __param(4, INotificationService)),
    ( __param(5, ILogService)),
    ( __param(6, ICodeEditorService))
], DelegateStandaloneKeybindingService);
let standaloneEditorInstantiationService = null;
function getStandaloneEditorInstantiationService() {
    if (standaloneEditorInstantiationService == null) {
        const serviceCollection = new ServiceCollection();
        serviceCollection.set(IQuickInputService, new SyncDescriptor(StandaloneQuickInputService, undefined, true));
        const keybindingService = StandaloneServices.get(IKeybindingService);
        if (!(keybindingService instanceof StandaloneKeybindingService) && isDynamicKeybindingService(keybindingService)) {
            serviceCollection.set(IKeybindingService, new SyncDescriptor(DelegateStandaloneKeybindingService, [keybindingService], true));
        }
        standaloneEditorInstantiationService = StandaloneServices.get(IInstantiationService).createChild(serviceCollection);
    }
    return standaloneEditorInstantiationService;
}
const createConfiguredEditor = (domElement, options, override) => {
    StandaloneServices.initialize(override ?? {});
    return getStandaloneEditorInstantiationService().createInstance(ConfiguredStandaloneEditor, domElement, false, options);
};
const createConfiguredDiffEditor = (domElement, options, override) => {
    StandaloneServices.initialize(override ?? {});
    return getStandaloneEditorInstantiationService().createInstance(ConfiguredStandaloneDiffEditor, domElement, options);
};
const Extensions = {
    ...Extensions$2,
    ...Extensions$3
};
export { Extensions, createConfiguredDiffEditor, createConfiguredEditor, createModelReference, deleteFile, writeFile };

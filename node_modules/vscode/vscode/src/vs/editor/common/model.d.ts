import { Event } from '../../base/common/event.js';
import { IMarkdownString } from '../../base/common/htmlContent.js';
import { IDisposable } from '../../base/common/lifecycle.js';
import { ThemeColor } from '../../base/common/themables.js';
import * as monaco from 'monaco-editor';
import { ISingleEditOperation } from './core/editOperation.js';
import { Position } from './core/position.js';
import { Range, IRange } from './core/range.js';
import { TextChange } from './core/textChange.js';
import { WordCharacterClassifier } from './core/wordCharacterClassifier.js';
import { IModelContentChange } from './textModelEvents.js';

/**
 * Vertical Lane in the overview ruler of the editor.
 */
declare enum OverviewRulerLane {
    Left = 1,
    Center = 2,
    Right = 4,
    Full = 7
}
/**
 * Vertical Lane in the glyph margin of the editor.
 */
declare enum GlyphMarginLane {
    Left = 1,
    Right = 2
}
/**
 * Position in the minimap to render the decoration.
 */
declare enum MinimapPosition {
    Inline = 1,
    Gutter = 2
}
interface IDecorationOptions {
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    color: string | ThemeColor | undefined;
    /**
     * CSS color to render.
     * e.g.: rgba(100, 100, 100, 0.5) or a color from the color registry
     */
    darkColor?: string | ThemeColor;
}
interface IModelDecorationGlyphMarginOptions {
    /**
     * The position in the glyph margin.
     */
    position: GlyphMarginLane;
}
/**
 * Options for rendering a model decoration in the overview ruler.
 */
interface IModelDecorationOverviewRulerOptions extends IDecorationOptions {
    /**
     * The position in the overview ruler.
     */
    position: OverviewRulerLane;
}
/**
 * Options for rendering a model decoration in the minimap.
 */
interface IModelDecorationMinimapOptions extends IDecorationOptions {
    /**
     * The position in the minimap.
     */
    position: MinimapPosition;
}
/**
 * Options for a model decoration.
 */
interface IModelDecorationOptions {
    /**
     * A debug description that can be used for inspecting model decorations.
     * @internal
     */
    description: string;
    /**
     * Customize the growing behavior of the decoration when typing at the edges of the decoration.
     * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
     */
    stickiness?: TrackedRangeStickiness;
    /**
     * CSS class name describing the decoration.
     */
    className?: string | null;
    /**
     * Indicates whether the decoration should span across the entire line when it continues onto the next line.
     */
    shouldFillLineOnLineBreak?: boolean | null;
    blockClassName?: string | null;
    /**
     * Indicates if this block should be rendered after the last line.
     * In this case, the range must be empty and set to the last line.
     */
    blockIsAfterEnd?: boolean | null;
    blockDoesNotCollapse?: boolean | null;
    blockPadding?: [top: number, right: number, bottom: number, left: number] | null;
    /**
     * Message to be rendered when hovering over the glyph margin decoration.
     */
    glyphMarginHoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Array of MarkdownString to render as the decoration message.
     */
    hoverMessage?: IMarkdownString | IMarkdownString[] | null;
    /**
     * Should the decoration expand to encompass a whole line.
     */
    isWholeLine?: boolean;
    /**
     * Always render the decoration (even when the range it encompasses is collapsed).
     */
    showIfCollapsed?: boolean;
    /**
     * Collapse the decoration if its entire range is being replaced via an edit.
     * @internal
     */
    collapseOnReplaceEdit?: boolean;
    /**
     * Specifies the stack order of a decoration.
     * A decoration with greater stack order is always in front of a decoration with
     * a lower stack order when the decorations are on the same line.
     */
    zIndex?: number;
    /**
     * If set, render this decoration in the overview ruler.
     */
    overviewRuler?: IModelDecorationOverviewRulerOptions | null;
    /**
     * If set, render this decoration in the minimap.
     */
    minimap?: IModelDecorationMinimapOptions | null;
    /**
     * If set, the decoration will be rendered in the glyph margin with this CSS class name.
     */
    glyphMarginClassName?: string | null;
    /**
     * If set and the decoration has {@link glyphMarginClassName} set, render this decoration
     * with the specified {@link IModelDecorationGlyphMarginOptions} in the glyph margin.
     */
    glyphMargin?: IModelDecorationGlyphMarginOptions | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name.
     */
    linesDecorationsClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the lines decorations with this CSS class name, but only for the first line in case of line wrapping.
     */
    firstLineDecorationClassName?: string | null;
    /**
     * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
     */
    marginClassName?: string | null;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     * Please use this only for CSS rules that must impact the text. For example, use `className`
     * to have a background color decoration.
     */
    inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * If set, the decoration will be rendered before the text with this CSS class name.
     */
    beforeContentClassName?: string | null;
    /**
     * If set, the decoration will be rendered after the text with this CSS class name.
     */
    afterContentClassName?: string | null;
    /**
     * If set, text will be injected in the view after the range.
     */
    after?: InjectedTextOptions | null;
    /**
     * If set, text will be injected in the view before the range.
     */
    before?: InjectedTextOptions | null;
    /**
     * If set, this decoration will not be rendered for comment tokens.
     * @internal
    */
    hideInCommentTokens?: boolean | null;
    /**
     * If set, this decoration will not be rendered for string tokens.
     * @internal
    */
    hideInStringTokens?: boolean | null;
}
/**
 * Configures text that is injected into the view without changing the underlying document.
*/
interface InjectedTextOptions {
    /**
     * Sets the text to inject. Must be a single line.
     */
    readonly content: string;
    /**
     * If set, the decoration will be rendered inline with the text with this CSS class name.
     */
    readonly inlineClassName?: string | null;
    /**
     * If there is an `inlineClassName` which affects letter spacing.
     */
    readonly inlineClassNameAffectsLetterSpacing?: boolean;
    /**
     * This field allows to attach data to this injected text.
     * The data can be read when injected texts at a given position are queried.
     */
    readonly attachedData?: unknown;
    /**
     * Configures cursor stops around injected text.
     * Defaults to {@link InjectedTextCursorStops.Both}.
    */
    readonly cursorStops?: InjectedTextCursorStops | null;
}
declare enum InjectedTextCursorStops {
    Both = 0,
    Right = 1,
    Left = 2,
    None = 3
}
/**
 * New model decorations.
 */
interface IModelDeltaDecoration {
    /**
     * Range that this decoration covers.
     */
    range: IRange;
    /**
     * Options associated with this decoration.
     */
    options: IModelDecorationOptions;
}
/**
 * An accessor that can add, change or remove model decorations.
 * @internal
 */
interface IModelDecorationsChangeAccessor {
    /**
     * Add a new decoration.
     * @param range Range that this decoration covers.
     * @param options Options associated with this decoration.
     * @return An unique identifier associated with this decoration.
     */
    addDecoration(range: IRange, options: IModelDecorationOptions): string;
    /**
     * Change the range that an existing decoration covers.
     * @param id The unique identifier associated with the decoration.
     * @param newRange The new range that this decoration covers.
     */
    changeDecoration(id: string, newRange: IRange): void;
    /**
     * Change the options associated with an existing decoration.
     * @param id The unique identifier associated with the decoration.
     * @param newOptions The new options associated with this decoration.
     */
    changeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;
    /**
     * Remove an existing decoration.
     * @param id The unique identifier associated with the decoration.
     */
    removeDecoration(id: string): void;
    /**
     * Perform a minimum amount of operations, in order to transform the decorations
     * identified by `oldDecorations` to the decorations described by `newDecorations`
     * and returns the new identifiers associated with the resulting decorations.
     *
     * @param oldDecorations Array containing previous decorations identifiers.
     * @param newDecorations Array describing what decorations should result after the call.
     * @return An array containing the new decorations identifiers.
     */
    deltaDecorations(oldDecorations: readonly string[], newDecorations: readonly IModelDeltaDecoration[]): string[];
}
/**
 * End of line character preference.
 */
declare const enum EndOfLinePreference {
    /**
     * Use the end of line character identified in the text buffer.
     */
    TextDefined = 0,
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2
}
/**
 * The default end of line to use when instantiating models.
 */
declare const enum DefaultEndOfLine {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 1,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 2
}
/**
 * End of line character preference.
 */
declare const enum EndOfLineSequence {
    /**
     * Use line feed (\n) as the end of line character.
     */
    LF = 0,
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    CRLF = 1
}
/**
 * An identifier for a single edit operation.
 * @internal
 */
interface ISingleEditOperationIdentifier {
    /**
     * Identifier major
     */
    major: number;
    /**
     * Identifier minor
     */
    minor: number;
}
/**
 * A single edit operation, that has an identifier.
 */
interface IIdentifiedSingleEditOperation extends ISingleEditOperation {
    /**
     * An identifier associated with this single edit operation.
     * @internal
     */
    identifier?: ISingleEditOperationIdentifier | null;
    /**
     * This indicates that this operation is inserting automatic whitespace
     * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
     * @internal
     */
    isAutoWhitespaceEdit?: boolean;
    /**
     * This indicates that this operation is in a set of operations that are tracked and should not be "simplified".
     * @internal
     */
    _isTracked?: boolean;
}
interface IValidEditOperation {
    /**
     * An identifier associated with this single edit operation.
     * @internal
     */
    identifier: ISingleEditOperationIdentifier | null;
    /**
     * The range to replace. This can be empty to emulate a simple insert.
     */
    range: Range;
    /**
     * The text to replace with. This can be empty to emulate a simple delete.
     */
    text: string;
    /**
     * @internal
     */
    textChange: TextChange;
}
/**
 * @internal
 */
interface ITextModelCreationOptions {
    tabSize: number;
    indentSize: number | 'tabSize';
    insertSpaces: boolean;
    detectIndentation: boolean;
    trimAutoWhitespace: boolean;
    defaultEOL: DefaultEndOfLine;
    isForSimpleWidget: boolean;
    largeFileOptimizations: boolean;
    bracketPairColorizationOptions: BracketPairColorizationOptions;
}
interface BracketPairColorizationOptions {
    enabled: boolean;
    independentColorPoolPerBracketType: boolean;
}
declare class FindMatch {
    _findMatchBrand: void;
    readonly range: Range;
    readonly matches: string[] | null;
    /**
     * @internal
     */
    constructor(range: Range, matches: string[] | null);
}
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
declare const enum TrackedRangeStickiness {
    AlwaysGrowsWhenTypingAtEdges = 0,
    NeverGrowsWhenTypingAtEdges = 1,
    GrowsOnlyWhenTypingBefore = 2,
    GrowsOnlyWhenTypingAfter = 3
}
/**
 * Text snapshot that works like an iterator.
 * Will try to return chunks of roughly ~64KB size.
 * Will return null when finished.
 */
interface ITextSnapshot {
    read(): string | null;
}
/**
 * A model.
 */
type ITextModel = monaco.editor.ITextModel
/**
 * @internal
 */
interface ITextBufferFactory {
    create(defaultEOL: DefaultEndOfLine): {
        textBuffer: ITextBuffer;
        disposable: IDisposable;
    };
    getFirstLineText(lengthLimit: number): string;
}
/**
 * @internal
 */
declare class ValidAnnotatedEditOperation implements IIdentifiedSingleEditOperation {
    readonly identifier: ISingleEditOperationIdentifier | null;
    readonly range: Range;
    readonly text: string | null;
    readonly forceMoveMarkers: boolean;
    readonly isAutoWhitespaceEdit: boolean;
    readonly _isTracked: boolean;
    constructor(identifier: ISingleEditOperationIdentifier | null, range: Range, text: string | null, forceMoveMarkers: boolean, isAutoWhitespaceEdit: boolean, _isTracked: boolean);
}
/**
 * @internal
 *
 * `lineNumber` is 1 based.
 */
interface IReadonlyTextBuffer {
    onDidChangeContent: Event<void>;
    equals(other: ITextBuffer): boolean;
    mightContainRTL(): boolean;
    mightContainUnusualLineTerminators(): boolean;
    resetMightContainUnusualLineTerminators(): void;
    mightContainNonBasicASCII(): boolean;
    getBOM(): string;
    getEOL(): string;
    getOffsetAt(lineNumber: number, column: number): number;
    getPositionAt(offset: number): Position;
    getRangeAt(offset: number, length: number): Range;
    getValueInRange(range: Range, eol: EndOfLinePreference): string;
    createSnapshot(preserveBOM: boolean): ITextSnapshot;
    getValueLengthInRange(range: Range, eol: EndOfLinePreference): number;
    getCharacterCountInRange(range: Range, eol: EndOfLinePreference): number;
    getLength(): number;
    getLineCount(): number;
    getLinesContent(): string[];
    getLineContent(lineNumber: number): string;
    getLineCharCode(lineNumber: number, index: number): number;
    getCharCode(offset: number): number;
    getLineLength(lineNumber: number): number;
    getLineFirstNonWhitespaceColumn(lineNumber: number): number;
    getLineLastNonWhitespaceColumn(lineNumber: number): number;
    findMatchesLineByLine(searchRange: Range, searchData: SearchData, captureMatches: boolean, limitResultCount: number): FindMatch[];
}
/**
 * @internal
 */
declare class SearchData {
    /**
     * The regex to search for. Always defined.
     */
    readonly regex: RegExp;
    /**
     * The word separator classifier.
     */
    readonly wordSeparators: WordCharacterClassifier | null;
    /**
     * The simple string to search for (if possible).
     */
    readonly simpleSearch: string | null;
    constructor(regex: RegExp, wordSeparators: WordCharacterClassifier | null, simpleSearch: string | null);
}
/**
 * @internal
 */
interface ITextBuffer extends IReadonlyTextBuffer, IDisposable {
    setEOL(newEOL: '\r\n' | '\n'): void;
    applyEdits(rawOperations: ValidAnnotatedEditOperation[], recordTrimAutoWhitespace: boolean, computeUndoEdits: boolean): ApplyEditsResult;
}
/**
 * @internal
 */
declare class ApplyEditsResult {
    readonly reverseEdits: IValidEditOperation[] | null;
    readonly changes: IInternalModelContentChange[];
    readonly trimAutoWhitespaceLineNumbers: number[] | null;
    constructor(reverseEdits: IValidEditOperation[] | null, changes: IInternalModelContentChange[], trimAutoWhitespaceLineNumbers: number[] | null);
}
/**
 * @internal
 */
interface IInternalModelContentChange extends IModelContentChange {
    range: Range;
    forceMoveMarkers: boolean;
}

export { ApplyEditsResult, type BracketPairColorizationOptions, DefaultEndOfLine, EndOfLinePreference, EndOfLineSequence, FindMatch, GlyphMarginLane, type IDecorationOptions, type IIdentifiedSingleEditOperation, type IInternalModelContentChange, type IModelDecorationGlyphMarginOptions, type IModelDecorationMinimapOptions, type IModelDecorationOptions, type IModelDecorationOverviewRulerOptions, type IModelDecorationsChangeAccessor, type IModelDeltaDecoration, type IReadonlyTextBuffer, type ISingleEditOperationIdentifier, type ITextBuffer, type ITextBufferFactory, type ITextModel, type ITextModelCreationOptions, type ITextSnapshot, type IValidEditOperation, InjectedTextCursorStops, type InjectedTextOptions, MinimapPosition, OverviewRulerLane, SearchData, TrackedRangeStickiness, ValidAnnotatedEditOperation };

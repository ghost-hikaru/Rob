import { VSBuffer } from '../../base/common/buffer.js';
import { CancellationToken } from '../../base/common/cancellation.js';
import { IReadonlyVSDataTransfer } from '../../base/common/dataTransfer.js';
import { Event } from '../../base/common/event.js';
import { IMarkdownString } from '../../base/common/htmlContent.js';
import { IDisposable } from '../../base/common/lifecycle.js';
import { ThemeIcon } from '../../base/common/themables.js';
import { URI } from '../../base/common/uri.js';
import { ISingleEditOperation } from './core/editOperation.js';
import { Position, IPosition } from './core/position.js';
import { Range, IRange } from './core/range.js';
import { Selection } from './core/selection.js';
import { LanguageId } from './encodedTokenAttributes.js';
import { ITextModel, EndOfLineSequence } from './model.js';
import { ExtensionIdentifier } from '../../platform/extensions/common/extensions.js';
import { IMarkerData } from '../../platform/markers/common/markers.js';

/**
 * @internal
 */
interface ILanguageIdCodec {
    encodeLanguageId(languageId: string): LanguageId;
    decodeLanguageId(languageId: LanguageId): string;
}
/**
 * A provider result represents the values a provider, like the {@link HoverProvider},
 * may return. For once this is the actual result type `T`, like `Hover`, or a thenable that resolves
 * to that type `T`. In addition, `null` and `undefined` can be returned - either directly or from a
 * thenable.
 */
type ProviderResult<T> = T | undefined | null | Thenable<T | undefined | null>;
/**
 * A hover represents additional information for a symbol or word. Hovers are
 * rendered in a tooltip-like widget.
 */
interface Hover {
    /**
     * The contents of this hover.
     */
    contents: IMarkdownString[];
    /**
     * The range to which this hover applies. When missing, the
     * editor will use the range at the current position or the
     * current position itself.
     */
    range?: IRange;
}
/**
 * The hover provider interface defines the contract between extensions and
 * the [hover](https://code.visualstudio.com/docs/editor/intellisense)-feature.
 */
interface HoverProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideHover(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Hover>;
}
/**
 * An evaluatable expression represents additional information for an expression in a document. Evaluatable expressions are
 * evaluated by a debugger or runtime and their result is rendered in a tooltip-like widget.
 * @internal
 */
interface EvaluatableExpression {
    /**
     * The range to which this expression applies.
     */
    range: IRange;
    /**
     * This expression overrides the expression extracted from the range.
     */
    expression?: string;
}
/**
 * The evaluatable expression provider interface defines the contract between extensions and
 * the debug hover.
 * @internal
 */
interface EvaluatableExpressionProvider {
    /**
     * Provide a hover for the given position and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideEvaluatableExpression(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<EvaluatableExpression>;
}
/**
 * A value-object that contains contextual information when requesting inline values from a InlineValuesProvider.
 * @internal
 */
interface InlineValueContext {
    frameId: number;
    stoppedLocation: Range;
}
/**
 * Provide inline value as text.
 * @internal
 */
interface InlineValueText {
    type: 'text';
    range: IRange;
    text: string;
}
/**
 * Provide inline value through a variable lookup.
 * @internal
 */
interface InlineValueVariableLookup {
    type: 'variable';
    range: IRange;
    variableName?: string;
    caseSensitiveLookup: boolean;
}
/**
 * Provide inline value through an expression evaluation.
 * @internal
 */
interface InlineValueExpression {
    type: 'expression';
    range: IRange;
    expression?: string;
}
/**
 * Inline value information can be provided by different means:
 * - directly as a text value (class InlineValueText).
 * - as a name to use for a variable lookup (class InlineValueVariableLookup)
 * - as an evaluatable expression (class InlineValueEvaluatableExpression)
 * The InlineValue types combines all inline value types into one type.
 * @internal
 */
type InlineValue = InlineValueText | InlineValueVariableLookup | InlineValueExpression;
/**
 * The inline values provider interface defines the contract between extensions and
 * the debugger's inline values feature.
 * @internal
 */
interface InlineValuesProvider {
    /**
     */
    onDidChangeInlineValues?: Event<void> | undefined;
    /**
     * Provide the "inline values" for the given range and document. Multiple hovers at the same
     * position will be merged by the editor. A hover can have a range which defaults
     * to the word range at the position when omitted.
     */
    provideInlineValues(model: ITextModel, viewPort: Range, context: InlineValueContext, token: CancellationToken): ProviderResult<InlineValue[]>;
}
declare const enum CompletionItemKind {
    Method = 0,
    Function = 1,
    Constructor = 2,
    Field = 3,
    Variable = 4,
    Class = 5,
    Struct = 6,
    Interface = 7,
    Module = 8,
    Property = 9,
    Event = 10,
    Operator = 11,
    Unit = 12,
    Value = 13,
    Constant = 14,
    Enum = 15,
    EnumMember = 16,
    Keyword = 17,
    Text = 18,
    Color = 19,
    File = 20,
    Reference = 21,
    Customcolor = 22,
    Folder = 23,
    TypeParameter = 24,
    User = 25,
    Issue = 26,
    Snippet = 27
}
interface CompletionItemLabel {
    label: string;
    detail?: string;
    description?: string;
}
declare const enum CompletionItemTag {
    Deprecated = 1
}
declare const enum CompletionItemInsertTextRule {
    None = 0,
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    KeepWhitespace = 1,
    /**
     * `insertText` is a snippet.
     */
    InsertAsSnippet = 4
}
interface CompletionItemRanges {
    insert: IRange;
    replace: IRange;
}
/**
 * A completion item represents a text snippet that is
 * proposed to complete text that is being typed.
 */
interface CompletionItem {
    /**
     * The label of this completion item. By default
     * this is also the text that is inserted when selecting
     * this completion.
     */
    label: string | CompletionItemLabel;
    /**
     * The kind of this completion item. Based on the kind
     * an icon is chosen by the editor.
     */
    kind: CompletionItemKind;
    /**
     * A modifier to the `kind` which affect how the item
     * is rendered, e.g. Deprecated is rendered with a strikeout
     */
    tags?: ReadonlyArray<CompletionItemTag>;
    /**
     * A human-readable string with additional information
     * about this item, like type or symbol information.
     */
    detail?: string;
    /**
     * A human-readable string that represents a doc-comment.
     */
    documentation?: string | IMarkdownString;
    /**
     * A string that should be used when comparing this item
     * with other items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    sortText?: string;
    /**
     * A string that should be used when filtering a set of
     * completion items. When `falsy` the {@link CompletionItem.label label}
     * is used.
     */
    filterText?: string;
    /**
     * Select this item when showing. *Note* that only one completion item can be selected and
     * that the editor decides which item that is. The rule is that the *first* item of those
     * that match best is selected.
     */
    preselect?: boolean;
    /**
     * A string or snippet that should be inserted in a document when selecting
     * this completion.
     */
    insertText: string;
    /**
     * Additional rules (as bitmask) that should be applied when inserting
     * this completion.
     */
    insertTextRules?: CompletionItemInsertTextRule;
    /**
     * A range of text that should be replaced by this completion item.
     *
     * Defaults to a range from the start of the {@link TextDocument.getWordRangeAtPosition current word} to the
     * current position.
     *
     * *Note:* The range must be a {@link Range.isSingleLine single line} and it must
     * {@link Range.contains contain} the position at which completion has been {@link CompletionItemProvider.provideCompletionItems requested}.
     */
    range: IRange | CompletionItemRanges;
    /**
     * An optional set of characters that when pressed while this completion is active will accept it first and
     * then type that character. *Note* that all commit characters should have `length=1` and that superfluous
     * characters will be ignored.
     */
    commitCharacters?: string[];
    /**
     * An optional array of additional text edits that are applied when
     * selecting this completion. Edits must not overlap with the main edit
     * nor with themselves.
     */
    additionalTextEdits?: ISingleEditOperation[];
    /**
     * A command that should be run upon acceptance of this item.
     */
    command?: Command;
    /**
     * @internal
     */
    extensionId?: ExtensionIdentifier;
    /**
     * @internal
     */
    _id?: [number, number];
}
interface CompletionList {
    suggestions: CompletionItem[];
    incomplete?: boolean;
    dispose?(): void;
    /**
     * @internal
     */
    duration?: number;
}
/**
 * How a suggest provider was triggered.
 */
declare const enum CompletionTriggerKind {
    Invoke = 0,
    TriggerCharacter = 1,
    TriggerForIncompleteCompletions = 2
}
/**
 * Contains additional information about the context in which
 * {@link CompletionItemProvider.provideCompletionItems completion provider} is triggered.
 */
interface CompletionContext {
    /**
     * How the completion was triggered.
     */
    triggerKind: CompletionTriggerKind;
    /**
     * Character that triggered the completion item provider.
     *
     * `undefined` if provider was not triggered by a character.
     */
    triggerCharacter?: string;
}
/**
 * The completion item provider interface defines the contract between extensions and
 * the [IntelliSense](https://code.visualstudio.com/docs/editor/intellisense).
 *
 * When computing *complete* completion items is expensive, providers can optionally implement
 * the `resolveCompletionItem`-function. In that case it is enough to return completion
 * items with a {@link CompletionItem.label label} from the
 * {@link CompletionItemProvider.provideCompletionItems provideCompletionItems}-function. Subsequently,
 * when a completion item is shown in the UI and gains focus this provider is asked to resolve
 * the item, like adding {@link CompletionItem.documentation doc-comment} or {@link CompletionItem.detail details}.
 */
interface CompletionItemProvider {
    /**
     * Used to identify completions in the (debug) UI and telemetry. This isn't the extension identifier because extensions
     * often contribute multiple completion item providers.
     *
     * @internal
     */
    _debugDisplayName: string;
    triggerCharacters?: string[];
    /**
     * Provide completion items for the given position and document.
     */
    provideCompletionItems(model: ITextModel, position: Position, context: CompletionContext, token: CancellationToken): ProviderResult<CompletionList>;
    /**
     * Given a completion item fill in more data, like {@link CompletionItem.documentation doc-comment}
     * or {@link CompletionItem.detail details}.
     *
     * The editor will only resolve a completion item once.
     */
    resolveCompletionItem?(item: CompletionItem, token: CancellationToken): ProviderResult<CompletionItem>;
}
/**
 * How an {@link InlineCompletionsProvider inline completion provider} was triggered.
 */
declare enum InlineCompletionTriggerKind {
    /**
     * Completion was triggered automatically while editing.
     * It is sufficient to return a single completion item in this case.
     */
    Automatic = 0,
    /**
     * Completion was triggered explicitly by a user gesture.
     * Return multiple completion items to enable cycling through them.
     */
    Explicit = 1
}
interface InlineCompletionContext {
    /**
     * How the completion was triggered.
     */
    readonly triggerKind: InlineCompletionTriggerKind;
    readonly selectedSuggestionInfo: SelectedSuggestionInfo | undefined;
}
declare class SelectedSuggestionInfo {
    readonly range: IRange;
    readonly text: string;
    readonly completionKind: CompletionItemKind;
    readonly isSnippetText: boolean;
    constructor(range: IRange, text: string, completionKind: CompletionItemKind, isSnippetText: boolean);
    equals(other: SelectedSuggestionInfo): boolean;
}
interface InlineCompletion {
    /**
     * The text to insert.
     * If the text contains a line break, the range must end at the end of a line.
     * If existing text should be replaced, the existing text must be a prefix of the text to insert.
     *
     * The text can also be a snippet. In that case, a preview with default parameters is shown.
     * When accepting the suggestion, the full snippet is inserted.
    */
    readonly insertText: string | {
        snippet: string;
    };
    /**
     * A text that is used to decide if this inline completion should be shown.
     * An inline completion is shown if the text to replace is a subword of the filter text.
     */
    readonly filterText?: string;
    /**
     * An optional array of additional text edits that are applied when
     * selecting this completion. Edits must not overlap with the main edit
     * nor with themselves.
     */
    readonly additionalTextEdits?: ISingleEditOperation[];
    /**
     * The range to replace.
     * Must begin and end on the same line.
    */
    readonly range?: IRange;
    readonly command?: Command;
    /**
     * If set to `true`, unopened closing brackets are removed and unclosed opening brackets are closed.
     * Defaults to `false`.
    */
    readonly completeBracketPairs?: boolean;
}
interface InlineCompletions<TItem extends InlineCompletion = InlineCompletion> {
    readonly items: readonly TItem[];
    /**
     * A list of commands associated with the inline completions of this list.
     */
    readonly commands?: Command[];
    readonly suppressSuggestions?: boolean | undefined;
    /**
     * When set and the user types a suggestion without derivating from it, the inline suggestion is not updated.
     */
    readonly enableForwardStability?: boolean | undefined;
}
type InlineCompletionProviderGroupId = string;
interface InlineCompletionsProvider<T extends InlineCompletions = InlineCompletions> {
    provideInlineCompletions(model: ITextModel, position: Position, context: InlineCompletionContext, token: CancellationToken): ProviderResult<T>;
    /**
     * Will be called when an item is shown.
     * @param updatedInsertText Is useful to understand bracket completion.
    */
    handleItemDidShow?(completions: T, item: T['items'][number], updatedInsertText: string): void;
    /**
     * Will be called when an item is partially accepted.
     */
    handlePartialAccept?(completions: T, item: T['items'][number], acceptedCharacters: number): void;
    /**
     * Will be called when a completions list is no longer in use and can be garbage-collected.
    */
    freeInlineCompletions(completions: T): void;
    /**
     * Only used for {@link yieldsToGroupIds}.
     * Multiple providers can have the same group id.
     */
    groupId?: InlineCompletionProviderGroupId;
    /**
     * Returns a list of preferred provider {@link groupId}s.
     * The current provider is only requested for completions if no provider with a preferred group id returned a result.
     */
    yieldsToGroupIds?: InlineCompletionProviderGroupId[];
    toString?(): string;
}
interface CodeAction {
    title: string;
    command?: Command;
    edit?: WorkspaceEdit;
    diagnostics?: IMarkerData[];
    kind?: string;
    isPreferred?: boolean;
    disabled?: string;
}
declare const enum CodeActionTriggerType {
    Invoke = 1,
    Auto = 2
}
/**
 * @internal
 */
interface CodeActionContext {
    only?: string;
    trigger: CodeActionTriggerType;
}
interface CodeActionList extends IDisposable {
    readonly actions: ReadonlyArray<CodeAction>;
}
/**
 * The code action interface defines the contract between extensions and
 * the [light bulb](https://code.visualstudio.com/docs/editor/editingevolved#_code-action) feature.
 * @internal
 */
interface CodeActionProvider {
    displayName?: string;
    /**
     * Provide commands for the given document and range.
     */
    provideCodeActions(model: ITextModel, range: Range | Selection, context: CodeActionContext, token: CancellationToken): ProviderResult<CodeActionList>;
    /**
     * Given a code action fill in the edit. Will only invoked when missing.
     */
    resolveCodeAction?(codeAction: CodeAction, token: CancellationToken): ProviderResult<CodeAction>;
    /**
     * Optional list of CodeActionKinds that this provider returns.
     */
    readonly providedCodeActionKinds?: ReadonlyArray<string>;
    readonly documentation?: ReadonlyArray<{
        readonly kind: string;
        readonly command: Command;
    }>;
    /**
     * @internal
     */
    _getAdditionalMenuItems?(context: CodeActionContext, actions: readonly CodeAction[]): Command[];
}
/**
 * @internal
 */
interface DocumentPasteEdit {
    readonly label: string;
    readonly detail: string;
    readonly handledMimeType?: string;
    readonly yieldTo?: readonly DropYieldTo[];
    insertText: string | {
        readonly snippet: string;
    };
    additionalEdit?: WorkspaceEdit;
}
/**
 * @internal
 */
interface DocumentPasteEditProvider {
    readonly id: string;
    readonly copyMimeTypes?: readonly string[];
    readonly pasteMimeTypes?: readonly string[];
    prepareDocumentPaste?(model: ITextModel, ranges: readonly IRange[], dataTransfer: IReadonlyVSDataTransfer, token: CancellationToken): Promise<undefined | IReadonlyVSDataTransfer>;
    provideDocumentPasteEdits?(model: ITextModel, ranges: readonly IRange[], dataTransfer: IReadonlyVSDataTransfer, token: CancellationToken): Promise<DocumentPasteEdit | undefined>;
}
/**
 * Represents a parameter of a callable-signature. A parameter can
 * have a label and a doc-comment.
 */
interface ParameterInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string | [number, number];
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | IMarkdownString;
}
/**
 * Represents the signature of something callable. A signature
 * can have a label, like a function-name, a doc-comment, and
 * a set of parameters.
 */
interface SignatureInformation {
    /**
     * The label of this signature. Will be shown in
     * the UI.
     */
    label: string;
    /**
     * The human-readable doc-comment of this signature. Will be shown
     * in the UI but can be omitted.
     */
    documentation?: string | IMarkdownString;
    /**
     * The parameters of this signature.
     */
    parameters: ParameterInformation[];
    /**
     * Index of the active parameter.
     *
     * If provided, this is used in place of `SignatureHelp.activeSignature`.
     */
    activeParameter?: number;
}
/**
 * Signature help represents the signature of something
 * callable. There can be multiple signatures but only one
 * active and only one active parameter.
 */
interface SignatureHelp {
    /**
     * One or more signatures.
     */
    signatures: SignatureInformation[];
    /**
     * The active signature.
     */
    activeSignature: number;
    /**
     * The active parameter of the active signature.
     */
    activeParameter: number;
}
interface SignatureHelpResult extends IDisposable {
    value: SignatureHelp;
}
declare enum SignatureHelpTriggerKind {
    Invoke = 1,
    TriggerCharacter = 2,
    ContentChange = 3
}
interface SignatureHelpContext {
    readonly triggerKind: SignatureHelpTriggerKind;
    readonly triggerCharacter?: string;
    readonly isRetrigger: boolean;
    readonly activeSignatureHelp?: SignatureHelp;
}
/**
 * The signature help provider interface defines the contract between extensions and
 * the [parameter hints](https://code.visualstudio.com/docs/editor/intellisense)-feature.
 */
interface SignatureHelpProvider {
    readonly signatureHelpTriggerCharacters?: ReadonlyArray<string>;
    readonly signatureHelpRetriggerCharacters?: ReadonlyArray<string>;
    /**
     * Provide help for the signature at the given position and document.
     */
    provideSignatureHelp(model: ITextModel, position: Position, token: CancellationToken, context: SignatureHelpContext): ProviderResult<SignatureHelpResult>;
}
/**
 * A document highlight kind.
 */
declare enum DocumentHighlightKind {
    /**
     * A textual occurrence.
     */
    Text = 0,
    /**
     * Read-access of a symbol, like reading a variable.
     */
    Read = 1,
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    Write = 2
}
/**
 * A document highlight is a range inside a text document which deserves
 * special attention. Usually a document highlight is visualized by changing
 * the background color of its range.
 */
interface DocumentHighlight {
    /**
     * The range this highlight applies to.
     */
    range: IRange;
    /**
     * The highlight kind, default is {@link DocumentHighlightKind.Text text}.
     */
    kind?: DocumentHighlightKind;
}
/**
 * The document highlight provider interface defines the contract between extensions and
 * the word-highlight-feature.
 */
interface DocumentHighlightProvider {
    /**
     * Provide a set of document highlights, like all occurrences of a variable or
     * all exit-points of a function.
     */
    provideDocumentHighlights(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<DocumentHighlight[]>;
}
/**
 * The linked editing range provider interface defines the contract between extensions and
 * the linked editing feature.
 */
interface LinkedEditingRangeProvider {
    /**
     * Provide a list of ranges that can be edited together.
     */
    provideLinkedEditingRanges(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<LinkedEditingRanges>;
}
/**
 * Represents a list of ranges that can be edited together along with a word pattern to describe valid contents.
 */
interface LinkedEditingRanges {
    /**
     * A list of ranges that can be edited together. The ranges must have
     * identical length and text content. The ranges cannot overlap
     */
    ranges: IRange[];
    /**
     * An optional word pattern that describes valid contents for the given ranges.
     * If no pattern is provided, the language configuration's word pattern will be used.
     */
    wordPattern?: RegExp;
}
/**
 * Value-object that contains additional information when
 * requesting references.
 */
interface ReferenceContext {
    /**
     * Include the declaration of the current symbol.
     */
    includeDeclaration: boolean;
}
/**
 * The reference provider interface defines the contract between extensions and
 * the [find references](https://code.visualstudio.com/docs/editor/editingevolved#_peek)-feature.
 */
interface ReferenceProvider {
    /**
     * Provide a set of project-wide references for the given position and document.
     */
    provideReferences(model: ITextModel, position: Position, context: ReferenceContext, token: CancellationToken): ProviderResult<Location[]>;
}
/**
 * Represents a location inside a resource, such as a line
 * inside a text file.
 */
interface Location {
    /**
     * The resource identifier of this location.
     */
    uri: URI;
    /**
     * The document range of this locations.
     */
    range: IRange;
}
interface LocationLink {
    /**
     * A range to select where this link originates from.
     */
    originSelectionRange?: IRange;
    /**
     * The target uri this link points to.
     */
    uri: URI;
    /**
     * The full range this link points to.
     */
    range: IRange;
    /**
     * A range to select this link points to. Must be contained
     * in `LocationLink.range`.
     */
    targetSelectionRange?: IRange;
}
type Definition = Location | Location[] | LocationLink[];
/**
 * The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.
 */
interface DefinitionProvider {
    /**
     * Provide the definition of the symbol at the given position and document.
     */
    provideDefinition(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The definition provider interface defines the contract between extensions and
 * the [go to definition](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-definition)
 * and peek definition features.
 */
interface DeclarationProvider {
    /**
     * Provide the declaration of the symbol at the given position and document.
     */
    provideDeclaration(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The implementation provider interface defines the contract between extensions and
 * the go to implementation feature.
 */
interface ImplementationProvider {
    /**
     * Provide the implementation of the symbol at the given position and document.
     */
    provideImplementation(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * The type definition provider interface defines the contract between extensions and
 * the go to type definition feature.
 */
interface TypeDefinitionProvider {
    /**
     * Provide the type definition of the symbol at the given position and document.
     */
    provideTypeDefinition(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<Definition | LocationLink[]>;
}
/**
 * A symbol kind.
 */
declare const enum SymbolKind {
    File = 0,
    Module = 1,
    Namespace = 2,
    Package = 3,
    Class = 4,
    Method = 5,
    Property = 6,
    Field = 7,
    Constructor = 8,
    Enum = 9,
    Interface = 10,
    Function = 11,
    Variable = 12,
    Constant = 13,
    String = 14,
    Number = 15,
    Boolean = 16,
    Array = 17,
    Object = 18,
    Key = 19,
    Null = 20,
    EnumMember = 21,
    Struct = 22,
    Event = 23,
    Operator = 24,
    TypeParameter = 25
}
declare const enum SymbolTag {
    Deprecated = 1
}
interface DocumentSymbol {
    name: string;
    detail: string;
    kind: SymbolKind;
    tags: ReadonlyArray<SymbolTag>;
    containerName?: string;
    range: IRange;
    selectionRange: IRange;
    children?: DocumentSymbol[];
}
/**
 * The document symbol provider interface defines the contract between extensions and
 * the [go to symbol](https://code.visualstudio.com/docs/editor/editingevolved#_go-to-symbol)-feature.
 */
interface DocumentSymbolProvider {
    displayName?: string;
    /**
     * Provide symbol information for the given document.
     */
    provideDocumentSymbols(model: ITextModel, token: CancellationToken): ProviderResult<DocumentSymbol[]>;
}
interface TextEdit {
    range: IRange;
    text: string;
    eol?: EndOfLineSequence;
}
/** @internal */
declare abstract class TextEdit {
    static asEditOperation(edit: TextEdit): ISingleEditOperation;
}
/**
 * Interface used to format a model
 */
interface FormattingOptions {
    /**
     * Size of a tab in spaces.
     */
    tabSize: number;
    /**
     * Prefer spaces over tabs.
     */
    insertSpaces: boolean;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface DocumentFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly displayName?: string;
    /**
     * Provide formatting edits for a whole document.
     */
    provideDocumentFormattingEdits(model: ITextModel, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface DocumentRangeFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly displayName?: string;
    /**
     * Provide formatting edits for a range in a document.
     *
     * The given range is a hint and providers can decide to format a smaller
     * or larger range. Often this is done by adjusting the start and end
     * of the range to full syntax nodes.
     */
    provideDocumentRangeFormattingEdits(model: ITextModel, range: Range, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
    provideDocumentRangesFormattingEdits?(model: ITextModel, ranges: Range[], options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * The document formatting provider interface defines the contract between extensions and
 * the formatting-feature.
 */
interface OnTypeFormattingEditProvider {
    /**
     * @internal
     */
    readonly extensionId?: ExtensionIdentifier;
    autoFormatTriggerCharacters: string[];
    /**
     * Provide formatting edits after a character has been typed.
     *
     * The given position and character should hint to the provider
     * what range the position to expand to, like find the matching `{`
     * when `}` has been entered.
     */
    provideOnTypeFormattingEdits(model: ITextModel, position: Position, ch: string, options: FormattingOptions, token: CancellationToken): ProviderResult<TextEdit[]>;
}
/**
 * @internal
 */
interface IInplaceReplaceSupportResult {
    value: string;
    range: IRange;
}
/**
 * A link inside the editor.
 */
interface ILink {
    range: IRange;
    url?: URI | string;
    tooltip?: string;
}
interface ILinksList {
    links: ILink[];
    dispose?(): void;
}
/**
 * A provider of links.
 */
interface LinkProvider {
    provideLinks(model: ITextModel, token: CancellationToken): ProviderResult<ILinksList>;
    resolveLink?: (link: ILink, token: CancellationToken) => ProviderResult<ILink>;
}
/**
 * A color in RGBA format.
 */
interface IColor {
    /**
     * The red component in the range [0-1].
     */
    readonly red: number;
    /**
     * The green component in the range [0-1].
     */
    readonly green: number;
    /**
     * The blue component in the range [0-1].
     */
    readonly blue: number;
    /**
     * The alpha component in the range [0-1].
     */
    readonly alpha: number;
}
/**
 * String representations for a color
 */
interface IColorPresentation {
    /**
     * The label of this color presentation. It will be shown on the color
     * picker header. By default this is also the text that is inserted when selecting
     * this color presentation.
     */
    label: string;
    /**
     * An {@link TextEdit edit} which is applied to a document when selecting
     * this presentation for the color.
     */
    textEdit?: TextEdit;
    /**
     * An optional array of additional {@link TextEdit text edits} that are applied when
     * selecting this color presentation.
     */
    additionalTextEdits?: TextEdit[];
}
/**
 * A color range is a range in a text model which represents a color.
 */
interface IColorInformation {
    /**
     * The range within the model.
     */
    range: IRange;
    /**
     * The color represented in this range.
     */
    color: IColor;
}
/**
 * A provider of colors for editor models.
 */
interface DocumentColorProvider {
    /**
     * Provides the color ranges for a specific model.
     */
    provideDocumentColors(model: ITextModel, token: CancellationToken): ProviderResult<IColorInformation[]>;
    /**
     * Provide the string representations for a color.
     */
    provideColorPresentations(model: ITextModel, colorInfo: IColorInformation, token: CancellationToken): ProviderResult<IColorPresentation[]>;
}
interface SelectionRange {
    range: IRange;
}
interface SelectionRangeProvider {
    /**
     * Provide ranges that should be selected from the given position.
     */
    provideSelectionRanges(model: ITextModel, positions: Position[], token: CancellationToken): ProviderResult<SelectionRange[][]>;
}
interface FoldingContext {
}
/**
 * A provider of folding ranges for editor models.
 */
interface FoldingRangeProvider {
    /**
     * @internal
     */
    readonly id?: string;
    /**
     * An optional event to signal that the folding ranges from this provider have changed.
     */
    onDidChange?: Event<this>;
    /**
     * Provides the folding ranges for a specific model.
     */
    provideFoldingRanges(model: ITextModel, context: FoldingContext, token: CancellationToken): ProviderResult<FoldingRange[]>;
}
interface FoldingRange {
    /**
     * The one-based start line of the range to fold. The folded area starts after the line's last character.
     */
    start: number;
    /**
     * The one-based end line of the range to fold. The folded area ends with the line's last character.
     */
    end: number;
    /**
     * Describes the {@link FoldingRangeKind Kind} of the folding range such as {@link FoldingRangeKind.Comment Comment} or
     * {@link FoldingRangeKind.Region Region}. The kind is used to categorize folding ranges and used by commands
     * like 'Fold all comments'. See
     * {@link FoldingRangeKind} for an enumeration of standardized kinds.
     */
    kind?: FoldingRangeKind;
}
declare class FoldingRangeKind {
    value: string;
    /**
     * Kind for folding range representing a comment. The value of the kind is 'comment'.
     */
    static readonly Comment: FoldingRangeKind;
    /**
     * Kind for folding range representing a import. The value of the kind is 'imports'.
     */
    static readonly Imports: FoldingRangeKind;
    /**
     * Kind for folding range representing regions (for example marked by `#region`, `#endregion`).
     * The value of the kind is 'region'.
     */
    static readonly Region: FoldingRangeKind;
    /**
     * Returns a {@link FoldingRangeKind} for the given value.
     *
     * @param value of the kind.
     */
    static fromValue(value: string): FoldingRangeKind;
    /**
     * Creates a new {@link FoldingRangeKind}.
     *
     * @param value of the kind.
     */
    constructor(value: string);
}
interface WorkspaceEditMetadata {
    needsConfirmation: boolean;
    label: string;
    description?: string;
    /**
     * @internal
     */
    iconPath?: ThemeIcon | URI | {
        light: URI;
        dark: URI;
    };
}
interface WorkspaceFileEditOptions {
    overwrite?: boolean;
    ignoreIfNotExists?: boolean;
    ignoreIfExists?: boolean;
    recursive?: boolean;
    copy?: boolean;
    folder?: boolean;
    skipTrashBin?: boolean;
    maxSize?: number;
    /**
     * @internal
     */
    contents?: Promise<VSBuffer>;
}
interface IWorkspaceFileEdit {
    oldResource?: URI;
    newResource?: URI;
    options?: WorkspaceFileEditOptions;
    metadata?: WorkspaceEditMetadata;
}
interface IWorkspaceTextEdit {
    resource: URI;
    textEdit: TextEdit & {
        insertAsSnippet?: boolean;
    };
    versionId: number | undefined;
    metadata?: WorkspaceEditMetadata;
}
interface WorkspaceEdit {
    edits: Array<IWorkspaceTextEdit | IWorkspaceFileEdit>;
}
interface Rejection {
    rejectReason?: string;
}
interface RenameLocation {
    range: IRange;
    text: string;
}
interface RenameProvider {
    provideRenameEdits(model: ITextModel, position: Position, newName: string, token: CancellationToken): ProviderResult<WorkspaceEdit & Rejection>;
    resolveRenameLocation?(model: ITextModel, position: Position, token: CancellationToken): ProviderResult<RenameLocation & Rejection>;
}
interface Command {
    id: string;
    title: string;
    tooltip?: string;
    arguments?: any[];
}
/**
 * @internal
 */
declare namespace Command {
    /**
     * @internal
     */
    function is(obj: any): obj is Command;
}
interface CodeLens {
    range: IRange;
    id?: string;
    command?: Command;
}
interface CodeLensList {
    lenses: CodeLens[];
    dispose(): void;
}
interface CodeLensProvider {
    onDidChange?: Event<this>;
    provideCodeLenses(model: ITextModel, token: CancellationToken): ProviderResult<CodeLensList>;
    resolveCodeLens?(model: ITextModel, codeLens: CodeLens, token: CancellationToken): ProviderResult<CodeLens>;
}
declare enum InlayHintKind {
    Type = 1,
    Parameter = 2
}
interface InlayHintLabelPart {
    label: string;
    tooltip?: string | IMarkdownString;
    command?: Command;
    location?: Location;
}
interface InlayHint {
    label: string | InlayHintLabelPart[];
    tooltip?: string | IMarkdownString;
    textEdits?: TextEdit[];
    position: IPosition;
    kind?: InlayHintKind;
    paddingLeft?: boolean;
    paddingRight?: boolean;
}
interface InlayHintList {
    hints: InlayHint[];
    dispose(): void;
}
interface InlayHintsProvider {
    displayName?: string;
    onDidChangeInlayHints?: Event<void>;
    provideInlayHints(model: ITextModel, range: Range, token: CancellationToken): ProviderResult<InlayHintList>;
    resolveInlayHint?(hint: InlayHint, token: CancellationToken): ProviderResult<InlayHint>;
}
interface SemanticTokensLegend {
    readonly tokenTypes: string[];
    readonly tokenModifiers: string[];
}
interface SemanticTokens {
    readonly resultId?: string;
    readonly data: Uint32Array;
}
interface SemanticTokensEdit {
    readonly start: number;
    readonly deleteCount: number;
    readonly data?: Uint32Array;
}
interface SemanticTokensEdits {
    readonly resultId?: string;
    readonly edits: SemanticTokensEdit[];
}
interface DocumentSemanticTokensProvider {
    onDidChange?: Event<void>;
    getLegend(): SemanticTokensLegend;
    provideDocumentSemanticTokens(model: ITextModel, lastResultId: string | null, token: CancellationToken): ProviderResult<SemanticTokens | SemanticTokensEdits>;
    releaseDocumentSemanticTokens(resultId: string | undefined): void;
}
interface DocumentRangeSemanticTokensProvider {
    getLegend(): SemanticTokensLegend;
    provideDocumentRangeSemanticTokens(model: ITextModel, range: Range, token: CancellationToken): ProviderResult<SemanticTokens>;
}
/**
 * @internal
 */
type DropYieldTo = {
    readonly providerId: string;
} | {
    readonly mimeType: string;
};
/**
 * @internal
 */
interface DocumentOnDropEdit {
    readonly label: string;
    readonly handledMimeType?: string;
    readonly yieldTo?: readonly DropYieldTo[];
    insertText: string | {
        readonly snippet: string;
    };
    additionalEdit?: WorkspaceEdit;
}
/**
 * @internal
 */
interface DocumentOnDropEditProvider {
    readonly id?: string;
    readonly dropMimeTypes?: readonly string[];
    provideDocumentOnDropEdits(model: ITextModel, position: IPosition, dataTransfer: IReadonlyVSDataTransfer, token: CancellationToken): ProviderResult<DocumentOnDropEdit>;
}
interface DocumentContextItem {
    readonly uri: URI;
    readonly version: number;
    readonly ranges: IRange[];
}
interface MappedEditsContext {
    /** The outer array is sorted by priority - from highest to lowest. The inner arrays contain elements of the same priority. */
    documents: DocumentContextItem[][];
}
interface MappedEditsProvider {
    /**
     * Provider maps code blocks from the chat into a workspace edit.
     *
     * @param document The document to provide mapped edits for.
     * @param codeBlocks Code blocks that come from an LLM's reply.
     * 						"Insert at cursor" in the panel chat only sends one edit that the user clicks on, but inline chat can send multiple blocks and let the lang server decide what to do with them.
     * @param context The context for providing mapped edits.
     * @param token A cancellation token.
     * @returns A provider result of text edits.
     */
    provideMappedEdits(document: ITextModel, codeBlocks: string[], context: MappedEditsContext, token: CancellationToken): Promise<WorkspaceEdit | null>;
}

export { type CodeAction, type CodeActionContext, type CodeActionList, type CodeActionProvider, CodeActionTriggerType, type CodeLens, type CodeLensList, type CodeLensProvider, Command, type CompletionContext, type CompletionItem, CompletionItemInsertTextRule, CompletionItemKind, type CompletionItemLabel, type CompletionItemProvider, type CompletionItemRanges, CompletionItemTag, type CompletionList, CompletionTriggerKind, type DeclarationProvider, type Definition, type DefinitionProvider, type DocumentColorProvider, type DocumentContextItem, type DocumentFormattingEditProvider, type DocumentHighlight, DocumentHighlightKind, type DocumentHighlightProvider, type DocumentOnDropEdit, type DocumentOnDropEditProvider, type DocumentPasteEdit, type DocumentPasteEditProvider, type DocumentRangeFormattingEditProvider, type DocumentRangeSemanticTokensProvider, type DocumentSemanticTokensProvider, type DocumentSymbol, type DocumentSymbolProvider, type DropYieldTo, type EvaluatableExpression, type EvaluatableExpressionProvider, type FoldingContext, type FoldingRange, FoldingRangeKind, type FoldingRangeProvider, type FormattingOptions, type Hover, type HoverProvider, type IColor, type IColorInformation, type IColorPresentation, type IInplaceReplaceSupportResult, type ILanguageIdCodec, type ILink, type ILinksList, type IWorkspaceFileEdit, type IWorkspaceTextEdit, type ImplementationProvider, type InlayHint, InlayHintKind, type InlayHintLabelPart, type InlayHintList, type InlayHintsProvider, type InlineCompletion, type InlineCompletionContext, type InlineCompletionProviderGroupId, InlineCompletionTriggerKind, type InlineCompletions, type InlineCompletionsProvider, type InlineValue, type InlineValueContext, type InlineValueExpression, type InlineValueText, type InlineValueVariableLookup, type InlineValuesProvider, type LinkProvider, type LinkedEditingRangeProvider, type LinkedEditingRanges, type Location, type LocationLink, type MappedEditsContext, type MappedEditsProvider, type OnTypeFormattingEditProvider, type ParameterInformation, type ProviderResult, type ReferenceContext, type ReferenceProvider, type Rejection, type RenameLocation, type RenameProvider, SelectedSuggestionInfo, type SelectionRange, type SelectionRangeProvider, type SemanticTokens, type SemanticTokensEdit, type SemanticTokensEdits, type SemanticTokensLegend, type SignatureHelp, type SignatureHelpContext, type SignatureHelpProvider, type SignatureHelpResult, SignatureHelpTriggerKind, type SignatureInformation, SymbolKind, SymbolTag, TextEdit, type TypeDefinitionProvider, type WorkspaceEdit, type WorkspaceEditMetadata, type WorkspaceFileEditOptions };

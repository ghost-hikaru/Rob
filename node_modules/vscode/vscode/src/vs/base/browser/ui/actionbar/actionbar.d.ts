import { Event } from '../../../common/event.js';
import { IActionViewItemOptions } from './actionViewItems.js';
import { IHoverDelegate } from '../iconLabel/iconHoverDelegate.js';
import { IAction, IActionRunner, IRunEvent } from '../../../common/actions.js';
import { KeyCode } from '../../../common/keyCodes.js';
import { IDisposable, Disposable } from '../../../common/lifecycle.js';

interface IActionViewItem extends IDisposable {
    action: IAction;
    actionRunner: IActionRunner;
    setActionContext(context: unknown): void;
    render(element: HTMLElement): void;
    isEnabled(): boolean;
    focus(fromRight?: boolean): void;
    blur(): void;
}
interface IActionViewItemProvider {
    (action: IAction, options: IActionViewItemOptions): IActionViewItem | undefined;
}
declare const enum ActionsOrientation {
    HORIZONTAL = 0,
    VERTICAL = 1
}
interface ActionTrigger {
    keys?: KeyCode[];
    keyDown: boolean;
}
interface IActionBarOptions {
    readonly orientation?: ActionsOrientation;
    readonly context?: unknown;
    readonly actionViewItemProvider?: IActionViewItemProvider;
    readonly actionRunner?: IActionRunner;
    readonly ariaLabel?: string;
    readonly ariaRole?: string;
    readonly animated?: boolean;
    readonly triggerKeys?: ActionTrigger;
    readonly allowContextMenu?: boolean;
    readonly preventLoopNavigation?: boolean;
    readonly focusOnlyEnabledItems?: boolean;
    readonly hoverDelegate?: IHoverDelegate;
    /**
     * If true, toggled primary items are highlighted with a background color.
     * Some action bars exclusively use icon states, we don't want to enable this for them.
     * Thus, this is opt-in.
     */
    readonly highlightToggledItems?: boolean;
}
interface IActionOptions extends IActionViewItemOptions {
    index?: number;
}
declare class ActionBar extends Disposable implements IActionRunner {
    private readonly options;
    private _actionRunner;
    private readonly _actionRunnerDisposables;
    private _context;
    private readonly _orientation;
    private readonly _triggerKeys;
    viewItems: IActionViewItem[];
    private readonly viewItemDisposables;
    private previouslyFocusedItem?;
    protected focusedItem?: number;
    private focusTracker;
    private triggerKeyDown;
    private focusable;
    domNode: HTMLElement;
    protected readonly actionsList: HTMLElement;
    private readonly _onDidBlur;
    readonly onDidBlur: Event<void>;
    private readonly _onDidCancel;
    readonly onDidCancel: Event<void>;
    private cancelHasListener;
    private readonly _onDidRun;
    readonly onDidRun: Event<IRunEvent>;
    private readonly _onWillRun;
    readonly onWillRun: Event<IRunEvent>;
    constructor(container: HTMLElement, options?: IActionBarOptions);
    private refreshRole;
    setAriaLabel(label: string): void;
    setFocusable(focusable: boolean): void;
    private isTriggerKeyEvent;
    private updateFocusedItem;
    get context(): unknown;
    set context(context: unknown);
    get actionRunner(): IActionRunner;
    set actionRunner(actionRunner: IActionRunner);
    getContainer(): HTMLElement;
    hasAction(action: IAction): boolean;
    getAction(indexOrElement: number | HTMLElement): IAction | undefined;
    push(arg: IAction | ReadonlyArray<IAction>, options?: IActionOptions): void;
    getWidth(index: number): number;
    getHeight(index: number): number;
    pull(index: number): void;
    clear(): void;
    length(): number;
    isEmpty(): boolean;
    focus(index?: number): void;
    focus(selectFirst?: boolean): void;
    private focusFirst;
    private focusLast;
    protected focusNext(forceLoop?: boolean): boolean;
    protected focusPrevious(forceLoop?: boolean): boolean;
    protected updateFocus(fromRight?: boolean, preventScroll?: boolean, forceFocus?: boolean): void;
    private doTrigger;
    run(action: IAction, context?: unknown): Promise<void>;
    dispose(): void;
}

export { ActionBar, type ActionTrigger, ActionsOrientation, type IActionBarOptions, type IActionOptions, type IActionViewItem, type IActionViewItemProvider };

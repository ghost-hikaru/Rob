import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { AutoSaveConfiguration, FILES_READONLY_INCLUDE_CONFIG, FILES_READONLY_EXCLUDE_CONFIG, HotExitConfiguration, hasReadonlyCapability, IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { equals } from 'monaco-editor/esm/vs/base/common/objects.js';
import { isWeb } from 'monaco-editor/esm/vs/base/common/platform.js';
import { IWorkspaceContextService } from 'monaco-editor/esm/vs/platform/workspace/common/workspace.js';
import { ResourceGlobMatcher } from '../../../common/resources.js';
import { IdleValue } from 'monaco-editor/esm/vs/base/common/async.js';
import { IUriIdentityService } from 'monaco-editor/esm/vs/platform/uriIdentity/common/uriIdentity.js';
import { IEnvironmentService } from 'monaco-editor/esm/vs/platform/environment/common/environment.js';
import { ResourceMap } from 'monaco-editor/esm/vs/base/common/map.js';
var FilesConfigurationService_1;
const AutoSaveAfterShortDelayContext = ( new RawContextKey('autoSaveAfterShortDelayContext', false, true));
const IFilesConfigurationService = ( createDecorator('filesConfigurationService'));
let FilesConfigurationService = class FilesConfigurationService extends Disposable {
    static { FilesConfigurationService_1 = this; }
    static { this.DEFAULT_AUTO_SAVE_MODE = isWeb ? AutoSaveConfiguration.AFTER_DELAY : AutoSaveConfiguration.OFF; }
    static { this.READONLY_MESSAGES = {
        providerReadonly: { value: ( localizeWithPath(
            'vs/workbench/services/filesConfiguration/common/filesConfigurationService',
            'providerReadonly',
            "Editor is read-only because the file system of the file is read-only."
        )), isTrusted: true },
        sessionReadonly: { value: ( localizeWithPath(
            'vs/workbench/services/filesConfiguration/common/filesConfigurationService',
            { key: 'sessionReadonly', comment: ['Please do not translate the word "command", it is part of our internal syntax which must not change', '{Locked="](command:{0})"}'] },
            "Editor is read-only because the file was set read-only in this session. [Click here](command:{0}) to set writeable.",
            'workbench.action.files.setActiveEditorWriteableInSession'
        )), isTrusted: true },
        configuredReadonly: { value: ( localizeWithPath(
            'vs/workbench/services/filesConfiguration/common/filesConfigurationService',
            { key: 'configuredReadonly', comment: ['Please do not translate the word "command", it is part of our internal syntax which must not change', '{Locked="](command:{0})"}'] },
            "Editor is read-only because the file was set read-only via settings. [Click here](command:{0}) to configure.",
            `workbench.action.openSettings?${encodeURIComponent('["files.readonly"]')}`
        )), isTrusted: true },
        fileLocked: { value: ( localizeWithPath(
            'vs/workbench/services/filesConfiguration/common/filesConfigurationService',
            { key: 'fileLocked', comment: ['Please do not translate the word "command", it is part of our internal syntax which must not change', '{Locked="](command:{0})"}'] },
            "Editor is read-only because of file permissions. [Click here](command:{0}) to set writeable anyway.",
            'workbench.action.files.setActiveEditorWriteableInSession'
        )), isTrusted: true },
        fileReadonly: { value: ( localizeWithPath(
            'vs/workbench/services/filesConfiguration/common/filesConfigurationService',
            'fileReadonly',
            "Editor is read-only because the file is read-only."
        )), isTrusted: true }
    }; }
    constructor(contextKeyService, configurationService, contextService, environmentService, uriIdentityService, fileService) {
        super();
        this.configurationService = configurationService;
        this.contextService = contextService;
        this.environmentService = environmentService;
        this.uriIdentityService = uriIdentityService;
        this.fileService = fileService;
        this._onAutoSaveConfigurationChange = this._register(( new Emitter()));
        this.onAutoSaveConfigurationChange = this._onAutoSaveConfigurationChange.event;
        this._onFilesAssociationChange = this._register(( new Emitter()));
        this.onFilesAssociationChange = this._onFilesAssociationChange.event;
        this._onReadonlyConfigurationChange = this._register(( new Emitter()));
        this.onReadonlyChange = this._onReadonlyConfigurationChange.event;
        this.readonlyIncludeMatcher = this._register(( new IdleValue(() => this.createReadonlyMatcher(FILES_READONLY_INCLUDE_CONFIG))));
        this.readonlyExcludeMatcher = this._register(( new IdleValue(() => this.createReadonlyMatcher(FILES_READONLY_EXCLUDE_CONFIG))));
        this.sessionReadonlyOverrides = ( new ResourceMap(resource => this.uriIdentityService.extUri.getComparisonKey(resource)));
        this.autoSaveAfterShortDelayContext = AutoSaveAfterShortDelayContext.bindTo(contextKeyService);
        const configuration = configurationService.getValue();
        this.currentFilesAssociationConfig = configuration?.files?.associations;
        this.currentHotExitConfig = configuration?.files?.hotExit || HotExitConfiguration.ON_EXIT;
        this.onFilesConfigurationChange(configuration);
        this.registerListeners();
    }
    createReadonlyMatcher(config) {
        const matcher = this._register(( new ResourceGlobMatcher(
            resource => this.configurationService.getValue(config, { resource }),
            event => event.affectsConfiguration(config),
            this.contextService,
            this.configurationService
        )));
        this._register(matcher.onExpressionChange(() => this._onReadonlyConfigurationChange.fire()));
        return matcher;
    }
    isReadonly(resource, stat) {
        const provider = this.fileService.getProvider(resource.scheme);
        if (provider && hasReadonlyCapability(provider)) {
            return provider.readOnlyMessage ?? FilesConfigurationService_1.READONLY_MESSAGES.providerReadonly;
        }
        const sessionReadonlyOverride = this.sessionReadonlyOverrides.get(resource);
        if (typeof sessionReadonlyOverride === 'boolean') {
            return sessionReadonlyOverride === true ? FilesConfigurationService_1.READONLY_MESSAGES.sessionReadonly : false;
        }
        if (this.uriIdentityService.extUri.isEqualOrParent(resource, this.environmentService.userRoamingDataHome) ||
            this.uriIdentityService.extUri.isEqual(resource, this.contextService.getWorkspace().configuration ?? undefined)) {
            return false;
        }
        if (this.readonlyIncludeMatcher.value.matches(resource)) {
            return !this.readonlyExcludeMatcher.value.matches(resource) ? FilesConfigurationService_1.READONLY_MESSAGES.configuredReadonly : false;
        }
        if (this.configuredReadonlyFromPermissions && stat?.locked) {
            return FilesConfigurationService_1.READONLY_MESSAGES.fileLocked;
        }
        if (stat?.readonly) {
            return FilesConfigurationService_1.READONLY_MESSAGES.fileReadonly;
        }
        return false;
    }
    async updateReadonly(resource, readonly) {
        if (readonly === 'toggle') {
            let stat = undefined;
            try {
                stat = await this.fileService.resolve(resource, { resolveMetadata: true });
            }
            catch (error) {
            }
            readonly = !this.isReadonly(resource, stat);
        }
        if (readonly === 'reset') {
            this.sessionReadonlyOverrides.delete(resource);
        }
        else {
            this.sessionReadonlyOverrides.set(resource, readonly);
        }
        this._onReadonlyConfigurationChange.fire();
    }
    registerListeners() {
        this._register(this.configurationService.onDidChangeConfiguration(e => {
            if (e.affectsConfiguration('files')) {
                this.onFilesConfigurationChange(this.configurationService.getValue());
            }
        }));
    }
    onFilesConfigurationChange(configuration) {
        const autoSaveMode = configuration?.files?.autoSave || FilesConfigurationService_1.DEFAULT_AUTO_SAVE_MODE;
        switch (autoSaveMode) {
            case AutoSaveConfiguration.AFTER_DELAY:
                this.configuredAutoSaveDelay = configuration?.files?.autoSaveDelay;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case AutoSaveConfiguration.ON_FOCUS_CHANGE:
                this.configuredAutoSaveDelay = undefined;
                this.configuredAutoSaveOnFocusChange = true;
                this.configuredAutoSaveOnWindowChange = false;
                break;
            case AutoSaveConfiguration.ON_WINDOW_CHANGE:
                this.configuredAutoSaveDelay = undefined;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = true;
                break;
            default:
                this.configuredAutoSaveDelay = undefined;
                this.configuredAutoSaveOnFocusChange = false;
                this.configuredAutoSaveOnWindowChange = false;
                break;
        }
        this.autoSaveAfterShortDelayContext.set(this.getAutoSaveMode() === 1 );
        this._onAutoSaveConfigurationChange.fire(this.getAutoSaveConfiguration());
        const filesAssociation = configuration?.files?.associations;
        if (!equals(this.currentFilesAssociationConfig, filesAssociation)) {
            this.currentFilesAssociationConfig = filesAssociation;
            this._onFilesAssociationChange.fire();
        }
        const hotExitMode = configuration?.files?.hotExit;
        if (hotExitMode === HotExitConfiguration.OFF || hotExitMode === HotExitConfiguration.ON_EXIT_AND_WINDOW_CLOSE) {
            this.currentHotExitConfig = hotExitMode;
        }
        else {
            this.currentHotExitConfig = HotExitConfiguration.ON_EXIT;
        }
        const readonlyFromPermissions = Boolean(configuration?.files?.readonlyFromPermissions);
        if (readonlyFromPermissions !== Boolean(this.configuredReadonlyFromPermissions)) {
            this.configuredReadonlyFromPermissions = readonlyFromPermissions;
            this._onReadonlyConfigurationChange.fire();
        }
    }
    getAutoSaveMode() {
        if (this.configuredAutoSaveOnFocusChange) {
            return 3 ;
        }
        if (this.configuredAutoSaveOnWindowChange) {
            return 4 ;
        }
        if (typeof this.configuredAutoSaveDelay === 'number' && this.configuredAutoSaveDelay >= 0) {
            return this.configuredAutoSaveDelay <= 1000 ? 1  : 2 ;
        }
        return 0 ;
    }
    getAutoSaveConfiguration() {
        return {
            autoSaveDelay: typeof this.configuredAutoSaveDelay === 'number' && this.configuredAutoSaveDelay >= 0 ? this.configuredAutoSaveDelay : undefined,
            autoSaveFocusChange: !!this.configuredAutoSaveOnFocusChange,
            autoSaveApplicationChange: !!this.configuredAutoSaveOnWindowChange
        };
    }
    async toggleAutoSave() {
        const currentSetting = this.configurationService.getValue('files.autoSave');
        let newAutoSaveValue;
        if (( [AutoSaveConfiguration.AFTER_DELAY, AutoSaveConfiguration.ON_FOCUS_CHANGE, AutoSaveConfiguration.ON_WINDOW_CHANGE].some(setting => setting === currentSetting))) {
            newAutoSaveValue = AutoSaveConfiguration.OFF;
        }
        else {
            newAutoSaveValue = AutoSaveConfiguration.AFTER_DELAY;
        }
        return this.configurationService.updateValue('files.autoSave', newAutoSaveValue);
    }
    get isHotExitEnabled() {
        if (this.contextService.getWorkspace().transient) {
            return false;
        }
        return this.currentHotExitConfig !== HotExitConfiguration.OFF;
    }
    get hotExitConfiguration() {
        return this.currentHotExitConfig;
    }
    preventSaveConflicts(resource, language) {
        return this.configurationService.getValue('files.saveConflictResolution', { resource, overrideIdentifier: language }) !== 'overwriteFileOnDisk';
    }
};
FilesConfigurationService = FilesConfigurationService_1 = ( __decorate([
    ( __param(0, IContextKeyService)),
    ( __param(1, IConfigurationService)),
    ( __param(2, IWorkspaceContextService)),
    ( __param(3, IEnvironmentService)),
    ( __param(4, IUriIdentityService)),
    ( __param(5, IFileService))
], FilesConfigurationService));
export { AutoSaveAfterShortDelayContext, FilesConfigurationService, IFilesConfigurationService };

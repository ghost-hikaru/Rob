import { flatten, mapArrayOrNot } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { isThenable } from 'monaco-editor/esm/vs/base/common/async.js';
import { CancellationTokenSource } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import * as path from 'monaco-editor/esm/vs/base/common/path.js';
import * as resources from 'monaco-editor/esm/vs/base/common/resources.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { resolvePatternsForProvider, QueryGlobTester, hasSiblingPromiseFn } from './search.js';
class TextSearchManager {
    constructor(query, provider, fileUtils, processType) {
        this.query = query;
        this.provider = provider;
        this.fileUtils = fileUtils;
        this.processType = processType;
        this.collector = null;
        this.isLimitHit = false;
        this.resultCount = 0;
    }
    search(onProgress, token) {
        const folderQueries = this.query.folderQueries || [];
        const tokenSource = ( new CancellationTokenSource(token));
        return ( new Promise((resolve, reject) => {
            this.collector = ( new TextSearchResultsCollector(onProgress));
            let isCanceled = false;
            const onResult = (result, folderIdx) => {
                if (isCanceled) {
                    return;
                }
                if (!this.isLimitHit) {
                    const resultSize = this.resultSize(result);
                    if (extensionResultIsMatch(result) && typeof this.query.maxResults === 'number' && this.resultCount + resultSize > this.query.maxResults) {
                        this.isLimitHit = true;
                        isCanceled = true;
                        tokenSource.cancel();
                        result = this.trimResultToSize(result, this.query.maxResults - this.resultCount);
                    }
                    const newResultSize = this.resultSize(result);
                    this.resultCount += newResultSize;
                    if (newResultSize > 0 || !extensionResultIsMatch(result)) {
                        this.collector.add(result, folderIdx);
                    }
                }
            };
            Promise.all(( folderQueries.map((fq, i) => {
                return this.searchInFolder(fq, r => onResult(r, i), tokenSource.token);
            }))).then(results => {
                tokenSource.dispose();
                this.collector.flush();
                const someFolderHitLImit = ( results.some(result => !!result && !!result.limitHit));
                resolve({
                    limitHit: this.isLimitHit || someFolderHitLImit,
                    messages: flatten(( results.map(result => {
                        if (!result?.message) {
                            return [];
                        }
                        if (Array.isArray(result.message)) {
                            return result.message;
                        }
                        else {
                            return [result.message];
                        }
                    }))),
                    stats: {
                        type: this.processType
                    }
                });
            }, (err) => {
                tokenSource.dispose();
                const errMsg = toErrorMessage(err);
                reject(( new Error(errMsg)));
            });
        }));
    }
    resultSize(result) {
        if (extensionResultIsMatch(result)) {
            return Array.isArray(result.ranges) ?
                result.ranges.length :
                1;
        }
        else {
            return 0;
        }
    }
    trimResultToSize(result, size) {
        const rangesArr = Array.isArray(result.ranges) ? result.ranges : [result.ranges];
        const matchesArr = Array.isArray(result.preview.matches) ? result.preview.matches : [result.preview.matches];
        return {
            ranges: rangesArr.slice(0, size),
            preview: {
                matches: matchesArr.slice(0, size),
                text: result.preview.text
            },
            uri: result.uri
        };
    }
    async searchInFolder(folderQuery, onResult, token) {
        const queryTester = ( new QueryGlobTester(this.query, folderQuery));
        const testingPs = [];
        const progress = {
            report: (result) => {
                if (!this.validateProviderResult(result)) {
                    return;
                }
                const hasSibling = folderQuery.folder.scheme === Schemas.file ?
                    hasSiblingPromiseFn(() => {
                        return this.fileUtils.readdir(resources.dirname(result.uri));
                    }) :
                    undefined;
                const relativePath = resources.relativePath(folderQuery.folder, result.uri);
                if (relativePath) {
                    const included = queryTester.includedInQuery(relativePath, path.basename(relativePath), hasSibling);
                    if (isThenable(included)) {
                        testingPs.push(included.then(isIncluded => {
                            if (isIncluded) {
                                onResult(result);
                            }
                        }));
                    }
                    else if (included) {
                        onResult(result);
                    }
                }
            }
        };
        const searchOptions = this.getSearchOptionsForFolder(folderQuery);
        const result = await this.provider.provideTextSearchResults(patternInfoToQuery(this.query.contentPattern), searchOptions, progress, token);
        if (testingPs.length) {
            await Promise.all(testingPs);
        }
        return result;
    }
    validateProviderResult(result) {
        if (extensionResultIsMatch(result)) {
            if (Array.isArray(result.ranges)) {
                if (!Array.isArray(result.preview.matches)) {
                    console.warn('INVALID - A text search provider match\'s`ranges` and`matches` properties must have the same type.');
                    return false;
                }
                if (result.preview.matches.length !== result.ranges.length) {
                    console.warn('INVALID - A text search provider match\'s`ranges` and`matches` properties must have the same length.');
                    return false;
                }
            }
            else {
                if (Array.isArray(result.preview.matches)) {
                    console.warn('INVALID - A text search provider match\'s`ranges` and`matches` properties must have the same length.');
                    return false;
                }
            }
        }
        return true;
    }
    getSearchOptionsForFolder(fq) {
        const includes = resolvePatternsForProvider(this.query.includePattern, fq.includePattern);
        const excludes = resolvePatternsForProvider(this.query.excludePattern, fq.excludePattern);
        const options = {
            folder: ( URI.from(fq.folder)),
            excludes,
            includes,
            useIgnoreFiles: !fq.disregardIgnoreFiles,
            useGlobalIgnoreFiles: !fq.disregardGlobalIgnoreFiles,
            useParentIgnoreFiles: !fq.disregardParentIgnoreFiles,
            followSymlinks: !fq.ignoreSymlinks,
            encoding: fq.fileEncoding && this.fileUtils.toCanonicalName(fq.fileEncoding),
            maxFileSize: this.query.maxFileSize,
            maxResults: this.query.maxResults,
            previewOptions: this.query.previewOptions,
            afterContext: this.query.afterContext,
            beforeContext: this.query.beforeContext
        };
        options.usePCRE2 = this.query.usePCRE2;
        return options;
    }
}
function patternInfoToQuery(patternInfo) {
    return {
        isCaseSensitive: patternInfo.isCaseSensitive || false,
        isRegExp: patternInfo.isRegExp || false,
        isWordMatch: patternInfo.isWordMatch || false,
        isMultiline: patternInfo.isMultiline || false,
        pattern: patternInfo.pattern
    };
}
class TextSearchResultsCollector {
    constructor(_onResult) {
        this._onResult = _onResult;
        this._currentFolderIdx = -1;
        this._currentFileMatch = null;
        this._batchedCollector = ( new BatchedCollector(512, items => this.sendItems(items)));
    }
    add(data, folderIdx) {
        if (this._currentFileMatch && (this._currentFolderIdx !== folderIdx || !resources.isEqual(this._currentUri, data.uri))) {
            this.pushToCollector();
            this._currentFileMatch = null;
        }
        if (!this._currentFileMatch) {
            this._currentFolderIdx = folderIdx;
            this._currentFileMatch = {
                resource: data.uri,
                results: []
            };
        }
        this._currentFileMatch.results.push(extensionResultToFrontendResult(data));
    }
    pushToCollector() {
        const size = this._currentFileMatch && this._currentFileMatch.results ?
            this._currentFileMatch.results.length :
            0;
        this._batchedCollector.addItem(this._currentFileMatch, size);
    }
    flush() {
        this.pushToCollector();
        this._batchedCollector.flush();
    }
    sendItems(items) {
        this._onResult(items);
    }
}
function extensionResultToFrontendResult(data) {
    if (extensionResultIsMatch(data)) {
        return {
            preview: {
                matches: mapArrayOrNot(data.preview.matches, m => ({
                    startLineNumber: m.start.line,
                    startColumn: m.start.character,
                    endLineNumber: m.end.line,
                    endColumn: m.end.character
                })),
                text: data.preview.text
            },
            ranges: mapArrayOrNot(data.ranges, r => ({
                startLineNumber: r.start.line,
                startColumn: r.start.character,
                endLineNumber: r.end.line,
                endColumn: r.end.character
            }))
        };
    }
    else {
        return {
            text: data.text,
            lineNumber: data.lineNumber
        };
    }
}
function extensionResultIsMatch(data) {
    return !!data.preview;
}
class BatchedCollector {
    static { this.TIMEOUT = 4000; }
    static { this.START_BATCH_AFTER_COUNT = 50; }
    constructor(maxBatchSize, cb) {
        this.maxBatchSize = maxBatchSize;
        this.cb = cb;
        this.totalNumberCompleted = 0;
        this.batch = [];
        this.batchSize = 0;
    }
    addItem(item, size) {
        if (!item) {
            return;
        }
        this.addItemToBatch(item, size);
    }
    addItems(items, size) {
        if (!items) {
            return;
        }
        this.addItemsToBatch(items, size);
    }
    addItemToBatch(item, size) {
        this.batch.push(item);
        this.batchSize += size;
        this.onUpdate();
    }
    addItemsToBatch(item, size) {
        this.batch = this.batch.concat(item);
        this.batchSize += size;
        this.onUpdate();
    }
    onUpdate() {
        if (this.totalNumberCompleted < BatchedCollector.START_BATCH_AFTER_COUNT) {
            this.flush();
        }
        else if (this.batchSize >= this.maxBatchSize) {
            this.flush();
        }
        else if (!this.timeoutHandle) {
            this.timeoutHandle = setTimeout(() => {
                this.flush();
            }, BatchedCollector.TIMEOUT);
        }
    }
    flush() {
        if (this.batchSize) {
            this.totalNumberCompleted += this.batchSize;
            this.cb(this.batch);
            this.batch = [];
            this.batchSize = 0;
            if (this.timeoutHandle) {
                clearTimeout(this.timeoutHandle);
                this.timeoutHandle = 0;
            }
        }
    }
}
export { BatchedCollector, TextSearchManager, TextSearchResultsCollector, extensionResultIsMatch };

import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { Queue } from 'monaco-editor/esm/vs/base/common/async.js';
import * as json from 'monaco-editor/esm/vs/base/common/json.js';
import * as objects from 'monaco-editor/esm/vs/base/common/objects.js';
import { setProperty } from '../../../../base/common/jsonEdit.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { EditOperation } from 'monaco-editor/esm/vs/editor/common/core/editOperation.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { Selection } from 'monaco-editor/esm/vs/editor/common/core/selection.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ITextFileService } from '../../textfile/common/textfiles.js';
import { IUserDataProfileService } from '../../userDataProfile/common/userDataProfile.js';
const IKeybindingEditingService = ( createDecorator('keybindingEditingService'));
let KeybindingsEditingService = class KeybindingsEditingService extends Disposable {
    constructor(textModelResolverService, textFileService, fileService, configurationService, userDataProfileService) {
        super();
        this.textModelResolverService = textModelResolverService;
        this.textFileService = textFileService;
        this.fileService = fileService;
        this.configurationService = configurationService;
        this.userDataProfileService = userDataProfileService;
        this.queue = ( new Queue());
    }
    addKeybinding(keybindingItem, key, when) {
        return this.queue.queue(() => this.doEditKeybinding(keybindingItem, key, when, true));
    }
    editKeybinding(keybindingItem, key, when) {
        return this.queue.queue(() => this.doEditKeybinding(keybindingItem, key, when, false));
    }
    resetKeybinding(keybindingItem) {
        return this.queue.queue(() => this.doResetKeybinding(keybindingItem));
    }
    removeKeybinding(keybindingItem) {
        return this.queue.queue(() => this.doRemoveKeybinding(keybindingItem));
    }
    async doEditKeybinding(keybindingItem, key, when, add) {
        const reference = await this.resolveAndValidate();
        const model = reference.object.textEditorModel;
        if (add) {
            this.updateKeybinding(keybindingItem, key, when, model, -1);
        }
        else {
            const userKeybindingEntries = json.parse(model.getValue());
            const userKeybindingEntryIndex = this.findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries);
            this.updateKeybinding(keybindingItem, key, when, model, userKeybindingEntryIndex);
            if (keybindingItem.isDefault && keybindingItem.resolvedKeybinding) {
                this.removeDefaultKeybinding(keybindingItem, model);
            }
        }
        try {
            await this.save();
        }
        finally {
            reference.dispose();
        }
    }
    doRemoveKeybinding(keybindingItem) {
        return this.resolveAndValidate()
            .then(reference => {
            const model = reference.object.textEditorModel;
            if (keybindingItem.isDefault) {
                this.removeDefaultKeybinding(keybindingItem, model);
            }
            else {
                this.removeUserKeybinding(keybindingItem, model);
            }
            return this.save().finally(() => reference.dispose());
        });
    }
    doResetKeybinding(keybindingItem) {
        return this.resolveAndValidate()
            .then(reference => {
            const model = reference.object.textEditorModel;
            if (!keybindingItem.isDefault) {
                this.removeUserKeybinding(keybindingItem, model);
                this.removeUnassignedDefaultKeybinding(keybindingItem, model);
            }
            return this.save().finally(() => reference.dispose());
        });
    }
    save() {
        return this.textFileService.save(this.userDataProfileService.currentProfile.keybindingsResource);
    }
    updateKeybinding(keybindingItem, newKey, when, model, userKeybindingEntryIndex) {
        const { tabSize, insertSpaces } = model.getOptions();
        const eol = model.getEOL();
        if (userKeybindingEntryIndex !== -1) {
            this.applyEditsToBuffer(setProperty(model.getValue(), [userKeybindingEntryIndex, 'key'], newKey, { tabSize, insertSpaces, eol })[0], model);
            const edits = setProperty(model.getValue(), [userKeybindingEntryIndex, 'when'], when, { tabSize, insertSpaces, eol });
            if (edits.length > 0) {
                this.applyEditsToBuffer(edits[0], model);
            }
        }
        else {
            this.applyEditsToBuffer(setProperty(model.getValue(), [-1], this.asObject(newKey, keybindingItem.command, when, false), { tabSize, insertSpaces, eol })[0], model);
        }
    }
    removeUserKeybinding(keybindingItem, model) {
        const { tabSize, insertSpaces } = model.getOptions();
        const eol = model.getEOL();
        const userKeybindingEntries = json.parse(model.getValue());
        const userKeybindingEntryIndex = this.findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries);
        if (userKeybindingEntryIndex !== -1) {
            this.applyEditsToBuffer(setProperty(model.getValue(), [userKeybindingEntryIndex], undefined, { tabSize, insertSpaces, eol })[0], model);
        }
    }
    removeDefaultKeybinding(keybindingItem, model) {
        const { tabSize, insertSpaces } = model.getOptions();
        const eol = model.getEOL();
        const key = keybindingItem.resolvedKeybinding ? keybindingItem.resolvedKeybinding.getUserSettingsLabel() : null;
        if (key) {
            const entry = this.asObject(key, keybindingItem.command, keybindingItem.when ? keybindingItem.when.serialize() : undefined, true);
            const userKeybindingEntries = json.parse(model.getValue());
            if (userKeybindingEntries.every(e => !this.areSame(e, entry))) {
                this.applyEditsToBuffer(setProperty(model.getValue(), [-1], entry, { tabSize, insertSpaces, eol })[0], model);
            }
        }
    }
    removeUnassignedDefaultKeybinding(keybindingItem, model) {
        const { tabSize, insertSpaces } = model.getOptions();
        const eol = model.getEOL();
        const userKeybindingEntries = json.parse(model.getValue());
        const indices = this.findUnassignedDefaultKeybindingEntryIndex(keybindingItem, userKeybindingEntries).reverse();
        for (const index of indices) {
            this.applyEditsToBuffer(setProperty(model.getValue(), [index], undefined, { tabSize, insertSpaces, eol })[0], model);
        }
    }
    findUserKeybindingEntryIndex(keybindingItem, userKeybindingEntries) {
        for (let index = 0; index < userKeybindingEntries.length; index++) {
            const keybinding = userKeybindingEntries[index];
            if (keybinding.command === keybindingItem.command) {
                if (!keybinding.when && !keybindingItem.when) {
                    return index;
                }
                if (keybinding.when && keybindingItem.when) {
                    const contextKeyExpr = ContextKeyExpr.deserialize(keybinding.when);
                    if (contextKeyExpr && contextKeyExpr.serialize() === keybindingItem.when.serialize()) {
                        return index;
                    }
                }
            }
        }
        return -1;
    }
    findUnassignedDefaultKeybindingEntryIndex(keybindingItem, userKeybindingEntries) {
        const indices = [];
        for (let index = 0; index < userKeybindingEntries.length; index++) {
            if (userKeybindingEntries[index].command === `-${keybindingItem.command}`) {
                indices.push(index);
            }
        }
        return indices;
    }
    asObject(key, command, when, negate) {
        const object = { key };
        if (command) {
            object['command'] = negate ? `-${command}` : command;
        }
        if (when) {
            object['when'] = when;
        }
        return object;
    }
    areSame(a, b) {
        if (a.command !== b.command) {
            return false;
        }
        if (a.key !== b.key) {
            return false;
        }
        const whenA = ContextKeyExpr.deserialize(a.when);
        const whenB = ContextKeyExpr.deserialize(b.when);
        if ((whenA && !whenB) || (!whenA && whenB)) {
            return false;
        }
        if (whenA && whenB && !whenA.equals(whenB)) {
            return false;
        }
        if (!objects.equals(a.args, b.args)) {
            return false;
        }
        return true;
    }
    applyEditsToBuffer(edit, model) {
        const startPosition = model.getPositionAt(edit.offset);
        const endPosition = model.getPositionAt(edit.offset + edit.length);
        const range = ( new Range(
            startPosition.lineNumber,
            startPosition.column,
            endPosition.lineNumber,
            endPosition.column
        ));
        const currentText = model.getValueInRange(range);
        const editOperation = currentText ? EditOperation.replace(range, edit.content) : EditOperation.insert(startPosition, edit.content);
        model.pushEditOperations([( new Selection(
            startPosition.lineNumber,
            startPosition.column,
            startPosition.lineNumber,
            startPosition.column
        ))], [editOperation], () => []);
    }
    resolveModelReference() {
        return this.fileService.exists(this.userDataProfileService.currentProfile.keybindingsResource)
            .then(exists => {
            const EOL = this.configurationService.getValue('files', { overrideIdentifier: 'json' })['eol'];
            const result = exists ? Promise.resolve(null) : this.textFileService.write(this.userDataProfileService.currentProfile.keybindingsResource, this.getEmptyContent(EOL), { encoding: 'utf8' });
            return result.then(() => this.textModelResolverService.createModelReference(this.userDataProfileService.currentProfile.keybindingsResource));
        });
    }
    resolveAndValidate() {
        if (this.textFileService.isDirty(this.userDataProfileService.currentProfile.keybindingsResource)) {
            return Promise.reject(( new Error(( localizeWithPath(
                'vs/workbench/services/keybinding/common/keybindingEditing',
                'errorKeybindingsFileDirty',
                "Unable to write because the keybindings configuration file has unsaved changes. Please save it first and then try again."
            )))));
        }
        return this.resolveModelReference()
            .then(reference => {
            const model = reference.object.textEditorModel;
            const EOL = model.getEOL();
            if (model.getValue()) {
                const parsed = this.parse(model);
                if (parsed.parseErrors.length) {
                    reference.dispose();
                    return Promise.reject(( new Error(( localizeWithPath(
                        'vs/workbench/services/keybinding/common/keybindingEditing',
                        'parseErrors',
                        "Unable to write to the keybindings configuration file. Please open it to correct errors/warnings in the file and try again."
                    )))));
                }
                if (parsed.result) {
                    if (!Array.isArray(parsed.result)) {
                        reference.dispose();
                        return Promise.reject(( new Error(( localizeWithPath(
                            'vs/workbench/services/keybinding/common/keybindingEditing',
                            'errorInvalidConfiguration',
                            "Unable to write to the keybindings configuration file. It has an object which is not of type Array. Please open the file to clean up and try again."
                        )))));
                    }
                }
                else {
                    const content = EOL + '[]';
                    this.applyEditsToBuffer({ content, length: content.length, offset: model.getValue().length }, model);
                }
            }
            else {
                const content = this.getEmptyContent(EOL);
                this.applyEditsToBuffer({ content, length: content.length, offset: 0 }, model);
            }
            return reference;
        });
    }
    parse(model) {
        const parseErrors = [];
        const result = json.parse(model.getValue(), parseErrors, { allowTrailingComma: true, allowEmptyContent: true });
        return { result, parseErrors };
    }
    getEmptyContent(EOL) {
        return '// ' + ( localizeWithPath(
            'vs/workbench/services/keybinding/common/keybindingEditing',
            'emptyKeybindingsHeader',
            "Place your key bindings in this file to override the defaults"
        )) + EOL + '[]';
    }
};
KeybindingsEditingService = ( __decorate([
    ( __param(0, ITextModelService)),
    ( __param(1, ITextFileService)),
    ( __param(2, IFileService)),
    ( __param(3, IConfigurationService)),
    ( __param(4, IUserDataProfileService))
], KeybindingsEditingService));
export { IKeybindingEditingService, KeybindingsEditingService };

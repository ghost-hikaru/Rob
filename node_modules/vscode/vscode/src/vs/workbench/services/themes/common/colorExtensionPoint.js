import * as nls from 'monaco-editor/esm/vs/nls.js';
import { ExtensionsRegistry } from '../../extensions/common/extensionsRegistry.js';
import { Extensions } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { Color } from 'monaco-editor/esm/vs/base/common/color.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
const colorRegistry = ( Registry.as(Extensions.ColorContribution));
const colorReferenceSchema = colorRegistry.getColorReferenceSchema();
const colorIdPattern = '^\\w+[.\\w+]*$';
const configurationExtPoint = ( ExtensionsRegistry.registerExtensionPoint({
    extensionPoint: 'colors',
    jsonSchema: {
        description: ( nls.localizeWithPath(
            'vs/workbench/services/themes/common/colorExtensionPoint',
            'contributes.color',
            'Contributes extension defined themable colors'
        )),
        type: 'array',
        items: {
            type: 'object',
            properties: {
                id: {
                    type: 'string',
                    description: ( nls.localizeWithPath(
                        'vs/workbench/services/themes/common/colorExtensionPoint',
                        'contributes.color.id',
                        'The identifier of the themable color'
                    )),
                    pattern: colorIdPattern,
                    patternErrorMessage: ( nls.localizeWithPath(
                        'vs/workbench/services/themes/common/colorExtensionPoint',
                        'contributes.color.id.format',
                        'Identifiers must only contain letters, digits and dots and can not start with a dot'
                    )),
                },
                description: {
                    type: 'string',
                    description: ( nls.localizeWithPath(
                        'vs/workbench/services/themes/common/colorExtensionPoint',
                        'contributes.color.description',
                        'The description of the themable color'
                    )),
                },
                defaults: {
                    type: 'object',
                    properties: {
                        light: {
                            description: ( nls.localizeWithPath(
                                'vs/workbench/services/themes/common/colorExtensionPoint',
                                'contributes.defaults.light',
                                'The default color for light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.'
                            )),
                            type: 'string',
                            anyOf: [
                                colorReferenceSchema,
                                { type: 'string', format: 'color-hex' }
                            ]
                        },
                        dark: {
                            description: ( nls.localizeWithPath(
                                'vs/workbench/services/themes/common/colorExtensionPoint',
                                'contributes.defaults.dark',
                                'The default color for dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default.'
                            )),
                            type: 'string',
                            anyOf: [
                                colorReferenceSchema,
                                { type: 'string', format: 'color-hex' }
                            ]
                        },
                        highContrast: {
                            description: ( nls.localizeWithPath(
                                'vs/workbench/services/themes/common/colorExtensionPoint',
                                'contributes.defaults.highContrast',
                                'The default color for high contrast dark themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default. If not provided, the `dark` color is used as default for high contrast dark themes.'
                            )),
                            type: 'string',
                            anyOf: [
                                colorReferenceSchema,
                                { type: 'string', format: 'color-hex' }
                            ]
                        },
                        highContrastLight: {
                            description: ( nls.localizeWithPath(
                                'vs/workbench/services/themes/common/colorExtensionPoint',
                                'contributes.defaults.highContrastLight',
                                'The default color for high contrast light themes. Either a color value in hex (#RRGGBB[AA]) or the identifier of a themable color which provides the default. If not provided, the `light` color is used as default for high contrast light themes.'
                            )),
                            type: 'string',
                            anyOf: [
                                colorReferenceSchema,
                                { type: 'string', format: 'color-hex' }
                            ]
                        }
                    },
                    required: ['light', 'dark']
                }
            }
        }
    }
}));
class ColorExtensionPoint {
    constructor() {
        configurationExtPoint.setHandler((extensions, delta) => {
            for (const extension of delta.added) {
                const extensionValue = extension.value;
                const collector = extension.collector;
                if (!extensionValue || !Array.isArray(extensionValue)) {
                    collector.error(( nls.localizeWithPath(
                        'vs/workbench/services/themes/common/colorExtensionPoint',
                        'invalid.colorConfiguration',
                        "'configuration.colors' must be a array"
                    )));
                    return;
                }
                const parseColorValue = (s, name) => {
                    if (s.length > 0) {
                        if (s[0] === '#') {
                            return Color.Format.CSS.parseHex(s);
                        }
                        else {
                            return s;
                        }
                    }
                    collector.error(( nls.localizeWithPath(
                        'vs/workbench/services/themes/common/colorExtensionPoint',
                        'invalid.default.colorType',
                        "{0} must be either a color value in hex (#RRGGBB[AA] or #RGB[A]) or the identifier of a themable color which provides the default.",
                        name
                    )));
                    return Color.red;
                };
                for (const colorContribution of extensionValue) {
                    if (typeof colorContribution.id !== 'string' || colorContribution.id.length === 0) {
                        collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/themes/common/colorExtensionPoint',
                            'invalid.id',
                            "'configuration.colors.id' must be defined and can not be empty"
                        )));
                        return;
                    }
                    if (!colorContribution.id.match(colorIdPattern)) {
                        collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/themes/common/colorExtensionPoint',
                            'invalid.id.format',
                            "'configuration.colors.id' must only contain letters, digits and dots and can not start with a dot"
                        )));
                        return;
                    }
                    if (typeof colorContribution.description !== 'string' || colorContribution.id.length === 0) {
                        collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/themes/common/colorExtensionPoint',
                            'invalid.description',
                            "'configuration.colors.description' must be defined and can not be empty"
                        )));
                        return;
                    }
                    const defaults = colorContribution.defaults;
                    if (!defaults || typeof defaults !== 'object' || typeof defaults.light !== 'string' || typeof defaults.dark !== 'string') {
                        collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/themes/common/colorExtensionPoint',
                            'invalid.defaults',
                            "'configuration.colors.defaults' must be defined and must contain 'light' and 'dark'"
                        )));
                        return;
                    }
                    if (defaults.highContrast && typeof defaults.highContrast !== 'string') {
                        collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/themes/common/colorExtensionPoint',
                            'invalid.defaults.highContrast',
                            "If defined, 'configuration.colors.defaults.highContrast' must be a string."
                        )));
                        return;
                    }
                    if (defaults.highContrastLight && typeof defaults.highContrastLight !== 'string') {
                        collector.error(( nls.localizeWithPath(
                            'vs/workbench/services/themes/common/colorExtensionPoint',
                            'invalid.defaults.highContrastLight',
                            "If defined, 'configuration.colors.defaults.highContrastLight' must be a string."
                        )));
                        return;
                    }
                    colorRegistry.registerColor(colorContribution.id, {
                        light: parseColorValue(defaults.light, 'configuration.colors.defaults.light'),
                        dark: parseColorValue(defaults.dark, 'configuration.colors.defaults.dark'),
                        hcDark: parseColorValue(defaults.highContrast ?? defaults.dark, 'configuration.colors.defaults.highContrast'),
                        hcLight: parseColorValue(defaults.highContrastLight ?? defaults.light, 'configuration.colors.defaults.highContrastLight'),
                    }, colorContribution.description);
                }
            }
            for (const extension of delta.removed) {
                const extensionValue = extension.value;
                for (const colorContribution of extensionValue) {
                    colorRegistry.deregisterColor(colorContribution.id);
                }
            }
        });
    }
}
export { ColorExtensionPoint };

import { IStringDictionary } from '../../../../base/common/collections.js';
import { Event, Emitter } from '../../../../base/common/event.js';
import { Disposable } from '../../../../base/common/lifecycle.js';
import { IRange } from '../../../../editor/common/core/range.js';
import { IConfigurationService, ConfigurationTarget } from '../../../../platform/configuration/common/configuration.js';
import { EditorModel } from '../../../common/editor/editorModel.js';
import { ISettingsEditorModel, ISettingsGroup, ISetting, IFilterResult, ISearchResultGroup, IGroupFilter, ISettingMatcher, ISettingMatch, IFilterMetadata } from './preferences.js';

declare abstract class AbstractSettingsModel extends EditorModel {
    protected _currentResultGroups: Map<string, ISearchResultGroup>;
    updateResultGroup(id: string, resultGroup: ISearchResultGroup | undefined): IFilterResult | undefined;
    /**
     * Remove duplicates between result groups, preferring results in earlier groups
     */
    private removeDuplicateResults;
    filterSettings(filter: string, groupFilter: IGroupFilter, settingMatcher: ISettingMatcher): ISettingMatch[];
    getPreference(key: string): ISetting | undefined;
    protected collectMetadata(groups: ISearchResultGroup[]): IStringDictionary<IFilterMetadata>;
    protected get filterGroups(): ISettingsGroup[];
    abstract settingsGroups: ISettingsGroup[];
    abstract findValueMatches(filter: string, setting: ISetting): IRange[];
    protected abstract update(): IFilterResult | undefined;
}
declare class Settings2EditorModel extends AbstractSettingsModel implements ISettingsEditorModel {
    private _defaultSettings;
    private readonly _onDidChangeGroups;
    readonly onDidChangeGroups: Event<void>;
    private additionalGroups;
    private dirty;
    constructor(_defaultSettings: DefaultSettings, configurationService: IConfigurationService);
    /** Doesn't include the "Commonly Used" group */
    protected get filterGroups(): ISettingsGroup[];
    get settingsGroups(): ISettingsGroup[];
    /** For programmatically added groups outside of registered configurations */
    setAdditionalGroups(groups: ISettingsGroup[]): void;
    findValueMatches(filter: string, setting: ISetting): IRange[];
    protected update(): IFilterResult;
}
declare class DefaultSettings extends Disposable {
    private _mostCommonlyUsedSettingsKeys;
    readonly target: ConfigurationTarget;
    private _allSettingsGroups;
    private _content;
    private _contentWithoutMostCommonlyUsed;
    private _settingsByName;
    readonly _onDidChange: Emitter<void>;
    readonly onDidChange: Event<void>;
    constructor(_mostCommonlyUsedSettingsKeys: string[], target: ConfigurationTarget);
    getContent(forceUpdate?: boolean): string;
    getContentWithoutMostCommonlyUsed(forceUpdate?: boolean): string;
    getSettingsGroups(forceUpdate?: boolean): ISettingsGroup[];
    private initialize;
    private parse;
    getRegisteredGroups(): ISettingsGroup[];
    private sortGroups;
    private initAllSettingsMap;
    private getMostCommonlyUsedSettings;
    private parseConfig;
    private removeEmptySettingsGroups;
    private parseSettings;
    private parseOverrideSettings;
    private matchesScope;
    private compareConfigurationNodes;
    private toContent;
}

export { DefaultSettings, Settings2EditorModel };

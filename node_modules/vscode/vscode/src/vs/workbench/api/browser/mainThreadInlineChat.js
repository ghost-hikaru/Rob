import { __decorate, __param } from '../../../../../../external/tslib/tslib.es6.js';
import { DisposableMap } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IInlineChatService } from '../../contrib/inlineChat/common/inlineChat.js';
import { IUriIdentityService } from 'monaco-editor/esm/vs/platform/uriIdentity/common/uriIdentity.js';
import { reviveWorkspaceEditDto } from './mainThreadBulkEdits.js';
import { ExtHostContext, MainContext } from '../common/extHost.protocol.js';
import { extHostNamedCustomer } from '../../services/extensions/common/extHostCustomers.js';
let MainThreadInlineChat = class MainThreadInlineChat {
    constructor(extHostContext, _inlineChatService, _uriIdentService) {
        this._inlineChatService = _inlineChatService;
        this._uriIdentService = _uriIdentService;
        this._registrations = ( new DisposableMap());
        this._progresses = ( new Map());
        this._proxy = ( extHostContext.getProxy(ExtHostContext.ExtHostInlineChat));
    }
    dispose() {
        this._registrations.dispose();
    }
    async $registerInteractiveEditorProvider(handle, label, debugName, supportsFeedback) {
        const unreg = this._inlineChatService.addProvider({
            debugName,
            label,
            prepareInlineChatSession: async (model, range, token) => {
                const session = await this._proxy.$prepareSession(handle, model.uri, range, token);
                if (!session) {
                    return undefined;
                }
                return {
                    ...session,
                    dispose: () => {
                        this._proxy.$releaseSession(handle, session.id);
                    }
                };
            },
            provideResponse: async (item, request, progress, token) => {
                this._progresses.set(request.requestId, progress);
                try {
                    const result = await this._proxy.$provideResponse(handle, item, request, token);
                    if (result?.type === 'bulkEdit') {
                        result.edits = reviveWorkspaceEditDto(result.edits, this._uriIdentService);
                    }
                    return result;
                }
                finally {
                    this._progresses.delete(request.requestId);
                }
            },
            handleInlineChatResponseFeedback: !supportsFeedback ? undefined : async (session, response, kind) => {
                this._proxy.$handleFeedback(handle, session.id, response.id, kind);
            }
        });
        this._registrations.set(handle, unreg);
    }
    async $handleProgressChunk(requestId, chunk) {
        this._progresses.get(requestId)?.report(chunk);
    }
    async $unregisterInteractiveEditorProvider(handle) {
        this._registrations.deleteAndDispose(handle);
    }
};
MainThreadInlineChat = __decorate([
    extHostNamedCustomer(MainContext.MainThreadInlineChat),
    ( __param(1, IInlineChatService)),
    ( __param(2, IUriIdentityService))
], MainThreadInlineChat);
export { MainThreadInlineChat };

import { raceCancellation } from 'monaco-editor/esm/vs/base/common/async.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { Iterable } from 'monaco-editor/esm/vs/base/common/iterator.js';
import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { StopWatch } from 'monaco-editor/esm/vs/base/common/stopwatch.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { MainContext } from './extHost.protocol.js';
import { ChatReplyFollowup, ChatFollowup, CompletionItemKind, ChatVariable, MarkdownString, Range } from './extHostTypeConverters.js';
class ChatProviderWrapper {
    static { this._pool = 0; }
    constructor(extension, provider) {
        this.extension = extension;
        this.provider = provider;
        this.handle = ChatProviderWrapper._pool++;
    }
}
class ExtHostChat {
    static { this._nextId = 0; }
    constructor(mainContext, logService) {
        this.logService = logService;
        this._chatProvider = ( new Map());
        this._chatSessions = ( new Map());
        this._onDidPerformUserAction = ( new Emitter());
        this.onDidPerformUserAction = this._onDidPerformUserAction.event;
        this._proxy = ( mainContext.getProxy(MainContext.MainThreadChat));
    }
    registerChatProvider(extension, id, provider) {
        const wrapper = ( new ChatProviderWrapper(extension, provider));
        this._chatProvider.set(wrapper.handle, wrapper);
        this._proxy.$registerChatProvider(wrapper.handle, id);
        return toDisposable(() => {
            this._proxy.$unregisterChatProvider(wrapper.handle);
            this._chatProvider.delete(wrapper.handle);
        });
    }
    transferChatSession(session, newWorkspace) {
        const sessionId = Iterable.find(( this._chatSessions.keys()), key => this._chatSessions.get(key) === session) ?? 0;
        if (typeof sessionId !== 'number') {
            return;
        }
        this._proxy.$transferChatSession(sessionId, newWorkspace);
    }
    addChatRequest(context) {
        this._proxy.$addRequest(context);
    }
    sendInteractiveRequestToProvider(providerId, message) {
        this._proxy.$sendRequestToProvider(providerId, message);
    }
    async $prepareChat(handle, initialState, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const session = await entry.provider.prepareSession(initialState, token);
        if (!session) {
            return undefined;
        }
        const id = ExtHostChat._nextId++;
        this._chatSessions.set(id, session);
        return {
            id,
            requesterUsername: session.requester?.name,
            requesterAvatarIconUri: session.requester?.icon,
            responderUsername: session.responder?.name,
            responderAvatarIconUri: session.responder?.icon,
            inputPlaceholder: session.inputPlaceholder,
        };
    }
    async $resolveRequest(handle, sessionId, context, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const realSession = this._chatSessions.get(sessionId);
        if (!realSession) {
            return undefined;
        }
        if (!entry.provider.resolveRequest) {
            return undefined;
        }
        const request = await entry.provider.resolveRequest(realSession, context, token);
        if (request) {
            return {
                message: typeof request.message === 'string' ? request.message : ChatReplyFollowup.from(request.message),
            };
        }
        return undefined;
    }
    async $provideWelcomeMessage(handle, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        if (!entry.provider.provideWelcomeMessage) {
            return undefined;
        }
        const content = await entry.provider.provideWelcomeMessage(token);
        if (!content) {
            return undefined;
        }
        return ( content.map(item => {
            if (typeof item === 'string') {
                return item;
            }
            else {
                return ( item.map(f => ChatReplyFollowup.from(f)));
            }
        }));
    }
    async $provideFollowups(handle, sessionId, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const realSession = this._chatSessions.get(sessionId);
        if (!realSession) {
            return;
        }
        if (!entry.provider.provideFollowups) {
            return undefined;
        }
        const rawFollowups = await entry.provider.provideFollowups(realSession, token);
        return rawFollowups?.map(f => ChatFollowup.from(f));
    }
    $removeRequest(handle, sessionId, requestId) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return;
        }
        const realSession = this._chatSessions.get(sessionId);
        if (!realSession) {
            return;
        }
        if (!entry.provider.removeRequest) {
            return;
        }
        entry.provider.removeRequest(realSession, requestId);
    }
    async $provideReply(handle, sessionId, request, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const realSession = this._chatSessions.get(sessionId);
        if (!realSession) {
            return;
        }
        const requestObj = {
            session: realSession,
            message: typeof request.message === 'string' ? request.message : ChatReplyFollowup.to(request.message),
            variables: {}
        };
        if (request.variables) {
            for (const key of ( Object.keys(request.variables))) {
                requestObj.variables[key] = ( request.variables[key].map(ChatVariable.to));
            }
        }
        const stopWatch = StopWatch.create(false);
        let firstProgress;
        const progressObj = {
            report: (progress) => {
                if (token.isCancellationRequested) {
                    return;
                }
                if (typeof firstProgress === 'undefined') {
                    firstProgress = stopWatch.elapsed();
                }
                if ('responseId' in progress) {
                    this._proxy.$acceptResponseProgress(handle, sessionId, { requestId: progress.responseId });
                }
                else if ('placeholder' in progress && 'resolvedContent' in progress) {
                    const resolvedContent = Promise.all([this._proxy.$acceptResponseProgress(handle, sessionId, { placeholder: progress.placeholder }), progress.resolvedContent]);
                    raceCancellation(resolvedContent, token).then((res) => {
                        if (!res) {
                            return;
                        }
                        const [progressHandle, progressContent] = res;
                        this._proxy.$acceptResponseProgress(handle, sessionId, progressContent, progressHandle ?? undefined);
                    });
                }
                else if ('content' in progress) {
                    this._proxy.$acceptResponseProgress(handle, sessionId, {
                        content: typeof progress.content === 'string' ? progress.content : MarkdownString.from(progress.content)
                    });
                }
                else if ('documents' in progress) {
                    this._proxy.$acceptResponseProgress(handle, sessionId, {
                        documents: ( progress.documents.map(d => ({
                            uri: d.uri,
                            version: d.version,
                            ranges: ( d.ranges.map(r => Range.from(r)))
                        })))
                    });
                }
                else {
                    this._proxy.$acceptResponseProgress(handle, sessionId, progress);
                }
            }
        };
        let result;
        try {
            result = await entry.provider.provideResponseWithProgress(requestObj, progressObj, token);
            if (!result) {
                result = { errorDetails: { message: ( localizeWithPath(
                    'vs/workbench/api/common/extHostChat',
                    'emptyResponse',
                    "Provider returned null response"
                )) } };
            }
        }
        catch (err) {
            result = { errorDetails: { message: ( localizeWithPath(
                'vs/workbench/api/common/extHostChat',
                'errorResponse',
                "Error from provider: {0}",
                err.message
            )), responseIsIncomplete: true } };
            this.logService.error(err);
        }
        try {
            if (realSession.saveState && ( this._chatSessions.has(sessionId))) {
                const newState = realSession.saveState();
                this._proxy.$acceptChatState(sessionId, newState);
            }
        }
        catch (err) {
            this.logService.warn(err);
        }
        const timings = { firstProgress: firstProgress ?? 0, totalElapsed: stopWatch.elapsed() };
        return { errorDetails: result.errorDetails, timings };
    }
    async $provideSlashCommands(handle, sessionId, token) {
        const entry = this._chatProvider.get(handle);
        if (!entry) {
            return undefined;
        }
        const realSession = this._chatSessions.get(sessionId);
        if (!realSession) {
            return undefined;
        }
        if (!entry.provider.provideSlashCommands) {
            return undefined;
        }
        const slashCommands = await entry.provider.provideSlashCommands(realSession, token);
        return slashCommands?.map(c => ({
            ...c,
            kind: CompletionItemKind.from(c.kind)
        }));
    }
    $releaseSession(sessionId) {
        this._chatSessions.delete(sessionId);
    }
    async $onDidPerformUserAction(event) {
        this._onDidPerformUserAction.fire(event);
    }
}
export { ExtHostChat };

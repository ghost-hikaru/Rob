import { ServiceIdentifier } from '../../platform/instantiation/common/instantiation.js';
import { URI } from '../../base/common/uri.js';
import { Event } from '../../base/common/event.js';
import { ThemeIcon } from '../../base/common/themables.js';
import { ContextKeyExpression } from '../../platform/contextkey/common/contextkey.js';
import { ExtensionIdentifier } from '../../platform/extensions/common/extensions.js';
import Severity from '../../base/common/severity.js';
import { IKeybindings } from '../../platform/keybinding/common/keybindingsRegistry.js';
import { SyncDescriptor } from '../../platform/instantiation/common/descriptors.js';
import { IProgressIndicator } from '../../platform/progress/common/progress.js';
import { IPaneComposite } from './panecomposite.js';
import { ILocalizedString } from '../../platform/action/common/action.js';

declare const enum ViewContainerLocation {
    Sidebar = 0,
    Panel = 1,
    AuxiliaryBar = 2
}
type OpenCommandActionDescriptor = {
    readonly id: string;
    readonly title?: ILocalizedString | string;
    readonly mnemonicTitle?: string;
    readonly order?: number;
    readonly keybindings?: IKeybindings & {
        when?: ContextKeyExpression;
    };
};
/**
 * View Container Contexts
 */
interface IViewContainerDescriptor {
    /**
     * The id of the view container
     */
    readonly id: string;
    /**
     * The title of the view container
     */
    readonly title: ILocalizedString;
    /**
     * Icon representation of the View container
     */
    readonly icon?: ThemeIcon | URI;
    /**
     * Order of the view container.
     */
    readonly order?: number;
    /**
     * IViewPaneContainer Ctor to instantiate
     */
    readonly ctorDescriptor: SyncDescriptor<IViewPaneContainer>;
    /**
     * Descriptor for open view container command
     * If not provided, view container info (id, title) is used.
     *
     * Note: To prevent registering open command, use `doNotRegisterOpenCommand` flag while registering the view container
     */
    readonly openCommandActionDescriptor?: OpenCommandActionDescriptor;
    /**
     * Storage id to use to store the view container state.
     * If not provided, it will be derived.
     */
    readonly storageId?: string;
    /**
     * If enabled, view container is not shown if it has no active views.
     */
    readonly hideIfEmpty?: boolean;
    /**
     * Id of the extension that contributed the view container
     */
    readonly extensionId?: ExtensionIdentifier;
    readonly alwaysUseContainerInfo?: boolean;
    readonly viewOrderDelegate?: ViewOrderDelegate;
    readonly rejectAddedViews?: boolean;
    requestedIndex?: number;
}
interface ViewOrderDelegate {
    getOrder(group?: string): number | undefined;
}
interface ViewContainer extends IViewContainerDescriptor {
}
interface IViewDescriptor {
    readonly type?: string;
    readonly id: string;
    readonly name: string;
    readonly ctorDescriptor: SyncDescriptor<IView>;
    readonly when?: ContextKeyExpression;
    readonly order?: number;
    readonly weight?: number;
    readonly collapsed?: boolean;
    readonly canToggleVisibility?: boolean;
    readonly canMoveView?: boolean;
    readonly containerIcon?: ThemeIcon | URI;
    readonly containerTitle?: string;
    readonly hideByDefault?: boolean;
    readonly workspace?: boolean;
    readonly focusCommand?: {
        id: string;
        keybindings?: IKeybindings;
    };
    readonly group?: string;
    readonly remoteAuthority?: string | string[];
    readonly virtualWorkspace?: string;
    readonly openCommandActionDescriptor?: OpenCommandActionDescriptor;
}
interface IViewDescriptorRef {
    viewDescriptor: IViewDescriptor;
    index: number;
}
interface IAddedViewDescriptorRef extends IViewDescriptorRef {
    collapsed: boolean;
    size?: number;
}
interface IViewContainerModel {
    readonly viewContainer: ViewContainer;
    readonly title: string;
    readonly icon: ThemeIcon | URI | undefined;
    readonly keybindingId: string | undefined;
    readonly onDidChangeContainerInfo: Event<{
        title?: boolean;
        icon?: boolean;
        keybindingId?: boolean;
        badgeEnablement?: boolean;
    }>;
    readonly allViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidChangeAllViewDescriptors: Event<{
        added: ReadonlyArray<IViewDescriptor>;
        removed: ReadonlyArray<IViewDescriptor>;
    }>;
    readonly activeViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidChangeActiveViewDescriptors: Event<{
        added: ReadonlyArray<IViewDescriptor>;
        removed: ReadonlyArray<IViewDescriptor>;
    }>;
    readonly visibleViewDescriptors: ReadonlyArray<IViewDescriptor>;
    readonly onDidAddVisibleViewDescriptors: Event<IAddedViewDescriptorRef[]>;
    readonly onDidRemoveVisibleViewDescriptors: Event<IViewDescriptorRef[]>;
    readonly onDidMoveVisibleViewDescriptors: Event<{
        from: IViewDescriptorRef;
        to: IViewDescriptorRef;
    }>;
    isVisible(id: string): boolean;
    setVisible(id: string, visible: boolean): void;
    isCollapsed(id: string): boolean;
    setCollapsed(id: string, collapsed: boolean): void;
    getSize(id: string): number | undefined;
    setSizes(newSizes: readonly {
        id: string;
        size: number;
    }[]): void;
    move(from: string, to: string): void;
}
interface IView {
    readonly id: string;
    focus(): void;
    isVisible(): boolean;
    isBodyVisible(): boolean;
    setExpanded(expanded: boolean): boolean;
    getProgressIndicator(): IProgressIndicator | undefined;
}
declare const IViewsService: ServiceIdentifier<IViewsService>;
interface IViewsService {
    readonly _serviceBrand: undefined;
    readonly onDidChangeViewContainerVisibility: Event<{
        id: string;
        visible: boolean;
        location: ViewContainerLocation;
    }>;
    isViewContainerVisible(id: string): boolean;
    openViewContainer(id: string, focus?: boolean): Promise<IPaneComposite | null>;
    closeViewContainer(id: string): void;
    getVisibleViewContainer(location: ViewContainerLocation): ViewContainer | null;
    getActiveViewPaneContainerWithId(viewContainerId: string): IViewPaneContainer | null;
    getFocusedViewName(): string;
    readonly onDidChangeViewVisibility: Event<{
        id: string;
        visible: boolean;
    }>;
    readonly onDidChangeFocusedView: Event<void>;
    isViewVisible(id: string): boolean;
    openView<T extends IView>(id: string, focus?: boolean): Promise<T | null>;
    closeView(id: string): void;
    getActiveViewWithId<T extends IView>(id: string): T | null;
    getViewWithId<T extends IView>(id: string): T | null;
    getViewProgressIndicator(id: string): IProgressIndicator | undefined;
}
declare enum ViewVisibilityState {
    Default = 0,
    Expand = 1
}
declare const IViewDescriptorService: ServiceIdentifier<IViewDescriptorService>;
interface IViewDescriptorService {
    readonly _serviceBrand: undefined;
    readonly viewContainers: ReadonlyArray<ViewContainer>;
    readonly onDidChangeViewContainers: Event<{
        added: ReadonlyArray<{
            container: ViewContainer;
            location: ViewContainerLocation;
        }>;
        removed: ReadonlyArray<{
            container: ViewContainer;
            location: ViewContainerLocation;
        }>;
    }>;
    getDefaultViewContainer(location: ViewContainerLocation): ViewContainer | undefined;
    getViewContainerById(id: string): ViewContainer | null;
    isViewContainerRemovedPermanently(id: string): boolean;
    getDefaultViewContainerLocation(viewContainer: ViewContainer): ViewContainerLocation | null;
    getViewContainerLocation(viewContainer: ViewContainer): ViewContainerLocation | null;
    getViewContainersByLocation(location: ViewContainerLocation): ViewContainer[];
    getViewContainerModel(viewContainer: ViewContainer): IViewContainerModel;
    readonly onDidChangeContainerLocation: Event<{
        viewContainer: ViewContainer;
        from: ViewContainerLocation;
        to: ViewContainerLocation;
    }>;
    moveViewContainerToLocation(viewContainer: ViewContainer, location: ViewContainerLocation, requestedIndex?: number): void;
    getViewContainerBadgeEnablementState(id: string): boolean;
    setViewContainerBadgeEnablementState(id: string, badgesEnabled: boolean): void;
    getViewDescriptorById(id: string): IViewDescriptor | null;
    getViewContainerByViewId(id: string): ViewContainer | null;
    getDefaultContainerById(id: string): ViewContainer | null;
    getViewLocationById(id: string): ViewContainerLocation | null;
    readonly onDidChangeContainer: Event<{
        views: IViewDescriptor[];
        from: ViewContainer;
        to: ViewContainer;
    }>;
    moveViewsToContainer(views: IViewDescriptor[], viewContainer: ViewContainer, visibilityState?: ViewVisibilityState): void;
    readonly onDidChangeLocation: Event<{
        views: IViewDescriptor[];
        from: ViewContainerLocation;
        to: ViewContainerLocation;
    }>;
    moveViewToLocation(view: IViewDescriptor, location: ViewContainerLocation): void;
    reset(): void;
}
interface IEditableData {
    validationMessage: (value: string) => {
        content: string;
        severity: Severity;
    } | null;
    placeholder?: string | null;
    startingValue?: string | null;
    onFinish: (value: string, success: boolean) => Promise<void>;
}
interface IViewPaneContainer {
    onDidAddViews: Event<IView[]>;
    onDidRemoveViews: Event<IView[]>;
    onDidChangeViewVisibility: Event<IView>;
    readonly views: IView[];
    setVisible(visible: boolean): void;
    isVisible(): boolean;
    focus(): void;
    getActionsContext(): unknown;
    getView(viewId: string): IView | undefined;
    toggleViewVisibility(viewId: string): void;
}

export { type IAddedViewDescriptorRef, type IEditableData, type IView, type IViewContainerDescriptor, type IViewContainerModel, type IViewDescriptor, type IViewDescriptorRef, IViewDescriptorService, type IViewPaneContainer, IViewsService, type ViewContainer, ViewContainerLocation, ViewVisibilityState };

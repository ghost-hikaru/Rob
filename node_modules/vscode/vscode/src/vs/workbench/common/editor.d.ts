import { Event } from '../../base/common/event.js';
import { URI } from '../../base/common/uri.js';
import { Disposable } from '../../base/common/lifecycle.js';
import { IDiffEditor } from '../../editor/common/editorCommon.js';
import { IEditorOptions, IBaseTextResourceEditorInput, IBaseUntypedEditorInput, IResourceEditorInput, ITextResourceEditorInput } from '../../platform/editor/common/editor.js';
import { EditorInput } from './editor/editorInput.js';
import { IInstantiationService } from '../../platform/instantiation/common/instantiation.js';
import { IContextKeyService } from '../../platform/contextkey/common/contextkey.js';
import { IEncodingSupport, ILanguageSupport } from '../services/textfile/common/textfiles.js';
import { IEditorGroup } from '../services/editor/common/editorGroupsService.js';
import { IComposite, ICompositeControl } from './composite.js';
import { IExtUri } from '../../base/common/resources.js';

interface IEditorDescriptor<T extends IEditorPane> {
    /**
     * The unique type identifier of the editor. All instances
     * of the same `IEditorPane` should have the same type
     * identifier.
     */
    readonly typeId: string;
    /**
     * The display name of the editor.
     */
    readonly name: string;
    /**
     * Instantiates the editor pane using the provided services.
     */
    instantiate(instantiationService: IInstantiationService): T;
    /**
     * Whether the descriptor is for the provided editor pane.
     */
    describes(editorPane: T): boolean;
}
/**
 * The editor pane is the container for workbench editors.
 */
interface IEditorPane extends IComposite {
    /**
     * An event to notify when the `IEditorControl` in this
     * editor pane changes.
     *
     * This can be used for editor panes that are a compound
     * of multiple editor controls to signal that the active
     * editor control has changed when the user clicks around.
     */
    readonly onDidChangeControl: Event<void>;
    /**
     * An optional event to notify when the selection inside the editor
     * pane changed in case the editor has a selection concept.
     *
     * For example, in a text editor pane, the selection changes whenever
     * the cursor is set to a new location.
     */
    readonly onDidChangeSelection?: Event<IEditorPaneSelectionChangeEvent>;
    /**
     * The assigned input of this editor.
     */
    readonly input: EditorInput | undefined;
    /**
     * The assigned options of the editor.
     */
    readonly options: IEditorOptions | undefined;
    /**
     * The assigned group this editor is showing in.
     */
    readonly group: IEditorGroup | undefined;
    /**
     * The minimum width of this editor.
     */
    readonly minimumWidth: number;
    /**
     * The maximum width of this editor.
     */
    readonly maximumWidth: number;
    /**
     * The minimum height of this editor.
     */
    readonly minimumHeight: number;
    /**
     * The maximum height of this editor.
     */
    readonly maximumHeight: number;
    /**
     * An event to notify whenever minimum/maximum width/height changes.
     */
    readonly onDidChangeSizeConstraints: Event<{
        width: number;
        height: number;
    } | undefined>;
    /**
     * The context key service for this editor. Should be overridden by
     * editors that have their own ScopedContextKeyService
     */
    readonly scopedContextKeyService: IContextKeyService | undefined;
    /**
     * Returns the underlying control of this editor. Callers need to cast
     * the control to a specific instance as needed, e.g. by using the
     * `isCodeEditor` helper method to access the text code editor.
     *
     * Use the `onDidChangeControl` event to track whenever the control
     * changes.
     */
    getControl(): IEditorControl | undefined;
    /**
     * Returns the current view state of the editor if any.
     *
     * This method is optional to override for the editor pane
     * and should only be overridden when the pane can deal with
     * `IEditorOptions.viewState` to be applied when opening.
     */
    getViewState(): object | undefined;
    /**
     * An optional method to return the current selection in
     * the editor pane in case the editor pane has a selection
     * concept.
     *
     * Clients of this method will typically react to the
     * `onDidChangeSelection` event to receive the current
     * selection as needed.
     */
    getSelection?(): IEditorPaneSelection | undefined;
    /**
     * Finds out if this editor is visible or not.
     */
    isVisible(): boolean;
}
interface IEditorPaneSelectionChangeEvent {
    /**
     * More details for how the selection was made.
     */
    reason: EditorPaneSelectionChangeReason;
}
declare const enum EditorPaneSelectionChangeReason {
    /**
     * The selection was changed as a result of a programmatic
     * method invocation.
     *
     * For a text editor pane, this for example can be a selection
     * being restored from previous view state automatically.
     */
    PROGRAMMATIC = 1,
    /**
     * The selection was changed by the user.
     *
     * This typically means the user changed the selection
     * with mouse or keyboard.
     */
    USER = 2,
    /**
     * The selection was changed as a result of editing in
     * the editor pane.
     *
     * For a text editor pane, this for example can be typing
     * in the text of the editor pane.
     */
    EDIT = 3,
    /**
     * The selection was changed as a result of a navigation
     * action.
     *
     * For a text editor pane, this for example can be a result
     * of selecting an entry from a text outline view.
     */
    NAVIGATION = 4,
    /**
     * The selection was changed as a result of a jump action
     * from within the editor pane.
     *
     * For a text editor pane, this for example can be a result
     * of invoking "Go to definition" from a symbol.
     */
    JUMP = 5
}
interface IEditorPaneSelection {
    /**
     * Asks to compare this selection to another selection.
     */
    compare(otherSelection: IEditorPaneSelection): EditorPaneSelectionCompareResult;
    /**
     * Asks to massage the provided `options` in a way
     * that the selection can be restored when the editor
     * is opened again.
     *
     * For a text editor this means to apply the selected
     * line and column as text editor options.
     */
    restore(options: IEditorOptions): IEditorOptions;
    /**
     * Only used for logging to print more info about the selection.
     */
    log?(): string;
}
declare const enum EditorPaneSelectionCompareResult {
    /**
     * The selections are identical.
     */
    IDENTICAL = 1,
    /**
     * The selections are similar.
     *
     * For a text editor this can mean that the one
     * selection is in close proximity to the other
     * selection.
     *
     * Upstream clients may decide in this case to
     * not treat the selection different from the
     * previous one because it is not distinct enough.
     */
    SIMILAR = 2,
    /**
     * The selections are entirely different.
     */
    DIFFERENT = 3
}
/**
 * Overrides `IEditorPane` where `input` and `group` are known to be set.
 */
interface IVisibleEditorPane extends IEditorPane {
    readonly input: EditorInput;
    readonly group: IEditorGroup;
}
/**
 * The text editor pane is the container for workbench text diff editors.
 */
interface ITextDiffEditorPane extends IEditorPane {
    /**
     * Returns the underlying text diff editor widget of this editor.
     */
    getControl(): IDiffEditor | undefined;
}
/**
 * Marker interface for the control inside an editor pane. Callers
 * have to cast the control to work with it, e.g. via methods
 * such as `isCodeEditor(control)`.
 */
interface IEditorControl extends ICompositeControl {
}
interface IEditorSerializer {
    /**
     * Determines whether the given editor can be serialized by the serializer.
     */
    canSerialize(editor: EditorInput): boolean;
    /**
     * Returns a string representation of the provided editor that contains enough information
     * to deserialize back to the original editor from the deserialize() method.
     */
    serialize(editor: EditorInput): string | undefined;
    /**
     * Returns an editor from the provided serialized form of the editor. This form matches
     * the value returned from the serialize() method.
     */
    deserialize(instantiationService: IInstantiationService, serializedEditor: string): EditorInput | undefined;
}
interface IUntitledTextResourceEditorInput extends IBaseTextResourceEditorInput {
    /**
     * Optional resource for the untitled editor. Depending on the value, the editor:
     * - should get a unique name if `undefined` (for example `Untitled-1`)
     * - should use the resource directly if the scheme is `untitled:`
     * - should change the scheme to `untitled:` otherwise and assume an associated path
     *
     * Untitled editors with associated path behave slightly different from other untitled
     * editors:
     * - they are dirty right when opening
     * - they will not ask for a file path when saving but use the associated path
     */
    readonly resource: URI | undefined;
}
/**
 * A resource side by side editor input shows 2 editors side by side but
 * without highlighting any differences.
 *
 * Note: both sides will be resolved as editor individually. As such, it is
 * possible to show 2 different editors side by side.
 *
 * @see {@link IResourceDiffEditorInput} for a variant that compares 2 editors.
 */
interface IResourceSideBySideEditorInput extends IBaseUntypedEditorInput {
    /**
     * The right hand side editor to open inside a side-by-side editor.
     */
    readonly primary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
    /**
     * The left hand side editor to open inside a side-by-side editor.
     */
    readonly secondary: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
}
/**
 * A resource diff editor input compares 2 editors side by side
 * highlighting the differences.
 *
 * Note: both sides must be resolvable to the same editor, or
 * a text based presentation will be used as fallback.
 */
interface IResourceDiffEditorInput extends IBaseUntypedEditorInput {
    /**
     * The left hand side editor to open inside a diff editor.
     */
    readonly original: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
    /**
     * The right hand side editor to open inside a diff editor.
     */
    readonly modified: IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput;
}
type IResourceMergeEditorInputSide = (IResourceEditorInput | ITextResourceEditorInput) & {
    detail?: string;
};
/**
 * A resource merge editor input compares multiple editors
 * highlighting the differences for merging.
 *
 * Note: all sides must be resolvable to the same editor, or
 * a text based presentation will be used as fallback.
 */
interface IResourceMergeEditorInput extends IBaseUntypedEditorInput {
    /**
     * The one changed version of the file.
     */
    readonly input1: IResourceMergeEditorInputSide;
    /**
     * The second changed version of the file.
     */
    readonly input2: IResourceMergeEditorInputSide;
    /**
     * The base common ancestor of the file to merge.
     */
    readonly base: IResourceEditorInput | ITextResourceEditorInput;
    /**
     * The resulting output of the merge.
     */
    readonly result: IResourceEditorInput | ITextResourceEditorInput;
}
declare const enum Verbosity {
    SHORT = 0,
    MEDIUM = 1,
    LONG = 2
}
declare const enum SaveReason {
    /**
     * Explicit user gesture.
     */
    EXPLICIT = 1,
    /**
     * Auto save after a timeout.
     */
    AUTO = 2,
    /**
     * Auto save after editor focus change.
     */
    FOCUS_CHANGE = 3,
    /**
     * Auto save after window change.
     */
    WINDOW_CHANGE = 4
}
type SaveSource = string;
interface ISaveOptions {
    /**
     * An indicator how the save operation was triggered.
     */
    reason?: SaveReason;
    /**
     * An indicator about the source of the save operation.
     *
     * Must use `SaveSourceRegistry.registerSource()` to obtain.
     */
    readonly source?: SaveSource;
    /**
     * Forces to save the contents of the working copy
     * again even if the working copy is not dirty.
     */
    readonly force?: boolean;
    /**
     * Instructs the save operation to skip any save participants.
     */
    readonly skipSaveParticipants?: boolean;
    /**
     * A hint as to which file systems should be available for saving.
     */
    readonly availableFileSystems?: string[];
}
interface IRevertOptions {
    /**
     * Forces to load the contents of the working copy
     * again even if the working copy is not dirty.
     */
    readonly force?: boolean;
    /**
     * A soft revert will clear dirty state of a working copy
     * but will not attempt to load it from its persisted state.
     *
     * This option may be used in scenarios where an editor is
     * closed and where we do not require to load the contents.
     */
    readonly soft?: boolean;
}
interface IMoveResult {
    editor: EditorInput | IUntypedEditorInput;
    options?: IEditorOptions;
}
declare const enum EditorInputCapabilities {
    /**
     * Signals no specific capability for the input.
     */
    None = 0,
    /**
     * Signals that the input is readonly.
     */
    Readonly = 2,
    /**
     * Signals that the input is untitled.
     */
    Untitled = 4,
    /**
     * Signals that the input can only be shown in one group
     * and not be split into multiple groups.
     */
    Singleton = 8,
    /**
     * Signals that the input requires workspace trust.
     */
    RequiresTrust = 16,
    /**
     * Signals that the editor can split into 2 in the same
     * editor group.
     */
    CanSplitInGroup = 32,
    /**
     * Signals that the editor wants its description to be
     * visible when presented to the user. By default, a UI
     * component may decide to hide the description portion
     * for brevity.
     */
    ForceDescription = 64,
    /**
     * Signals that the editor supports dropping into the
     * editor by holding shift.
     */
    CanDropIntoEditor = 128,
    /**
     * Signals that the editor is composed of multiple editors
     * within.
     */
    MultipleEditors = 256,
    /**
     * Signals that the editor cannot be in a dirty state
     * and may still have unsaved changes
     */
    Scratchpad = 512
}
type IUntypedEditorInput = IResourceEditorInput | ITextResourceEditorInput | IUntitledTextResourceEditorInput | IResourceDiffEditorInput | IResourceSideBySideEditorInput | IResourceMergeEditorInput;
declare abstract class AbstractEditorInput extends Disposable {
}
interface EditorInputWithPreferredResource {
    /**
     * An editor may provide an additional preferred resource alongside
     * the `resource` property. While the `resource` property serves as
     * unique identifier of the editor that should be used whenever we
     * compare to other editors, the `preferredResource` should be used
     * in places where e.g. the resource is shown to the user.
     *
     * For example: on Windows and macOS, the same URI with different
     * casing may point to the same file. The editor may chose to
     * "normalize" the URIs so that only one editor opens for different
     * URIs. But when displaying the editor label to the user, the
     * preferred URI should be used.
     *
     * Not all editors have a `preferredResource`. The `EditorResourceAccessor`
     * utility can be used to always get the right resource without having
     * to do instanceof checks.
     */
    readonly preferredResource: URI;
}
interface IUntypedFileEditorInput extends ITextResourceEditorInput {
    /**
     * A marker to create a `IFileEditorInput` from this untyped input.
     */
    forceFile: true;
}
/**
 * This is a tagging interface to declare an editor input being capable of dealing with files. It is only used in the editor registry
 * to register this kind of input to the platform.
 */
interface IFileEditorInput extends EditorInput, IEncodingSupport, ILanguageSupport, EditorInputWithPreferredResource {
    /**
     * Gets the resource this file input is about. This will always be the
     * canonical form of the resource, so it may differ from the original
     * resource that was provided to create the input. Use `preferredResource`
     * for the form as it was created.
     */
    readonly resource: URI;
    /**
     * Sets the preferred resource to use for this file input.
     */
    setPreferredResource(preferredResource: URI): void;
    /**
     * Sets the preferred name to use for this file input.
     *
     * Note: for certain file schemes the input may decide to ignore this
     * name and use our standard naming. Specifically for schemes we own,
     * we do not let others override the name.
     */
    setPreferredName(name: string): void;
    /**
     * Sets the preferred description to use for this file input.
     *
     * Note: for certain file schemes the input may decide to ignore this
     * description and use our standard naming. Specifically for schemes we own,
     * we do not let others override the description.
     */
    setPreferredDescription(description: string): void;
    /**
     * Sets the preferred encoding to use for this file input.
     */
    setPreferredEncoding(encoding: string): void;
    /**
     * Sets the preferred language id to use for this file input.
     */
    setPreferredLanguageId(languageId: string): void;
    /**
     * Sets the preferred contents to use for this file input.
     */
    setPreferredContents(contents: string): void;
    /**
     * Forces this file input to open as binary instead of text.
     */
    setForceOpenAsBinary(): void;
    /**
     * Figure out if the file input has been resolved or not.
     */
    isResolved(): boolean;
}
interface EditorInputWithOptions {
    editor: EditorInput;
    options?: IEditorOptions;
}
interface EditorInputWithOptionsAndGroup extends EditorInputWithOptions {
    group: IEditorGroup;
}
/**
 * Context passed into `EditorPane#setInput` to give additional
 * context information around why the editor was opened.
 */
interface IEditorOpenContext {
    /**
     * An indicator if the editor input is new for the group the editor is in.
     * An editor is new for a group if it was not part of the group before and
     * otherwise was already opened in the group and just became the active editor.
     *
     * This hint can e.g. be used to decide whether to restore view state or not.
     */
    newInGroup?: boolean;
}
interface IEditorIdentifier {
    groupId: GroupIdentifier;
    editor: EditorInput;
}
/**
 * More information around why an editor was closed in the model.
 */
declare enum EditorCloseContext {
    /**
     * No specific context for closing (e.g. explicit user gesture).
     */
    UNKNOWN = 0,
    /**
     * The editor closed because it was replaced with another editor.
     * This can either happen via explicit replace call or when an
     * editor is in preview mode and another editor opens.
     */
    REPLACE = 1,
    /**
     * The editor closed as a result of moving it to another group.
     */
    MOVE = 2,
    /**
     * The editor closed because another editor turned into preview
     * and this used to be the preview editor before.
     */
    UNPIN = 3
}
interface IEditorCloseEvent extends IEditorIdentifier {
    /**
     * More information around why the editor was closed.
     */
    readonly context: EditorCloseContext;
    /**
     * The index of the editor before closing.
     */
    readonly index: number;
    /**
     * Whether the editor was sticky or not.
     */
    readonly sticky: boolean;
}
interface IActiveEditorChangeEvent {
    /**
     * The new active editor or `undefined` if the group is empty.
     */
    editor: EditorInput | undefined;
}
interface IEditorWillMoveEvent extends IEditorIdentifier {
    /**
     * The target group of the move operation.
     */
    readonly target: GroupIdentifier;
}
interface IEditorWillOpenEvent extends IEditorIdentifier {
}
type GroupIdentifier = number;
declare const enum GroupModelChangeKind {
    GROUP_ACTIVE = 0,
    GROUP_INDEX = 1,
    GROUP_LOCKED = 2,
    EDITOR_OPEN = 3,
    EDITOR_CLOSE = 4,
    EDITOR_MOVE = 5,
    EDITOR_ACTIVE = 6,
    EDITOR_LABEL = 7,
    EDITOR_CAPABILITIES = 8,
    EDITOR_PIN = 9,
    EDITOR_STICKY = 10,
    EDITOR_DIRTY = 11,
    EDITOR_WILL_DISPOSE = 12
}
interface IEditorPartConfiguration {
    showTabs?: boolean;
    wrapTabs?: boolean;
    scrollToSwitchTabs?: boolean;
    highlightModifiedTabs?: boolean;
    tabCloseButton?: 'left' | 'right' | 'off';
    tabSizing?: 'fit' | 'shrink' | 'fixed';
    tabSizingFixedMinWidth?: number;
    tabSizingFixedMaxWidth?: number;
    pinnedTabSizing?: 'normal' | 'compact' | 'shrink';
    pinnedTabsOnSeparateRow?: boolean;
    tabHeight?: 'default' | 'compact';
    preventPinnedEditorClose?: PreventPinnedEditorClose;
    titleScrollbarSizing?: 'default' | 'large';
    focusRecentEditorAfterClose?: boolean;
    showIcons?: boolean;
    enablePreview?: boolean;
    enablePreviewFromQuickOpen?: boolean;
    enablePreviewFromCodeNavigation?: boolean;
    closeOnFileDelete?: boolean;
    openPositioning?: 'left' | 'right' | 'first' | 'last';
    openSideBySideDirection?: 'right' | 'down';
    closeEmptyGroups?: boolean;
    autoLockGroups?: Set<string>;
    revealIfOpen?: boolean;
    mouseBackForwardToNavigate?: boolean;
    labelFormat?: 'default' | 'short' | 'medium' | 'long';
    restoreViewState?: boolean;
    splitInGroupLayout?: 'vertical' | 'horizontal';
    splitSizing?: 'auto' | 'split' | 'distribute';
    splitOnDragAndDrop?: boolean;
    centeredLayoutFixedWidth?: boolean;
    doubleClickTabToToggleEditorGroupSizes?: boolean;
    limit?: {
        enabled?: boolean;
        excludeDirty?: boolean;
        value?: number;
        perEditorGroup?: boolean;
    };
    decorations?: {
        badges?: boolean;
        colors?: boolean;
    };
}
interface IEditorPartOptions extends IEditorPartConfiguration {
    hasIcons?: boolean;
}
interface IEditorPartOptionsChangeEvent {
    oldPartOptions: IEditorPartOptions;
    newPartOptions: IEditorPartOptions;
}
declare enum SideBySideEditor {
    PRIMARY = 1,
    SECONDARY = 2,
    BOTH = 3,
    ANY = 4
}
interface IFindEditorOptions {
    /**
     * Whether to consider any or both side by side editor as matching.
     * By default, side by side editors will not be considered
     * as matching, even if the editor is opened in one of the sides.
     */
    supportSideBySide?: SideBySideEditor.PRIMARY | SideBySideEditor.SECONDARY | SideBySideEditor.ANY;
}
interface IMatchEditorOptions {
    /**
     * Whether to consider a side by side editor as matching.
     * By default, side by side editors will not be considered
     * as matching, even if the editor is opened in one of the sides.
     */
    supportSideBySide?: SideBySideEditor.ANY | SideBySideEditor.BOTH;
    /**
     * Only consider an editor to match when the
     * `candidate === editor` but not when
     * `candidate.matches(editor)`.
     */
    strictEquals?: boolean;
}
type PreventPinnedEditorClose = 'keyboardAndMouse' | 'keyboard' | 'mouse' | 'never' | undefined;
declare const enum CloseDirection {
    LEFT = 0,
    RIGHT = 1
}
interface IEditorMemento<T> {
    saveEditorState(group: IEditorGroup, resource: URI, state: T): void;
    saveEditorState(group: IEditorGroup, editor: EditorInput, state: T): void;
    loadEditorState(group: IEditorGroup, resource: URI): T | undefined;
    loadEditorState(group: IEditorGroup, editor: EditorInput): T | undefined;
    clearEditorState(resource: URI, group?: IEditorGroup): void;
    clearEditorState(editor: EditorInput, group?: IEditorGroup): void;
    clearEditorStateOnDispose(resource: URI, editor: EditorInput): void;
    moveEditorState(source: URI, target: URI, comparer: IExtUri): void;
}
declare const enum EditorsOrder {
    /**
     * Editors sorted by most recent activity (most recent active first)
     */
    MOST_RECENTLY_ACTIVE = 0,
    /**
     * Editors sorted by sequential order
     */
    SEQUENTIAL = 1
}

export { AbstractEditorInput, CloseDirection, EditorCloseContext, EditorInputCapabilities, type EditorInputWithOptions, type EditorInputWithOptionsAndGroup, type EditorInputWithPreferredResource, EditorPaneSelectionChangeReason, EditorPaneSelectionCompareResult, EditorsOrder, type GroupIdentifier, GroupModelChangeKind, type IActiveEditorChangeEvent, type IEditorCloseEvent, type IEditorControl, type IEditorDescriptor, type IEditorIdentifier, type IEditorMemento, type IEditorOpenContext, type IEditorPane, type IEditorPaneSelection, type IEditorPaneSelectionChangeEvent, type IEditorPartOptions, type IEditorPartOptionsChangeEvent, type IEditorSerializer, type IEditorWillMoveEvent, type IEditorWillOpenEvent, type IFileEditorInput, type IFindEditorOptions, type IMatchEditorOptions, type IMoveResult, type IResourceDiffEditorInput, type IResourceMergeEditorInput, type IResourceMergeEditorInputSide, type IResourceSideBySideEditorInput, type IRevertOptions, type ISaveOptions, type ITextDiffEditorPane, type IUntitledTextResourceEditorInput, type IUntypedEditorInput, type IUntypedFileEditorInput, type IVisibleEditorPane, type PreventPinnedEditorClose, SaveReason, type SaveSource, SideBySideEditor, Verbosity };

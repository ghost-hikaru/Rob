import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import * as aria from 'monaco-editor/esm/vs/base/browser/ui/aria/aria.js';
import { KeyChord } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { ModesRegistry } from 'monaco-editor/esm/vs/editor/common/languages/modesRegistry.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { registerAction2, Action2, MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { OUTPUT_MODE_ID, OUTPUT_MIME, LOG_MODE_ID, LOG_MIME, OUTPUT_VIEW_ID, IOutputService, CONTEXT_IN_OUTPUT, CONTEXT_OUTPUT_SCROLL_LOCK, CONTEXT_ACTIVE_LOG_OUTPUT, ACTIVE_OUTPUT_CHANNEL_CONTEXT, Extensions as Extensions$3 } from '../../../services/output/common/output.js';
import { OutputViewPane } from './outputView.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { Extensions as Extensions$1 } from '../../../common/contributions.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Extensions, IViewsService } from '../../../common/views.js';
import { ViewPaneContainer } from '../../../browser/parts/views/viewPaneContainer.js';
import { Extensions as Extensions$2 } from 'monaco-editor/esm/vs/platform/configuration/common/configurationRegistry.js';
import { IQuickInputService } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { assertIsDefined } from 'monaco-editor/esm/vs/base/common/types.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { registerIcon } from 'monaco-editor/esm/vs/platform/theme/common/iconRegistry.js';
import { Categories } from 'monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js';
import { Disposable, toDisposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';
ModesRegistry.registerLanguage({
    id: OUTPUT_MODE_ID,
    extensions: [],
    mimetypes: [OUTPUT_MIME]
});
ModesRegistry.registerLanguage({
    id: LOG_MODE_ID,
    extensions: [],
    mimetypes: [LOG_MIME]
});
const outputViewIcon = registerIcon('output-view-icon', Codicon.output, ( nls.localizeWithPath(
    'vs/workbench/contrib/output/browser/output.contribution',
    'outputViewIcon',
    'View icon of the output view.'
)));
const VIEW_CONTAINER = ( Registry.as(Extensions.ViewContainersRegistry)).registerViewContainer({
    id: OUTPUT_VIEW_ID,
    title: { value: ( nls.localizeWithPath(
        'vs/workbench/contrib/output/browser/output.contribution',
        'output',
        "Output"
    )), original: 'Output' },
    icon: outputViewIcon,
    order: 1,
    ctorDescriptor: ( new SyncDescriptor(
        ViewPaneContainer,
        [OUTPUT_VIEW_ID, { mergeViewWithContainerWhenSingleView: true }]
    )),
    storageId: OUTPUT_VIEW_ID,
    hideIfEmpty: true,
}, 1 , { doNotRegisterOpenCommand: true });
( Registry.as(Extensions.ViewsRegistry)).registerViews([{
        id: OUTPUT_VIEW_ID,
        name: ( nls.localizeWithPath(
            'vs/workbench/contrib/output/browser/output.contribution',
            'output',
            "Output"
        )),
        containerIcon: outputViewIcon,
        canMoveView: true,
        canToggleVisibility: false,
        ctorDescriptor: ( new SyncDescriptor(OutputViewPane)),
        openCommandActionDescriptor: {
            id: 'workbench.action.output.toggleOutput',
            mnemonicTitle: ( nls.localizeWithPath(
                'vs/workbench/contrib/output/browser/output.contribution',
                { key: 'miToggleOutput', comment: ['&& denotes a mnemonic'] },
                "&&Output"
            )),
            keybindings: {
                primary: 2048  | 1024  | 51 ,
                linux: {
                    primary: KeyChord(2048  | 41 , 2048  | 38 )
                }
            },
            order: 1,
        }
    }], VIEW_CONTAINER);
let OutputContribution = class OutputContribution extends Disposable {
    constructor(instantiationService, outputService) {
        super();
        this.outputService = outputService;
        this.registerActions();
    }
    registerActions() {
        this.registerSwitchOutputAction();
        this.registerShowOutputChannelsAction();
        this.registerClearOutputAction();
        this.registerToggleAutoScrollAction();
        this.registerOpenActiveLogOutputFileAction();
        this.registerShowLogsAction();
        this.registerOpenLogFileAction();
    }
    registerSwitchOutputAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: `workbench.output.action.switchBetweenOutputs`,
                    title: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'switchBetweenOutputs.label',
                        "Switch Output"
                    )),
                });
            }
            async run(accessor, channelId) {
                if (channelId) {
                    accessor.get(IOutputService).showChannel(channelId, true);
                }
            }
        }));
        const switchOutputMenu = ( new MenuId('workbench.output.menu.switchOutput'));
        this._register(MenuRegistry.appendMenuItem(MenuId.ViewTitle, {
            submenu: switchOutputMenu,
            title: ( nls.localizeWithPath(
                'vs/workbench/contrib/output/browser/output.contribution',
                'switchToOutput.label',
                "Switch Output"
            )),
            group: 'navigation',
            when: ( ContextKeyExpr.equals('view', OUTPUT_VIEW_ID)),
            order: 1,
            isSelection: true
        }));
        const registeredChannels = ( new Map());
        this._register(toDisposable(() => dispose(( registeredChannels.values()))));
        const registerOutputChannels = (channels) => {
            for (const channel of channels) {
                const title = channel.label;
                const group = channel.extensionId ? '0_ext_outputchannels' : '1_core_outputchannels';
                registeredChannels.set(channel.id, registerAction2(class extends Action2 {
                    constructor() {
                        super({
                            id: `workbench.action.output.show.${channel.id}`,
                            title,
                            toggled: ( ACTIVE_OUTPUT_CHANNEL_CONTEXT.isEqualTo(channel.id)),
                            menu: {
                                id: switchOutputMenu,
                                group,
                            }
                        });
                    }
                    async run(accessor) {
                        return accessor.get(IOutputService).showChannel(channel.id, true);
                    }
                }));
            }
        };
        registerOutputChannels(this.outputService.getChannelDescriptors());
        const outputChannelRegistry = ( Registry.as(Extensions$3.OutputChannels));
        this._register(outputChannelRegistry.onDidRegisterChannel(e => {
            const channel = this.outputService.getChannelDescriptor(e);
            if (channel) {
                registerOutputChannels([channel]);
            }
        }));
        this._register(outputChannelRegistry.onDidRemoveChannel(e => {
            registeredChannels.get(e)?.dispose();
            registeredChannels.delete(e);
        }));
    }
    registerShowOutputChannelsAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: 'workbench.action.showOutputChannels',
                    title: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'showOutputChannels',
                        "Show Output Channels..."
                    )), original: 'Show Output Channels...' },
                    category: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'output',
                        "Output"
                    )), original: 'Output' },
                    f1: true
                });
            }
            async run(accessor) {
                const outputService = accessor.get(IOutputService);
                const quickInputService = accessor.get(IQuickInputService);
                const extensionChannels = [], coreChannels = [];
                for (const channel of outputService.getChannelDescriptors()) {
                    if (channel.extensionId) {
                        extensionChannels.push(channel);
                    }
                    else {
                        coreChannels.push(channel);
                    }
                }
                const entries = [];
                for (const { id, label } of extensionChannels) {
                    entries.push({ id, label });
                }
                if (extensionChannels.length && coreChannels.length) {
                    entries.push({ type: 'separator' });
                }
                for (const { id, label } of coreChannels) {
                    entries.push({ id, label });
                }
                const entry = await quickInputService.pick(entries, { placeHolder: ( nls.localizeWithPath(
                    'vs/workbench/contrib/output/browser/output.contribution',
                    'selectOutput',
                    "Select Output Channel"
                )) });
                if (entry) {
                    return outputService.showChannel(entry.id);
                }
            }
        }));
    }
    registerClearOutputAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: `workbench.output.action.clearOutput`,
                    title: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'clearOutput.label',
                        "Clear Output"
                    )), original: 'Clear Output' },
                    category: Categories.View,
                    menu: [{
                            id: MenuId.ViewTitle,
                            when: ( ContextKeyExpr.equals('view', OUTPUT_VIEW_ID)),
                            group: 'navigation',
                            order: 2
                        }, {
                            id: MenuId.CommandPalette
                        }, {
                            id: MenuId.EditorContext,
                            when: CONTEXT_IN_OUTPUT
                        }],
                    icon: Codicon.clearAll
                });
            }
            async run(accessor) {
                const outputService = accessor.get(IOutputService);
                const activeChannel = outputService.getActiveChannel();
                if (activeChannel) {
                    activeChannel.clear();
                    aria.status(( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'outputCleared',
                        "Output was cleared"
                    )));
                }
            }
        }));
    }
    registerToggleAutoScrollAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: `workbench.output.action.toggleAutoScroll`,
                    title: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'toggleAutoScroll',
                        "Toggle Auto Scrolling"
                    )), original: 'Toggle Auto Scrolling' },
                    tooltip: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'outputScrollOff',
                        "Turn Auto Scrolling Off"
                    )),
                    menu: {
                        id: MenuId.ViewTitle,
                        when: ( ContextKeyExpr.and(( ContextKeyExpr.equals('view', OUTPUT_VIEW_ID)))),
                        group: 'navigation',
                        order: 3,
                    },
                    icon: Codicon.lock,
                    toggled: {
                        condition: CONTEXT_OUTPUT_SCROLL_LOCK,
                        icon: Codicon.unlock,
                        tooltip: ( nls.localizeWithPath(
                            'vs/workbench/contrib/output/browser/output.contribution',
                            'outputScrollOn',
                            "Turn Auto Scrolling On"
                        ))
                    }
                });
            }
            async run(accessor) {
                const outputView = accessor.get(IViewsService).getActiveViewWithId(OUTPUT_VIEW_ID);
                outputView.scrollLock = !outputView.scrollLock;
            }
        }));
    }
    registerOpenActiveLogOutputFileAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: `workbench.action.openActiveLogOutputFile`,
                    title: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'openActiveLogOutputFile',
                        "Open Log Output File"
                    )), original: 'Open Log Output File' },
                    menu: [{
                            id: MenuId.ViewTitle,
                            when: ( ContextKeyExpr.equals('view', OUTPUT_VIEW_ID)),
                            group: 'navigation',
                            order: 4
                        }],
                    icon: Codicon.goToFile,
                    precondition: CONTEXT_ACTIVE_LOG_OUTPUT
                });
            }
            async run(accessor) {
                const outputService = accessor.get(IOutputService);
                const editorService = accessor.get(IEditorService);
                const fileConfigurationService = accessor.get(IFilesConfigurationService);
                const logFileOutputChannelDescriptor = this.getLogFileOutputChannelDescriptor(outputService);
                if (logFileOutputChannelDescriptor) {
                    await fileConfigurationService.updateReadonly(logFileOutputChannelDescriptor.file, true);
                    await editorService.openEditor({
                        resource: logFileOutputChannelDescriptor.file,
                        options: {
                            pinned: true,
                        }
                    });
                }
            }
            getLogFileOutputChannelDescriptor(outputService) {
                const channel = outputService.getActiveChannel();
                if (channel) {
                    const descriptor = outputService.getChannelDescriptors().filter(c => c.id === channel.id)[0];
                    if (descriptor && descriptor.file && descriptor.log) {
                        return descriptor;
                    }
                }
                return null;
            }
        }));
    }
    registerShowLogsAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: 'workbench.action.showLogs',
                    title: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'showLogs',
                        "Show Logs..."
                    )), original: 'Show Logs...' },
                    category: Categories.Developer,
                    menu: {
                        id: MenuId.CommandPalette,
                    },
                });
            }
            async run(accessor) {
                const outputService = accessor.get(IOutputService);
                const quickInputService = accessor.get(IQuickInputService);
                const extensionLogs = [], logs = [];
                for (const channel of outputService.getChannelDescriptors()) {
                    if (channel.log) {
                        if (channel.extensionId) {
                            extensionLogs.push(channel);
                        }
                        else {
                            logs.push(channel);
                        }
                    }
                }
                const entries = [];
                for (const { id, label } of logs) {
                    entries.push({ id, label });
                }
                if (extensionLogs.length && logs.length) {
                    entries.push({ type: 'separator', label: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'extensionLogs',
                        "Extension Logs"
                    )) });
                }
                for (const { id, label } of extensionLogs) {
                    entries.push({ id, label });
                }
                const entry = await quickInputService.pick(entries, { placeHolder: ( nls.localizeWithPath(
                    'vs/workbench/contrib/output/browser/output.contribution',
                    'selectlog',
                    "Select Log"
                )) });
                if (entry) {
                    return outputService.showChannel(entry.id);
                }
            }
        }));
    }
    registerOpenLogFileAction() {
        this._register(registerAction2(class extends Action2 {
            constructor() {
                super({
                    id: 'workbench.action.openLogFile',
                    title: { value: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'openLogFile',
                        "Open Log File..."
                    )), original: 'Open Log File...' },
                    category: Categories.Developer,
                    menu: {
                        id: MenuId.CommandPalette,
                    },
                    description: {
                        description: 'workbench.action.openLogFile',
                        args: [{
                                name: 'logFile',
                                schema: {
                                    markdownDescription: ( nls.localizeWithPath(
                                        'vs/workbench/contrib/output/browser/output.contribution',
                                        'logFile',
                                        "The id of the log file to open, for example `\"window\"`. Currently the best way to get this is to get the ID by checking the `workbench.action.output.show.<id>` commands"
                                    )),
                                    type: 'string'
                                }
                            }]
                    },
                });
            }
            async run(accessor, args) {
                const outputService = accessor.get(IOutputService);
                const quickInputService = accessor.get(IQuickInputService);
                const editorService = accessor.get(IEditorService);
                const fileConfigurationService = accessor.get(IFilesConfigurationService);
                const entries = ( outputService.getChannelDescriptors().filter(c => c.file && c.log)
                    .map(channel => ({ id: channel.id, label: channel.label, channel })));
                const argName = args && typeof args === 'string' ? args : undefined;
                let entry;
                if (argName) {
                    entry = entries.find(e => e.id === argName);
                }
                if (!entry) {
                    entry = await quickInputService.pick(entries, { placeHolder: ( nls.localizeWithPath(
                        'vs/workbench/contrib/output/browser/output.contribution',
                        'selectlogFile',
                        "Select Log File"
                    )) });
                }
                if (entry) {
                    const resource = assertIsDefined(entry.channel.file);
                    await fileConfigurationService.updateReadonly(resource, true);
                    await editorService.openEditor({
                        resource,
                        options: {
                            pinned: true,
                        }
                    });
                }
            }
        }));
    }
};
OutputContribution = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, IOutputService))
], OutputContribution));
( Registry.as(Extensions$1.Workbench)).registerWorkbenchContribution(OutputContribution, 3 );
( Registry.as(Extensions$2.Configuration)).registerConfiguration({
    id: 'output',
    order: 30,
    title: ( nls.localizeWithPath(
        'vs/workbench/contrib/output/browser/output.contribution',
        'output',
        "Output"
    )),
    type: 'object',
    properties: {
        'output.smartScroll.enabled': {
            type: 'boolean',
            description: ( nls.localizeWithPath(
                'vs/workbench/contrib/output/browser/output.contribution',
                'output.smartScroll.enabled',
                "Enable/disable the ability of smart scrolling in the output view. Smart scrolling allows you to lock scrolling automatically when you click in the output view and unlocks when you click in the last line."
            )),
            default: true,
            scope: 3 ,
            tags: ['output']
        }
    }
});

import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { ITextResourceConfigurationService } from 'monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { AbstractTextResourceEditor } from '../../../browser/parts/editor/textResourceEditor.js';
import { CONTEXT_OUTPUT_SCROLL_LOCK, OUTPUT_VIEW_ID, CONTEXT_IN_OUTPUT } from '../../../services/output/common/output.js';
import { registerThemingParticipant, IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IEditorGroupsService } from '../../../services/editor/common/editorGroupsService.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { ViewPane } from '../../../browser/parts/views/viewPane.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { IContextMenuService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { IViewDescriptorService } from '../../../common/views.js';
import { TextResourceEditorInput } from '../../../common/editor/textResourceEditorInput.js';
import { IOpenerService } from 'monaco-editor/esm/vs/platform/opener/common/opener.js';
import { SIDE_BAR_BACKGROUND } from '../../../common/theme.js';
import { editorBackground } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { Dimension } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { createCancelablePromise } from 'monaco-editor/esm/vs/base/common/async.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { ResourceContextKey } from '../../../common/contextkeys.js';
import { ServiceCollection } from 'monaco-editor/esm/vs/platform/instantiation/common/serviceCollection.js';
let OutputViewPane = class OutputViewPane extends ViewPane {
    get scrollLock() { return !!this.scrollLockContextKey.get(); }
    set scrollLock(scrollLock) { this.scrollLockContextKey.set(scrollLock); }
    constructor(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService) {
        super(options, keybindingService, contextMenuService, configurationService, contextKeyService, viewDescriptorService, instantiationService, openerService, themeService, telemetryService);
        this.editorPromise = null;
        this.scrollLockContextKey = CONTEXT_OUTPUT_SCROLL_LOCK.bindTo(this.contextKeyService);
        const editorInstantiationService = instantiationService.createChild(( new ServiceCollection([IContextKeyService, this.scopedContextKeyService])));
        this.editor = editorInstantiationService.createInstance(OutputEditor);
        this._register(this.editor.onTitleAreaUpdate(() => {
            this.updateTitle(this.editor.getTitle());
            this.updateActions();
        }));
        this._register(this.onDidChangeBodyVisibility(() => this.onDidChangeVisibility(this.isBodyVisible())));
    }
    showChannel(channel, preserveFocus) {
        if (this.channelId !== channel.id) {
            this.setInput(channel);
        }
        if (!preserveFocus) {
            this.focus();
        }
    }
    focus() {
        super.focus();
        this.editorPromise?.then(() => this.editor.focus());
    }
    renderBody(container) {
        super.renderBody(container);
        this.editor.create(container);
        container.classList.add('output-view');
        const codeEditor = this.editor.getControl();
        codeEditor.setAriaOptions({ role: 'document', activeDescendant: undefined });
        this._register(codeEditor.onDidChangeModelContent(() => {
            if (!this.scrollLock) {
                this.editor.revealLastLine();
            }
        }));
        this._register(codeEditor.onDidChangeCursorPosition((e) => {
            if (e.reason !== 3 ) {
                return;
            }
            if (!this.configurationService.getValue('output.smartScroll.enabled')) {
                return;
            }
            const model = codeEditor.getModel();
            if (model) {
                const newPositionLine = e.position.lineNumber;
                const lastLine = model.getLineCount();
                this.scrollLock = lastLine !== newPositionLine;
            }
        }));
    }
    layoutBody(height, width) {
        super.layoutBody(height, width);
        this.editor.layout(( new Dimension(width, height)));
    }
    onDidChangeVisibility(visible) {
        this.editor.setVisible(visible);
        if (!visible) {
            this.clearInput();
        }
    }
    setInput(channel) {
        this.channelId = channel.id;
        const input = this.createInput(channel);
        if (!this.editor.input || !input.matches(this.editor.input)) {
            this.editorPromise?.cancel();
            this.editorPromise = createCancelablePromise(token => this.editor.setInput(this.createInput(channel), { preserveFocus: true }, Object.create(null), token)
                .then(() => this.editor));
        }
    }
    clearInput() {
        this.channelId = undefined;
        this.editor.clearInput();
        this.editorPromise = null;
    }
    createInput(channel) {
        return this.instantiationService.createInstance(TextResourceEditorInput, channel.uri, ( nls.localizeWithPath(
            'vs/workbench/contrib/output/browser/outputView',
            'output model title',
            "{0} - Output",
            channel.label
        )), ( nls.localizeWithPath(
            'vs/workbench/contrib/output/browser/outputView',
            'channel',
            "Output channel for '{0}'",
            channel.label
        )), undefined, undefined);
    }
};
OutputViewPane = ( __decorate([
    ( __param(1, IKeybindingService)),
    ( __param(2, IContextMenuService)),
    ( __param(3, IConfigurationService)),
    ( __param(4, IContextKeyService)),
    ( __param(5, IViewDescriptorService)),
    ( __param(6, IInstantiationService)),
    ( __param(7, IOpenerService)),
    ( __param(8, IThemeService)),
    ( __param(9, ITelemetryService))
], OutputViewPane));
let OutputEditor = class OutputEditor extends AbstractTextResourceEditor {
    constructor(telemetryService, instantiationService, storageService, configurationService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService, contextKeyService) {
        super(OUTPUT_VIEW_ID, telemetryService, instantiationService, storageService, textResourceConfigurationService, themeService, editorGroupService, editorService, fileService);
        this.configurationService = configurationService;
        this.resourceContext = this._register(instantiationService.createInstance(ResourceContextKey));
    }
    getId() {
        return OUTPUT_VIEW_ID;
    }
    getTitle() {
        return ( nls.localizeWithPath('vs/workbench/contrib/output/browser/outputView', 'output', "Output"));
    }
    getConfigurationOverrides() {
        const options = super.getConfigurationOverrides();
        options.wordWrap = 'on';
        options.lineNumbers = 'off';
        options.glyphMargin = false;
        options.lineDecorationsWidth = 20;
        options.rulers = [];
        options.folding = false;
        options.scrollBeyondLastLine = false;
        options.renderLineHighlight = 'none';
        options.minimap = { enabled: false };
        options.renderValidationDecorations = 'editable';
        options.padding = undefined;
        options.readOnly = true;
        options.domReadOnly = true;
        options.unicodeHighlight = {
            nonBasicASCII: false,
            invisibleCharacters: false,
            ambiguousCharacters: false,
        };
        const outputConfig = this.configurationService.getValue('[Log]');
        if (outputConfig) {
            if (outputConfig['editor.minimap.enabled']) {
                options.minimap = { enabled: true };
            }
            if ('editor.wordWrap' in outputConfig) {
                options.wordWrap = outputConfig['editor.wordWrap'];
            }
        }
        return options;
    }
    getAriaLabel() {
        return this.input ? this.input.getAriaLabel() : ( nls.localizeWithPath(
            'vs/workbench/contrib/output/browser/outputView',
            'outputViewAriaLabel',
            "Output panel"
        ));
    }
    async setInput(input, options, context, token) {
        const focus = !(options && options.preserveFocus);
        if (this.input && input.matches(this.input)) {
            return;
        }
        if (this.input) {
            this.input.dispose();
        }
        await super.setInput(input, options, context, token);
        this.resourceContext.set(input.resource);
        if (focus) {
            this.focus();
        }
        this.revealLastLine();
    }
    clearInput() {
        if (this.input) {
            this.input.dispose();
        }
        super.clearInput();
        this.resourceContext.reset();
    }
    createEditor(parent) {
        parent.setAttribute('role', 'document');
        super.createEditor(parent);
        const scopedContextKeyService = this.scopedContextKeyService;
        if (scopedContextKeyService) {
            CONTEXT_IN_OUTPUT.bindTo(scopedContextKeyService).set(true);
        }
    }
};
OutputEditor = ( __decorate([
    ( __param(0, ITelemetryService)),
    ( __param(1, IInstantiationService)),
    ( __param(2, IStorageService)),
    ( __param(3, IConfigurationService)),
    ( __param(4, ITextResourceConfigurationService)),
    ( __param(5, IThemeService)),
    ( __param(6, IEditorGroupsService)),
    ( __param(7, IEditorService)),
    ( __param(8, IFileService)),
    ( __param(9, IContextKeyService))
], OutputEditor));
registerThemingParticipant((theme, collector) => {
    const sidebarBackground = theme.getColor(SIDE_BAR_BACKGROUND);
    if (sidebarBackground && sidebarBackground !== theme.getColor(editorBackground)) {
        collector.addRule(`
			.monaco-workbench .part.sidebar .output-view .monaco-editor,
			.monaco-workbench .part.sidebar .output-view .monaco-editor .margin,
			.monaco-workbench .part.sidebar .output-view .monaco-editor .monaco-editor-background {
				background-color: ${sidebarBackground};
			}
		`);
    }
});
export { OutputViewPane };

import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { Disposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IStorageService } from 'monaco-editor/esm/vs/platform/storage/common/storage.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { ACTIVE_OUTPUT_CHANNEL_CONTEXT, CONTEXT_ACTIVE_LOG_OUTPUT, OUTPUT_SCHEME, OUTPUT_VIEW_ID, Extensions, LOG_MIME, OUTPUT_MIME } from '../../../services/output/common/output.js';
import { OutputLinkProvider } from './outputLinkProvider.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { ILifecycleService } from '../../../services/lifecycle/common/lifecycle.js';
import { IViewsService } from '../../../common/views.js';
import { IOutputChannelModelService } from '../common/outputChannelModelService.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
const OUTPUT_ACTIVE_CHANNEL_KEY = 'output.activechannel';
let OutputChannel = class OutputChannel extends Disposable {
    constructor(outputChannelDescriptor, outputChannelModelService, languageService) {
        super();
        this.outputChannelDescriptor = outputChannelDescriptor;
        this.scrollLock = false;
        this.id = outputChannelDescriptor.id;
        this.label = outputChannelDescriptor.label;
        this.uri = ( URI.from({ scheme: OUTPUT_SCHEME, path: this.id }));
        this.model = this._register(outputChannelModelService.createOutputChannelModel(this.id, this.uri, outputChannelDescriptor.languageId ? languageService.createById(outputChannelDescriptor.languageId) : languageService.createByMimeType(outputChannelDescriptor.log ? LOG_MIME : OUTPUT_MIME), outputChannelDescriptor.file));
    }
    append(output) {
        this.model.append(output);
    }
    update(mode, till) {
        this.model.update(mode, till, true);
    }
    clear() {
        this.model.clear();
    }
    replace(value) {
        this.model.replace(value);
    }
};
OutputChannel = ( __decorate([
    ( __param(1, IOutputChannelModelService)),
    ( __param(2, ILanguageService))
], OutputChannel));
let OutputService = class OutputService extends Disposable {
    constructor(storageService, instantiationService, textModelResolverService, logService, lifecycleService, viewsService, contextKeyService) {
        super();
        this.storageService = storageService;
        this.instantiationService = instantiationService;
        this.logService = logService;
        this.lifecycleService = lifecycleService;
        this.viewsService = viewsService;
        this.channels = ( new Map());
        this._onActiveOutputChannel = this._register(( new Emitter()));
        this.onActiveOutputChannel = this._onActiveOutputChannel.event;
        this.activeChannelIdInStorage = this.storageService.get(OUTPUT_ACTIVE_CHANNEL_KEY, 1 , '');
        this.activeOutputChannelContext = ACTIVE_OUTPUT_CHANNEL_CONTEXT.bindTo(contextKeyService);
        this.activeOutputChannelContext.set(this.activeChannelIdInStorage);
        this._register(this.onActiveOutputChannel(channel => this.activeOutputChannelContext.set(channel)));
        this.activeLogOutputChannelContext = CONTEXT_ACTIVE_LOG_OUTPUT.bindTo(contextKeyService);
        textModelResolverService.registerTextModelContentProvider(OUTPUT_SCHEME, this);
        instantiationService.createInstance(OutputLinkProvider);
        const registry = ( Registry.as(Extensions.OutputChannels));
        for (const channelIdentifier of registry.getChannels()) {
            this.onDidRegisterChannel(channelIdentifier.id);
        }
        this._register(registry.onDidRegisterChannel(this.onDidRegisterChannel, this));
        if (!this.activeChannel) {
            const channels = this.getChannelDescriptors();
            this.setActiveChannel(channels && channels.length > 0 ? this.getChannel(channels[0].id) : undefined);
        }
        this._register(Event.filter(this.viewsService.onDidChangeViewVisibility, e => e.id === OUTPUT_VIEW_ID && e.visible)(() => {
            if (this.activeChannel) {
                this.viewsService.getActiveViewWithId(OUTPUT_VIEW_ID)?.showChannel(this.activeChannel, true);
            }
        }));
        this._register(this.lifecycleService.onDidShutdown(() => this.dispose()));
    }
    provideTextContent(resource) {
        const channel = this.getChannel(resource.path);
        if (channel) {
            return channel.model.loadModel();
        }
        return null;
    }
    async showChannel(id, preserveFocus) {
        const channel = this.getChannel(id);
        if (this.activeChannel?.id !== channel?.id) {
            this.setActiveChannel(channel);
            this._onActiveOutputChannel.fire(id);
        }
        const outputView = await this.viewsService.openView(OUTPUT_VIEW_ID, !preserveFocus);
        if (outputView && channel) {
            outputView.showChannel(channel, !!preserveFocus);
        }
    }
    getChannel(id) {
        return this.channels.get(id);
    }
    getChannelDescriptor(id) {
        return ( Registry.as(Extensions.OutputChannels)).getChannel(id);
    }
    getChannelDescriptors() {
        return ( Registry.as(Extensions.OutputChannels)).getChannels();
    }
    getActiveChannel() {
        return this.activeChannel;
    }
    async onDidRegisterChannel(channelId) {
        const channel = this.createChannel(channelId);
        this.channels.set(channelId, channel);
        if (!this.activeChannel || this.activeChannelIdInStorage === channelId) {
            this.setActiveChannel(channel);
            this._onActiveOutputChannel.fire(channelId);
            const outputView = this.viewsService.getActiveViewWithId(OUTPUT_VIEW_ID);
            outputView?.showChannel(channel, true);
        }
    }
    createChannel(id) {
        const channelDisposables = [];
        const channel = this.instantiateChannel(id);
        channel.model.onDispose(() => {
            if (this.activeChannel === channel) {
                const channels = this.getChannelDescriptors();
                const channel = channels.length ? this.getChannel(channels[0].id) : undefined;
                if (channel && this.viewsService.isViewVisible(OUTPUT_VIEW_ID)) {
                    this.showChannel(channel.id);
                }
                else {
                    this.setActiveChannel(undefined);
                }
            }
            ( Registry.as(Extensions.OutputChannels)).removeChannel(id);
            dispose(channelDisposables);
        }, channelDisposables);
        return channel;
    }
    instantiateChannel(id) {
        const channelData = ( Registry.as(Extensions.OutputChannels)).getChannel(id);
        if (!channelData) {
            this.logService.error(`Channel '${id}' is not registered yet`);
            throw new Error(`Channel '${id}' is not registered yet`);
        }
        return this.instantiationService.createInstance(OutputChannel, channelData);
    }
    setActiveChannel(channel) {
        this.activeChannel = channel;
        this.activeLogOutputChannelContext.set(!!channel?.outputChannelDescriptor?.file && channel?.outputChannelDescriptor?.log);
        if (this.activeChannel) {
            this.storageService.store(OUTPUT_ACTIVE_CHANNEL_KEY, this.activeChannel.id, 1 , 1 );
        }
        else {
            this.storageService.remove(OUTPUT_ACTIVE_CHANNEL_KEY, 1 );
        }
    }
};
OutputService = ( __decorate([
    ( __param(0, IStorageService)),
    ( __param(1, IInstantiationService)),
    ( __param(2, ITextModelService)),
    ( __param(3, ILogService)),
    ( __param(4, ILifecycleService)),
    ( __param(5, IViewsService)),
    ( __param(6, IContextKeyService))
], OutputService));
export { OutputService };

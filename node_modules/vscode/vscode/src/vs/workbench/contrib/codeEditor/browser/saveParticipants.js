import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import * as strings from 'monaco-editor/esm/vs/base/common/strings.js';
import { isCodeEditor } from 'monaco-editor/esm/vs/editor/browser/editorBrowser.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { trimTrailingWhitespace } from 'monaco-editor/esm/vs/editor/common/commands/trimTrailingWhitespaceCommand.js';
import { EditOperation } from 'monaco-editor/esm/vs/editor/common/core/editOperation.js';
import { Position } from 'monaco-editor/esm/vs/editor/common/core/position.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { ILanguageFeaturesService } from 'monaco-editor/esm/vs/editor/common/services/languageFeatures.js';
import { applyCodeAction, ApplyCodeActionReason, getCodeActions } from 'monaco-editor/esm/vs/editor/contrib/codeAction/browser/codeAction.js';
import { CodeActionKind, CodeActionTriggerSource } from 'monaco-editor/esm/vs/editor/contrib/codeAction/common/types.js';
import { formatDocumentWithSelectedProvider, formatDocumentRangesWithSelectedProvider } from 'monaco-editor/esm/vs/editor/contrib/format/browser/format.js';
import { SnippetController2 } from 'monaco-editor/esm/vs/editor/contrib/snippet/browser/snippetController2.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../../common/contributions.js';
import { getModifiedRanges } from '../../format/browser/formatModified.js';
import { ITextFileService } from '../../../services/textfile/common/textfiles.js';
let TrimWhitespaceParticipant = class TrimWhitespaceParticipant {
    constructor(configurationService, codeEditorService) {
        this.configurationService = configurationService;
        this.codeEditorService = codeEditorService;
    }
    async participate(model, env) {
        if (!model.textEditorModel) {
            return;
        }
        if (this.configurationService.getValue('files.trimTrailingWhitespace', { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
            this.doTrimTrailingWhitespace(model.textEditorModel, env.reason === 2 );
        }
    }
    doTrimTrailingWhitespace(model, isAutoSaved) {
        let prevSelection = [];
        let cursors = [];
        const editor = findEditor(model, this.codeEditorService);
        if (editor) {
            prevSelection = editor.getSelections();
            if (isAutoSaved) {
                cursors = ( prevSelection.map(s => s.getPosition()));
                const snippetsRange = SnippetController2.get(editor)?.getSessionEnclosingRange();
                if (snippetsRange) {
                    for (let lineNumber = snippetsRange.startLineNumber; lineNumber <= snippetsRange.endLineNumber; lineNumber++) {
                        cursors.push(( new Position(lineNumber, model.getLineMaxColumn(lineNumber))));
                    }
                }
            }
        }
        const ops = trimTrailingWhitespace(model, cursors);
        if (!ops.length) {
            return;
        }
        model.pushEditOperations(prevSelection, ops, (_edits) => prevSelection);
    }
};
TrimWhitespaceParticipant = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, ICodeEditorService))
], TrimWhitespaceParticipant));
function findEditor(model, codeEditorService) {
    let candidate = null;
    if (model.isAttachedToEditor()) {
        for (const editor of codeEditorService.listCodeEditors()) {
            if (editor.hasModel() && editor.getModel() === model) {
                if (editor.hasTextFocus()) {
                    return editor;
                }
                candidate = editor;
            }
        }
    }
    return candidate;
}
let FinalNewLineParticipant = class FinalNewLineParticipant {
    constructor(configurationService, codeEditorService) {
        this.configurationService = configurationService;
        this.codeEditorService = codeEditorService;
    }
    async participate(model, _env) {
        if (!model.textEditorModel) {
            return;
        }
        if (this.configurationService.getValue('files.insertFinalNewline', { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
            this.doInsertFinalNewLine(model.textEditorModel);
        }
    }
    doInsertFinalNewLine(model) {
        const lineCount = model.getLineCount();
        const lastLine = model.getLineContent(lineCount);
        const lastLineIsEmptyOrWhitespace = strings.lastNonWhitespaceIndex(lastLine) === -1;
        if (!lineCount || lastLineIsEmptyOrWhitespace) {
            return;
        }
        const edits = [EditOperation.insert(( new Position(lineCount, model.getLineMaxColumn(lineCount))), model.getEOL())];
        const editor = findEditor(model, this.codeEditorService);
        if (editor) {
            editor.executeEdits('insertFinalNewLine', edits, editor.getSelections());
        }
        else {
            model.pushEditOperations([], edits, () => null);
        }
    }
};
FinalNewLineParticipant = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, ICodeEditorService))
], FinalNewLineParticipant));
let TrimFinalNewLinesParticipant = class TrimFinalNewLinesParticipant {
    constructor(configurationService, codeEditorService) {
        this.configurationService = configurationService;
        this.codeEditorService = codeEditorService;
    }
    async participate(model, env) {
        if (!model.textEditorModel) {
            return;
        }
        if (this.configurationService.getValue('files.trimFinalNewlines', { overrideIdentifier: model.textEditorModel.getLanguageId(), resource: model.resource })) {
            this.doTrimFinalNewLines(model.textEditorModel, env.reason === 2 );
        }
    }
    findLastNonEmptyLine(model) {
        for (let lineNumber = model.getLineCount(); lineNumber >= 1; lineNumber--) {
            const lineContent = model.getLineContent(lineNumber);
            if (lineContent.length > 0) {
                return lineNumber;
            }
        }
        return 0;
    }
    doTrimFinalNewLines(model, isAutoSaved) {
        const lineCount = model.getLineCount();
        if (lineCount === 1) {
            return;
        }
        let prevSelection = [];
        let cannotTouchLineNumber = 0;
        const editor = findEditor(model, this.codeEditorService);
        if (editor) {
            prevSelection = editor.getSelections();
            if (isAutoSaved) {
                for (let i = 0, len = prevSelection.length; i < len; i++) {
                    const positionLineNumber = prevSelection[i].positionLineNumber;
                    if (positionLineNumber > cannotTouchLineNumber) {
                        cannotTouchLineNumber = positionLineNumber;
                    }
                }
            }
        }
        const lastNonEmptyLine = this.findLastNonEmptyLine(model);
        const deleteFromLineNumber = Math.max(lastNonEmptyLine + 1, cannotTouchLineNumber + 1);
        const deletionRange = model.validateRange(( new Range(deleteFromLineNumber, 1, lineCount, model.getLineMaxColumn(lineCount))));
        if (deletionRange.isEmpty()) {
            return;
        }
        model.pushEditOperations(prevSelection, [EditOperation.delete(deletionRange)], _edits => prevSelection);
        editor?.setSelections(prevSelection);
    }
};
TrimFinalNewLinesParticipant = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, ICodeEditorService))
], TrimFinalNewLinesParticipant));
let FormatOnSaveParticipant = class FormatOnSaveParticipant {
    constructor(configurationService, codeEditorService, instantiationService) {
        this.configurationService = configurationService;
        this.codeEditorService = codeEditorService;
        this.instantiationService = instantiationService;
    }
    async participate(model, env, progress, token) {
        if (!model.textEditorModel) {
            return;
        }
        if (env.reason === 2 ) {
            return undefined;
        }
        const textEditorModel = model.textEditorModel;
        const overrides = { overrideIdentifier: textEditorModel.getLanguageId(), resource: textEditorModel.uri };
        const nestedProgress = ( new Progress(provider => {
            progress.report({
                message: ( localizeWithPath(
                    'vs/workbench/contrib/codeEditor/browser/saveParticipants',
                    { key: 'formatting2', comment: ['[configure]({1}) is a link. Only translate `configure`. Do not change brackets and parentheses or {1}'] },
                    "Running '{0}' Formatter ([configure]({1})).",
                    provider.displayName || provider.extensionId && provider.extensionId.value || '???',
                    'command:workbench.action.openSettings?%5B%22editor.formatOnSave%22%5D'
                ))
            });
        }));
        const enabled = this.configurationService.getValue('editor.formatOnSave', overrides);
        if (!enabled) {
            return undefined;
        }
        const editorOrModel = findEditor(textEditorModel, this.codeEditorService) || textEditorModel;
        const mode = this.configurationService.getValue('editor.formatOnSaveMode', overrides);
        if (mode === 'file') {
            await this.instantiationService.invokeFunction(formatDocumentWithSelectedProvider, editorOrModel, 2 , nestedProgress, token);
        }
        else {
            const ranges = await this.instantiationService.invokeFunction(getModifiedRanges, isCodeEditor(editorOrModel) ? editorOrModel.getModel() : editorOrModel);
            if (ranges === null && mode === 'modificationsIfAvailable') {
                await this.instantiationService.invokeFunction(formatDocumentWithSelectedProvider, editorOrModel, 2 , nestedProgress, token);
            }
            else if (ranges) {
                await this.instantiationService.invokeFunction(formatDocumentRangesWithSelectedProvider, editorOrModel, ranges, 2 , nestedProgress, token);
            }
        }
    }
};
FormatOnSaveParticipant = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, ICodeEditorService)),
    ( __param(2, IInstantiationService))
], FormatOnSaveParticipant));
let CodeActionOnSaveParticipant = class CodeActionOnSaveParticipant {
    constructor(configurationService, instantiationService, languageFeaturesService) {
        this.configurationService = configurationService;
        this.instantiationService = instantiationService;
        this.languageFeaturesService = languageFeaturesService;
    }
    async participate(model, env, progress, token) {
        if (!model.textEditorModel) {
            return;
        }
        const textEditorModel = model.textEditorModel;
        const settingsOverrides = { overrideIdentifier: textEditorModel.getLanguageId(), resource: textEditorModel.uri };
        const setting = this.configurationService.getValue('editor.codeActionsOnSave', settingsOverrides);
        if (!setting) {
            return undefined;
        }
        if (env.reason === 2 ) {
            return undefined;
        }
        const convertedSetting = {};
        for (const key in setting) {
            if (typeof setting[key] === 'boolean') {
                convertedSetting[key] = setting[key] ? 'explicit' : 'never';
            }
            else if (typeof setting[key] === 'string') {
                convertedSetting[key] = setting[key];
            }
        }
        const codeActionsOnSave = this.createCodeActionsOnSave(( Object.keys(convertedSetting)));
        if (!Array.isArray(setting)) {
            codeActionsOnSave.sort((a, b) => {
                if (CodeActionKind.SourceFixAll.contains(a)) {
                    if (CodeActionKind.SourceFixAll.contains(b)) {
                        return 0;
                    }
                    return -1;
                }
                if (CodeActionKind.SourceFixAll.contains(b)) {
                    return 1;
                }
                return 0;
            });
        }
        if (!codeActionsOnSave.length) {
            return undefined;
        }
        const excludedActions = ( ( Object.keys(setting))
            .filter(x => convertedSetting[x] === 'never' || false)
            .map(x => ( new CodeActionKind(x))));
        progress.report({ message: ( localizeWithPath(
            'vs/workbench/contrib/codeEditor/browser/saveParticipants',
            'codeaction',
            "Quick Fixes"
        )) });
        const filteredSaveList = codeActionsOnSave.filter(x => convertedSetting[x.value] === 'always' || (convertedSetting[x.value] === 'explicit') && env.reason === 1 );
        await this.applyOnSaveActions(textEditorModel, filteredSaveList, excludedActions, progress, token);
    }
    createCodeActionsOnSave(settingItems) {
        const kinds = ( settingItems.map(x => ( new CodeActionKind(x))));
        return kinds.filter(kind => {
            return kinds.every(otherKind => otherKind.equals(kind) || !otherKind.contains(kind));
        });
    }
    async applyOnSaveActions(model, codeActionsOnSave, excludes, progress, token) {
        const getActionProgress = new (class {
            constructor() {
                this._names = ( new Set());
            }
            _report() {
                progress.report({
                    message: ( localizeWithPath(
                        'vs/workbench/contrib/codeEditor/browser/saveParticipants',
                        { key: 'codeaction.get2', comment: ['[configure]({1}) is a link. Only translate `configure`. Do not change brackets and parentheses or {1}'] },
                        "Getting code actions from '{0}' ([configure]({1})).",
                        ( [...this._names].map(name => `'${name}'`)).join(', '),
                        'command:workbench.action.openSettings?%5B%22editor.codeActionsOnSave%22%5D'
                    ))
                });
            }
            report(provider) {
                if (provider.displayName && !( this._names.has(provider.displayName))) {
                    this._names.add(provider.displayName);
                    this._report();
                }
            }
        });
        for (const codeActionKind of codeActionsOnSave) {
            const actionsToRun = await this.getActionsToRun(model, codeActionKind, excludes, getActionProgress, token);
            if (token.isCancellationRequested) {
                actionsToRun.dispose();
                return;
            }
            try {
                for (const action of actionsToRun.validActions) {
                    progress.report({ message: ( localizeWithPath(
                        'vs/workbench/contrib/codeEditor/browser/saveParticipants',
                        'codeAction.apply',
                        "Applying code action '{0}'.",
                        action.action.title
                    )) });
                    await this.instantiationService.invokeFunction(applyCodeAction, action, ApplyCodeActionReason.OnSave, {}, token);
                    if (token.isCancellationRequested) {
                        return;
                    }
                }
            }
            catch {
            }
            finally {
                actionsToRun.dispose();
            }
        }
    }
    getActionsToRun(model, codeActionKind, excludes, progress, token) {
        return getCodeActions(this.languageFeaturesService.codeActionProvider, model, model.getFullModelRange(), {
            type: 2 ,
            triggerAction: CodeActionTriggerSource.OnSave,
            filter: { include: codeActionKind, excludes: excludes, includeSourceActions: true },
        }, progress, token);
    }
};
CodeActionOnSaveParticipant = ( __decorate([
    ( __param(0, IConfigurationService)),
    ( __param(1, IInstantiationService)),
    ( __param(2, ILanguageFeaturesService))
], CodeActionOnSaveParticipant));
let SaveParticipantsContribution = class SaveParticipantsContribution extends Disposable {
    constructor(instantiationService, textFileService) {
        super();
        this.instantiationService = instantiationService;
        this.textFileService = textFileService;
        this.registerSaveParticipants();
    }
    registerSaveParticipants() {
        this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimWhitespaceParticipant)));
        this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(CodeActionOnSaveParticipant)));
        this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FormatOnSaveParticipant)));
        this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(FinalNewLineParticipant)));
        this._register(this.textFileService.files.addSaveParticipant(this.instantiationService.createInstance(TrimFinalNewLinesParticipant)));
    }
};
SaveParticipantsContribution = ( __decorate([
    ( __param(0, IInstantiationService)),
    ( __param(1, ITextFileService))
], SaveParticipantsContribution));
const workbenchContributionsRegistry = ( Registry.as(Extensions.Workbench));
workbenchContributionsRegistry.registerWorkbenchContribution(SaveParticipantsContribution, 3 );
export { FinalNewLineParticipant, SaveParticipantsContribution, TrimFinalNewLinesParticipant, TrimWhitespaceParticipant };

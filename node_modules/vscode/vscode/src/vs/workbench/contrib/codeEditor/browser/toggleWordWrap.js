import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { Disposable, DisposableStore } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { registerEditorContribution, registerDiffEditorContribution, registerEditorAction, EditorAction } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { ICodeEditorService } from 'monaco-editor/esm/vs/editor/browser/services/codeEditorService.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { ContextKeyExpr, RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { Registry } from 'monaco-editor/esm/vs/platform/registry/common/platform.js';
import { Extensions } from '../../../common/contributions.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
const transientWordWrapState = 'transientWordWrapState';
const isWordWrapMinifiedKey = 'isWordWrapMinified';
const isDominatedByLongLinesKey = 'isDominatedByLongLines';
const CAN_TOGGLE_WORD_WRAP = ( new RawContextKey('canToggleWordWrap', false, true));
const EDITOR_WORD_WRAP = ( new RawContextKey('editorWordWrap', false, ( nls.localizeWithPath(
    'vs/workbench/contrib/codeEditor/browser/toggleWordWrap',
    'editorWordWrap',
    'Whether the editor is currently using word wrapping.'
))));
function writeTransientState(model, state, codeEditorService) {
    codeEditorService.setTransientModelProperty(model, transientWordWrapState, state);
}
function readTransientState(model, codeEditorService) {
    return codeEditorService.getTransientModelProperty(model, transientWordWrapState);
}
const TOGGLE_WORD_WRAP_ID = 'editor.action.toggleWordWrap';
class ToggleWordWrapAction extends EditorAction {
    constructor() {
        super({
            id: TOGGLE_WORD_WRAP_ID,
            label: ( nls.localizeWithPath(
                'vs/workbench/contrib/codeEditor/browser/toggleWordWrap',
                'toggle.wordwrap',
                "View: Toggle Word Wrap"
            )),
            alias: 'View: Toggle Word Wrap',
            precondition: undefined,
            kbOpts: {
                kbExpr: null,
                primary: 512  | 56 ,
                weight: 100
            }
        });
    }
    run(accessor, editor) {
        const codeEditorService = accessor.get(ICodeEditorService);
        if (!canToggleWordWrap(codeEditorService, editor)) {
            return;
        }
        const model = editor.getModel();
        const transientState = readTransientState(model, codeEditorService);
        let newState;
        if (transientState) {
            newState = null;
        }
        else {
            const actualWrappingInfo = editor.getOption(144 );
            const wordWrapOverride = (actualWrappingInfo.wrappingColumn === -1 ? 'on' : 'off');
            newState = { wordWrapOverride };
        }
        writeTransientState(model, newState, codeEditorService);
        const diffEditor = findDiffEditorContainingCodeEditor(editor, codeEditorService);
        if (diffEditor) {
            const originalEditor = diffEditor.getOriginalEditor();
            const modifiedEditor = diffEditor.getModifiedEditor();
            const otherEditor = (originalEditor === editor ? modifiedEditor : originalEditor);
            if (canToggleWordWrap(codeEditorService, otherEditor)) {
                writeTransientState(otherEditor.getModel(), newState, codeEditorService);
                diffEditor.updateOptions({});
            }
        }
    }
}
function findDiffEditorContainingCodeEditor(editor, codeEditorService) {
    if (!editor.getOption(61 )) {
        return null;
    }
    for (const diffEditor of codeEditorService.listDiffEditors()) {
        const originalEditor = diffEditor.getOriginalEditor();
        const modifiedEditor = diffEditor.getModifiedEditor();
        if (originalEditor === editor || modifiedEditor === editor) {
            return diffEditor;
        }
    }
    return null;
}
let ToggleWordWrapController = class ToggleWordWrapController extends Disposable {
    static { this.ID = 'editor.contrib.toggleWordWrapController'; }
    constructor(_editor, _contextKeyService, _codeEditorService) {
        super();
        this._editor = _editor;
        this._contextKeyService = _contextKeyService;
        this._codeEditorService = _codeEditorService;
        const options = this._editor.getOptions();
        const wrappingInfo = options.get(144 );
        const isWordWrapMinified = this._contextKeyService.createKey(isWordWrapMinifiedKey, wrappingInfo.isWordWrapMinified);
        const isDominatedByLongLines = this._contextKeyService.createKey(isDominatedByLongLinesKey, wrappingInfo.isDominatedByLongLines);
        let currentlyApplyingEditorConfig = false;
        this._register(_editor.onDidChangeConfiguration((e) => {
            if (!e.hasChanged(144 )) {
                return;
            }
            const options = this._editor.getOptions();
            const wrappingInfo = options.get(144 );
            isWordWrapMinified.set(wrappingInfo.isWordWrapMinified);
            isDominatedByLongLines.set(wrappingInfo.isDominatedByLongLines);
            if (!currentlyApplyingEditorConfig) {
                ensureWordWrapSettings();
            }
        }));
        this._register(_editor.onDidChangeModel((e) => {
            ensureWordWrapSettings();
        }));
        this._register(_codeEditorService.onDidChangeTransientModelProperty(() => {
            ensureWordWrapSettings();
        }));
        const ensureWordWrapSettings = () => {
            if (!canToggleWordWrap(this._codeEditorService, this._editor)) {
                return;
            }
            const transientState = readTransientState(this._editor.getModel(), this._codeEditorService);
            try {
                currentlyApplyingEditorConfig = true;
                this._applyWordWrapState(transientState);
            }
            finally {
                currentlyApplyingEditorConfig = false;
            }
        };
    }
    _applyWordWrapState(state) {
        const wordWrapOverride2 = state ? state.wordWrapOverride : 'inherit';
        this._editor.updateOptions({
            wordWrapOverride2: wordWrapOverride2
        });
    }
};
ToggleWordWrapController = ( __decorate([
    ( __param(1, IContextKeyService)),
    ( __param(2, ICodeEditorService))
], ToggleWordWrapController));
let DiffToggleWordWrapController = class DiffToggleWordWrapController extends Disposable {
    static { this.ID = 'diffeditor.contrib.toggleWordWrapController'; }
    constructor(_diffEditor, _codeEditorService) {
        super();
        this._diffEditor = _diffEditor;
        this._codeEditorService = _codeEditorService;
        this._register(this._diffEditor.onDidChangeModel(() => {
            this._ensureSyncedWordWrapToggle();
        }));
    }
    _ensureSyncedWordWrapToggle() {
        const originalEditor = this._diffEditor.getOriginalEditor();
        const modifiedEditor = this._diffEditor.getModifiedEditor();
        if (!originalEditor.hasModel() || !modifiedEditor.hasModel()) {
            return;
        }
        const originalTransientState = readTransientState(originalEditor.getModel(), this._codeEditorService);
        const modifiedTransientState = readTransientState(modifiedEditor.getModel(), this._codeEditorService);
        if (originalTransientState && !modifiedTransientState && canToggleWordWrap(this._codeEditorService, originalEditor)) {
            writeTransientState(modifiedEditor.getModel(), originalTransientState, this._codeEditorService);
            this._diffEditor.updateOptions({});
        }
        if (!originalTransientState && modifiedTransientState && canToggleWordWrap(this._codeEditorService, modifiedEditor)) {
            writeTransientState(originalEditor.getModel(), modifiedTransientState, this._codeEditorService);
            this._diffEditor.updateOptions({});
        }
    }
};
DiffToggleWordWrapController = ( __decorate([
    ( __param(1, ICodeEditorService))
], DiffToggleWordWrapController));
function canToggleWordWrap(codeEditorService, editor) {
    if (!editor) {
        return false;
    }
    if (editor.isSimpleWidget) {
        return false;
    }
    const model = editor.getModel();
    if (!model) {
        return false;
    }
    if (model.uri.scheme === 'output') {
        return false;
    }
    if (editor.getOption(61 )) {
        for (const diffEditor of codeEditorService.listDiffEditors()) {
            if (diffEditor.getOriginalEditor() === editor && !diffEditor.renderSideBySide) {
                return false;
            }
        }
    }
    return true;
}
let EditorWordWrapContextKeyTracker = class EditorWordWrapContextKeyTracker {
    constructor(_editorService, _codeEditorService, _contextService) {
        this._editorService = _editorService;
        this._codeEditorService = _codeEditorService;
        this._contextService = _contextService;
        window.addEventListener('focus', () => this._update(), true);
        window.addEventListener('blur', () => this._update(), true);
        this._editorService.onDidActiveEditorChange(() => this._update());
        this._canToggleWordWrap = CAN_TOGGLE_WORD_WRAP.bindTo(this._contextService);
        this._editorWordWrap = EDITOR_WORD_WRAP.bindTo(this._contextService);
        this._activeEditor = null;
        this._activeEditorListener = ( new DisposableStore());
        this._update();
    }
    _update() {
        const activeEditor = this._codeEditorService.getFocusedCodeEditor() || this._codeEditorService.getActiveCodeEditor();
        if (this._activeEditor === activeEditor) {
            return;
        }
        this._activeEditorListener.clear();
        this._activeEditor = activeEditor;
        if (activeEditor) {
            this._activeEditorListener.add(activeEditor.onDidChangeModel(() => this._updateFromCodeEditor()));
            this._activeEditorListener.add(activeEditor.onDidChangeConfiguration((e) => {
                if (e.hasChanged(144 )) {
                    this._updateFromCodeEditor();
                }
            }));
            this._updateFromCodeEditor();
        }
    }
    _updateFromCodeEditor() {
        if (!canToggleWordWrap(this._codeEditorService, this._activeEditor)) {
            return this._setValues(false, false);
        }
        else {
            const wrappingInfo = this._activeEditor.getOption(144 );
            this._setValues(true, wrappingInfo.wrappingColumn !== -1);
        }
    }
    _setValues(canToggleWordWrap, isWordWrap) {
        this._canToggleWordWrap.set(canToggleWordWrap);
        this._editorWordWrap.set(isWordWrap);
    }
};
EditorWordWrapContextKeyTracker = ( __decorate([
    ( __param(0, IEditorService)),
    ( __param(1, ICodeEditorService)),
    ( __param(2, IContextKeyService))
], EditorWordWrapContextKeyTracker));
const workbenchRegistry = ( Registry.as(Extensions.Workbench));
workbenchRegistry.registerWorkbenchContribution(EditorWordWrapContextKeyTracker, 2 );
registerEditorContribution(ToggleWordWrapController.ID, ToggleWordWrapController, 0 );
registerDiffEditorContribution(DiffToggleWordWrapController.ID, DiffToggleWordWrapController);
registerEditorAction(ToggleWordWrapAction);
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
    command: {
        id: TOGGLE_WORD_WRAP_ID,
        title: ( nls.localizeWithPath(
            'vs/workbench/contrib/codeEditor/browser/toggleWordWrap',
            'unwrapMinified',
            "Disable wrapping for this file"
        )),
        icon: Codicon.wordWrap
    },
    group: 'navigation',
    order: 1,
    when: ( ContextKeyExpr.and(( ContextKeyExpr.has(isDominatedByLongLinesKey)), ( ContextKeyExpr.has(isWordWrapMinifiedKey))))
});
MenuRegistry.appendMenuItem(MenuId.EditorTitle, {
    command: {
        id: TOGGLE_WORD_WRAP_ID,
        title: ( nls.localizeWithPath(
            'vs/workbench/contrib/codeEditor/browser/toggleWordWrap',
            'wrapMinified',
            "Enable wrapping for this file"
        )),
        icon: Codicon.wordWrap
    },
    group: 'navigation',
    order: 1,
    when: ( ContextKeyExpr.and(( EditorContextKeys.inDiffEditor.negate()), ( ContextKeyExpr.has(isDominatedByLongLinesKey)), ContextKeyExpr.not(isWordWrapMinifiedKey)))
});
MenuRegistry.appendMenuItem(MenuId.MenubarViewMenu, {
    command: {
        id: TOGGLE_WORD_WRAP_ID,
        title: ( nls.localizeWithPath(
            'vs/workbench/contrib/codeEditor/browser/toggleWordWrap',
            { key: 'miToggleWordWrap', comment: ['&& denotes a mnemonic'] },
            "&&Word Wrap"
        )),
        toggled: EDITOR_WORD_WRAP,
        precondition: CAN_TOGGLE_WORD_WRAP
    },
    order: 1,
    group: '5_editor'
});
export { readTransientState, writeTransientState };

import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { OS, isWindows } from 'monaco-editor/esm/vs/base/common/platform.js';
import { extname, basename } from 'monaco-editor/esm/vs/base/common/path.js';
import * as resources from 'monaco-editor/esm/vs/base/common/resources.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { toErrorMessage } from 'monaco-editor/esm/vs/base/common/errorMessage.js';
import { Action } from 'monaco-editor/esm/vs/base/common/actions.js';
import { dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { VIEWLET_ID, VIEW_ID } from '../common/files.js';
import { IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { EditorResourceAccessor, SideBySideEditor } from '../../../common/editor.js';
import { IQuickInputService, ItemActivation } from 'monaco-editor/esm/vs/platform/quickinput/common/quickInput.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { IHostService } from '../../../services/host/browser/host.js';
import { SAVE_ALL_IN_GROUP_COMMAND_ID, REVEAL_IN_EXPLORER_COMMAND_ID, NEW_UNTITLED_FILE_COMMAND_ID } from './fileConstants.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { IClipboardService } from 'monaco-editor/esm/vs/platform/clipboard/common/clipboardService.js';
import { ILanguageService } from 'monaco-editor/esm/vs/editor/common/languages/language.js';
import { IModelService } from 'monaco-editor/esm/vs/editor/common/services/model.js';
import { ICommandService, CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { RawContextKey } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { Severity, INotificationService } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IEditorService } from '../../../services/editor/common/editorService.js';
import { CLOSE_EDITORS_AND_GROUP_COMMAND_ID } from '../../../browser/parts/editor/editorCommands.js';
import { coalesce } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { NewExplorerItem } from '../common/explorerModel.js';
import { getErrorMessage } from 'monaco-editor/esm/vs/base/common/errors.js';
import { triggerUpload } from 'monaco-editor/esm/vs/base/browser/dom.js';
import { IFilesConfigurationService } from '../../../services/filesConfiguration/common/filesConfigurationService.js';
import { IWorkingCopyService } from '../../../services/workingCopy/common/workingCopyService.js';
import { timeout } from 'monaco-editor/esm/vs/base/common/async.js';
import { IWorkingCopyFileService } from '../../../services/workingCopy/common/workingCopyFileService.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { IViewsService } from '../../../common/views.js';
import { trim, rtrim } from 'monaco-editor/esm/vs/base/common/strings.js';
import { IUriIdentityService } from 'monaco-editor/esm/vs/platform/uriIdentity/common/uriIdentity.js';
import { ResourceFileEdit } from 'monaco-editor/esm/vs/editor/browser/services/bulkEditService.js';
import { IExplorerService } from './files.js';
import { FileDownload, BrowserFileUpload } from './fileImportExport.js';
import { IPaneCompositePartService } from '../../../services/panecomposite/browser/panecomposite.js';
import { IRemoteAgentService } from '../../../services/remote/common/remoteAgentService.js';
import { IPathService } from '../../../services/path/common/pathService.js';
import { Action2 } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { ActiveEditorContext, EmptyWorkspaceSupportContext, ActiveEditorCanToggleReadonlyContext } from '../../../common/contextkeys.js';
import { KeyChord } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { Categories } from 'monaco-editor/esm/vs/platform/action/common/actionCommonCategories.js';
import { IDialogService, getFileNamesMessage } from '../../../../platform/dialogs/common/dialogs.js';
const NEW_FILE_COMMAND_ID = 'explorer.newFile';
const NEW_FILE_LABEL = ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'newFile', "New File..."));
const NEW_FOLDER_COMMAND_ID = 'explorer.newFolder';
const NEW_FOLDER_LABEL = ( nls.localizeWithPath(
    'vs/workbench/contrib/files/browser/fileActions',
    'newFolder',
    "New Folder..."
));
const TRIGGER_RENAME_LABEL = ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'rename', "Rename..."));
const MOVE_FILE_TO_TRASH_LABEL = ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'delete', "Delete"));
const COPY_FILE_LABEL = ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'copyFile', "Copy"));
const PASTE_FILE_LABEL = ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'pasteFile', "Paste"));
const FileCopiedContext = ( new RawContextKey('fileCopied', false));
const DOWNLOAD_COMMAND_ID = 'explorer.download';
const DOWNLOAD_LABEL = ( nls.localizeWithPath(
    'vs/workbench/contrib/files/browser/fileActions',
    'download',
    "Download..."
));
const UPLOAD_COMMAND_ID = 'explorer.upload';
const UPLOAD_LABEL = ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'upload', "Upload..."));
const CONFIRM_DELETE_SETTING_KEY = 'explorer.confirmDelete';
const MAX_UNDO_FILE_SIZE = 5000000;
function onError(notificationService, error) {
    if (error.message === 'string') {
        error = error.message;
    }
    notificationService.error(toErrorMessage(error, false));
}
async function refreshIfSeparator(value, explorerService) {
    if (value && ((value.indexOf('/') >= 0) || (value.indexOf('\\') >= 0))) {
        await explorerService.refresh();
    }
}
async function deleteFiles(explorerService, workingCopyFileService, dialogService, configurationService, elements, useTrash, skipConfirm = false, ignoreIfNotExists = false) {
    let primaryButton;
    if (useTrash) {
        primaryButton = isWindows ? ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'deleteButtonLabelRecycleBin',
            "&&Move to Recycle Bin"
        )) : ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            { key: 'deleteButtonLabelTrash', comment: ['&& denotes a mnemonic'] },
            "&&Move to Trash"
        ));
    }
    else {
        primaryButton = ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            { key: 'deleteButtonLabel', comment: ['&& denotes a mnemonic'] },
            "&&Delete"
        ));
    }
    const distinctElements = resources.distinctParents(elements, e => e.resource);
    const dirtyWorkingCopies = ( new Set());
    for (const distinctElement of distinctElements) {
        for (const dirtyWorkingCopy of workingCopyFileService.getDirty(distinctElement.resource)) {
            dirtyWorkingCopies.add(dirtyWorkingCopy);
        }
    }
    let confirmed = true;
    if (dirtyWorkingCopies.size) {
        let message;
        if (distinctElements.length > 1) {
            message = ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'dirtyMessageFilesDelete',
                "You are deleting files with unsaved changes. Do you want to continue?"
            ));
        }
        else if (distinctElements[0].isDirectory) {
            if (dirtyWorkingCopies.size === 1) {
                message = ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'dirtyMessageFolderOneDelete',
                    "You are deleting a folder {0} with unsaved changes in 1 file. Do you want to continue?",
                    distinctElements[0].name
                ));
            }
            else {
                message = ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'dirtyMessageFolderDelete',
                    "You are deleting a folder {0} with unsaved changes in {1} files. Do you want to continue?",
                    distinctElements[0].name,
                    dirtyWorkingCopies.size
                ));
            }
        }
        else {
            message = ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'dirtyMessageFileDelete',
                "You are deleting {0} with unsaved changes. Do you want to continue?",
                distinctElements[0].name
            ));
        }
        const response = await dialogService.confirm({
            type: 'warning',
            message,
            detail: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'dirtyWarning',
                "Your changes will be lost if you don't save them."
            )),
            primaryButton
        });
        if (!response.confirmed) {
            confirmed = false;
        }
        else {
            skipConfirm = true;
        }
    }
    if (!confirmed) {
        return;
    }
    let confirmation;
    const deleteDetail = ( distinctElements.some(e => e.isDirectory)) ? ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'irreversible',
        "This action is irreversible!"
    )) :
        distinctElements.length > 1 ? ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'restorePlural',
            "You can restore these files using the Undo command"
        )) : ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'restore',
            "You can restore this file using the Undo command"
        ));
    if (skipConfirm || (useTrash && configurationService.getValue(CONFIRM_DELETE_SETTING_KEY) === false)) {
        confirmation = { confirmed: true };
    }
    else if (useTrash) {
        let { message, detail } = getMoveToTrashMessage(distinctElements);
        detail += detail ? '\n' : '';
        if (isWindows) {
            detail += distinctElements.length > 1 ? ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'undoBinFiles',
                "You can restore these files from the Recycle Bin."
            )) : ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'undoBin',
                "You can restore this file from the Recycle Bin."
            ));
        }
        else {
            detail += distinctElements.length > 1 ? ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'undoTrashFiles',
                "You can restore these files from the Trash."
            )) : ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'undoTrash',
                "You can restore this file from the Trash."
            ));
        }
        confirmation = await dialogService.confirm({
            message,
            detail,
            primaryButton,
            checkbox: {
                label: ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'doNotAskAgain',
                    "Do not ask me again"
                ))
            }
        });
    }
    else {
        let { message, detail } = getDeleteMessage(distinctElements);
        detail += detail ? '\n' : '';
        detail += deleteDetail;
        confirmation = await dialogService.confirm({
            type: 'warning',
            message,
            detail,
            primaryButton
        });
    }
    if (confirmation.confirmed && confirmation.checkboxChecked === true) {
        await configurationService.updateValue(CONFIRM_DELETE_SETTING_KEY, false);
    }
    if (!confirmation.confirmed) {
        return;
    }
    try {
        const resourceFileEdits = ( distinctElements.map(e => ( new ResourceFileEdit(
            e.resource,
            undefined,
            { recursive: true, folder: e.isDirectory, ignoreIfNotExists, skipTrashBin: !useTrash, maxSize: MAX_UNDO_FILE_SIZE }
        ))));
        const options = {
            undoLabel: distinctElements.length > 1 ? ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                { key: 'deleteBulkEdit', comment: ['Placeholder will be replaced by the number of files deleted'] },
                "Delete {0} files",
                distinctElements.length
            )) : ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                { key: 'deleteFileBulkEdit', comment: ['Placeholder will be replaced by the name of the file deleted'] },
                "Delete {0}",
                distinctElements[0].name
            )),
            progressLabel: distinctElements.length > 1 ? ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                { key: 'deletingBulkEdit', comment: ['Placeholder will be replaced by the number of files deleted'] },
                "Deleting {0} files",
                distinctElements.length
            )) : ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                { key: 'deletingFileBulkEdit', comment: ['Placeholder will be replaced by the name of the file deleted'] },
                "Deleting {0}",
                distinctElements[0].name
            )),
        };
        await explorerService.applyBulkEdit(resourceFileEdits, options);
    }
    catch (error) {
        let errorMessage;
        let detailMessage;
        let primaryButton;
        if (useTrash) {
            errorMessage = isWindows ? ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'binFailed',
                "Failed to delete using the Recycle Bin. Do you want to permanently delete instead?"
            )) : ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'trashFailed',
                "Failed to delete using the Trash. Do you want to permanently delete instead?"
            ));
            detailMessage = deleteDetail;
            primaryButton = ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                { key: 'deletePermanentlyButtonLabel', comment: ['&& denotes a mnemonic'] },
                "&&Delete Permanently"
            ));
        }
        else {
            errorMessage = toErrorMessage(error, false);
            primaryButton = ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                { key: 'retryButtonLabel', comment: ['&& denotes a mnemonic'] },
                "&&Retry"
            ));
        }
        const res = await dialogService.confirm({
            type: 'warning',
            message: errorMessage,
            detail: detailMessage,
            primaryButton
        });
        if (res.confirmed) {
            if (useTrash) {
                useTrash = false;
            }
            skipConfirm = true;
            ignoreIfNotExists = true;
            return deleteFiles(explorerService, workingCopyFileService, dialogService, configurationService, elements, useTrash, skipConfirm, ignoreIfNotExists);
        }
    }
}
function getMoveToTrashMessage(distinctElements) {
    if (containsBothDirectoryAndFile(distinctElements)) {
        return {
            message: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'confirmMoveTrashMessageFilesAndDirectories',
                "Are you sure you want to delete the following {0} files/directories and their contents?",
                distinctElements.length
            )),
            detail: getFileNamesMessage(( distinctElements.map(e => e.resource)))
        };
    }
    if (distinctElements.length > 1) {
        if (distinctElements[0].isDirectory) {
            return {
                message: ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'confirmMoveTrashMessageMultipleDirectories',
                    "Are you sure you want to delete the following {0} directories and their contents?",
                    distinctElements.length
                )),
                detail: getFileNamesMessage(( distinctElements.map(e => e.resource)))
            };
        }
        return {
            message: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'confirmMoveTrashMessageMultiple',
                "Are you sure you want to delete the following {0} files?",
                distinctElements.length
            )),
            detail: getFileNamesMessage(( distinctElements.map(e => e.resource)))
        };
    }
    if (distinctElements[0].isDirectory && !distinctElements[0].isSymbolicLink) {
        return { message: ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'confirmMoveTrashMessageFolder',
            "Are you sure you want to delete '{0}' and its contents?",
            distinctElements[0].name
        )), detail: '' };
    }
    return { message: ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'confirmMoveTrashMessageFile',
        "Are you sure you want to delete '{0}'?",
        distinctElements[0].name
    )), detail: '' };
}
function getDeleteMessage(distinctElements) {
    if (containsBothDirectoryAndFile(distinctElements)) {
        return {
            message: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'confirmDeleteMessageFilesAndDirectories',
                "Are you sure you want to permanently delete the following {0} files/directories and their contents?",
                distinctElements.length
            )),
            detail: getFileNamesMessage(( distinctElements.map(e => e.resource)))
        };
    }
    if (distinctElements.length > 1) {
        if (distinctElements[0].isDirectory) {
            return {
                message: ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'confirmDeleteMessageMultipleDirectories',
                    "Are you sure you want to permanently delete the following {0} directories and their contents?",
                    distinctElements.length
                )),
                detail: getFileNamesMessage(( distinctElements.map(e => e.resource)))
            };
        }
        return {
            message: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'confirmDeleteMessageMultiple',
                "Are you sure you want to permanently delete the following {0} files?",
                distinctElements.length
            )),
            detail: getFileNamesMessage(( distinctElements.map(e => e.resource)))
        };
    }
    if (distinctElements[0].isDirectory) {
        return { message: ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'confirmDeleteMessageFolder',
            "Are you sure you want to permanently delete '{0}' and its contents?",
            distinctElements[0].name
        )), detail: '' };
    }
    return { message: ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'confirmDeleteMessageFile',
        "Are you sure you want to permanently delete '{0}'?",
        distinctElements[0].name
    )), detail: '' };
}
function containsBothDirectoryAndFile(distinctElements) {
    const directory = distinctElements.find(element => element.isDirectory);
    const file = distinctElements.find(element => !element.isDirectory);
    return !!directory && !!file;
}
async function findValidPasteFileTarget(explorerService, fileService, dialogService, targetFolder, fileToPaste, incrementalNaming) {
    let name = resources.basenameOrAuthority(fileToPaste.resource);
    let candidate = resources.joinPath(targetFolder.resource, name);
    if (incrementalNaming === 'disabled') {
        const canOverwrite = await askForOverwrite(fileService, dialogService, candidate);
        if (!canOverwrite) {
            return;
        }
    }
    while (!fileToPaste.allowOverwrite) {
        if (!explorerService.findClosest(candidate)) {
            break;
        }
        if (incrementalNaming !== 'disabled') {
            name = incrementFileName(name, !!fileToPaste.isDirectory, incrementalNaming);
        }
        candidate = resources.joinPath(targetFolder.resource, name);
    }
    return candidate;
}
function incrementFileName(name, isFolder, incrementalNaming) {
    if (incrementalNaming === 'simple') {
        let namePrefix = name;
        let extSuffix = '';
        if (!isFolder) {
            extSuffix = extname(name);
            namePrefix = basename(name, extSuffix);
        }
        const suffixRegex = /^(.+ copy)( \d+)?$/;
        if (suffixRegex.test(namePrefix)) {
            return namePrefix.replace(suffixRegex, (match, g1, g2) => {
                const number = (g2 ? parseInt(g2) : 1);
                return number === 0
                    ? `${g1}`
                    : (number < 1073741824
                        ? `${g1} ${number + 1}`
                        : `${g1}${g2} copy`);
            }) + extSuffix;
        }
        return `${namePrefix} copy${extSuffix}`;
    }
    const separators = '[\\.\\-_]';
    const maxNumber = 1073741824 ;
    const suffixFileRegex = RegExp('(.*' + separators + ')(\\d+)(\\..*)$');
    if (!isFolder && name.match(suffixFileRegex)) {
        return name.replace(suffixFileRegex, (match, g1, g2, g3) => {
            const number = parseInt(g2);
            return number < maxNumber
                ? g1 + String(number + 1).padStart(g2.length, '0') + g3
                : `${g1}${g2}.1${g3}`;
        });
    }
    const prefixFileRegex = RegExp('(\\d+)(' + separators + '.*)(\\..*)$');
    if (!isFolder && name.match(prefixFileRegex)) {
        return name.replace(prefixFileRegex, (match, g1, g2, g3) => {
            const number = parseInt(g1);
            return number < maxNumber
                ? String(number + 1).padStart(g1.length, '0') + g2 + g3
                : `${g1}${g2}.1${g3}`;
        });
    }
    const prefixFileNoNameRegex = RegExp('(\\d+)(\\..*)$');
    if (!isFolder && name.match(prefixFileNoNameRegex)) {
        return name.replace(prefixFileNoNameRegex, (match, g1, g2) => {
            const number = parseInt(g1);
            return number < maxNumber
                ? String(number + 1).padStart(g1.length, '0') + g2
                : `${g1}.1${g2}`;
        });
    }
    const lastIndexOfDot = name.lastIndexOf('.');
    if (!isFolder && lastIndexOfDot >= 0) {
        return `${name.substr(0, lastIndexOfDot)}.1${name.substr(lastIndexOfDot)}`;
    }
    const noNameNoExtensionRegex = RegExp('(\\d+)$');
    if (!isFolder && lastIndexOfDot === -1 && name.match(noNameNoExtensionRegex)) {
        return name.replace(noNameNoExtensionRegex, (match, g1) => {
            const number = parseInt(g1);
            return number < maxNumber
                ? String(number + 1).padStart(g1.length, '0')
                : `${g1}.1`;
        });
    }
    const noExtensionRegex = RegExp('(.*)(\\d*)$');
    if (!isFolder && lastIndexOfDot === -1 && name.match(noExtensionRegex)) {
        return name.replace(noExtensionRegex, (match, g1, g2) => {
            let number = parseInt(g2);
            if (isNaN(number)) {
                number = 0;
            }
            return number < maxNumber
                ? g1 + String(number + 1).padStart(g2.length, '0')
                : `${g1}${g2}.1`;
        });
    }
    if (isFolder && name.match(/(\d+)$/)) {
        return name.replace(/(\d+)$/, (match, ...groups) => {
            const number = parseInt(groups[0]);
            return number < maxNumber
                ? String(number + 1).padStart(groups[0].length, '0')
                : `${groups[0]}.1`;
        });
    }
    if (isFolder && name.match(/^(\d+)/)) {
        return name.replace(/^(\d+)(.*)$/, (match, ...groups) => {
            const number = parseInt(groups[0]);
            return number < maxNumber
                ? String(number + 1).padStart(groups[0].length, '0') + groups[1]
                : `${groups[0]}${groups[1]}.1`;
        });
    }
    return `${name}.1`;
}
async function askForOverwrite(fileService, dialogService, targetResource) {
    const exists = await fileService.exists(targetResource);
    if (!exists) {
        return true;
    }
    const { confirmed } = await dialogService.confirm({
        type: Severity.Warning,
        message: ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'confirmOverwrite',
            "A file or folder with the name '{0}' already exists in the destination folder. Do you want to replace it?",
            basename(targetResource.path)
        )),
        primaryButton: ( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'replaceButtonLabel',
            "&&Replace"
        ))
    });
    return confirmed;
}
class GlobalCompareResourcesAction extends Action2 {
    static { this.ID = 'workbench.files.action.compareFileWith'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'globalCompareFile',
        "Compare Active File With..."
    )); }
    constructor() {
        super({
            id: GlobalCompareResourcesAction.ID,
            title: { value: GlobalCompareResourcesAction.LABEL, original: 'Compare Active File With...' },
            f1: true,
            category: Categories.File,
            precondition: ActiveEditorContext
        });
    }
    async run(accessor) {
        const editorService = accessor.get(IEditorService);
        const textModelService = accessor.get(ITextModelService);
        const quickInputService = accessor.get(IQuickInputService);
        const activeInput = editorService.activeEditor;
        const activeResource = EditorResourceAccessor.getOriginalUri(activeInput);
        if (activeResource && textModelService.canHandleResource(activeResource)) {
            const picks = await quickInputService.quickAccess.pick('', { itemActivation: ItemActivation.SECOND });
            if (picks?.length === 1) {
                const resource = picks[0].resource;
                if (URI.isUri(resource) && textModelService.canHandleResource(resource)) {
                    editorService.openEditor({
                        original: { resource: activeResource },
                        modified: { resource: resource },
                        options: { pinned: true }
                    });
                }
            }
        }
    }
}
class ToggleAutoSaveAction extends Action2 {
    static { this.ID = 'workbench.action.toggleAutoSave'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'toggleAutoSave',
        "Toggle Auto Save"
    )); }
    constructor() {
        super({
            id: ToggleAutoSaveAction.ID,
            title: { value: ToggleAutoSaveAction.LABEL, original: 'Toggle Auto Save' },
            f1: true,
            category: Categories.File
        });
    }
    run(accessor) {
        const filesConfigurationService = accessor.get(IFilesConfigurationService);
        return filesConfigurationService.toggleAutoSave();
    }
}
let BaseSaveAllAction = class BaseSaveAllAction extends Action {
    constructor(id, label, commandService, notificationService, workingCopyService) {
        super(id, label);
        this.commandService = commandService;
        this.notificationService = notificationService;
        this.workingCopyService = workingCopyService;
        this.lastDirtyState = this.workingCopyService.hasDirty;
        this.enabled = this.lastDirtyState;
        this.registerListeners();
    }
    registerListeners() {
        this._register(this.workingCopyService.onDidChangeDirty(workingCopy => this.updateEnablement(workingCopy)));
    }
    updateEnablement(workingCopy) {
        const hasDirty = workingCopy.isDirty() || this.workingCopyService.hasDirty;
        if (this.lastDirtyState !== hasDirty) {
            this.enabled = hasDirty;
            this.lastDirtyState = this.enabled;
        }
    }
    async run(context) {
        try {
            await this.doRun(context);
        }
        catch (error) {
            onError(this.notificationService, error);
        }
    }
};
BaseSaveAllAction = ( __decorate([
    ( __param(2, ICommandService)),
    ( __param(3, INotificationService)),
    ( __param(4, IWorkingCopyService))
], BaseSaveAllAction));
class SaveAllInGroupAction extends BaseSaveAllAction {
    static { this.ID = 'workbench.files.action.saveAllInGroup'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'saveAllInGroup',
        "Save All in Group"
    )); }
    get class() {
        return 'explorer-action ' + ThemeIcon.asClassName(Codicon.saveAll);
    }
    doRun(context) {
        return this.commandService.executeCommand(SAVE_ALL_IN_GROUP_COMMAND_ID, {}, context);
    }
}
let CloseGroupAction = class CloseGroupAction extends Action {
    static { this.ID = 'workbench.files.action.closeGroup'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'closeGroup',
        "Close Group"
    )); }
    constructor(id, label, commandService) {
        super(id, label, ThemeIcon.asClassName(Codicon.closeAll));
        this.commandService = commandService;
    }
    run(context) {
        return this.commandService.executeCommand(CLOSE_EDITORS_AND_GROUP_COMMAND_ID, {}, context);
    }
};
CloseGroupAction = ( __decorate([
    ( __param(2, ICommandService))
], CloseGroupAction));
class FocusFilesExplorer extends Action2 {
    static { this.ID = 'workbench.files.action.focusFilesExplorer'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'focusFilesExplorer',
        "Focus on Files Explorer"
    )); }
    constructor() {
        super({
            id: FocusFilesExplorer.ID,
            title: { value: FocusFilesExplorer.LABEL, original: 'Focus on Files Explorer' },
            f1: true,
            category: Categories.File
        });
    }
    async run(accessor) {
        const paneCompositeService = accessor.get(IPaneCompositePartService);
        await paneCompositeService.openPaneComposite(VIEWLET_ID, 0 , true);
    }
}
class ShowActiveFileInExplorer extends Action2 {
    static { this.ID = 'workbench.files.action.showActiveFileInExplorer'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'showInExplorer',
        "Reveal Active File in Explorer View"
    )); }
    constructor() {
        super({
            id: ShowActiveFileInExplorer.ID,
            title: { value: ShowActiveFileInExplorer.LABEL, original: 'Reveal Active File in Explorer View' },
            f1: true,
            category: Categories.File
        });
    }
    async run(accessor) {
        const commandService = accessor.get(ICommandService);
        const editorService = accessor.get(IEditorService);
        const resource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
        if (resource) {
            commandService.executeCommand(REVEAL_IN_EXPLORER_COMMAND_ID, resource);
        }
    }
}
class ShowOpenedFileInNewWindow extends Action2 {
    static { this.ID = 'workbench.action.files.showOpenedFileInNewWindow'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'openFileInNewWindow',
        "Open Active File in New Window"
    )); }
    constructor() {
        super({
            id: ShowOpenedFileInNewWindow.ID,
            title: { value: ShowOpenedFileInNewWindow.LABEL, original: 'Open Active File in New Window' },
            f1: true,
            category: Categories.File,
            keybinding: { primary: KeyChord(2048  | 41 , 45 ), weight: 200  },
            precondition: EmptyWorkspaceSupportContext
        });
    }
    async run(accessor) {
        const editorService = accessor.get(IEditorService);
        const hostService = accessor.get(IHostService);
        const dialogService = accessor.get(IDialogService);
        const fileService = accessor.get(IFileService);
        const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
        if (fileResource) {
            if (fileService.hasProvider(fileResource)) {
                hostService.openWindow([{ fileUri: fileResource }], { forceNewWindow: true });
            }
            else {
                dialogService.error(( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'openFileToShowInNewWindow.unsupportedschema',
                    "The active editor must contain an openable resource."
                )));
            }
        }
    }
}
function validateFileName(pathService, item, name, os) {
    name = getWellFormedFileName(name);
    if (!name || name.length === 0 || /^\s+$/.test(name)) {
        return {
            content: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'emptyFileNameError',
                "A file or folder name must be provided."
            )),
            severity: Severity.Error
        };
    }
    if (name[0] === '/' || name[0] === '\\') {
        return {
            content: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'fileNameStartsWithSlashError',
                "A file or folder name cannot start with a slash."
            )),
            severity: Severity.Error
        };
    }
    const names = coalesce(name.split(/[\\/]/));
    const parent = item.parent;
    if (name !== item.name) {
        const child = parent?.getChild(name);
        if (child && child !== item) {
            return {
                content: ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'fileNameExistsError',
                    "A file or folder **{0}** already exists at this location. Please choose a different name.",
                    name
                )),
                severity: Severity.Error
            };
        }
    }
    if (( names.some(folderName => !pathService.hasValidBasename(item.resource, os, folderName)))) {
        const escapedName = name.replace(/\*/g, '\\*');
        return {
            content: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'invalidFileNameError',
                "The name **{0}** is not valid as a file or folder name. Please choose a different name.",
                trimLongName(escapedName)
            )),
            severity: Severity.Error
        };
    }
    if (( names.some(name => /^\s|\s$/.test(name)))) {
        return {
            content: ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'fileNameWhitespaceWarning',
                "Leading or trailing whitespace detected in file or folder name."
            )),
            severity: Severity.Warning
        };
    }
    return null;
}
function trimLongName(name) {
    if (name?.length > 255) {
        return `${name.substr(0, 255)}...`;
    }
    return name;
}
function getWellFormedFileName(filename) {
    if (!filename) {
        return filename;
    }
    filename = trim(filename, '\t');
    filename = rtrim(filename, '/');
    filename = rtrim(filename, '\\');
    return filename;
}
class CompareNewUntitledTextFilesAction extends Action2 {
    static { this.ID = 'workbench.files.action.compareNewUntitledTextFiles'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'compareNewUntitledTextFiles',
        "Compare New Untitled Text Files"
    )); }
    constructor() {
        super({
            id: CompareNewUntitledTextFilesAction.ID,
            title: { value: CompareNewUntitledTextFilesAction.LABEL, original: 'Compare New Untitled Text Files' },
            f1: true,
            category: Categories.File
        });
    }
    async run(accessor) {
        const editorService = accessor.get(IEditorService);
        await editorService.openEditor({
            original: { resource: undefined },
            modified: { resource: undefined },
            options: { pinned: true }
        });
    }
}
class CompareWithClipboardAction extends Action2 {
    static { this.ID = 'workbench.files.action.compareWithClipboard'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'compareWithClipboard',
        "Compare Active File with Clipboard"
    )); }
    static { this.SCHEME_COUNTER = 0; }
    constructor() {
        super({
            id: CompareWithClipboardAction.ID,
            title: { value: CompareWithClipboardAction.LABEL, original: 'Compare Active File with Clipboard' },
            f1: true,
            category: Categories.File,
            keybinding: { primary: KeyChord(2048  | 41 , 33 ), weight: 200  }
        });
    }
    async run(accessor) {
        const editorService = accessor.get(IEditorService);
        const instantiationService = accessor.get(IInstantiationService);
        const textModelService = accessor.get(ITextModelService);
        const fileService = accessor.get(IFileService);
        const resource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
        const scheme = `clipboardCompare${CompareWithClipboardAction.SCHEME_COUNTER++}`;
        if (resource && (fileService.hasProvider(resource) || resource.scheme === Schemas.untitled)) {
            if (!this.registrationDisposal) {
                const provider = instantiationService.createInstance(ClipboardContentProvider);
                this.registrationDisposal = textModelService.registerTextModelContentProvider(scheme, provider);
            }
            const name = resources.basename(resource);
            const editorLabel = ( nls.localizeWithPath(
                'vs/workbench/contrib/files/browser/fileActions',
                'clipboardComparisonLabel',
                "Clipboard â†” {0}",
                name
            ));
            await editorService.openEditor({
                original: { resource: resource.with({ scheme }) },
                modified: { resource: resource },
                label: editorLabel,
                options: { pinned: true }
            }).finally(() => {
                dispose(this.registrationDisposal);
                this.registrationDisposal = undefined;
            });
        }
    }
    dispose() {
        dispose(this.registrationDisposal);
        this.registrationDisposal = undefined;
    }
}
let ClipboardContentProvider = class ClipboardContentProvider {
    constructor(clipboardService, languageService, modelService) {
        this.clipboardService = clipboardService;
        this.languageService = languageService;
        this.modelService = modelService;
    }
    async provideTextContent(resource) {
        const text = await this.clipboardService.readText();
        const model = this.modelService.createModel(text, this.languageService.createByFilepathOrFirstLine(resource), resource);
        return model;
    }
};
ClipboardContentProvider = ( __decorate([
    ( __param(0, IClipboardService)),
    ( __param(1, ILanguageService)),
    ( __param(2, IModelService))
], ClipboardContentProvider));
function onErrorWithRetry(notificationService, error, retry) {
    notificationService.prompt(Severity.Error, toErrorMessage(error, false), [{
            label: ( nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'retry', "Retry")),
            run: () => retry()
        }]);
}
async function openExplorerAndCreate(accessor, isFolder) {
    const explorerService = accessor.get(IExplorerService);
    const fileService = accessor.get(IFileService);
    const configService = accessor.get(IConfigurationService);
    const filesConfigService = accessor.get(IFilesConfigurationService);
    const editorService = accessor.get(IEditorService);
    const viewsService = accessor.get(IViewsService);
    const notificationService = accessor.get(INotificationService);
    const remoteAgentService = accessor.get(IRemoteAgentService);
    const commandService = accessor.get(ICommandService);
    const pathService = accessor.get(IPathService);
    const wasHidden = !viewsService.isViewVisible(VIEW_ID);
    const view = await viewsService.openView(VIEW_ID, true);
    if (wasHidden) {
        await timeout(500);
    }
    if (!view) {
        if (isFolder) {
            throw new Error('Open a folder or workspace first.');
        }
        return commandService.executeCommand(NEW_UNTITLED_FILE_COMMAND_ID);
    }
    const stats = explorerService.getContext(false);
    const stat = stats.length > 0 ? stats[0] : undefined;
    let folder;
    if (stat) {
        folder = stat.isDirectory ? stat : (stat.parent || explorerService.roots[0]);
    }
    else {
        folder = explorerService.roots[0];
    }
    if (folder.isReadonly) {
        throw new Error('Parent folder is readonly.');
    }
    const newStat = ( new NewExplorerItem(fileService, configService, filesConfigService, folder, isFolder));
    folder.addChild(newStat);
    const onSuccess = async (value) => {
        try {
            const resourceToCreate = resources.joinPath(folder.resource, value);
            if (value.endsWith('/')) {
                isFolder = true;
            }
            await explorerService.applyBulkEdit([( new ResourceFileEdit(undefined, resourceToCreate, { folder: isFolder }))], {
                undoLabel: ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'createBulkEdit',
                    "Create {0}",
                    value
                )),
                progressLabel: ( nls.localizeWithPath(
                    'vs/workbench/contrib/files/browser/fileActions',
                    'creatingBulkEdit',
                    "Creating {0}",
                    value
                )),
                confirmBeforeUndo: true
            });
            await refreshIfSeparator(value, explorerService);
            if (isFolder) {
                await explorerService.select(resourceToCreate, true);
            }
            else {
                await editorService.openEditor({ resource: resourceToCreate, options: { pinned: true } });
            }
        }
        catch (error) {
            onErrorWithRetry(notificationService, error, () => onSuccess(value));
        }
    };
    const os = (await remoteAgentService.getEnvironment())?.os ?? OS;
    await explorerService.setEditable(newStat, {
        validationMessage: value => validateFileName(pathService, newStat, value, os),
        onFinish: async (value, success) => {
            folder.removeChild(newStat);
            await explorerService.setEditable(newStat, null);
            if (success) {
                onSuccess(value);
            }
        }
    });
}
CommandsRegistry.registerCommand({
    id: NEW_FILE_COMMAND_ID,
    handler: async (accessor) => {
        await openExplorerAndCreate(accessor, false);
    }
});
CommandsRegistry.registerCommand({
    id: NEW_FOLDER_COMMAND_ID,
    handler: async (accessor) => {
        await openExplorerAndCreate(accessor, true);
    }
});
const renameHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const notificationService = accessor.get(INotificationService);
    const remoteAgentService = accessor.get(IRemoteAgentService);
    const pathService = accessor.get(IPathService);
    const configurationService = accessor.get(IConfigurationService);
    const stats = explorerService.getContext(false);
    const stat = stats.length > 0 ? stats[0] : undefined;
    if (!stat) {
        return;
    }
    const os = (await remoteAgentService.getEnvironment())?.os ?? OS;
    await explorerService.setEditable(stat, {
        validationMessage: value => validateFileName(pathService, stat, value, os),
        onFinish: async (value, success) => {
            if (success) {
                const parentResource = stat.parent.resource;
                const targetResource = resources.joinPath(parentResource, value);
                if (( stat.resource.toString()) !== ( targetResource.toString())) {
                    try {
                        await explorerService.applyBulkEdit([( new ResourceFileEdit(stat.resource, targetResource))], {
                            confirmBeforeUndo: configurationService.getValue().explorer.confirmUndo === "verbose" ,
                            undoLabel: ( nls.localizeWithPath(
                                'vs/workbench/contrib/files/browser/fileActions',
                                'renameBulkEdit',
                                "Rename {0} to {1}",
                                stat.name,
                                value
                            )),
                            progressLabel: ( nls.localizeWithPath(
                                'vs/workbench/contrib/files/browser/fileActions',
                                'renamingBulkEdit',
                                "Renaming {0} to {1}",
                                stat.name,
                                value
                            )),
                        });
                        await refreshIfSeparator(value, explorerService);
                    }
                    catch (e) {
                        notificationService.error(e);
                    }
                }
            }
            await explorerService.setEditable(stat, null);
        }
    });
};
const moveFileToTrashHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const stats = explorerService.getContext(true).filter(s => !s.isRoot);
    if (stats.length) {
        await deleteFiles(accessor.get(IExplorerService), accessor.get(IWorkingCopyFileService), accessor.get(IDialogService), accessor.get(IConfigurationService), stats, true);
    }
};
const deleteFileHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const stats = explorerService.getContext(true).filter(s => !s.isRoot);
    if (stats.length) {
        await deleteFiles(accessor.get(IExplorerService), accessor.get(IWorkingCopyFileService), accessor.get(IDialogService), accessor.get(IConfigurationService), stats, false);
    }
};
let pasteShouldMove = false;
const copyFileHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const stats = explorerService.getContext(true);
    if (stats.length > 0) {
        await explorerService.setToCopy(stats, false);
        pasteShouldMove = false;
    }
};
const cutFileHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const stats = explorerService.getContext(true);
    if (stats.length > 0) {
        await explorerService.setToCopy(stats, true);
        pasteShouldMove = true;
    }
};
const downloadFileHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const notificationService = accessor.get(INotificationService);
    const instantiationService = accessor.get(IInstantiationService);
    const context = explorerService.getContext(true);
    const explorerItems = context.length ? context : explorerService.roots;
    const downloadHandler = instantiationService.createInstance(FileDownload);
    try {
        await downloadHandler.download(explorerItems);
    }
    catch (error) {
        notificationService.error(error);
        throw error;
    }
};
CommandsRegistry.registerCommand({
    id: DOWNLOAD_COMMAND_ID,
    handler: downloadFileHandler
});
const uploadFileHandler = async (accessor) => {
    const explorerService = accessor.get(IExplorerService);
    const notificationService = accessor.get(INotificationService);
    const instantiationService = accessor.get(IInstantiationService);
    const context = explorerService.getContext(true);
    const element = context.length ? context[0] : explorerService.roots[0];
    try {
        const files = await triggerUpload();
        if (files) {
            const browserUpload = instantiationService.createInstance(BrowserFileUpload);
            await browserUpload.upload(element, files);
        }
    }
    catch (error) {
        notificationService.error(error);
        throw error;
    }
};
CommandsRegistry.registerCommand({
    id: UPLOAD_COMMAND_ID,
    handler: uploadFileHandler
});
const pasteFileHandler = async (accessor) => {
    const clipboardService = accessor.get(IClipboardService);
    const explorerService = accessor.get(IExplorerService);
    const fileService = accessor.get(IFileService);
    const notificationService = accessor.get(INotificationService);
    const editorService = accessor.get(IEditorService);
    const configurationService = accessor.get(IConfigurationService);
    const uriIdentityService = accessor.get(IUriIdentityService);
    const dialogService = accessor.get(IDialogService);
    const context = explorerService.getContext(true);
    const toPaste = resources.distinctParents(await clipboardService.readResources(), r => r);
    const element = context.length ? context[0] : explorerService.roots[0];
    const incrementalNaming = configurationService.getValue().explorer.incrementalNaming;
    try {
        const sourceTargetPairs = coalesce(await Promise.all(( toPaste.map(async (fileToPaste) => {
            if (( element.resource.toString()) !== ( fileToPaste.toString()) && resources.isEqualOrParent(element.resource, fileToPaste)) {
                throw new Error(nls.localizeWithPath('vs/workbench/contrib/files/browser/fileActions', 'fileIsAncestor', "File to paste is an ancestor of the destination folder"));
            }
            const fileToPasteStat = await fileService.stat(fileToPaste);
            let target;
            if (uriIdentityService.extUri.isEqual(element.resource, fileToPaste)) {
                target = element.parent;
            }
            else {
                target = element.isDirectory ? element : element.parent;
            }
            const targetFile = await findValidPasteFileTarget(explorerService, fileService, dialogService, target, { resource: fileToPaste, isDirectory: fileToPasteStat.isDirectory, allowOverwrite: pasteShouldMove || incrementalNaming === 'disabled' }, incrementalNaming);
            if (!targetFile) {
                return undefined;
            }
            return { source: fileToPaste, target: targetFile };
        }))));
        if (sourceTargetPairs.length >= 1) {
            if (pasteShouldMove) {
                const resourceFileEdits = ( sourceTargetPairs.map(pair => ( new ResourceFileEdit(pair.source, pair.target, { overwrite: incrementalNaming === 'disabled' }))));
                const options = {
                    confirmBeforeUndo: configurationService.getValue().explorer.confirmUndo === "verbose" ,
                    progressLabel: sourceTargetPairs.length > 1 ? ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'movingBulkEdit', comment: ['Placeholder will be replaced by the number of files being moved'] },
                        "Moving {0} files",
                        sourceTargetPairs.length
                    ))
                        : ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'movingFileBulkEdit', comment: ['Placeholder will be replaced by the name of the file moved.'] },
                        "Moving {0}",
                        resources.basenameOrAuthority(sourceTargetPairs[0].target)
                    )),
                    undoLabel: sourceTargetPairs.length > 1 ? ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'moveBulkEdit', comment: ['Placeholder will be replaced by the number of files being moved'] },
                        "Move {0} files",
                        sourceTargetPairs.length
                    ))
                        : ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'moveFileBulkEdit', comment: ['Placeholder will be replaced by the name of the file moved.'] },
                        "Move {0}",
                        resources.basenameOrAuthority(sourceTargetPairs[0].target)
                    ))
                };
                await explorerService.applyBulkEdit(resourceFileEdits, options);
            }
            else {
                const resourceFileEdits = ( sourceTargetPairs.map(pair => ( new ResourceFileEdit(
                    pair.source,
                    pair.target,
                    { copy: true, overwrite: incrementalNaming === 'disabled' }
                ))));
                const undoLevel = configurationService.getValue().explorer.confirmUndo;
                const options = {
                    confirmBeforeUndo: undoLevel === "default"  || undoLevel === "verbose" ,
                    progressLabel: sourceTargetPairs.length > 1 ? ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'copyingBulkEdit', comment: ['Placeholder will be replaced by the number of files being copied'] },
                        "Copying {0} files",
                        sourceTargetPairs.length
                    ))
                        : ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'copyingFileBulkEdit', comment: ['Placeholder will be replaced by the name of the file copied.'] },
                        "Copying {0}",
                        resources.basenameOrAuthority(sourceTargetPairs[0].target)
                    )),
                    undoLabel: sourceTargetPairs.length > 1 ? ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'copyBulkEdit', comment: ['Placeholder will be replaced by the number of files being copied'] },
                        "Paste {0} files",
                        sourceTargetPairs.length
                    ))
                        : ( nls.localizeWithPath(
                        'vs/workbench/contrib/files/browser/fileActions',
                        { key: 'copyFileBulkEdit', comment: ['Placeholder will be replaced by the name of the file copied.'] },
                        "Paste {0}",
                        resources.basenameOrAuthority(sourceTargetPairs[0].target)
                    ))
                };
                await explorerService.applyBulkEdit(resourceFileEdits, options);
            }
            const pair = sourceTargetPairs[0];
            await explorerService.select(pair.target);
            if (sourceTargetPairs.length === 1) {
                const item = explorerService.findClosest(pair.target);
                if (item && !item.isDirectory) {
                    await editorService.openEditor({ resource: item.resource, options: { pinned: true, preserveFocus: true } });
                }
            }
        }
    }
    catch (e) {
        onError(notificationService, ( new Error(( nls.localizeWithPath(
            'vs/workbench/contrib/files/browser/fileActions',
            'fileDeleted',
            "The file(s) to paste have been deleted or moved since you copied them. {0}",
            getErrorMessage(e)
        )))));
    }
    finally {
        if (pasteShouldMove) {
            await explorerService.setToCopy([], false);
            pasteShouldMove = false;
        }
    }
};
const openFilePreserveFocusHandler = async (accessor) => {
    const editorService = accessor.get(IEditorService);
    const explorerService = accessor.get(IExplorerService);
    const stats = explorerService.getContext(true);
    await editorService.openEditors(( stats.filter(s => !s.isDirectory).map(s => ({
        resource: s.resource,
        options: { preserveFocus: true }
    }))));
};
class BaseSetActiveEditorReadonlyInSession extends Action2 {
    constructor(id, title, newReadonlyState) {
        super({
            id,
            title,
            f1: true,
            category: Categories.File,
            precondition: ActiveEditorCanToggleReadonlyContext
        });
        this.newReadonlyState = newReadonlyState;
    }
    async run(accessor) {
        const editorService = accessor.get(IEditorService);
        const filesConfigurationService = accessor.get(IFilesConfigurationService);
        const fileResource = EditorResourceAccessor.getOriginalUri(editorService.activeEditor, { supportSideBySide: SideBySideEditor.PRIMARY });
        if (!fileResource) {
            return;
        }
        await filesConfigurationService.updateReadonly(fileResource, this.newReadonlyState);
    }
}
class SetActiveEditorReadonlyInSession extends BaseSetActiveEditorReadonlyInSession {
    static { this.ID = 'workbench.action.files.setActiveEditorReadonlyInSession'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'setActiveEditorReadonlyInSession',
        "Set Active Editor Read-only in Session"
    )); }
    constructor() {
        super(SetActiveEditorReadonlyInSession.ID, { value: SetActiveEditorReadonlyInSession.LABEL, original: 'Set Active Editor Readonly in Session' }, true);
    }
}
class SetActiveEditorWriteableInSession extends BaseSetActiveEditorReadonlyInSession {
    static { this.ID = 'workbench.action.files.setActiveEditorWriteableInSession'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'setActiveEditorWriteableInSession',
        "Set Active Editor Writeable in Session"
    )); }
    constructor() {
        super(SetActiveEditorWriteableInSession.ID, { value: SetActiveEditorWriteableInSession.LABEL, original: 'Set Active Editor Writeable in Session' }, false);
    }
}
class ToggleActiveEditorReadonlyInSession extends BaseSetActiveEditorReadonlyInSession {
    static { this.ID = 'workbench.action.files.toggleActiveEditorReadonlyInSession'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'toggleActiveEditorReadonlyInSession',
        "Toggle Active Editor Read-only in Session"
    )); }
    constructor() {
        super(ToggleActiveEditorReadonlyInSession.ID, { value: ToggleActiveEditorReadonlyInSession.LABEL, original: 'Toggle Active Editor Readonly in Session' }, 'toggle');
    }
}
class ResetActiveEditorReadonlyInSession extends BaseSetActiveEditorReadonlyInSession {
    static { this.ID = 'workbench.action.files.resetActiveEditorReadonlyInSession'; }
    static { this.LABEL = ( nls.localizeWithPath(
        'vs/workbench/contrib/files/browser/fileActions',
        'resetActiveEditorReadonlyInSession',
        "Reset Active Editor Read-only in Session"
    )); }
    constructor() {
        super(ResetActiveEditorReadonlyInSession.ID, { value: ResetActiveEditorReadonlyInSession.LABEL, original: 'Reset Active Editor Readonly in Session' }, 'reset');
    }
}
export { COPY_FILE_LABEL, CloseGroupAction, CompareNewUntitledTextFilesAction, CompareWithClipboardAction, DOWNLOAD_COMMAND_ID, DOWNLOAD_LABEL, FileCopiedContext, FocusFilesExplorer, GlobalCompareResourcesAction, MOVE_FILE_TO_TRASH_LABEL, NEW_FILE_COMMAND_ID, NEW_FILE_LABEL, NEW_FOLDER_COMMAND_ID, NEW_FOLDER_LABEL, PASTE_FILE_LABEL, ResetActiveEditorReadonlyInSession, SaveAllInGroupAction, SetActiveEditorReadonlyInSession, SetActiveEditorWriteableInSession, ShowActiveFileInExplorer, ShowOpenedFileInNewWindow, TRIGGER_RENAME_LABEL, ToggleActiveEditorReadonlyInSession, ToggleAutoSaveAction, UPLOAD_COMMAND_ID, UPLOAD_LABEL, copyFileHandler, cutFileHandler, deleteFileHandler, findValidPasteFileTarget, incrementFileName, moveFileToTrashHandler, openFilePreserveFocusHandler, pasteFileHandler, renameHandler, validateFileName };

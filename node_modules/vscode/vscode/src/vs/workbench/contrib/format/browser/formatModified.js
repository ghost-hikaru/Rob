import { isNonEmptyArray } from 'monaco-editor/esm/vs/base/common/arrays.js';
import { CancellationToken } from 'monaco-editor/esm/vs/base/common/cancellation.js';
import { registerEditorAction, EditorAction } from 'monaco-editor/esm/vs/editor/browser/editorExtensions.js';
import { Range } from 'monaco-editor/esm/vs/editor/common/core/range.js';
import { EditorContextKeys } from 'monaco-editor/esm/vs/editor/common/editorContextKeys.js';
import { shouldSynchronizeModel } from 'monaco-editor/esm/vs/editor/common/model.js';
import { IEditorWorkerService } from 'monaco-editor/esm/vs/editor/common/services/editorWorker.js';
import { ITextModelService } from 'monaco-editor/esm/vs/editor/common/services/resolverService.js';
import { formatDocumentRangesWithSelectedProvider } from 'monaco-editor/esm/vs/editor/contrib/format/browser/format.js';
import * as nls from 'monaco-editor/esm/vs/nls.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { Progress } from 'monaco-editor/esm/vs/platform/progress/common/progress.js';
import { getOriginalResource } from '../../scm/browser/dirtydiffDecorator.js';
import { IQuickDiffService } from '../../scm/common/quickDiff.js';
registerEditorAction(class FormatModifiedAction extends EditorAction {
    constructor() {
        super({
            id: 'editor.action.formatChanges',
            label: ( nls.localizeWithPath(
                'vs/workbench/contrib/format/browser/formatModified',
                'formatChanges',
                "Format Modified Lines"
            )),
            alias: 'Format Modified Lines',
            precondition: ( ContextKeyExpr.and(
                EditorContextKeys.writable,
                EditorContextKeys.hasDocumentSelectionFormattingProvider
            )),
        });
    }
    async run(accessor, editor) {
        const instaService = accessor.get(IInstantiationService);
        if (!editor.hasModel()) {
            return;
        }
        const ranges = await instaService.invokeFunction(getModifiedRanges, editor.getModel());
        if (isNonEmptyArray(ranges)) {
            return instaService.invokeFunction(formatDocumentRangesWithSelectedProvider, editor, ranges, 1 , Progress.None, CancellationToken.None);
        }
    }
});
async function getModifiedRanges(accessor, modified) {
    const quickDiffService = accessor.get(IQuickDiffService);
    const workerService = accessor.get(IEditorWorkerService);
    const modelService = accessor.get(ITextModelService);
    const original = await getOriginalResource(quickDiffService, modified.uri, modified.getLanguageId(), shouldSynchronizeModel(modified));
    if (!original) {
        return null;
    }
    const ranges = [];
    const ref = await modelService.createModelReference(original);
    try {
        if (!workerService.canComputeDirtyDiff(original, modified.uri)) {
            return undefined;
        }
        const changes = await workerService.computeDirtyDiff(original, modified.uri, false);
        if (!isNonEmptyArray(changes)) {
            return undefined;
        }
        for (const change of changes) {
            ranges.push(modified.validateRange(( new Range(
                change.modifiedStartLineNumber,
                1,
                change.modifiedEndLineNumber || change.modifiedStartLineNumber ,
                Number.MAX_SAFE_INTEGER
            ))));
        }
    }
    finally {
        ref.dispose();
    }
    return ranges;
}
export { getModifiedRanges };

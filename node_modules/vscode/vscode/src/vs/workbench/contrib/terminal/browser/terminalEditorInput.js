import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import Severity from 'monaco-editor/esm/vs/base/common/severity.js';
import { toDisposable, dispose } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { IThemeService } from 'monaco-editor/esm/vs/platform/theme/common/themeService.js';
import { ThemeIcon } from 'monaco-editor/esm/vs/base/common/themables.js';
import { EditorInput } from '../../../common/editor/editorInput.js';
import { terminalEditorId, ITerminalInstanceService } from './terminal.js';
import { getColorClass, getUriClasses } from './terminalIcon.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { TerminalLocation, TerminalExitReason } from '../../../../platform/terminal/common/terminal.js';
import { ILifecycleService } from '../../../services/lifecycle/common/lifecycle.js';
import { IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { IConfigurationService } from 'monaco-editor/esm/vs/platform/configuration/common/configuration.js';
import { TerminalContextKeys } from '../common/terminalContextKey.js';
import '../../../../../../../override/vs/platform/dialogs/common/dialogs.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { IDialogService } from '../../../../platform/dialogs/common/dialogs.js';
var TerminalEditorInput_1;
let TerminalEditorInput = class TerminalEditorInput extends EditorInput {
    static { TerminalEditorInput_1 = this; }
    static { this.ID = 'workbench.editors.terminal'; }
    setGroup(group) {
        this._group = group;
    }
    get group() {
        return this._group;
    }
    get typeId() {
        return TerminalEditorInput_1.ID;
    }
    get editorId() {
        return terminalEditorId;
    }
    get capabilities() {
        return 2  | 8  | 128 ;
    }
    setTerminalInstance(instance) {
        if (this._terminalInstance) {
            throw new Error('cannot set instance that has already been set');
        }
        this._terminalInstance = instance;
        this._setupInstanceListeners();
    }
    copy() {
        const instance = this._terminalInstanceService.createInstance(this._copyLaunchConfig || {}, TerminalLocation.Editor);
        instance.focusWhenReady();
        this._copyLaunchConfig = undefined;
        return this._instantiationService.createInstance(TerminalEditorInput_1, instance.resource, instance);
    }
    setCopyLaunchConfig(launchConfig) {
        this._copyLaunchConfig = launchConfig;
    }
    get terminalInstance() {
        return this._isDetached ? undefined : this._terminalInstance;
    }
    showConfirm() {
        if (this._isReverted) {
            return false;
        }
        const confirmOnKill = this._configurationService.getValue("terminal.integrated.confirmOnKill" );
        if (confirmOnKill === 'editor' || confirmOnKill === 'always') {
            return this._terminalInstance?.hasChildProcesses || false;
        }
        return false;
    }
    async confirm(terminals) {
        const { confirmed } = await this._dialogService.confirm({
            type: Severity.Warning,
            message: ( localizeWithPath(
                'vs/workbench/contrib/terminal/browser/terminalEditorInput',
                'confirmDirtyTerminal.message',
                "Do you want to terminate running processes?"
            )),
            primaryButton: ( localizeWithPath(
                'vs/workbench/contrib/terminal/browser/terminalEditorInput',
                { key: 'confirmDirtyTerminal.button', comment: ['&& denotes a mnemonic'] },
                "&&Terminate"
            )),
            detail: terminals.length > 1 ?
                ( terminals.map(terminal => terminal.editor.getName())).join('\n') + '\n\n' + ( localizeWithPath(
                    'vs/workbench/contrib/terminal/browser/terminalEditorInput',
                    'confirmDirtyTerminals.detail',
                    "Closing will terminate the running processes in the terminals."
                )) :
                ( localizeWithPath(
                    'vs/workbench/contrib/terminal/browser/terminalEditorInput',
                    'confirmDirtyTerminal.detail',
                    "Closing will terminate the running processes in this terminal."
                ))
        });
        return confirmed ? 1  : 2 ;
    }
    async revert() {
        this._isReverted = true;
    }
    constructor(resource, _terminalInstance, _themeService, _terminalInstanceService, _instantiationService, _configurationService, _lifecycleService, _contextKeyService, _dialogService) {
        super();
        this.resource = resource;
        this._terminalInstance = _terminalInstance;
        this._themeService = _themeService;
        this._terminalInstanceService = _terminalInstanceService;
        this._instantiationService = _instantiationService;
        this._configurationService = _configurationService;
        this._lifecycleService = _lifecycleService;
        this._dialogService = _dialogService;
        this.closeHandler = this;
        this._isDetached = false;
        this._isShuttingDown = false;
        this._isReverted = false;
        this._onDidRequestAttach = this._register(( new Emitter()));
        this.onDidRequestAttach = this._onDidRequestAttach.event;
        this._terminalEditorFocusContextKey = TerminalContextKeys.editorFocus.bindTo(_contextKeyService);
        if (_terminalInstance) {
            this._setupInstanceListeners();
        }
    }
    _setupInstanceListeners() {
        const instance = this._terminalInstance;
        if (!instance) {
            return;
        }
        const instanceOnDidFocusListener = instance.onDidFocus(() => this._terminalEditorFocusContextKey.set(true));
        const instanceOnDidBlurListener = instance.onDidBlur(() => this._terminalEditorFocusContextKey.reset());
        this._register(toDisposable(() => {
            if (!this._isDetached && !this._isShuttingDown) {
                instance.dispose(TerminalExitReason.User);
            }
            dispose([instanceOnDidFocusListener, instanceOnDidBlurListener]);
        }));
        const disposeListeners = [
            instance.onExit((e) => {
                if (!instance.waitOnExit) {
                    this.dispose();
                }
            }),
            instance.onDisposed(() => this.dispose()),
            instance.onTitleChanged(() => this._onDidChangeLabel.fire()),
            instance.onIconChanged(() => this._onDidChangeLabel.fire()),
            instanceOnDidFocusListener,
            instanceOnDidBlurListener,
            instance.statusList.onDidChangePrimaryStatus(() => this._onDidChangeLabel.fire())
        ];
        this._lifecycleService.onWillShutdown((e) => {
            this._isShuttingDown = true;
            dispose(disposeListeners);
            const shouldPersistTerminals = this._configurationService.getValue("terminal.integrated.enablePersistentSessions" ) && e.reason === 3 ;
            if (shouldPersistTerminals) {
                instance.detachProcessAndDispose(TerminalExitReason.Shutdown);
            }
            else {
                instance.dispose(TerminalExitReason.Shutdown);
            }
        });
    }
    getName() {
        return this._terminalInstance?.title || this.resource.fragment;
    }
    getLabelExtraClasses() {
        if (!this._terminalInstance) {
            return [];
        }
        const extraClasses = ['terminal-tab'];
        const colorClass = getColorClass(this._terminalInstance);
        if (colorClass) {
            extraClasses.push(colorClass);
        }
        const uriClasses = getUriClasses(this._terminalInstance, this._themeService.getColorTheme().type);
        if (uriClasses) {
            extraClasses.push(...uriClasses);
        }
        if (ThemeIcon.isThemeIcon(this._terminalInstance.icon)) {
            extraClasses.push(`codicon-${this._terminalInstance.icon.id}`);
        }
        return extraClasses;
    }
    detachInstance() {
        if (!this._isShuttingDown) {
            this._terminalInstance?.detachFromElement();
            this._isDetached = true;
        }
    }
    getDescription() {
        return this._terminalInstance?.description;
    }
    toUntyped() {
        return {
            resource: this.resource,
            options: {
                override: terminalEditorId,
                pinned: true,
                forceReload: true
            }
        };
    }
};
TerminalEditorInput = TerminalEditorInput_1 = ( __decorate([
    ( __param(2, IThemeService)),
    ( __param(3, ITerminalInstanceService)),
    ( __param(4, IInstantiationService)),
    ( __param(5, IConfigurationService)),
    ( __param(6, ILifecycleService)),
    ( __param(7, IContextKeyService)),
    ( __param(8, IDialogService))
], TerminalEditorInput));
export { TerminalEditorInput };

import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { CommandsRegistry } from 'monaco-editor/esm/vs/platform/commands/common/commands.js';
import { ContextKeyExpr } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { KeybindingsRegistry } from 'monaco-editor/esm/vs/platform/keybinding/common/keybindingsRegistry.js';
import { KeyChord } from 'monaco-editor/esm/vs/base/common/keyCodes.js';
import { isNotificationViewItem } from '../../../common/notifications.js';
import { MenuRegistry, MenuId } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IListService, WorkbenchList } from 'monaco-editor/esm/vs/platform/list/browser/listService.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { notificationToMetrics } from './notificationsTelemetry.js';
import { NotificationsCenterVisibleContext, NotificationFocusedContext, NotificationsToastsVisibleContext } from '../../../common/contextkeys.js';
import { INotificationService, NotificationPriority } from 'monaco-editor/esm/vs/platform/notification/common/notification.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ActionRunner } from 'monaco-editor/esm/vs/base/common/actions.js';
import { hash } from 'monaco-editor/esm/vs/base/common/hash.js';
import { firstOrDefault } from 'monaco-editor/esm/vs/base/common/arrays.js';
const SHOW_NOTIFICATIONS_CENTER = 'notifications.showList';
const HIDE_NOTIFICATIONS_CENTER = 'notifications.hideList';
const TOGGLE_NOTIFICATIONS_CENTER = 'notifications.toggleList';
const HIDE_NOTIFICATION_TOAST = 'notifications.hideToasts';
const FOCUS_NOTIFICATION_TOAST = 'notifications.focusToasts';
const FOCUS_NEXT_NOTIFICATION_TOAST = 'notifications.focusNextToast';
const FOCUS_PREVIOUS_NOTIFICATION_TOAST = 'notifications.focusPreviousToast';
const FOCUS_FIRST_NOTIFICATION_TOAST = 'notifications.focusFirstToast';
const FOCUS_LAST_NOTIFICATION_TOAST = 'notifications.focusLastToast';
const COLLAPSE_NOTIFICATION = 'notification.collapse';
const EXPAND_NOTIFICATION = 'notification.expand';
const ACCEPT_PRIMARY_ACTION_NOTIFICATION = 'notification.acceptPrimaryAction';
const TOGGLE_NOTIFICATION = 'notification.toggle';
const CLEAR_NOTIFICATION = 'notification.clear';
const CLEAR_ALL_NOTIFICATIONS = 'notifications.clearAll';
const TOGGLE_DO_NOT_DISTURB_MODE = 'notifications.toggleDoNotDisturbMode';
function getNotificationFromContext(listService, context) {
    if (isNotificationViewItem(context)) {
        return context;
    }
    const list = listService.lastFocusedList;
    if (list instanceof WorkbenchList) {
        let element = list.getFocusedElements()[0];
        if (!isNotificationViewItem(element)) {
            if (list.isDOMFocused()) {
                element = list.element(0);
            }
        }
        if (isNotificationViewItem(element)) {
            return element;
        }
    }
    return undefined;
}
function registerNotificationCommands(center, toasts, model) {
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: SHOW_NOTIFICATIONS_CENTER,
        weight: 200 ,
        primary: KeyChord(2048  | 41 , 2048  | 1024  | 44 ),
        handler: () => {
            toasts.hide();
            center.show();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: HIDE_NOTIFICATIONS_CENTER,
        weight: 200  + 50,
        when: NotificationsCenterVisibleContext,
        primary: 9 ,
        handler: accessor => {
            const telemetryService = accessor.get(ITelemetryService);
            for (const notification of model.notifications) {
                if (notification.visible) {
                    telemetryService.publicLog2('notification:hide', notificationToMetrics(notification.message.original, notification.sourceId, notification.priority === NotificationPriority.SILENT));
                }
            }
            center.hide();
        }
    });
    CommandsRegistry.registerCommand(TOGGLE_NOTIFICATIONS_CENTER, () => {
        if (center.isVisible) {
            center.hide();
        }
        else {
            toasts.hide();
            center.show();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: CLEAR_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 20 ,
        mac: {
            primary: 2048  | 1
        },
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            if (notification && !notification.hasProgress) {
                notification.close();
            }
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: EXPAND_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 17 ,
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            notification?.expand();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: ACCEPT_PRIMARY_ACTION_NOTIFICATION,
        weight: 200 ,
        when: ( ContextKeyExpr.and(NotificationsToastsVisibleContext)),
        primary: 2048  | 1024  | 31 ,
        handler: (accessor) => {
            const actionRunner = accessor.get(IInstantiationService).createInstance(NotificationActionRunner);
            const notification = firstOrDefault(model.notifications);
            if (!notification) {
                return;
            }
            const primaryAction = notification.actions?.primary ? firstOrDefault(notification.actions.primary) : undefined;
            if (!primaryAction) {
                return;
            }
            actionRunner.run(primaryAction, notification);
            notification.close();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: COLLAPSE_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 15 ,
        handler: (accessor, args) => {
            const notification = getNotificationFromContext(accessor.get(IListService), args);
            notification?.collapse();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: TOGGLE_NOTIFICATION,
        weight: 200 ,
        when: NotificationFocusedContext,
        primary: 10 ,
        secondary: [3 ],
        handler: accessor => {
            const notification = getNotificationFromContext(accessor.get(IListService));
            notification?.toggle();
        }
    });
    CommandsRegistry.registerCommand(HIDE_NOTIFICATION_TOAST, accessor => {
        const telemetryService = accessor.get(ITelemetryService);
        for (const notification of model.notifications) {
            if (notification.visible) {
                telemetryService.publicLog2('notification:hide', notificationToMetrics(notification.message.original, notification.sourceId, notification.priority === NotificationPriority.SILENT));
            }
        }
        toasts.hide();
    });
    KeybindingsRegistry.registerKeybindingRule({
        id: HIDE_NOTIFICATION_TOAST,
        weight: 200  - 50,
        when: NotificationsToastsVisibleContext,
        primary: 9
    });
    KeybindingsRegistry.registerKeybindingRule({
        id: HIDE_NOTIFICATION_TOAST,
        weight: 200  + 100,
        when: ( ContextKeyExpr.and(NotificationsToastsVisibleContext, NotificationFocusedContext)),
        primary: 9
    });
    CommandsRegistry.registerCommand(FOCUS_NOTIFICATION_TOAST, () => toasts.focus());
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_NEXT_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext)),
        primary: 18 ,
        handler: () => {
            toasts.focusNext();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_PREVIOUS_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext)),
        primary: 16 ,
        handler: () => {
            toasts.focusPrevious();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_FIRST_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext)),
        primary: 11 ,
        secondary: [14 ],
        handler: () => {
            toasts.focusFirst();
        }
    });
    KeybindingsRegistry.registerCommandAndKeybindingRule({
        id: FOCUS_LAST_NOTIFICATION_TOAST,
        weight: 200 ,
        when: ( ContextKeyExpr.and(NotificationFocusedContext, NotificationsToastsVisibleContext)),
        primary: 12 ,
        secondary: [13 ],
        handler: () => {
            toasts.focusLast();
        }
    });
    CommandsRegistry.registerCommand(CLEAR_ALL_NOTIFICATIONS, () => center.clearAll());
    CommandsRegistry.registerCommand(TOGGLE_DO_NOT_DISTURB_MODE, accessor => {
        const notificationService = accessor.get(INotificationService);
        notificationService.doNotDisturbMode = !notificationService.doNotDisturbMode;
    });
    const category = { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'notifications',
        "Notifications"
    )), original: 'Notifications' };
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: SHOW_NOTIFICATIONS_CENTER, title: { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'showNotifications',
        "Show Notifications"
    )), original: 'Show Notifications' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: HIDE_NOTIFICATIONS_CENTER, title: { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'hideNotifications',
        "Hide Notifications"
    )), original: 'Hide Notifications' }, category }, when: NotificationsCenterVisibleContext });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: CLEAR_ALL_NOTIFICATIONS, title: { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'clearAllNotifications',
        "Clear All Notifications"
    )), original: 'Clear All Notifications' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: ACCEPT_PRIMARY_ACTION_NOTIFICATION, title: { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'acceptNotificationPrimaryAction',
        "Accept Notification Primary Action"
    )), original: 'Accept Notification Primary Action' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: TOGGLE_DO_NOT_DISTURB_MODE, title: { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'toggleDoNotDisturbMode',
        "Toggle Do Not Disturb Mode"
    )), original: 'Toggle Do Not Disturb Mode' }, category } });
    MenuRegistry.appendMenuItem(MenuId.CommandPalette, { command: { id: FOCUS_NOTIFICATION_TOAST, title: { value: ( localizeWithPath(
        'vs/workbench/browser/parts/notifications/notificationsCommands',
        'focusNotificationToasts',
        "Focus Notification Toast"
    )), original: 'Focus Notification Toast' }, category }, when: NotificationsToastsVisibleContext });
}
let NotificationActionRunner = class NotificationActionRunner extends ActionRunner {
    constructor(telemetryService, notificationService) {
        super();
        this.telemetryService = telemetryService;
        this.notificationService = notificationService;
    }
    async runAction(action, context) {
        this.telemetryService.publicLog2('workbenchActionExecuted', { id: action.id, from: 'message' });
        if (isNotificationViewItem(context)) {
            this.telemetryService.publicLog2('notification:actionExecuted', {
                id: ( hash(( context.message.original.toString())).toString()),
                actionLabel: action.label,
                source: context.sourceId || 'core',
                silent: context.priority === NotificationPriority.SILENT
            });
        }
        try {
            await super.runAction(action, context);
        }
        catch (error) {
            this.notificationService.error(error);
        }
    }
};
NotificationActionRunner = ( __decorate([
    ( __param(0, ITelemetryService)),
    ( __param(1, INotificationService))
], NotificationActionRunner));
export { ACCEPT_PRIMARY_ACTION_NOTIFICATION, CLEAR_ALL_NOTIFICATIONS, CLEAR_NOTIFICATION, COLLAPSE_NOTIFICATION, EXPAND_NOTIFICATION, HIDE_NOTIFICATIONS_CENTER, HIDE_NOTIFICATION_TOAST, NotificationActionRunner, SHOW_NOTIFICATIONS_CENTER, TOGGLE_DO_NOT_DISTURB_MODE, getNotificationFromContext, registerNotificationCommands };

import { __decorate, __param } from '../../../../../../../external/tslib/tslib.es6.js';
import { Delayer } from 'monaco-editor/esm/vs/base/common/async.js';
import * as dom from 'monaco-editor/esm/vs/base/browser/dom.js';
import { IContextViewService } from 'monaco-editor/esm/vs/platform/contextview/browser/contextView.js';
import { toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { asCssVariable, badgeBackground, badgeForeground, contrastBorder } from 'monaco-editor/esm/vs/platform/theme/common/colorRegistry.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { IInstantiationService } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { ContextScopedHistoryInputBox } from 'monaco-editor/esm/vs/platform/history/browser/contextScopedHistoryWidget.js';
import { RawContextKey, IContextKeyService } from 'monaco-editor/esm/vs/platform/contextkey/common/contextkey.js';
import { Codicon } from 'monaco-editor/esm/vs/base/common/codicons.js';
import { IKeybindingService } from 'monaco-editor/esm/vs/platform/keybinding/common/keybinding.js';
import { showHistoryKeybindingHint } from 'monaco-editor/esm/vs/platform/history/browser/historyWidgetKeybindingHint.js';
import { MenuRegistry, MenuId, SubmenuItemAction } from 'monaco-editor/esm/vs/platform/actions/common/actions.js';
import { MenuWorkbenchToolBar } from 'monaco-editor/esm/vs/platform/actions/browser/toolbar.js';
import { SubmenuEntryActionViewItem } from 'monaco-editor/esm/vs/platform/actions/browser/menuEntryActionViewItem.js';
import { Widget } from 'monaco-editor/esm/vs/base/browser/ui/widget.js';
import { Emitter } from 'monaco-editor/esm/vs/base/common/event.js';
import { defaultInputBoxStyles } from 'monaco-editor/esm/vs/platform/theme/browser/defaultStyles.js';
const viewFilterMenu = ( new MenuId('menu.view.filter'));
const viewFilterSubmenu = ( new MenuId('submenu.view.filter'));
MenuRegistry.appendMenuItem(viewFilterMenu, {
    submenu: viewFilterSubmenu,
    title: ( localizeWithPath(
        'vs/workbench/browser/parts/views/viewFilter',
        'more filters',
        "More Filters..."
    )),
    group: 'navigation',
    icon: Codicon.filter,
});
class MoreFiltersActionViewItem extends SubmenuEntryActionViewItem {
    constructor() {
        super(...arguments);
        this._checked = false;
    }
    set checked(checked) {
        if (this._checked !== checked) {
            this._checked = checked;
            this.updateChecked();
        }
    }
    updateChecked() {
        if (this.element) {
            this.element.classList.toggle('checked', this._checked);
        }
    }
    render(container) {
        super.render(container);
        this.updateChecked();
    }
}
let FilterWidget = class FilterWidget extends Widget {
    get onDidFocus() { return this.focusTracker.onDidFocus; }
    get onDidBlur() { return this.focusTracker.onDidBlur; }
    constructor(options, instantiationService, contextViewService, contextKeyService, keybindingService) {
        super();
        this.options = options;
        this.instantiationService = instantiationService;
        this.contextViewService = contextViewService;
        this.keybindingService = keybindingService;
        this._onDidChangeFilterText = this._register(( new Emitter()));
        this.onDidChangeFilterText = this._onDidChangeFilterText.event;
        this.isMoreFiltersChecked = false;
        this.delayedFilterUpdate = ( new Delayer(400));
        this._register(toDisposable(() => this.delayedFilterUpdate.cancel()));
        if (options.focusContextKey) {
            this.focusContextKey = ( new RawContextKey(options.focusContextKey, false)).bindTo(contextKeyService);
        }
        this.element = dom.$('.viewpane-filter');
        [this.filterInputBox, this.focusTracker] = this.createInput(this.element);
        this._register(this.filterInputBox);
        this._register(this.focusTracker);
        const controlsContainer = dom.append(this.element, dom.$('.viewpane-filter-controls'));
        this.filterBadge = this.createBadge(controlsContainer);
        this.toolbar = this._register(this.createToolBar(controlsContainer));
        this.adjustInputBox();
    }
    hasFocus() {
        return this.filterInputBox.hasFocus();
    }
    focus() {
        this.filterInputBox.focus();
    }
    blur() {
        this.filterInputBox.blur();
    }
    updateBadge(message) {
        this.filterBadge.classList.toggle('hidden', !message);
        this.filterBadge.textContent = message || '';
        this.adjustInputBox();
    }
    setFilterText(filterText) {
        this.filterInputBox.value = filterText;
    }
    getFilterText() {
        return this.filterInputBox.value;
    }
    getHistory() {
        return this.filterInputBox.getHistory();
    }
    layout(width) {
        this.element.parentElement?.classList.toggle('grow', width > 700);
        this.element.classList.toggle('small', width < 400);
        this.adjustInputBox();
    }
    checkMoreFilters(checked) {
        this.isMoreFiltersChecked = checked;
        if (this.moreFiltersActionViewItem) {
            this.moreFiltersActionViewItem.checked = checked;
        }
    }
    createInput(container) {
        const inputBox = this._register(this.instantiationService.createInstance(ContextScopedHistoryInputBox, container, this.contextViewService, {
            placeholder: this.options.placeholder,
            ariaLabel: this.options.ariaLabel,
            history: this.options.history || [],
            showHistoryHint: () => showHistoryKeybindingHint(this.keybindingService),
            inputBoxStyles: defaultInputBoxStyles
        }));
        if (this.options.text) {
            inputBox.value = this.options.text;
        }
        this._register(inputBox.onDidChange(filter => this.delayedFilterUpdate.trigger(() => this.onDidInputChange(inputBox))));
        this._register(dom.addStandardDisposableListener(inputBox.inputElement, dom.EventType.KEY_DOWN, (e) => this.onInputKeyDown(e, inputBox)));
        this._register(dom.addStandardDisposableListener(container, dom.EventType.KEY_DOWN, this.handleKeyboardEvent));
        this._register(dom.addStandardDisposableListener(container, dom.EventType.KEY_UP, this.handleKeyboardEvent));
        this._register(dom.addStandardDisposableListener(inputBox.inputElement, dom.EventType.CLICK, (e) => {
            e.stopPropagation();
            e.preventDefault();
        }));
        const focusTracker = this._register(dom.trackFocus(inputBox.inputElement));
        if (this.focusContextKey) {
            this._register(focusTracker.onDidFocus(() => this.focusContextKey.set(true)));
            this._register(focusTracker.onDidBlur(() => this.focusContextKey.set(false)));
            this._register(toDisposable(() => this.focusContextKey.reset()));
        }
        return [inputBox, focusTracker];
    }
    createBadge(container) {
        const filterBadge = dom.append(container, dom.$('.viewpane-filter-badge.hidden'));
        filterBadge.style.backgroundColor = asCssVariable(badgeBackground);
        filterBadge.style.color = asCssVariable(badgeForeground);
        filterBadge.style.border = `1px solid ${asCssVariable(contrastBorder)}`;
        return filterBadge;
    }
    createToolBar(container) {
        return this.instantiationService.createInstance(MenuWorkbenchToolBar, container, viewFilterMenu, {
            hiddenItemStrategy: -1 ,
            actionViewItemProvider: (action) => {
                if (action instanceof SubmenuItemAction && action.item.submenu.id === viewFilterSubmenu.id) {
                    this.moreFiltersActionViewItem = this.instantiationService.createInstance(MoreFiltersActionViewItem, action, undefined);
                    this.moreFiltersActionViewItem.checked = this.isMoreFiltersChecked;
                    return this.moreFiltersActionViewItem;
                }
                return undefined;
            }
        });
    }
    onDidInputChange(inputbox) {
        inputbox.addToHistory();
        this._onDidChangeFilterText.fire(inputbox.value);
    }
    adjustInputBox() {
        this.filterInputBox.inputElement.style.paddingRight = this.element.classList.contains('small') || this.filterBadge.classList.contains('hidden') ? '25px' : '150px';
    }
    handleKeyboardEvent(event) {
        if (event.equals(10 )
            || event.equals(15 )
            || event.equals(17 )) {
            event.stopPropagation();
        }
    }
    onInputKeyDown(event, filterInputBox) {
        let handled = false;
        if (event.equals(2 ) && !this.toolbar.isEmpty()) {
            this.toolbar.focus();
            handled = true;
        }
        if (handled) {
            event.stopPropagation();
            event.preventDefault();
        }
    }
};
FilterWidget = ( __decorate([
    ( __param(1, IInstantiationService)),
    ( __param(2, IContextViewService)),
    ( __param(3, IContextKeyService)),
    ( __param(4, IKeybindingService))
], FilterWidget));
export { FilterWidget, viewFilterSubmenu };

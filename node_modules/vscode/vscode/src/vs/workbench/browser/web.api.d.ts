import { UriComponents, URI } from '../../base/common/uri.js';
import { IWebSocketFactory } from '../../platform/remote/browser/browserSocketFactory.js';
import { IURLCallbackProvider } from '../services/url/browser/urlService.js';
import { LogLevel } from '../../platform/log/common/log.js';
import { IUpdateProvider } from '../services/update/browser/updateService.js';
import { Event } from '../../base/common/event.js';
import { IWorkspaceProvider } from '../services/host/browser/browserHostService.js';
import { IProductConfiguration } from '../../base/common/product.js';
import { ISecretStorageProvider } from '../../platform/secrets/common/secrets.js';
import { TunnelProviderFeatures } from '../../platform/tunnel/common/tunnel.js';
import { ITextEditorOptions } from '../../platform/editor/common/editor.js';
import { EditorGroupLayout } from '../services/editor/common/editorGroupsService.js';

interface IWorkbenchConstructionOptions {
    /**
     * The remote authority is the IP:PORT from where the workbench is served
     * from. It is for example being used for the websocket connections as address.
     */
    readonly remoteAuthority?: string;
    /**
     * The connection token to send to the server.
     */
    readonly connectionToken?: string | Promise<string>;
    /**
     * An endpoint to serve iframe content ("webview") from. This is required
     * to provide full security isolation from the workbench host.
     */
    readonly webviewEndpoint?: string;
    /**
     * A factory for web sockets.
     */
    readonly webSocketFactory?: IWebSocketFactory;
    /**
     * A provider for resource URIs.
     *
     * *Note*: This will only be invoked after the `connectionToken` is resolved.
     */
    readonly resourceUriProvider?: IResourceUriProvider;
    /**
     * Resolves an external uri before it is opened.
     */
    readonly resolveExternalUri?: IExternalUriResolver;
    /**
     * A provider for supplying tunneling functionality,
     * such as creating tunnels and showing candidate ports to forward.
     */
    readonly tunnelProvider?: ITunnelProvider;
    /**
     * Endpoints to be used for proxying authentication code exchange calls in the browser.
     */
    readonly codeExchangeProxyEndpoints?: {
        [providerId: string]: string;
    };
    /**
     * The identifier of an edit session associated with the current workspace.
     */
    readonly editSessionId?: string;
    /**
     * Resource delegation handler that allows for loading of resources when
     * using remote resolvers.
     *
     * This is exclusive with {@link resourceUriProvider}. `resourceUriProvider`
     * should be used if a {@link webSocketFactory} is used, and will be preferred.
     */
    readonly remoteResourceProvider?: IRemoteResourceProvider;
    /**
     * A handler for opening workspaces and providing the initial workspace.
     */
    readonly workspaceProvider?: IWorkspaceProvider;
    /**
     * Settings sync options
     */
    readonly settingsSyncOptions?: ISettingsSyncOptions;
    /**
     * The secret storage provider to store and retrieve secrets.
     */
    readonly secretStorageProvider?: ISecretStorageProvider;
    /**
     * Additional builtin extensions those cannot be uninstalled but only be disabled.
     * It can be one of the following:
     * 	- an extension in the Marketplace
     * 	- location of the extension where it is hosted.
     */
    readonly additionalBuiltinExtensions?: readonly (MarketplaceExtension | UriComponents)[];
    /**
     * List of extensions to be enabled if they are installed.
     * Note: This will not install extensions if not installed.
     */
    readonly enabledExtensions?: readonly ExtensionId[];
    /**
     * Additional domains allowed to open from the workbench without the
     * link protection popup.
     */
    readonly additionalTrustedDomains?: string[];
    /**
     * Enable workspace trust feature for the current window
     */
    readonly enableWorkspaceTrust?: boolean;
    /**
     * Urls that will be opened externally that are allowed access
     * to the opener window. This is primarily used to allow
     * `window.close()` to be called from the newly opened window.
     */
    readonly openerAllowedExternalUrlPrefixes?: string[];
    /**
     * Support for URL callbacks.
     */
    readonly urlCallbackProvider?: IURLCallbackProvider;
    /**
     * Support adding additional properties to telemetry.
     */
    readonly resolveCommonTelemetryProperties?: ICommonTelemetryPropertiesResolver;
    /**
     * A set of optional commands that should be registered with the commands
     * registry.
     *
     * Note: commands can be called from extensions if the identifier is known!
     */
    readonly commands?: readonly ICommand[];
    /**
     * Optional default layout to apply on first time the workspace is opened
     * (unless `force` is specified). This includes visibility of views and
     * editors including editor grid layout.
     */
    readonly defaultLayout?: IDefaultLayout;
    /**
     * Optional configuration default overrides contributed to the workbench.
     */
    readonly configurationDefaults?: Record<string, any>;
    /**
     * Profile to use for the workbench.
     */
    readonly profile?: {
        readonly name: string;
        readonly contents?: string | UriComponents;
    };
    /**
     * URI of the profile to preview.
     */
    readonly profileToPreview?: UriComponents;
    /**
     * Support for update reporting
     */
    readonly updateProvider?: IUpdateProvider;
    /**
     * Support for product quality switching
     */
    readonly productQualityChangeHandler?: IProductQualityChangeHandler;
    /**
     * Optional home indicator to appear above the hamburger menu in the activity bar.
     */
    readonly homeIndicator?: IHomeIndicator;
    /**
     * Optional welcome banner to appear above the workbench. Can be dismissed by the
     * user.
     */
    readonly welcomeBanner?: IWelcomeBanner;
    /**
     * Optional override for the product configuration properties.
     */
    readonly productConfiguration?: Partial<IProductConfiguration>;
    /**
     * Optional override for properties of the window indicator in the status bar.
     */
    readonly windowIndicator?: IWindowIndicator;
    /**
     * Specifies the default theme type (LIGHT, DARK..) and allows to provide initial colors that are shown
     * until the color theme that is specified in the settings (`editor.colorTheme`) is loaded and applied.
     * Once there are persisted colors from a last run these will be used.
     *
     * The idea is that the colors match the main colors from the theme defined in the `configurationDefaults`.
     */
    readonly initialColorTheme?: IInitialColorTheme;
    /**
     *  Welcome dialog. Can be dismissed by the user.
     */
    readonly welcomeDialog?: IWelcomeDialog;
    readonly messagePorts?: ReadonlyMap<ExtensionId, MessagePort>;
    readonly developmentOptions?: IDevelopmentOptions;
}
interface IResourceUriProvider {
    (uri: URI): URI;
}
/**
 * The identifier of an extension in the format: `PUBLISHER.NAME`. For example: `vscode.csharp`
 */
type ExtensionId = string;
type MarketplaceExtension = ExtensionId | {
    readonly id: ExtensionId;
    preRelease?: boolean;
    migrateStorageFrom?: ExtensionId;
};
interface ICommonTelemetryPropertiesResolver {
    (): {
        [key: string]: any;
    };
}
interface IExternalUriResolver {
    (uri: URI): Promise<URI>;
}
interface ITunnelProvider {
    /**
     * Support for creating tunnels.
     */
    tunnelFactory?: ITunnelFactory;
    /**
     * Support for filtering candidate ports.
     */
    showPortCandidate?: IShowPortCandidate;
    /**
     * The features that the tunnel provider supports.
     */
    features?: TunnelProviderFeatures;
}
interface ITunnelFactory {
    (tunnelOptions: ITunnelOptions, tunnelCreationOptions: TunnelCreationOptions): Promise<ITunnel> | undefined;
}
interface ITunnelOptions {
    remoteAddress: {
        port: number;
        host: string;
    };
    /**
     * The desired local port. If this port can't be used, then another will be chosen.
     */
    localAddressPort?: number;
    label?: string;
    privacy?: string;
    protocol?: string;
}
interface TunnelCreationOptions {
    /**
     * True when the local operating system will require elevation to use the requested local port.
     */
    elevationRequired?: boolean;
}
interface ITunnel {
    remoteAddress: {
        port: number;
        host: string;
    };
    /**
     * The complete local address(ex. localhost:1234)
     */
    localAddress: string;
    privacy?: string;
    /**
     * If protocol is not provided, it is assumed to be http, regardless of the localAddress
     */
    protocol?: string;
    /**
     * Implementers of Tunnel should fire onDidDispose when dispose is called.
     */
    onDidDispose: Event<void>;
    dispose(): Promise<void> | void;
}
interface IShowPortCandidate {
    (host: string, port: number, detail: string): Promise<boolean>;
}
declare enum Menu {
    CommandPalette = 0,
    StatusBarWindowIndicatorMenu = 1
}
interface ICommand {
    /**
     * An identifier for the command. Commands can be executed from extensions
     * using the `vscode.commands.executeCommand` API using that command ID.
     */
    id: string;
    /**
     * The optional label of the command. If provided, the command will appear
     * in the command palette.
     */
    label?: string;
    /**
     * The optional menus to append this command to. Only valid if `label` is
     * provided as well.
     * @default Menu.CommandPalette
     */
    menu?: Menu | Menu[];
    /**
     * A function that is being executed with any arguments passed over. The
     * return type will be send back to the caller.
     *
     * Note: arguments and return type should be serializable so that they can
     * be exchanged across processes boundaries.
     */
    handler: (...args: any[]) => unknown;
}
interface IHomeIndicator {
    /**
     * The link to open when clicking the home indicator.
     */
    href: string;
    /**
     * The icon name for the home indicator. This needs to be one of the existing
     * icons from our Codicon icon set. For example `code`.
     */
    icon: string;
    /**
     * A tooltip that will appear while hovering over the home indicator.
     */
    title: string;
}
interface IWelcomeBanner {
    /**
     * Welcome banner message to appear as text.
     */
    message: string;
    /**
     * Optional icon for the banner. This is either the URL to an icon to use
     * or the name of one of the existing icons from our Codicon icon set.
     *
     * If not provided a default icon will be used.
     */
    icon?: string | UriComponents;
    /**
     * Optional actions to appear as links after the welcome banner message.
     */
    actions?: IWelcomeLinkAction[];
}
interface IWelcomeLinkAction {
    /**
     * The link to open when clicking. Supports command invocation when
     * using the `command:<commandId>` value.
     */
    href: string;
    /**
     * The label to show for the action link.
     */
    label: string;
    /**
     * A tooltip that will appear while hovering over the action link.
     */
    title?: string;
}
interface IWindowIndicator {
    /**
     * Triggering this event will cause the window indicator to update.
     */
    readonly onDidChange?: Event<void>;
    /**
     * Label of the window indicator may include octicons
     * e.g. `$(remote) label`
     */
    label: string;
    /**
     * Tooltip of the window indicator should not include
     * octicons and be descriptive.
     */
    tooltip: string;
    /**
     * If provided, overrides the default command that
     * is executed when clicking on the window indicator.
     */
    command?: string;
}
declare enum ColorScheme {
    DARK = "dark",
    LIGHT = "light",
    HIGH_CONTRAST_LIGHT = "hcLight",
    HIGH_CONTRAST_DARK = "hcDark"
}
interface IInitialColorTheme {
    /**
     * Initial color theme type.
     */
    readonly themeType: ColorScheme;
    /**
     * A list of workbench colors to apply initially.
     */
    readonly colors?: {
        [colorId: string]: string;
    };
}
interface IWelcomeDialog {
    /**
     * Unique identifier of the welcome dialog. The identifier will be used to determine
     * if the dialog has been previously displayed.
     */
    id: string;
    /**
     * Title of the welcome dialog.
     */
    title: string;
    /**
     * Button text of the welcome dialog.
     */
    buttonText: string;
    /**
     * Button command to execute from the welcome dialog.
     */
    buttonCommand: string;
    /**
     * Message text for the welcome dialog.
     */
    message: string;
    /**
     * Media to include in the welcome dialog.
     */
    media: {
        altText: string;
        path: string;
    };
}
interface IDefaultView {
    /**
     * The identifier of the view to show by default.
     */
    readonly id: string;
}
interface IDefaultEditor {
    /**
     * The location of the editor in the editor grid layout.
     * Editors are layed out in editor groups and the view
     * column is counted from top left to bottom right in
     * the order of appearance beginning with `1`.
     *
     * If not provided, the editor will open in the active
     * group.
     */
    readonly viewColumn?: number;
    /**
     * The resource of the editor to open.
     */
    readonly uri: UriComponents;
    /**
     * Optional extra options like which editor
     * to use or which text to select.
     */
    readonly options?: ITextEditorOptions;
    /**
     * Will not open an untitled editor in case
     * the resource does not exist.
     */
    readonly openOnlyIfExists?: boolean;
}
interface IDefaultLayout {
    /**
     * A list of views to show by default.
     */
    readonly views?: IDefaultView[];
    /**
     * A list of editors to show by default.
     */
    readonly editors?: IDefaultEditor[];
    /**
     * The layout to use for the workbench.
     */
    readonly layout?: {
        /**
         * The layout of the editor area.
         */
        readonly editors?: EditorGroupLayout;
    };
    /**
     * Forces this layout to be applied even if this isn't
     * the first time the workspace has been opened
     */
    readonly force?: boolean;
}
interface IProductQualityChangeHandler {
    /**
     * Handler is being called when the user wants to switch between
     * `insider` or `stable` product qualities.
     */
    (newQuality: 'insider' | 'stable'): void;
}
/**
 * Settings sync options
 */
interface ISettingsSyncOptions {
    /**
     * Is settings sync enabled
     */
    readonly enabled: boolean;
    /**
     * Version of extensions sync state.
     * Extensions sync state will be reset if version is provided and different from previous version.
     */
    readonly extensionsSyncStateVersion?: string;
    /**
     * Handler is being called when the user changes Settings Sync enablement.
     */
    enablementHandler?(enablement: boolean, authenticationProvider: string): void;
    /**
     * Authentication provider
     */
    readonly authenticationProvider?: {
        /**
         * Unique identifier of the authentication provider.
         */
        readonly id: string;
        /**
         * Called when the user wants to signin to Settings Sync using the given authentication provider.
         * The returned promise should resolve to the authentication session id.
         */
        signIn(): Promise<string>;
    };
}
interface IDevelopmentOptions {
    /**
     * Current logging level. Default is `LogLevel.Info`.
     */
    readonly logLevel?: LogLevel;
    /**
     * Extension log level.
     */
    readonly extensionLogLevel?: [string, LogLevel][];
    /**
     * Location of a module containing extension tests to run once the workbench is open.
     */
    readonly extensionTestsPath?: UriComponents;
    /**
     * Add extensions under development.
     */
    readonly extensions?: readonly UriComponents[];
    /**
     * Whether to enable the smoke test driver.
     */
    readonly enableSmokeTestDriver?: boolean;
}
/**
 * Utility provided in the {@link WorkbenchOptions} which allows loading resources
 * when remote resolvers are used in the web.
 */
interface IRemoteResourceProvider {
    /**
     * Path the workbench should delegate requests to. The embedder should
     * install a service worker on this path and emit {@link onDidReceiveRequest}
     * events when requests come in for that path.
     */
    readonly path: string;
    /**
     * Event that should fire when requests are made on the {@link pathPrefix}.
     */
    readonly onDidReceiveRequest: Event<IRemoteResourceRequest>;
}
/**
 * todo@connor4312: this may eventually gain more properties like method and
 * headers, but for now we only deal with GET requests.
 */
interface IRemoteResourceRequest {
    /**
     * Request URI. Generally will begin with the current
     * origin and {@link IRemoteResourceProvider.pathPrefix}.
     */
    uri: URI;
    /**
     * A method called by the editor to issue a response to the request.
     */
    respondWith(statusCode: number, body: Uint8Array, headers: Record<string, string>): void;
}

export { ColorScheme, type ExtensionId, type ICommand, type ICommonTelemetryPropertiesResolver, type IDefaultEditor, type IDefaultLayout, type IDefaultView, type IDevelopmentOptions, type IExternalUriResolver, type IHomeIndicator, type IInitialColorTheme, type IProductQualityChangeHandler, type IRemoteResourceProvider, type IRemoteResourceRequest, type IResourceUriProvider, type ISettingsSyncOptions, type IShowPortCandidate, type ITunnel, type ITunnelFactory, type ITunnelOptions, type ITunnelProvider, type IWelcomeBanner, type IWelcomeDialog, type IWelcomeLinkAction, type IWindowIndicator, type IWorkbenchConstructionOptions, type MarketplaceExtension, Menu, type TunnelCreationOptions };

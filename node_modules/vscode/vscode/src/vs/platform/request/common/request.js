import { getErrorMessage } from 'monaco-editor/esm/vs/base/common/errors.js';
import { Disposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { localizeWithPath } from 'monaco-editor/esm/vs/nls.js';
import { createDecorator } from 'monaco-editor/esm/vs/platform/instantiation/common/instantiation.js';
import { CONTEXT_LOG_LEVEL, LogLevelToString, LogLevel } from 'monaco-editor/esm/vs/platform/log/common/log.js';
const IRequestService = ( createDecorator('requestService'));
class LoggableHeaders {
    constructor(original) {
        this.original = original;
    }
    toJSON() {
        if (!this.headers) {
            const headers = Object.create(null);
            for (const key in this.original) {
                if (key.toLowerCase() === 'authorization' || key.toLowerCase() === 'proxy-authorization') {
                    headers[key] = '*****';
                }
                else {
                    headers[key] = this.original[key];
                }
            }
            this.headers = headers;
        }
        return this.headers;
    }
}
class AbstractRequestService extends Disposable {
    constructor(loggerService) {
        super();
        this.counter = 0;
        this.logger = loggerService.createLogger('network', {
            name: ( localizeWithPath('vs/platform/request/common/request', 'request', "Network Requests")),
            when: ( CONTEXT_LOG_LEVEL.isEqualTo(LogLevelToString(LogLevel.Trace))).serialize()
        });
    }
    async logAndRequest(stack, options, request) {
        const prefix = `${stack} #${++this.counter}: ${options.url}`;
        this.logger.trace(`${prefix} - begin`, options.type, ( new LoggableHeaders(options.headers ?? {})));
        try {
            const result = await request();
            this.logger.trace(`${prefix} - end`, options.type, result.res.statusCode, result.res.headers);
            return result;
        }
        catch (error) {
            this.logger.error(`${prefix} - error`, options.type, getErrorMessage(error));
            throw error;
        }
    }
}
export { AbstractRequestService, IRequestService };

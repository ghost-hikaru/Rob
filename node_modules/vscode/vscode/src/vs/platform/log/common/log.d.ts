import { ServiceIdentifier } from '../../instantiation/common/instantiation.js';
import { Event } from '../../../base/common/event.js';
import { IDisposable } from '../../../base/common/lifecycle.js';
import { URI } from '../../../base/common/uri.js';

declare enum LogLevel {
    Off = 0,
    Trace = 1,
    Debug = 2,
    Info = 3,
    Warning = 4,
    Error = 5
}
interface ILogger extends IDisposable {
    onDidChangeLogLevel: Event<LogLevel>;
    getLevel(): LogLevel;
    setLevel(level: LogLevel): void;
    trace(message: string, ...args: any[]): void;
    debug(message: string, ...args: any[]): void;
    info(message: string, ...args: any[]): void;
    warn(message: string, ...args: any[]): void;
    error(message: string | Error, ...args: any[]): void;
    /**
     * An operation to flush the contents. Can be synchronous.
     */
    flush(): void;
}

declare const ILogService: ServiceIdentifier<ILogService>;
interface ILogService extends ILogger {
    readonly _serviceBrand: undefined;
}
interface ILoggerOptions {
    /**
     * Id of the logger.
     */
    id?: string;
    /**
     * Name of the logger.
     */
    name?: string;
    /**
     * Do not create rotating files if max size exceeds.
     */
    donotRotate?: boolean;
    /**
     * Do not use formatters.
     */
    donotUseFormatters?: boolean;
    /**
     * When to log. Set to `always` to log always.
     */
    logLevel?: 'always' | LogLevel;
    /**
     * Whether the log should be hidden from the user.
     */
    hidden?: boolean;
    /**
     * Condition which must be true to show this logger
     */
    when?: string;
    /**
     * Id of the extension that created this logger.
     */
    extensionId?: string;
}
interface ILoggerResource {
    readonly resource: URI;
    readonly id: string;
    readonly name?: string;
    readonly logLevel?: LogLevel;
    readonly hidden?: boolean;
    readonly when?: string;
    readonly extensionId?: string;
}
type DidChangeLoggersEvent = {
    readonly added: Iterable<ILoggerResource>;
    readonly removed: Iterable<ILoggerResource>;
};
declare const ILoggerService: ServiceIdentifier<ILoggerService>;
interface ILoggerService {
    readonly _serviceBrand: undefined;
    /**
     * Creates a logger for the given resource, or gets one if it already exists.
     *
     * This will also register the logger with the logger service.
     */
    createLogger(resource: URI, options?: ILoggerOptions): ILogger;
    /**
     * Creates a logger with the given id in the logs folder, or gets one if it already exists.
     *
     * This will also register the logger with the logger service.
     */
    createLogger(id: string, options?: Omit<ILoggerOptions, 'id'>): ILogger;
    /**
     * Gets an existing logger, if any.
     */
    getLogger(resourceOrId: URI | string): ILogger | undefined;
    /**
     * An event which fires when the log level of a logger has changed
     */
    readonly onDidChangeLogLevel: Event<LogLevel | [URI, LogLevel]>;
    /**
     * Set default log level.
     */
    setLogLevel(level: LogLevel): void;
    /**
     * Set log level for a logger.
     */
    setLogLevel(resource: URI, level: LogLevel): void;
    /**
     * Get log level for a logger or the default log level.
     */
    getLogLevel(resource?: URI): LogLevel;
    /**
     * An event which fires when the visibility of a logger has changed
     */
    readonly onDidChangeVisibility: Event<[URI, boolean]>;
    /**
     * Set the visibility of a logger.
     */
    setVisibility(resourceOrId: URI | string, visible: boolean): void;
    /**
     * An event which fires when the logger resources are changed
     */
    readonly onDidChangeLoggers: Event<DidChangeLoggersEvent>;
    /**
     * Register a logger with the logger service.
     *
     * Note that this will not create a logger, but only register it.
     *
     * Use `createLogger` to create a logger and register it.
     *
     * Use it when you want to register a logger that is not created by the logger service.
     */
    registerLogger(resource: ILoggerResource): void;
    /**
     * Deregister the logger for the given resource.
     */
    deregisterLogger(resource: URI): void;
    /**
     * Get all registered loggers
     */
    getRegisteredLoggers(): Iterable<ILoggerResource>;
    /**
     * Get the registered logger for the given resource.
     */
    getRegisteredLogger(resource: URI): ILoggerResource | undefined;
}

export { type DidChangeLoggersEvent, ILogService, type ILogger, type ILoggerOptions, type ILoggerResource, ILoggerService, LogLevel };

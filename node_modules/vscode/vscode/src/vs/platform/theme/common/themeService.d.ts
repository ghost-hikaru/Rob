import { ServiceIdentifier } from '../../instantiation/common/instantiation.js';
import { Color } from '../../../base/common/color.js';
import { Event } from '../../../base/common/event.js';
import { Disposable } from '../../../base/common/lifecycle.js';
import { ColorIdentifier } from './colorRegistry.js';
import { IconContribution, IconDefinition } from './iconRegistry.js';
import { ColorScheme } from './theme.js';

interface ITokenStyle {
    readonly foreground: number | undefined;
    readonly bold: boolean | undefined;
    readonly underline: boolean | undefined;
    readonly strikethrough: boolean | undefined;
    readonly italic: boolean | undefined;
}
interface IColorTheme {
    readonly type: ColorScheme;
    readonly label: string;
    /**
     * Resolves the color of the given color identifier. If the theme does not
     * specify the color, the default color is returned unless <code>useDefault</code> is set to false.
     * @param color the id of the color
     * @param useDefault specifies if the default color should be used. If not set, the default is used.
     */
    getColor(color: ColorIdentifier, useDefault?: boolean): Color | undefined;
    /**
     * Returns whether the theme defines a value for the color. If not, that means the
     * default color will be used.
     */
    defines(color: ColorIdentifier): boolean;
    /**
     * Returns the token style for a given classification. The result uses the <code>MetadataConsts</code> format
     */
    getTokenStyleMetadata(type: string, modifiers: string[], modelLanguage: string): ITokenStyle | undefined;
    /**
     * List of all colors used with tokens. <code>getTokenStyleMetadata</code> references the colors by index into this list.
     */
    readonly tokenColorMap: string[];
    /**
     * Defines whether semantic highlighting should be enabled for the theme.
     */
    readonly semanticHighlighting: boolean;
}
interface IFileIconTheme {
    readonly hasFileIcons: boolean;
    readonly hasFolderIcons: boolean;
    readonly hidesExplorerArrows: boolean;
}
interface IProductIconTheme {
    /**
     * Resolves the definition for the given icon as defined by the theme.
     *
     * @param iconContribution The icon
     */
    getIcon(iconContribution: IconContribution): IconDefinition | undefined;
}

declare const IThemeService: ServiceIdentifier<IThemeService>;
interface IThemeService {
    readonly _serviceBrand: undefined;
    getColorTheme(): IColorTheme;
    readonly onDidColorThemeChange: Event<IColorTheme>;
    getFileIconTheme(): IFileIconTheme;
    readonly onDidFileIconThemeChange: Event<IFileIconTheme>;
    getProductIconTheme(): IProductIconTheme;
    readonly onDidProductIconThemeChange: Event<IProductIconTheme>;
}
/**
 * Utility base class for all themable components.
 */
declare class Themable extends Disposable {
    protected themeService: IThemeService;
    protected theme: IColorTheme;
    constructor(themeService: IThemeService);
    protected onThemeChange(theme: IColorTheme): void;
    updateStyles(): void;
    protected getColor(id: string, modify?: (color: Color, theme: IColorTheme) => Color): string | null;
}

export { type IColorTheme, type IFileIconTheme, type IProductIconTheme, IThemeService, type ITokenStyle, Themable };

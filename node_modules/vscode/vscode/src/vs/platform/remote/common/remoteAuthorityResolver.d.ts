import { ServiceIdentifier } from '../../instantiation/common/instantiation.js';
import { Event } from '../../../base/common/event.js';
import { URI } from '../../../base/common/uri.js';

declare const enum RemoteConnectionType {
    WebSocket = 0,
    Managed = 1
}
declare class ManagedRemoteConnection {
    readonly id: number;
    readonly type = RemoteConnectionType.Managed;
    constructor(id: number);
    toString(): string;
}
declare class WebSocketRemoteConnection {
    readonly host: string;
    readonly port: number;
    readonly type = RemoteConnectionType.WebSocket;
    constructor(host: string, port: number);
    toString(): string;
}
type RemoteConnection = WebSocketRemoteConnection | ManagedRemoteConnection;
type RemoteConnectionOfType<T extends RemoteConnectionType> = RemoteConnection & {
    type: T;
};
interface ResolvedAuthority {
    readonly authority: string;
    readonly connectTo: RemoteConnection;
    readonly connectionToken: string | undefined;
}
interface ResolvedOptions {
    readonly extensionHostEnv?: {
        [key: string]: string | null;
    };
    readonly isTrusted?: boolean;
    readonly authenticationSession?: {
        id: string;
        providerId: string;
    };
}
interface TunnelDescription {
    remoteAddress: {
        port: number;
        host: string;
    };
    localAddress: {
        port: number;
        host: string;
    } | string;
    privacy?: string;
    protocol?: string;
}
interface TunnelPrivacy {
    themeIcon: string;
    id: string;
    label: string;
}
interface TunnelInformation {
    environmentTunnels?: TunnelDescription[];
    features?: {
        elevation: boolean;
        public?: boolean;
        privacyOptions: TunnelPrivacy[];
    };
}
interface ResolverResult {
    authority: ResolvedAuthority;
    options?: ResolvedOptions;
    tunnelInformation?: TunnelInformation;
}
interface IRemoteConnectionData {
    connectTo: RemoteConnection;
    connectionToken: string | undefined;
}
declare enum RemoteAuthorityResolverErrorCode {
    Unknown = "Unknown",
    NotAvailable = "NotAvailable",
    TemporarilyNotAvailable = "TemporarilyNotAvailable",
    NoResolverFound = "NoResolverFound",
    InvalidAuthority = "InvalidAuthority"
}

declare const IRemoteAuthorityResolverService: ServiceIdentifier<IRemoteAuthorityResolverService>;
interface IRemoteAuthorityResolverService {
    readonly _serviceBrand: undefined;
    readonly onDidChangeConnectionData: Event<void>;
    resolveAuthority(authority: string): Promise<ResolverResult>;
    getConnectionData(authority: string): IRemoteConnectionData | null;
    /**
     * Get the canonical URI for a `vscode-remote://` URI.
     *
     * **NOTE**: This can throw e.g. in cases where there is no resolver installed for the specific remote authority.
     *
     * @param uri The `vscode-remote://` URI
     */
    getCanonicalURI(uri: URI): Promise<URI>;
    _clearResolvedAuthority(authority: string): void;
    _setResolvedAuthority(resolvedAuthority: ResolvedAuthority, resolvedOptions?: ResolvedOptions): void;
    _setResolvedAuthorityError(authority: string, err: any): void;
    _setAuthorityConnectionToken(authority: string, connectionToken: string): void;
    _setCanonicalURIProvider(provider: (uri: URI) => Promise<URI>): void;
}

export { IRemoteAuthorityResolverService, type IRemoteConnectionData, ManagedRemoteConnection, RemoteAuthorityResolverErrorCode, type RemoteConnection, type RemoteConnectionOfType, RemoteConnectionType, type ResolvedAuthority, type ResolvedOptions, type ResolverResult, type TunnelDescription, type TunnelInformation, type TunnelPrivacy, WebSocketRemoteConnection };

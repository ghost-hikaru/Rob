import { __decorate, __param } from '../external/tslib/tslib.es6.js';
import { StandaloneServices } from 'monaco-editor/esm/vs/editor/standalone/browser/standaloneServices.js';
import { SyncDescriptor } from 'monaco-editor/esm/vs/platform/instantiation/common/descriptors.js';
import { FileService } from '../vscode/src/vs/platform/files/common/fileService.js';
import { ILogService } from 'monaco-editor/esm/vs/platform/log/common/log.js';
import { InMemoryFileSystemProvider } from '../vscode/src/vs/platform/files/common/inMemoryFilesystemProvider.js';
import { URI } from 'monaco-editor/esm/vs/base/common/uri.js';
import { FileType, FilePermission } from '../vscode/src/vs/platform/files/common/files.js';
export { FileChangeType, FileSystemProviderCapabilities } from '../vscode/src/vs/platform/files/common/files.js';
import { createFileSystemProviderError, FileSystemProviderErrorCode, FileSystemProviderError, IFileService } from 'monaco-editor/esm/vs/platform/files/common/files.js';
export { FileSystemProviderError, FileSystemProviderErrorCode } from 'monaco-editor/esm/vs/platform/files/common/files.js';
import { Disposable, DisposableStore, toDisposable } from 'monaco-editor/esm/vs/base/common/lifecycle.js';
import { extUri, joinPath } from 'monaco-editor/esm/vs/base/common/resources.js';
import { Emitter, Event } from 'monaco-editor/esm/vs/base/common/event.js';
export { HTMLFileSystemProvider } from 'monaco-editor/esm/vs/platform/files/browser/htmlFileSystemProvider.js';
import * as path from 'monaco-editor/esm/vs/base/common/path.js';
import '../vscode/src/vs/workbench/contrib/files/browser/files.contribution.js';
import { Schemas } from 'monaco-editor/esm/vs/base/common/network.js';
import { IndexedDBFileSystemProvider } from '../vscode/src/vs/platform/files/browser/indexedDBFileSystemProvider.js';
import { IndexedDB } from 'monaco-editor/esm/vs/base/browser/indexedDB.js';
export { IndexedDB } from 'monaco-editor/esm/vs/base/browser/indexedDB.js';
import { ITelemetryService } from 'monaco-editor/esm/vs/platform/telemetry/common/telemetry.js';
import { logsPath } from '../workbench.js';
class RegisteredFile {
    constructor(uri, readonly) {
        this.uri = uri;
        this.readonly = readonly;
        this._onDidChange = new Emitter();
        this.onDidChange = this._onDidChange.event;
        this._onDidDelete = new Emitter();
        this.onDidDelete = this._onDidDelete.event;
        this._onDidRename = new Emitter();
        this.onDidRename = this._onDidRename.event;
        this.ctime = Date.now();
        this.mtime = Date.now();
        this.type = FileType.File;
    }
    async stats() {
        return {
            ctime: this.ctime,
            mtime: this.mtime,
            size: await this.getSize(),
            type: FileType.File,
            permissions: this.readonly ? FilePermission.Readonly : undefined
        };
    }
    async getSize() {
        return (await this.read()).length;
    }
    async delete() {
        this._onDidDelete.fire();
    }
    async rename(to) {
        const previousUri = this.uri;
        this.uri = to;
        this._onDidRename.fire({ from: previousUri, to });
    }
}
class RegisteredReadOnlyFile extends RegisteredFile {
    constructor(uri, read) {
        super(uri, true);
        this.read = read;
    }
    write() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async delete() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
    async rename() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.FileWriteLocked);
    }
}
class RegisteredMemoryFile extends RegisteredFile {
    constructor(uri, content) {
        super(uri, false);
        this.content = content;
    }
    async read() {
        return this.content;
    }
    async write(content) {
        this.content = content;
        this._onDidChange.fire();
    }
}
const encoder = new TextEncoder();
const decoder = new TextDecoder();
class RegisteredFileSystemProvider extends Disposable {
    constructor(readonly) {
        super();
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this.files = new Map();
        this.capabilities = 2  | 1024 ;
        if (readonly) {
            this.capabilities |= 2048 ;
        }
    }
    registerFile(file) {
        this.files.set(( file.uri.toString()), file);
        this._onDidChangeFile.fire([{
                resource: file.uri,
                type: 1
            }]);
        const disposableStore = new DisposableStore();
        disposableStore.add(toDisposable(() => {
            if (this.files.get(( file.uri.toString())) === file) {
                this.files.delete(( file.uri.toString()));
                this._onDidChangeFile.fire([{
                        resource: file.uri,
                        type: 2
                    }]);
            }
        }));
        disposableStore.add(file.onDidDelete(() => {
            disposableStore.dispose();
        }));
        disposableStore.add(file.onDidChange(() => {
            this._onDidChangeFile.fire([{
                    resource: file.uri,
                    type: 0
                }]);
        }));
        disposableStore.add(file.onDidRename(({ from, to }) => {
            if (this.files.get(( from.toString())) === file) {
                this.files.delete(( from.toString()));
                this._onDidChangeFile.fire([{
                        resource: from,
                        type: 2
                    }]);
                this.files.set(( to.toString()), file);
                this._onDidChangeFile.fire([{
                        resource: to,
                        type: 1
                    }]);
            }
        }));
        return disposableStore;
    }
    async stat(resource) {
        const resourceUri = ( resource.toString());
        const file = this.files.get(resourceUri);
        if (file != null) {
            return file.stats();
        }
        const handledUris = Array.from(( this.files.keys()));
        for (const handledUri of handledUris) {
            if (handledUri.startsWith(resourceUri + '/')) {
                return {
                    ctime: Date.now(),
                    mtime: Date.now(),
                    size: 0,
                    type: FileType.Directory
                };
            }
        }
        throw createFileSystemProviderError('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async readdir(resource) {
        const includedPaths = ( Array.from(( this.files.keys()))
            .map(uri => path.relative(resource.path, ( URI.parse(uri)).path)))
            .filter(path => !path.startsWith('..'));
        const files = includedPaths.filter(path => !path.includes('/'));
        const directories = ( includedPaths.filter(path => path.includes('/')).map(path => path.slice(0, path.indexOf('/'))));
        return [
            ...( files.map(path => [
                path,
                FileType.File
            ])),
            ...( directories.map(path => [
                path,
                FileType.Directory
            ]))
        ];
    }
    async readFile(resource) {
        const file = this.files.get(( resource.toString()));
        if (file != null) {
            const data = await file.read();
            if (data instanceof Uint8Array) {
                return data;
            }
            else {
                return encoder.encode(data);
            }
        }
        throw FileSystemProviderError.create('file not found', FileSystemProviderErrorCode.FileNotFound);
    }
    watch() {
        return Disposable.None;
    }
    async writeFile(resource, content) {
        const file = this.files.get(( resource.toString()));
        if (file?.write != null) {
            await file.write(decoder.decode(content));
            return;
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async delete(resource) {
        const file = this.files.get(( resource.toString()));
        if (file != null) {
            await file.delete();
            return;
        }
        throw createFileSystemProviderError('File not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async rename(from, to) {
        const file = this.files.get(( from.toString()));
        if (file != null) {
            await file.rename(to);
            return;
        }
        throw createFileSystemProviderError('File not found', FileSystemProviderErrorCode.FileNotFound);
    }
    async mkdir() {
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
}
function isFullfiled(result) {
    return result.status === 'fulfilled';
}
class OverlayFileSystemProvider {
    constructor() {
        this.providers = [];
        this.onDidChangeCapabilities = Event.None;
        this._onDidChangeFile = new Emitter();
        this.onDidChangeFile = this._onDidChangeFile.event;
        this._onDidChangeOverlays = new Emitter();
        this.onDidChangeOverlays = this._onDidChangeOverlays.event;
        this.capabilities = 2  | 1024 ;
    }
    register(priority, provider) {
        const item = { priority, provider };
        this.providers.push(item);
        this.providers.sort((a, b) => b.priority - a.priority);
        const disposableStore = new DisposableStore();
        disposableStore.add(provider.onDidChangeFile(e => {
            this._onDidChangeFile.fire(e);
        }));
        disposableStore.add({
            dispose: () => {
                const index = this.providers.indexOf(item);
                if (index >= 0) {
                    this.providers.splice(index, 1);
                    this._onDidChangeOverlays.fire();
                }
            }
        });
        this._onDidChangeOverlays.fire();
        return disposableStore;
    }
    get delegates() {
        return ( this.providers.map(({ provider }) => provider));
    }
    async readFromDelegates(caller) {
        let firstError;
        for (const delegate of this.delegates) {
            try {
                return await caller(delegate);
            }
            catch (err) {
                firstError ?? (firstError = err);
                if (err instanceof FileSystemProviderError && [
                    FileSystemProviderErrorCode.NoPermissions,
                    FileSystemProviderErrorCode.FileNotFound,
                    FileSystemProviderErrorCode.Unavailable
                ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw firstError;
    }
    async writeToDelegates(resource, caller) {
        for (const provider of this.delegates) {
            if (((provider.capabilities & 2048) ) > 0) {
                continue;
            }
            try {
                return await caller(provider);
            }
            catch (err) {
                if (err instanceof FileSystemProviderError && [
                    FileSystemProviderErrorCode.NoPermissions,
                    FileSystemProviderErrorCode.FileNotFound,
                    FileSystemProviderErrorCode.Unavailable
                ].includes(err.code)) {
                    continue;
                }
                throw err;
            }
        }
        throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
    }
    async stat(resource) {
        return this.readFromDelegates(async (delegate) => {
            const result = await delegate.stat(resource);
            const readOnly = ((delegate.capabilities & 2048) ) > 0;
            return {
                ...result,
                permissions: result.permissions ?? (readOnly ? FilePermission.Readonly : undefined)
            };
        });
    }
    async readFile(resource) {
        return this.readFromDelegates(delegate => delegate.readFile(resource));
    }
    async readdir(resource) {
        const results = await Promise.allSettled(( this.delegates.map(delegate => delegate.readdir(resource))));
        if (!( results.some(isFullfiled))) {
            throw results[0].reason;
        }
        return Object.entries(Object.fromEntries(( results.filter(isFullfiled).map(result => result.value)).flat()));
    }
    watch(resource, opts) {
        const store = new DisposableStore();
        for (const delegate of this.delegates) {
            store.add(delegate.watch(resource, opts));
        }
        return store;
    }
    async writeFile(resource, content, opts) {
        await this.writeToDelegates(resource, async (delegate) => {
            try {
                const stats = await delegate.stat(resource);
                if (((stats.permissions ?? 0) & FilePermission.Readonly) > 0) {
                    throw createFileSystemProviderError('Not allowed', FileSystemProviderErrorCode.NoPermissions);
                }
            }
            catch (err) {
            }
            return delegate.writeFile(resource, content, opts);
        });
    }
    async mkdir(resource) {
        await this.writeToDelegates(resource, delegate => delegate.mkdir(resource));
    }
    async delete(resource, opts) {
        await this.writeToDelegates(resource, delegate => delegate.delete(resource, opts));
    }
    async rename(from, to, opts) {
        await this.writeToDelegates(from, delegate => delegate.rename(from, to, opts));
    }
}
class MkdirpOnWriteInMemoryFileSystemProvider extends InMemoryFileSystemProvider {
    async writeFile(resource, content, opts) {
        await StandaloneServices.get(IFileService)['mkdirp'](this, extUri.dirname(resource));
        return super.writeFile(resource, content, opts);
    }
}
class DelegateFileSystemProvider {
    constructor(options) {
        this.options = options;
        this.onDidChangeCapabilities = this.options.delegate.onDidChangeCapabilities;
        this.onDidChangeFile = ( Event.map(this.options.delegate.onDidChangeFile, changes => ( changes.map(change => ({
            type: change.type,
            resource: this.options.fromDeletate(change.resource)
        })))));
        this.readFile = this.options.delegate.readFile != null
            ? (resource) => {
                return this.options.delegate.readFile(this.options.toDelegate(resource));
            }
            : undefined;
        this.writeFile = this.options.delegate.writeFile != null
            ? (resource, content, opts) => {
                return this.options.delegate.writeFile(this.options.toDelegate(resource), content, opts);
            }
            : undefined;
    }
    get capabilities() { return this.options.delegate.capabilities; }
    watch(resource, opts) {
        return this.options.delegate.watch(this.options.toDelegate(resource), opts);
    }
    stat(resource) {
        return this.options.delegate.stat(this.options.toDelegate(resource));
    }
    mkdir(resource) {
        return this.options.delegate.mkdir(this.options.toDelegate(resource));
    }
    readdir(resource) {
        return this.options.delegate.readdir(this.options.toDelegate(resource));
    }
    delete(resource, opts) {
        return this.options.delegate.delete(this.options.toDelegate(resource), opts);
    }
    rename(from, to, opts) {
        return this.options.delegate.rename(this.options.toDelegate(from), this.options.toDelegate(to), opts);
    }
}
const fileSystemProvider = new OverlayFileSystemProvider();
fileSystemProvider.register(0, new MkdirpOnWriteInMemoryFileSystemProvider());
const extensionFileSystemProvider = new RegisteredFileSystemProvider(true);
const userDataFileSystemProvider = new InMemoryFileSystemProvider();
void userDataFileSystemProvider.mkdir(( URI.from({ scheme: Schemas.vscodeUserData, path: '/User/' })));
const providers = {
    extension: extensionFileSystemProvider,
    [logsPath.scheme]: new InMemoryFileSystemProvider(),
    [Schemas.vscodeUserData]: userDataFileSystemProvider,
    [Schemas.tmp]: new InMemoryFileSystemProvider(),
    file: fileSystemProvider
};
let MemoryFileService = class MemoryFileService extends FileService {
    constructor(logService, telemetryService) {
        super(logService);
        for (const [scheme, provider] of Object.entries(providers)) {
            let disposable = this.registerProvider(scheme, provider);
            if (provider instanceof OverlayFileSystemProvider) {
                provider.onDidChangeOverlays(() => {
                    disposable.dispose();
                    disposable = this.registerProvider(scheme, fileSystemProvider);
                });
            }
            if (provider instanceof IndexedDBFileSystemProvider) {
                this._register(provider.onReportError(e => telemetryService.publicLog2('indexedDBFileSystemProviderError', e)));
            }
        }
    }
};
MemoryFileService = __decorate([
    ( __param(0, ILogService)),
    ( __param(1, ITelemetryService))
], MemoryFileService);
function getServiceOverride() {
    return {
        [( IFileService.toString())]: new SyncDescriptor(MemoryFileService, [], true)
    };
}
function registerCustomProvider(scheme, provider) {
    providers[scheme] = provider;
}
function registerExtensionFile(extensionLocation, filePath, getContent) {
    return extensionFileSystemProvider.registerFile(new RegisteredReadOnlyFile(joinPath(extensionLocation, filePath), getContent));
}
async function initFile(scheme, file, content, options) {
    const provider = providers[scheme];
    if (provider == null || provider.writeFile == null) {
        throw new Error(`${scheme} provider doesn't exist or doesn't support writing files`);
    }
    if (!(options?.overwrite ?? false)) {
        try {
            await provider.stat(file);
            return;
        }
        catch (error) {
        }
    }
    await provider.writeFile(file, content instanceof Uint8Array ? content : encoder.encode(content), {
        atomic: false,
        create: true,
        overwrite: false,
        unlock: false,
        ...options
    });
}
async function createIndexedDBProviders() {
    const userDataStore = 'vscode-userdata-store';
    const logsStore = 'vscode-logs-store';
    const indexedDB = await IndexedDB.create('vscode-web-db', 3, [userDataStore, logsStore]);
    providers[logsPath.scheme] = new IndexedDBFileSystemProvider(logsPath.scheme, indexedDB, logsStore, false);
    const userDataProvider = new IndexedDBFileSystemProvider(Schemas.vscodeUserData, indexedDB, userDataStore, true);
    providers[Schemas.vscodeUserData] = userDataProvider;
    return userDataProvider;
}
function registerFileSystemOverlay(priority, provider) {
    return fileSystemProvider.register(priority, provider);
}
export { DelegateFileSystemProvider, FilePermission, FileType, InMemoryFileSystemProvider, IndexedDBFileSystemProvider, RegisteredFile, RegisteredFileSystemProvider, RegisteredMemoryFile, RegisteredReadOnlyFile, createIndexedDBProviders, getServiceOverride as default, initFile, registerCustomProvider, registerExtensionFile, registerFileSystemOverlay };

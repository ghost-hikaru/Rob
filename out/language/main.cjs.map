{
  "version": 3,
  "sources": ["../../node_modules/vscode-languageserver/lib/common/utils/is.js", "../../node_modules/vscode-jsonrpc/lib/common/is.js", "../../node_modules/vscode-jsonrpc/lib/common/messages.js", "../../node_modules/vscode-jsonrpc/lib/common/linkedMap.js", "../../node_modules/vscode-jsonrpc/lib/common/disposable.js", "../../node_modules/vscode-jsonrpc/lib/common/ral.js", "../../node_modules/vscode-jsonrpc/lib/common/events.js", "../../node_modules/vscode-jsonrpc/lib/common/cancellation.js", "../../node_modules/vscode-jsonrpc/lib/common/sharedArrayCancellation.js", "../../node_modules/vscode-jsonrpc/lib/common/semaphore.js", "../../node_modules/vscode-jsonrpc/lib/common/messageReader.js", "../../node_modules/vscode-jsonrpc/lib/common/messageWriter.js", "../../node_modules/vscode-jsonrpc/lib/common/messageBuffer.js", "../../node_modules/vscode-jsonrpc/lib/common/connection.js", "../../node_modules/vscode-jsonrpc/lib/common/api.js", "../../node_modules/vscode-jsonrpc/lib/node/ril.js", "../../node_modules/vscode-jsonrpc/lib/node/main.js", "../../node_modules/vscode-jsonrpc/node.js", "../../node_modules/vscode-languageserver-types/lib/umd/main.js", "../../node_modules/vscode-languageserver-protocol/lib/common/messages.js", "../../node_modules/vscode-languageserver-protocol/lib/common/utils/is.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineCompletion.js", "../../node_modules/vscode-languageserver-protocol/lib/common/protocol.js", "../../node_modules/vscode-languageserver-protocol/lib/common/connection.js", "../../node_modules/vscode-languageserver-protocol/lib/common/api.js", "../../node_modules/vscode-languageserver-protocol/lib/node/main.js", "../../node_modules/vscode-languageserver/lib/common/utils/uuid.js", "../../node_modules/vscode-languageserver/lib/common/progress.js", "../../node_modules/vscode-languageserver/lib/common/configuration.js", "../../node_modules/vscode-languageserver/lib/common/workspaceFolder.js", "../../node_modules/vscode-languageserver/lib/common/callHierarchy.js", "../../node_modules/vscode-languageserver/lib/common/semanticTokens.js", "../../node_modules/vscode-languageserver/lib/common/showDocument.js", "../../node_modules/vscode-languageserver/lib/common/fileOperations.js", "../../node_modules/vscode-languageserver/lib/common/linkedEditingRange.js", "../../node_modules/vscode-languageserver/lib/common/typeHierarchy.js", "../../node_modules/vscode-languageserver/lib/common/inlineValue.js", "../../node_modules/vscode-languageserver/lib/common/foldingRange.js", "../../node_modules/vscode-languageserver/lib/common/inlayHint.js", "../../node_modules/vscode-languageserver/lib/common/diagnostic.js", "../../node_modules/vscode-languageserver/lib/common/textDocuments.js", "../../node_modules/vscode-languageserver/lib/common/notebook.js", "../../node_modules/vscode-languageserver/lib/common/moniker.js", "../../node_modules/vscode-languageserver/lib/common/server.js", "../../node_modules/vscode-languageserver/lib/node/files.js", "../../node_modules/vscode-languageserver-protocol/node.js", "../../node_modules/vscode-languageserver/lib/common/inlineCompletion.proposed.js", "../../node_modules/vscode-languageserver/lib/common/api.js", "../../node_modules/vscode-languageserver/lib/node/main.js", "../../node_modules/vscode-languageserver/node.js", "../../node_modules/langium/src/default-module.ts", "../../node_modules/vscode-languageserver-textdocument/lib/esm/main.js", "../../node_modules/langium/src/syntax-tree.ts", "../../node_modules/langium/src/utils/stream.ts", "../../node_modules/langium/src/utils/cst-util.ts", "../../node_modules/langium/src/dependency-injection.ts", "../../node_modules/langium/src/utils/collections.ts", "../../node_modules/langium/src/grammar/generated/ast.ts", "../../node_modules/langium/src/utils/ast-util.ts", "../../node_modules/langium/src/generator/generator-tracing.ts", "../../node_modules/langium/src/generator/node-processor.ts", "../../node_modules/langium/src/generator/template-string.ts", "../../node_modules/langium/src/generator/template-node.ts", "../../node_modules/langium/src/generator/generator-node.ts", "../../node_modules/langium/src/grammar/type-system/type-collector/types.ts", "../../node_modules/langium/src/grammar/type-system/types-util.ts", "../../node_modules/langium/src/references/name-provider.ts", "../../node_modules/@chevrotain/regexp-to-ast/src/utils.ts", "../../node_modules/@chevrotain/regexp-to-ast/src/character-classes.ts", "../../node_modules/@chevrotain/regexp-to-ast/src/regexp-parser.ts", "../../node_modules/@chevrotain/regexp-to-ast/src/base-regexp-visitor.ts", "../../node_modules/langium/src/utils/regex-util.ts", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/node_modules/path-browserify/index.js", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/bootstrap", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/runtime/define property getters", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/runtime/hasOwnProperty shorthand", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/webpack/runtime/make namespace object", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/src/platform.ts", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/src/uri.ts", "../../node_modules/vscode-uri/lib/esm/webpack:/LIB/src/utils.ts", "../../node_modules/langium/src/utils/uri-util.ts", "../../node_modules/langium/src/grammar/generated/grammar.ts", "../../node_modules/vscode-languageserver-types/lib/esm/main.js", "../../node_modules/langium/src/utils/promise-util.ts", "../../node_modules/langium/src/validation/validation-registry.ts", "../../node_modules/langium/src/grammar/type-system/type-collector/declared-types.ts", "../../node_modules/langium/src/grammar/type-system/type-collector/plain-types.ts", "../../node_modules/langium/src/grammar/validation/validator.ts", "../../node_modules/langium/src/grammar/internal-grammar-util.ts", "../../node_modules/langium/src/grammar/type-system/type-collector/inferred-types.ts", "../../node_modules/langium/src/grammar/type-system/type-collector/all-types.ts", "../../node_modules/langium/src/grammar/type-system/ast-collector.ts", "../../node_modules/langium/src/grammar/generated/module.ts", "../../node_modules/langium/src/references/scope.ts", "../../node_modules/langium/src/references/scope-computation.ts", "../../node_modules/langium/src/utils/caching.ts", "../../node_modules/langium/src/references/scope-provider.ts", "../../node_modules/langium/src/grammar/references/grammar-scope.ts", "../../node_modules/langium/src/grammar/lsp/grammar-code-actions.ts", "../../node_modules/langium/src/validation/document-validator.ts", "../../node_modules/langium/src/lsp/completion/completion-provider.ts", "../../node_modules/langium/src/lsp/completion/follow-element-computation.ts", "../../node_modules/langium/src/grammar/lsp/grammar-completion-provider.ts", "../../node_modules/langium/src/lsp/folding-range-provider.ts", "../../node_modules/langium/src/grammar/lsp/grammar-folding-ranges.ts", "../../node_modules/langium/src/lsp/formatter.ts", "../../node_modules/langium/src/grammar/lsp/grammar-formatter.ts", "../../node_modules/langium/src/grammar/lsp/grammar-semantic-tokens.ts", "../../node_modules/langium/src/lsp/semantic-token-provider.ts", "../../node_modules/langium/src/grammar/references/grammar-naming.ts", "../../node_modules/langium/src/references/references.ts", "../../node_modules/langium/src/grammar/references/grammar-references.ts", "../../node_modules/langium/src/grammar/lsp/grammar-definition.ts", "../../node_modules/langium/src/lsp/call-hierarchy-provider.ts", "../../node_modules/langium/src/lsp/definition-provider.ts", "../../node_modules/langium/src/lsp/document-highlight-provider.ts", "../../node_modules/langium/src/lsp/document-symbol-provider.ts", "../../node_modules/langium/src/lsp/execute-command-handler.ts", "../../node_modules/langium/src/lsp/fuzzy-matcher.ts", "../../node_modules/langium/src/lsp/hover-provider.ts", "../../node_modules/langium/src/lsp/implementation-provider.ts", "../../node_modules/langium/src/lsp/inlay-hint-provider.ts", "../../node_modules/langium/src/lsp/language-server.ts", "../../node_modules/langium/src/workspace/documents.ts", "../../node_modules/langium/src/lsp/signature-help-provider.ts", "../../node_modules/langium/src/lsp/node-kind-provider.ts", "../../node_modules/langium/src/lsp/references-provider.ts", "../../node_modules/langium/src/lsp/rename-provider.ts", "../../node_modules/langium/src/lsp/type-provider.ts", "../../node_modules/langium/src/lsp/workspace-symbol-provider.ts", "../../node_modules/langium/src/grammar/lsp/grammar-call-hierarchy.ts", "../../node_modules/langium/src/grammar/validation/validation-resources-collector.ts", "../../node_modules/langium/src/grammar/workspace/documents.ts", "../../node_modules/langium/src/grammar/validation/types-validator.ts", "../../node_modules/langium/src/grammar/langium-grammar-module.ts", "../../node_modules/langium/src/workspace/file-system-provider.ts", "../../node_modules/langium/src/utils/grammar-util.ts", "../../node_modules/langium/src/grammar/grammar-config.ts", "../../node_modules/lodash-es/_freeGlobal.js", "../../node_modules/lodash-es/_root.js", "../../node_modules/lodash-es/_Symbol.js", "../../node_modules/lodash-es/_getRawTag.js", "../../node_modules/lodash-es/_objectToString.js", "../../node_modules/lodash-es/_baseGetTag.js", "../../node_modules/lodash-es/isObjectLike.js", "../../node_modules/lodash-es/isSymbol.js", "../../node_modules/lodash-es/_arrayMap.js", "../../node_modules/lodash-es/isArray.js", "../../node_modules/lodash-es/_baseToString.js", "../../node_modules/lodash-es/_trimmedEndIndex.js", "../../node_modules/lodash-es/_baseTrim.js", "../../node_modules/lodash-es/isObject.js", "../../node_modules/lodash-es/toNumber.js", "../../node_modules/lodash-es/toFinite.js", "../../node_modules/lodash-es/toInteger.js", "../../node_modules/lodash-es/identity.js", "../../node_modules/lodash-es/isFunction.js", "../../node_modules/lodash-es/_coreJsData.js", "../../node_modules/lodash-es/_isMasked.js", "../../node_modules/lodash-es/_toSource.js", "../../node_modules/lodash-es/_baseIsNative.js", "../../node_modules/lodash-es/_getValue.js", "../../node_modules/lodash-es/_getNative.js", "../../node_modules/lodash-es/_WeakMap.js", "../../node_modules/lodash-es/_baseCreate.js", "../../node_modules/lodash-es/_apply.js", "../../node_modules/lodash-es/noop.js", "../../node_modules/lodash-es/_copyArray.js", "../../node_modules/lodash-es/_shortOut.js", "../../node_modules/lodash-es/constant.js", "../../node_modules/lodash-es/_defineProperty.js", "../../node_modules/lodash-es/_baseSetToString.js", "../../node_modules/lodash-es/_setToString.js", "../../node_modules/lodash-es/_arrayEach.js", "../../node_modules/lodash-es/_baseFindIndex.js", "../../node_modules/lodash-es/_baseIsNaN.js", "../../node_modules/lodash-es/_strictIndexOf.js", "../../node_modules/lodash-es/_baseIndexOf.js", "../../node_modules/lodash-es/_arrayIncludes.js", "../../node_modules/lodash-es/_isIndex.js", "../../node_modules/lodash-es/_baseAssignValue.js", "../../node_modules/lodash-es/eq.js", "../../node_modules/lodash-es/_assignValue.js", "../../node_modules/lodash-es/_copyObject.js", "../../node_modules/lodash-es/_overRest.js", "../../node_modules/lodash-es/_baseRest.js", "../../node_modules/lodash-es/isLength.js", "../../node_modules/lodash-es/isArrayLike.js", "../../node_modules/lodash-es/_isIterateeCall.js", "../../node_modules/lodash-es/_createAssigner.js", "../../node_modules/lodash-es/_isPrototype.js", "../../node_modules/lodash-es/_baseTimes.js", "../../node_modules/lodash-es/_baseIsArguments.js", "../../node_modules/lodash-es/isArguments.js", "../../node_modules/lodash-es/stubFalse.js", "../../node_modules/lodash-es/isBuffer.js", "../../node_modules/lodash-es/_baseIsTypedArray.js", "../../node_modules/lodash-es/_baseUnary.js", "../../node_modules/lodash-es/_nodeUtil.js", "../../node_modules/lodash-es/isTypedArray.js", "../../node_modules/lodash-es/_arrayLikeKeys.js", "../../node_modules/lodash-es/_overArg.js", "../../node_modules/lodash-es/_nativeKeys.js", "../../node_modules/lodash-es/_baseKeys.js", "../../node_modules/lodash-es/keys.js", "../../node_modules/lodash-es/assign.js", "../../node_modules/lodash-es/_nativeKeysIn.js", "../../node_modules/lodash-es/_baseKeysIn.js", "../../node_modules/lodash-es/keysIn.js", "../../node_modules/lodash-es/_isKey.js", "../../node_modules/lodash-es/_nativeCreate.js", "../../node_modules/lodash-es/_hashClear.js", "../../node_modules/lodash-es/_hashDelete.js", "../../node_modules/lodash-es/_hashGet.js", "../../node_modules/lodash-es/_hashHas.js", "../../node_modules/lodash-es/_hashSet.js", "../../node_modules/lodash-es/_Hash.js", "../../node_modules/lodash-es/_listCacheClear.js", "../../node_modules/lodash-es/_assocIndexOf.js", "../../node_modules/lodash-es/_listCacheDelete.js", "../../node_modules/lodash-es/_listCacheGet.js", "../../node_modules/lodash-es/_listCacheHas.js", "../../node_modules/lodash-es/_listCacheSet.js", "../../node_modules/lodash-es/_ListCache.js", "../../node_modules/lodash-es/_Map.js", "../../node_modules/lodash-es/_mapCacheClear.js", "../../node_modules/lodash-es/_isKeyable.js", "../../node_modules/lodash-es/_getMapData.js", "../../node_modules/lodash-es/_mapCacheDelete.js", "../../node_modules/lodash-es/_mapCacheGet.js", "../../node_modules/lodash-es/_mapCacheHas.js", "../../node_modules/lodash-es/_mapCacheSet.js", "../../node_modules/lodash-es/_MapCache.js", "../../node_modules/lodash-es/memoize.js", "../../node_modules/lodash-es/_memoizeCapped.js", "../../node_modules/lodash-es/_stringToPath.js", "../../node_modules/lodash-es/toString.js", "../../node_modules/lodash-es/_castPath.js", "../../node_modules/lodash-es/_toKey.js", "../../node_modules/lodash-es/_baseGet.js", "../../node_modules/lodash-es/get.js", "../../node_modules/lodash-es/_arrayPush.js", "../../node_modules/lodash-es/_isFlattenable.js", "../../node_modules/lodash-es/_baseFlatten.js", "../../node_modules/lodash-es/flatten.js", "../../node_modules/lodash-es/_getPrototype.js", "../../node_modules/lodash-es/_baseSlice.js", "../../node_modules/lodash-es/_arrayReduce.js", "../../node_modules/lodash-es/_stackClear.js", "../../node_modules/lodash-es/_stackDelete.js", "../../node_modules/lodash-es/_stackGet.js", "../../node_modules/lodash-es/_stackHas.js", "../../node_modules/lodash-es/_stackSet.js", "../../node_modules/lodash-es/_Stack.js", "../../node_modules/lodash-es/_baseAssign.js", "../../node_modules/lodash-es/_baseAssignIn.js", "../../node_modules/lodash-es/_cloneBuffer.js", "../../node_modules/lodash-es/_arrayFilter.js", "../../node_modules/lodash-es/stubArray.js", "../../node_modules/lodash-es/_getSymbols.js", "../../node_modules/lodash-es/_copySymbols.js", "../../node_modules/lodash-es/_getSymbolsIn.js", "../../node_modules/lodash-es/_copySymbolsIn.js", "../../node_modules/lodash-es/_baseGetAllKeys.js", "../../node_modules/lodash-es/_getAllKeys.js", "../../node_modules/lodash-es/_getAllKeysIn.js", "../../node_modules/lodash-es/_DataView.js", "../../node_modules/lodash-es/_Promise.js", "../../node_modules/lodash-es/_Set.js", "../../node_modules/lodash-es/_getTag.js", "../../node_modules/lodash-es/_initCloneArray.js", "../../node_modules/lodash-es/_Uint8Array.js", "../../node_modules/lodash-es/_cloneArrayBuffer.js", "../../node_modules/lodash-es/_cloneDataView.js", "../../node_modules/lodash-es/_cloneRegExp.js", "../../node_modules/lodash-es/_cloneSymbol.js", "../../node_modules/lodash-es/_cloneTypedArray.js", "../../node_modules/lodash-es/_initCloneByTag.js", "../../node_modules/lodash-es/_initCloneObject.js", "../../node_modules/lodash-es/_baseIsMap.js", "../../node_modules/lodash-es/isMap.js", "../../node_modules/lodash-es/_baseIsSet.js", "../../node_modules/lodash-es/isSet.js", "../../node_modules/lodash-es/_baseClone.js", "../../node_modules/lodash-es/clone.js", "../../node_modules/lodash-es/compact.js", "../../node_modules/lodash-es/_setCacheAdd.js", "../../node_modules/lodash-es/_setCacheHas.js", "../../node_modules/lodash-es/_SetCache.js", "../../node_modules/lodash-es/_arraySome.js", "../../node_modules/lodash-es/_cacheHas.js", "../../node_modules/lodash-es/_equalArrays.js", "../../node_modules/lodash-es/_mapToArray.js", "../../node_modules/lodash-es/_setToArray.js", "../../node_modules/lodash-es/_equalByTag.js", "../../node_modules/lodash-es/_equalObjects.js", "../../node_modules/lodash-es/_baseIsEqualDeep.js", "../../node_modules/lodash-es/_baseIsEqual.js", "../../node_modules/lodash-es/_baseIsMatch.js", "../../node_modules/lodash-es/_isStrictComparable.js", "../../node_modules/lodash-es/_getMatchData.js", "../../node_modules/lodash-es/_matchesStrictComparable.js", "../../node_modules/lodash-es/_baseMatches.js", "../../node_modules/lodash-es/_baseHasIn.js", "../../node_modules/lodash-es/_hasPath.js", "../../node_modules/lodash-es/hasIn.js", "../../node_modules/lodash-es/_baseMatchesProperty.js", "../../node_modules/lodash-es/_baseProperty.js", "../../node_modules/lodash-es/_basePropertyDeep.js", "../../node_modules/lodash-es/property.js", "../../node_modules/lodash-es/_baseIteratee.js", "../../node_modules/lodash-es/_arrayAggregator.js", "../../node_modules/lodash-es/_createBaseFor.js", "../../node_modules/lodash-es/_baseFor.js", "../../node_modules/lodash-es/_baseForOwn.js", "../../node_modules/lodash-es/_createBaseEach.js", "../../node_modules/lodash-es/_baseEach.js", "../../node_modules/lodash-es/_baseAggregator.js", "../../node_modules/lodash-es/_createAggregator.js", "../../node_modules/lodash-es/defaults.js", "../../node_modules/lodash-es/isArrayLikeObject.js", "../../node_modules/lodash-es/_arrayIncludesWith.js", "../../node_modules/lodash-es/_baseDifference.js", "../../node_modules/lodash-es/difference.js", "../../node_modules/lodash-es/last.js", "../../node_modules/lodash-es/drop.js", "../../node_modules/lodash-es/dropRight.js", "../../node_modules/lodash-es/_castFunction.js", "../../node_modules/lodash-es/forEach.js", "../../node_modules/lodash-es/_arrayEvery.js", "../../node_modules/lodash-es/_baseEvery.js", "../../node_modules/lodash-es/every.js", "../../node_modules/lodash-es/_baseFilter.js", "../../node_modules/lodash-es/filter.js", "../../node_modules/lodash-es/_createFind.js", "../../node_modules/lodash-es/findIndex.js", "../../node_modules/lodash-es/find.js", "../../node_modules/lodash-es/head.js", "../../node_modules/lodash-es/_baseMap.js", "../../node_modules/lodash-es/map.js", "../../node_modules/lodash-es/flatMap.js", "../../node_modules/lodash-es/groupBy.js", "../../node_modules/lodash-es/_baseHas.js", "../../node_modules/lodash-es/has.js", "../../node_modules/lodash-es/isString.js", "../../node_modules/lodash-es/_baseValues.js", "../../node_modules/lodash-es/values.js", "../../node_modules/lodash-es/includes.js", "../../node_modules/lodash-es/indexOf.js", "../../node_modules/lodash-es/isEmpty.js", "../../node_modules/lodash-es/_baseIsRegExp.js", "../../node_modules/lodash-es/isRegExp.js", "../../node_modules/lodash-es/isUndefined.js", "../../node_modules/lodash-es/_baseLt.js", "../../node_modules/lodash-es/_baseExtremum.js", "../../node_modules/lodash-es/min.js", "../../node_modules/lodash-es/negate.js", "../../node_modules/lodash-es/_baseSet.js", "../../node_modules/lodash-es/_basePickBy.js", "../../node_modules/lodash-es/pickBy.js", "../../node_modules/lodash-es/_baseReduce.js", "../../node_modules/lodash-es/reduce.js", "../../node_modules/lodash-es/reject.js", "../../node_modules/lodash-es/_baseSome.js", "../../node_modules/lodash-es/some.js", "../../node_modules/lodash-es/_createSet.js", "../../node_modules/lodash-es/_baseUniq.js", "../../node_modules/lodash-es/uniq.js", "../../node_modules/lodash-es/uniqBy.js", "../../node_modules/@chevrotain/utils/src/print.ts", "../../node_modules/@chevrotain/utils/src/timer.ts", "../../node_modules/@chevrotain/utils/src/to-fast-properties.ts", "../../node_modules/@chevrotain/gast/src/model.ts", "../../node_modules/@chevrotain/gast/src/visitor.ts", "../../node_modules/@chevrotain/gast/src/helpers.ts", "../../node_modules/chevrotain/src/parse/grammar/rest.ts", "../../node_modules/chevrotain/src/parse/grammar/first.ts", "../../node_modules/chevrotain/src/parse/constants.ts", "../../node_modules/chevrotain/src/parse/grammar/follow.ts", "../../node_modules/chevrotain/src/scan/reg_exp_parser.ts", "../../node_modules/chevrotain/src/scan/reg_exp.ts", "../../node_modules/chevrotain/src/scan/lexer.ts", "../../node_modules/chevrotain/src/scan/tokens.ts", "../../node_modules/chevrotain/src/scan/lexer_errors_public.ts", "../../node_modules/chevrotain/src/scan/lexer_public.ts", "../../node_modules/chevrotain/src/scan/tokens_public.ts", "../../node_modules/chevrotain/src/parse/errors_public.ts", "../../node_modules/chevrotain/src/parse/grammar/resolver.ts", "../../node_modules/chevrotain/src/parse/grammar/interpreter.ts", "../../node_modules/chevrotain/src/parse/grammar/lookahead.ts", "../../node_modules/chevrotain/src/parse/grammar/checks.ts", "../../node_modules/chevrotain/src/parse/grammar/gast/gast_resolver_public.ts", "../../node_modules/chevrotain/src/parse/exceptions_public.ts", "../../node_modules/chevrotain/src/parse/parser/traits/recoverable.ts", "../../node_modules/chevrotain/src/parse/grammar/keys.ts", "../../node_modules/chevrotain/src/parse/grammar/llk_lookahead.ts", "../../node_modules/chevrotain/src/parse/parser/traits/looksahead.ts", "../../node_modules/chevrotain/src/parse/cst/cst.ts", "../../node_modules/chevrotain/src/lang/lang_extensions.ts", "../../node_modules/chevrotain/src/parse/cst/cst_visitor.ts", "../../node_modules/chevrotain/src/parse/parser/traits/tree_builder.ts", "../../node_modules/chevrotain/src/parse/parser/traits/lexer_adapter.ts", "../../node_modules/chevrotain/src/parse/parser/traits/recognizer_api.ts", "../../node_modules/chevrotain/src/parse/parser/traits/recognizer_engine.ts", "../../node_modules/chevrotain/src/parse/parser/traits/error_handler.ts", "../../node_modules/chevrotain/src/parse/parser/traits/context_assist.ts", "../../node_modules/chevrotain/src/parse/parser/traits/gast_recorder.ts", "../../node_modules/chevrotain/src/parse/parser/traits/perf_tracer.ts", "../../node_modules/chevrotain/src/parse/parser/utils/apply_mixins.ts", "../../node_modules/chevrotain/src/parse/parser/parser.ts", "../../node_modules/chevrotain-allstar/src/atn.ts", "../../node_modules/chevrotain-allstar/src/dfa.ts", "../../node_modules/chevrotain-allstar/src/all-star-lookahead.ts", "../../node_modules/langium/src/parser/cst-node-builder.ts", "../../node_modules/langium/src/parser/langium-parser.ts", "../../node_modules/langium/src/utils/errors.ts", "../../node_modules/langium/src/parser/parser-builder-base.ts", "../../node_modules/langium/src/parser/completion-parser-builder.ts", "../../node_modules/langium/src/parser/langium-parser-builder.ts", "../../node_modules/langium/src/parser/token-builder.ts", "../../node_modules/langium/src/parser/value-converter.ts", "../../node_modules/langium/src/references/linker.ts", "../../node_modules/langium/src/serializer/json-serializer.ts", "../../node_modules/langium/src/service-registry.ts", "../../node_modules/langium/src/workspace/ast-descriptions.ts", "../../node_modules/langium/src/workspace/ast-node-locator.ts", "../../node_modules/langium/src/workspace/configuration.ts", "../../node_modules/langium/src/workspace/document-builder.ts", "../../node_modules/langium/src/workspace/index-manager.ts", "../../node_modules/langium/src/workspace/workspace-manager.ts", "../../node_modules/langium/src/parser/lexer.ts", "../../node_modules/langium/src/documentation/jsdoc.ts", "../../node_modules/langium/src/documentation/documentation-provider.ts", "../../node_modules/langium/src/documentation/comment-provider.ts", "../../node_modules/langium/src/utils/disposable.ts", "../../node_modules/langium/src/node/node-file-system-provider.ts", "../../src/language/main.ts", "../../src/language/generated/ast.ts", "../../src/language/generated/grammar.ts", "../../src/language/generated/module.ts", "../../src/language/rob-validator.ts", "../../src/semantics/accept-weaver.ts", "../../src/language/rob-module.ts"],
  "sourcesContent": ["\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.thenable = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\nfunction boolean(value) {\n    return value === true || value === false;\n}\nexports.boolean = boolean;\nfunction string(value) {\n    return typeof value === 'string' || value instanceof String;\n}\nexports.string = string;\nfunction number(value) {\n    return typeof value === 'number' || value instanceof Number;\n}\nexports.number = number;\nfunction error(value) {\n    return value instanceof Error;\n}\nexports.error = error;\nfunction func(value) {\n    return typeof value === 'function';\n}\nexports.func = func;\nfunction array(value) {\n    return Array.isArray(value);\n}\nexports.array = array;\nfunction stringArray(value) {\n    return array(value) && value.every(elem => string(elem));\n}\nexports.stringArray = stringArray;\nfunction typedArray(value, check) {\n    return Array.isArray(value) && value.every(check);\n}\nexports.typedArray = typedArray;\nfunction thenable(value) {\n    return value && func(value.then);\n}\nexports.thenable = thenable;\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Message = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType = exports.RequestType0 = exports.AbstractMessageSignature = exports.ParameterStructures = exports.ResponseError = exports.ErrorCodes = void 0;\r\nconst is = require(\"./is\");\r\n/**\r\n * Predefined error codes.\r\n */\r\nvar ErrorCodes;\r\n(function (ErrorCodes) {\r\n    // Defined by JSON RPC\r\n    ErrorCodes.ParseError = -32700;\r\n    ErrorCodes.InvalidRequest = -32600;\r\n    ErrorCodes.MethodNotFound = -32601;\r\n    ErrorCodes.InvalidParams = -32602;\r\n    ErrorCodes.InternalError = -32603;\r\n    /**\r\n     * This is the start range of JSON RPC reserved error codes.\r\n     * It doesn't denote a real error code. No application error codes should\r\n     * be defined between the start and end range. For backwards\r\n     * compatibility the `ServerNotInitialized` and the `UnknownErrorCode`\r\n     * are left in the range.\r\n     *\r\n     * @since 3.16.0\r\n    */\r\n    ErrorCodes.jsonrpcReservedErrorRangeStart = -32099;\r\n    /** @deprecated use  jsonrpcReservedErrorRangeStart */\r\n    ErrorCodes.serverErrorStart = -32099;\r\n    /**\r\n     * An error occurred when write a message to the transport layer.\r\n     */\r\n    ErrorCodes.MessageWriteError = -32099;\r\n    /**\r\n     * An error occurred when reading a message from the transport layer.\r\n     */\r\n    ErrorCodes.MessageReadError = -32098;\r\n    /**\r\n     * The connection got disposed or lost and all pending responses got\r\n     * rejected.\r\n     */\r\n    ErrorCodes.PendingResponseRejected = -32097;\r\n    /**\r\n     * The connection is inactive and a use of it failed.\r\n     */\r\n    ErrorCodes.ConnectionInactive = -32096;\r\n    /**\r\n     * Error code indicating that a server received a notification or\r\n     * request before the server has received the `initialize` request.\r\n     */\r\n    ErrorCodes.ServerNotInitialized = -32002;\r\n    ErrorCodes.UnknownErrorCode = -32001;\r\n    /**\r\n     * This is the end range of JSON RPC reserved error codes.\r\n     * It doesn't denote a real error code.\r\n     *\r\n     * @since 3.16.0\r\n    */\r\n    ErrorCodes.jsonrpcReservedErrorRangeEnd = -32000;\r\n    /** @deprecated use  jsonrpcReservedErrorRangeEnd */\r\n    ErrorCodes.serverErrorEnd = -32000;\r\n})(ErrorCodes || (exports.ErrorCodes = ErrorCodes = {}));\r\n/**\r\n * An error object return in a response in case a request\r\n * has failed.\r\n */\r\nclass ResponseError extends Error {\r\n    constructor(code, message, data) {\r\n        super(message);\r\n        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;\r\n        this.data = data;\r\n        Object.setPrototypeOf(this, ResponseError.prototype);\r\n    }\r\n    toJson() {\r\n        const result = {\r\n            code: this.code,\r\n            message: this.message\r\n        };\r\n        if (this.data !== undefined) {\r\n            result.data = this.data;\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.ResponseError = ResponseError;\r\nclass ParameterStructures {\r\n    constructor(kind) {\r\n        this.kind = kind;\r\n    }\r\n    static is(value) {\r\n        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;\r\n    }\r\n    toString() {\r\n        return this.kind;\r\n    }\r\n}\r\nexports.ParameterStructures = ParameterStructures;\r\n/**\r\n * The parameter structure is automatically inferred on the number of parameters\r\n * and the parameter type in case of a single param.\r\n */\r\nParameterStructures.auto = new ParameterStructures('auto');\r\n/**\r\n * Forces `byPosition` parameter structure. This is useful if you have a single\r\n * parameter which has a literal type.\r\n */\r\nParameterStructures.byPosition = new ParameterStructures('byPosition');\r\n/**\r\n * Forces `byName` parameter structure. This is only useful when having a single\r\n * parameter. The library will report errors if used with a different number of\r\n * parameters.\r\n */\r\nParameterStructures.byName = new ParameterStructures('byName');\r\n/**\r\n * An abstract implementation of a MessageType.\r\n */\r\nclass AbstractMessageSignature {\r\n    constructor(method, numberOfParams) {\r\n        this.method = method;\r\n        this.numberOfParams = numberOfParams;\r\n    }\r\n    get parameterStructures() {\r\n        return ParameterStructures.auto;\r\n    }\r\n}\r\nexports.AbstractMessageSignature = AbstractMessageSignature;\r\n/**\r\n * Classes to type request response pairs\r\n */\r\nclass RequestType0 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 0);\r\n    }\r\n}\r\nexports.RequestType0 = RequestType0;\r\nclass RequestType extends AbstractMessageSignature {\r\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\r\n        super(method, 1);\r\n        this._parameterStructures = _parameterStructures;\r\n    }\r\n    get parameterStructures() {\r\n        return this._parameterStructures;\r\n    }\r\n}\r\nexports.RequestType = RequestType;\r\nclass RequestType1 extends AbstractMessageSignature {\r\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\r\n        super(method, 1);\r\n        this._parameterStructures = _parameterStructures;\r\n    }\r\n    get parameterStructures() {\r\n        return this._parameterStructures;\r\n    }\r\n}\r\nexports.RequestType1 = RequestType1;\r\nclass RequestType2 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 2);\r\n    }\r\n}\r\nexports.RequestType2 = RequestType2;\r\nclass RequestType3 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 3);\r\n    }\r\n}\r\nexports.RequestType3 = RequestType3;\r\nclass RequestType4 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 4);\r\n    }\r\n}\r\nexports.RequestType4 = RequestType4;\r\nclass RequestType5 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 5);\r\n    }\r\n}\r\nexports.RequestType5 = RequestType5;\r\nclass RequestType6 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 6);\r\n    }\r\n}\r\nexports.RequestType6 = RequestType6;\r\nclass RequestType7 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 7);\r\n    }\r\n}\r\nexports.RequestType7 = RequestType7;\r\nclass RequestType8 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 8);\r\n    }\r\n}\r\nexports.RequestType8 = RequestType8;\r\nclass RequestType9 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 9);\r\n    }\r\n}\r\nexports.RequestType9 = RequestType9;\r\nclass NotificationType extends AbstractMessageSignature {\r\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\r\n        super(method, 1);\r\n        this._parameterStructures = _parameterStructures;\r\n    }\r\n    get parameterStructures() {\r\n        return this._parameterStructures;\r\n    }\r\n}\r\nexports.NotificationType = NotificationType;\r\nclass NotificationType0 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 0);\r\n    }\r\n}\r\nexports.NotificationType0 = NotificationType0;\r\nclass NotificationType1 extends AbstractMessageSignature {\r\n    constructor(method, _parameterStructures = ParameterStructures.auto) {\r\n        super(method, 1);\r\n        this._parameterStructures = _parameterStructures;\r\n    }\r\n    get parameterStructures() {\r\n        return this._parameterStructures;\r\n    }\r\n}\r\nexports.NotificationType1 = NotificationType1;\r\nclass NotificationType2 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 2);\r\n    }\r\n}\r\nexports.NotificationType2 = NotificationType2;\r\nclass NotificationType3 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 3);\r\n    }\r\n}\r\nexports.NotificationType3 = NotificationType3;\r\nclass NotificationType4 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 4);\r\n    }\r\n}\r\nexports.NotificationType4 = NotificationType4;\r\nclass NotificationType5 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 5);\r\n    }\r\n}\r\nexports.NotificationType5 = NotificationType5;\r\nclass NotificationType6 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 6);\r\n    }\r\n}\r\nexports.NotificationType6 = NotificationType6;\r\nclass NotificationType7 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 7);\r\n    }\r\n}\r\nexports.NotificationType7 = NotificationType7;\r\nclass NotificationType8 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 8);\r\n    }\r\n}\r\nexports.NotificationType8 = NotificationType8;\r\nclass NotificationType9 extends AbstractMessageSignature {\r\n    constructor(method) {\r\n        super(method, 9);\r\n    }\r\n}\r\nexports.NotificationType9 = NotificationType9;\r\nvar Message;\r\n(function (Message) {\r\n    /**\r\n     * Tests if the given message is a request message\r\n     */\r\n    function isRequest(message) {\r\n        const candidate = message;\r\n        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));\r\n    }\r\n    Message.isRequest = isRequest;\r\n    /**\r\n     * Tests if the given message is a notification message\r\n     */\r\n    function isNotification(message) {\r\n        const candidate = message;\r\n        return candidate && is.string(candidate.method) && message.id === void 0;\r\n    }\r\n    Message.isNotification = isNotification;\r\n    /**\r\n     * Tests if the given message is a response message\r\n     */\r\n    function isResponse(message) {\r\n        const candidate = message;\r\n        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);\r\n    }\r\n    Message.isResponse = isResponse;\r\n})(Message || (exports.Message = Message = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nvar _a;\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LRUCache = exports.LinkedMap = exports.Touch = void 0;\r\nvar Touch;\r\n(function (Touch) {\r\n    Touch.None = 0;\r\n    Touch.First = 1;\r\n    Touch.AsOld = Touch.First;\r\n    Touch.Last = 2;\r\n    Touch.AsNew = Touch.Last;\r\n})(Touch || (exports.Touch = Touch = {}));\r\nclass LinkedMap {\r\n    constructor() {\r\n        this[_a] = 'LinkedMap';\r\n        this._map = new Map();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n        this._state = 0;\r\n    }\r\n    clear() {\r\n        this._map.clear();\r\n        this._head = undefined;\r\n        this._tail = undefined;\r\n        this._size = 0;\r\n        this._state++;\r\n    }\r\n    isEmpty() {\r\n        return !this._head && !this._tail;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    get first() {\r\n        return this._head?.value;\r\n    }\r\n    get last() {\r\n        return this._tail?.value;\r\n    }\r\n    has(key) {\r\n        return this._map.has(key);\r\n    }\r\n    get(key, touch = Touch.None) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        if (touch !== Touch.None) {\r\n            this.touch(item, touch);\r\n        }\r\n        return item.value;\r\n    }\r\n    set(key, value, touch = Touch.None) {\r\n        let item = this._map.get(key);\r\n        if (item) {\r\n            item.value = value;\r\n            if (touch !== Touch.None) {\r\n                this.touch(item, touch);\r\n            }\r\n        }\r\n        else {\r\n            item = { key, value, next: undefined, previous: undefined };\r\n            switch (touch) {\r\n                case Touch.None:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                case Touch.First:\r\n                    this.addItemFirst(item);\r\n                    break;\r\n                case Touch.Last:\r\n                    this.addItemLast(item);\r\n                    break;\r\n                default:\r\n                    this.addItemLast(item);\r\n                    break;\r\n            }\r\n            this._map.set(key, item);\r\n            this._size++;\r\n        }\r\n        return this;\r\n    }\r\n    delete(key) {\r\n        return !!this.remove(key);\r\n    }\r\n    remove(key) {\r\n        const item = this._map.get(key);\r\n        if (!item) {\r\n            return undefined;\r\n        }\r\n        this._map.delete(key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    shift() {\r\n        if (!this._head && !this._tail) {\r\n            return undefined;\r\n        }\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        const item = this._head;\r\n        this._map.delete(item.key);\r\n        this.removeItem(item);\r\n        this._size--;\r\n        return item.value;\r\n    }\r\n    forEach(callbackfn, thisArg) {\r\n        const state = this._state;\r\n        let current = this._head;\r\n        while (current) {\r\n            if (thisArg) {\r\n                callbackfn.bind(thisArg)(current.value, current.key, this);\r\n            }\r\n            else {\r\n                callbackfn(current.value, current.key, this);\r\n            }\r\n            if (this._state !== state) {\r\n                throw new Error(`LinkedMap got modified during iteration.`);\r\n            }\r\n            current = current.next;\r\n        }\r\n    }\r\n    keys() {\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]: () => {\r\n                return iterator;\r\n            },\r\n            next: () => {\r\n                if (this._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: current.key, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    values() {\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]: () => {\r\n                return iterator;\r\n            },\r\n            next: () => {\r\n                if (this._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: current.value, done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    entries() {\r\n        const state = this._state;\r\n        let current = this._head;\r\n        const iterator = {\r\n            [Symbol.iterator]: () => {\r\n                return iterator;\r\n            },\r\n            next: () => {\r\n                if (this._state !== state) {\r\n                    throw new Error(`LinkedMap got modified during iteration.`);\r\n                }\r\n                if (current) {\r\n                    const result = { value: [current.key, current.value], done: false };\r\n                    current = current.next;\r\n                    return result;\r\n                }\r\n                else {\r\n                    return { value: undefined, done: true };\r\n                }\r\n            }\r\n        };\r\n        return iterator;\r\n    }\r\n    [(_a = Symbol.toStringTag, Symbol.iterator)]() {\r\n        return this.entries();\r\n    }\r\n    trimOld(newSize) {\r\n        if (newSize >= this.size) {\r\n            return;\r\n        }\r\n        if (newSize === 0) {\r\n            this.clear();\r\n            return;\r\n        }\r\n        let current = this._head;\r\n        let currentSize = this.size;\r\n        while (current && currentSize > newSize) {\r\n            this._map.delete(current.key);\r\n            current = current.next;\r\n            currentSize--;\r\n        }\r\n        this._head = current;\r\n        this._size = currentSize;\r\n        if (current) {\r\n            current.previous = undefined;\r\n        }\r\n        this._state++;\r\n    }\r\n    addItemFirst(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._tail = item;\r\n        }\r\n        else if (!this._head) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n        }\r\n        this._head = item;\r\n        this._state++;\r\n    }\r\n    addItemLast(item) {\r\n        // First time Insert\r\n        if (!this._head && !this._tail) {\r\n            this._head = item;\r\n        }\r\n        else if (!this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        else {\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n        }\r\n        this._tail = item;\r\n        this._state++;\r\n    }\r\n    removeItem(item) {\r\n        if (item === this._head && item === this._tail) {\r\n            this._head = undefined;\r\n            this._tail = undefined;\r\n        }\r\n        else if (item === this._head) {\r\n            // This can only happened if size === 1 which is handle\r\n            // by the case above.\r\n            if (!item.next) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            item.next.previous = undefined;\r\n            this._head = item.next;\r\n        }\r\n        else if (item === this._tail) {\r\n            // This can only happened if size === 1 which is handle\r\n            // by the case above.\r\n            if (!item.previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            item.previous.next = undefined;\r\n            this._tail = item.previous;\r\n        }\r\n        else {\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            if (!next || !previous) {\r\n                throw new Error('Invalid list');\r\n            }\r\n            next.previous = previous;\r\n            previous.next = next;\r\n        }\r\n        item.next = undefined;\r\n        item.previous = undefined;\r\n        this._state++;\r\n    }\r\n    touch(item, touch) {\r\n        if (!this._head || !this._tail) {\r\n            throw new Error('Invalid list');\r\n        }\r\n        if ((touch !== Touch.First && touch !== Touch.Last)) {\r\n            return;\r\n        }\r\n        if (touch === Touch.First) {\r\n            if (item === this._head) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item\r\n            if (item === this._tail) {\r\n                // previous must be defined since item was not head but is tail\r\n                // So there are more than on item in the map\r\n                previous.next = undefined;\r\n                this._tail = previous;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            // Insert the node at head\r\n            item.previous = undefined;\r\n            item.next = this._head;\r\n            this._head.previous = item;\r\n            this._head = item;\r\n            this._state++;\r\n        }\r\n        else if (touch === Touch.Last) {\r\n            if (item === this._tail) {\r\n                return;\r\n            }\r\n            const next = item.next;\r\n            const previous = item.previous;\r\n            // Unlink the item.\r\n            if (item === this._head) {\r\n                // next must be defined since item was not tail but is head\r\n                // So there are more than on item in the map\r\n                next.previous = undefined;\r\n                this._head = next;\r\n            }\r\n            else {\r\n                // Both next and previous are not undefined since item was neither head nor tail.\r\n                next.previous = previous;\r\n                previous.next = next;\r\n            }\r\n            item.next = undefined;\r\n            item.previous = this._tail;\r\n            this._tail.next = item;\r\n            this._tail = item;\r\n            this._state++;\r\n        }\r\n    }\r\n    toJSON() {\r\n        const data = [];\r\n        this.forEach((value, key) => {\r\n            data.push([key, value]);\r\n        });\r\n        return data;\r\n    }\r\n    fromJSON(data) {\r\n        this.clear();\r\n        for (const [key, value] of data) {\r\n            this.set(key, value);\r\n        }\r\n    }\r\n}\r\nexports.LinkedMap = LinkedMap;\r\nclass LRUCache extends LinkedMap {\r\n    constructor(limit, ratio = 1) {\r\n        super();\r\n        this._limit = limit;\r\n        this._ratio = Math.min(Math.max(0, ratio), 1);\r\n    }\r\n    get limit() {\r\n        return this._limit;\r\n    }\r\n    set limit(limit) {\r\n        this._limit = limit;\r\n        this.checkTrim();\r\n    }\r\n    get ratio() {\r\n        return this._ratio;\r\n    }\r\n    set ratio(ratio) {\r\n        this._ratio = Math.min(Math.max(0, ratio), 1);\r\n        this.checkTrim();\r\n    }\r\n    get(key, touch = Touch.AsNew) {\r\n        return super.get(key, touch);\r\n    }\r\n    peek(key) {\r\n        return super.get(key, Touch.None);\r\n    }\r\n    set(key, value) {\r\n        super.set(key, value, Touch.Last);\r\n        this.checkTrim();\r\n        return this;\r\n    }\r\n    checkTrim() {\r\n        if (this.size > this._limit) {\r\n            this.trimOld(Math.round(this._limit * this._ratio));\r\n        }\r\n    }\r\n}\r\nexports.LRUCache = LRUCache;\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Disposable = void 0;\r\nvar Disposable;\r\n(function (Disposable) {\r\n    function create(func) {\r\n        return {\r\n            dispose: func\r\n        };\r\n    }\r\n    Disposable.create = create;\r\n})(Disposable || (exports.Disposable = Disposable = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nlet _ral;\r\nfunction RAL() {\r\n    if (_ral === undefined) {\r\n        throw new Error(`No runtime abstraction layer installed`);\r\n    }\r\n    return _ral;\r\n}\r\n(function (RAL) {\r\n    function install(ral) {\r\n        if (ral === undefined) {\r\n            throw new Error(`No runtime abstraction layer provided`);\r\n        }\r\n        _ral = ral;\r\n    }\r\n    RAL.install = install;\r\n})(RAL || (RAL = {}));\r\nexports.default = RAL;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Emitter = exports.Event = void 0;\r\nconst ral_1 = require(\"./ral\");\r\nvar Event;\r\n(function (Event) {\r\n    const _disposable = { dispose() { } };\r\n    Event.None = function () { return _disposable; };\r\n})(Event || (exports.Event = Event = {}));\r\nclass CallbackList {\r\n    add(callback, context = null, bucket) {\r\n        if (!this._callbacks) {\r\n            this._callbacks = [];\r\n            this._contexts = [];\r\n        }\r\n        this._callbacks.push(callback);\r\n        this._contexts.push(context);\r\n        if (Array.isArray(bucket)) {\r\n            bucket.push({ dispose: () => this.remove(callback, context) });\r\n        }\r\n    }\r\n    remove(callback, context = null) {\r\n        if (!this._callbacks) {\r\n            return;\r\n        }\r\n        let foundCallbackWithDifferentContext = false;\r\n        for (let i = 0, len = this._callbacks.length; i < len; i++) {\r\n            if (this._callbacks[i] === callback) {\r\n                if (this._contexts[i] === context) {\r\n                    // callback & context match => remove it\r\n                    this._callbacks.splice(i, 1);\r\n                    this._contexts.splice(i, 1);\r\n                    return;\r\n                }\r\n                else {\r\n                    foundCallbackWithDifferentContext = true;\r\n                }\r\n            }\r\n        }\r\n        if (foundCallbackWithDifferentContext) {\r\n            throw new Error('When adding a listener with a context, you should remove it with the same context');\r\n        }\r\n    }\r\n    invoke(...args) {\r\n        if (!this._callbacks) {\r\n            return [];\r\n        }\r\n        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);\r\n        for (let i = 0, len = callbacks.length; i < len; i++) {\r\n            try {\r\n                ret.push(callbacks[i].apply(contexts[i], args));\r\n            }\r\n            catch (e) {\r\n                // eslint-disable-next-line no-console\r\n                (0, ral_1.default)().console.error(e);\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n    isEmpty() {\r\n        return !this._callbacks || this._callbacks.length === 0;\r\n    }\r\n    dispose() {\r\n        this._callbacks = undefined;\r\n        this._contexts = undefined;\r\n    }\r\n}\r\nclass Emitter {\r\n    constructor(_options) {\r\n        this._options = _options;\r\n    }\r\n    /**\r\n     * For the public to allow to subscribe\r\n     * to events from this Emitter\r\n     */\r\n    get event() {\r\n        if (!this._event) {\r\n            this._event = (listener, thisArgs, disposables) => {\r\n                if (!this._callbacks) {\r\n                    this._callbacks = new CallbackList();\r\n                }\r\n                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {\r\n                    this._options.onFirstListenerAdd(this);\r\n                }\r\n                this._callbacks.add(listener, thisArgs);\r\n                const result = {\r\n                    dispose: () => {\r\n                        if (!this._callbacks) {\r\n                            // disposable is disposed after emitter is disposed.\r\n                            return;\r\n                        }\r\n                        this._callbacks.remove(listener, thisArgs);\r\n                        result.dispose = Emitter._noop;\r\n                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {\r\n                            this._options.onLastListenerRemove(this);\r\n                        }\r\n                    }\r\n                };\r\n                if (Array.isArray(disposables)) {\r\n                    disposables.push(result);\r\n                }\r\n                return result;\r\n            };\r\n        }\r\n        return this._event;\r\n    }\r\n    /**\r\n     * To be kept private to fire an event to\r\n     * subscribers\r\n     */\r\n    fire(event) {\r\n        if (this._callbacks) {\r\n            this._callbacks.invoke.call(this._callbacks, event);\r\n        }\r\n    }\r\n    dispose() {\r\n        if (this._callbacks) {\r\n            this._callbacks.dispose();\r\n            this._callbacks = undefined;\r\n        }\r\n    }\r\n}\r\nexports.Emitter = Emitter;\r\nEmitter._noop = function () { };\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CancellationTokenSource = exports.CancellationToken = void 0;\r\nconst ral_1 = require(\"./ral\");\r\nconst Is = require(\"./is\");\r\nconst events_1 = require(\"./events\");\r\nvar CancellationToken;\r\n(function (CancellationToken) {\r\n    CancellationToken.None = Object.freeze({\r\n        isCancellationRequested: false,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    CancellationToken.Cancelled = Object.freeze({\r\n        isCancellationRequested: true,\r\n        onCancellationRequested: events_1.Event.None\r\n    });\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && (candidate === CancellationToken.None\r\n            || candidate === CancellationToken.Cancelled\r\n            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));\r\n    }\r\n    CancellationToken.is = is;\r\n})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));\r\nconst shortcutEvent = Object.freeze(function (callback, context) {\r\n    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);\r\n    return { dispose() { handle.dispose(); } };\r\n});\r\nclass MutableToken {\r\n    constructor() {\r\n        this._isCancelled = false;\r\n    }\r\n    cancel() {\r\n        if (!this._isCancelled) {\r\n            this._isCancelled = true;\r\n            if (this._emitter) {\r\n                this._emitter.fire(undefined);\r\n                this.dispose();\r\n            }\r\n        }\r\n    }\r\n    get isCancellationRequested() {\r\n        return this._isCancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        if (this._isCancelled) {\r\n            return shortcutEvent;\r\n        }\r\n        if (!this._emitter) {\r\n            this._emitter = new events_1.Emitter();\r\n        }\r\n        return this._emitter.event;\r\n    }\r\n    dispose() {\r\n        if (this._emitter) {\r\n            this._emitter.dispose();\r\n            this._emitter = undefined;\r\n        }\r\n    }\r\n}\r\nclass CancellationTokenSource {\r\n    get token() {\r\n        if (!this._token) {\r\n            // be lazy and create the token only when\r\n            // actually needed\r\n            this._token = new MutableToken();\r\n        }\r\n        return this._token;\r\n    }\r\n    cancel() {\r\n        if (!this._token) {\r\n            // save an object by returning the default\r\n            // cancelled token when cancellation happens\r\n            // before someone asks for the token\r\n            this._token = CancellationToken.Cancelled;\r\n        }\r\n        else {\r\n            this._token.cancel();\r\n        }\r\n    }\r\n    dispose() {\r\n        if (!this._token) {\r\n            // ensure to initialize with an empty token if we had none\r\n            this._token = CancellationToken.None;\r\n        }\r\n        else if (this._token instanceof MutableToken) {\r\n            // actually dispose\r\n            this._token.dispose();\r\n        }\r\n    }\r\n}\r\nexports.CancellationTokenSource = CancellationTokenSource;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = void 0;\r\nconst cancellation_1 = require(\"./cancellation\");\r\nvar CancellationState;\r\n(function (CancellationState) {\r\n    CancellationState.Continue = 0;\r\n    CancellationState.Cancelled = 1;\r\n})(CancellationState || (CancellationState = {}));\r\nclass SharedArraySenderStrategy {\r\n    constructor() {\r\n        this.buffers = new Map();\r\n    }\r\n    enableCancellation(request) {\r\n        if (request.id === null) {\r\n            return;\r\n        }\r\n        const buffer = new SharedArrayBuffer(4);\r\n        const data = new Int32Array(buffer, 0, 1);\r\n        data[0] = CancellationState.Continue;\r\n        this.buffers.set(request.id, buffer);\r\n        request.$cancellationData = buffer;\r\n    }\r\n    async sendCancellation(_conn, id) {\r\n        const buffer = this.buffers.get(id);\r\n        if (buffer === undefined) {\r\n            return;\r\n        }\r\n        const data = new Int32Array(buffer, 0, 1);\r\n        Atomics.store(data, 0, CancellationState.Cancelled);\r\n    }\r\n    cleanup(id) {\r\n        this.buffers.delete(id);\r\n    }\r\n    dispose() {\r\n        this.buffers.clear();\r\n    }\r\n}\r\nexports.SharedArraySenderStrategy = SharedArraySenderStrategy;\r\nclass SharedArrayBufferCancellationToken {\r\n    constructor(buffer) {\r\n        this.data = new Int32Array(buffer, 0, 1);\r\n    }\r\n    get isCancellationRequested() {\r\n        return Atomics.load(this.data, 0) === CancellationState.Cancelled;\r\n    }\r\n    get onCancellationRequested() {\r\n        throw new Error(`Cancellation over SharedArrayBuffer doesn't support cancellation events`);\r\n    }\r\n}\r\nclass SharedArrayBufferCancellationTokenSource {\r\n    constructor(buffer) {\r\n        this.token = new SharedArrayBufferCancellationToken(buffer);\r\n    }\r\n    cancel() {\r\n    }\r\n    dispose() {\r\n    }\r\n}\r\nclass SharedArrayReceiverStrategy {\r\n    constructor() {\r\n        this.kind = 'request';\r\n    }\r\n    createCancellationTokenSource(request) {\r\n        const buffer = request.$cancellationData;\r\n        if (buffer === undefined) {\r\n            return new cancellation_1.CancellationTokenSource();\r\n        }\r\n        return new SharedArrayBufferCancellationTokenSource(buffer);\r\n    }\r\n}\r\nexports.SharedArrayReceiverStrategy = SharedArrayReceiverStrategy;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Semaphore = void 0;\r\nconst ral_1 = require(\"./ral\");\r\nclass Semaphore {\r\n    constructor(capacity = 1) {\r\n        if (capacity <= 0) {\r\n            throw new Error('Capacity must be greater than 0');\r\n        }\r\n        this._capacity = capacity;\r\n        this._active = 0;\r\n        this._waiting = [];\r\n    }\r\n    lock(thunk) {\r\n        return new Promise((resolve, reject) => {\r\n            this._waiting.push({ thunk, resolve, reject });\r\n            this.runNext();\r\n        });\r\n    }\r\n    get active() {\r\n        return this._active;\r\n    }\r\n    runNext() {\r\n        if (this._waiting.length === 0 || this._active === this._capacity) {\r\n            return;\r\n        }\r\n        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());\r\n    }\r\n    doRunNext() {\r\n        if (this._waiting.length === 0 || this._active === this._capacity) {\r\n            return;\r\n        }\r\n        const next = this._waiting.shift();\r\n        this._active++;\r\n        if (this._active > this._capacity) {\r\n            throw new Error(`To many thunks active`);\r\n        }\r\n        try {\r\n            const result = next.thunk();\r\n            if (result instanceof Promise) {\r\n                result.then((value) => {\r\n                    this._active--;\r\n                    next.resolve(value);\r\n                    this.runNext();\r\n                }, (err) => {\r\n                    this._active--;\r\n                    next.reject(err);\r\n                    this.runNext();\r\n                });\r\n            }\r\n            else {\r\n                this._active--;\r\n                next.resolve(result);\r\n                this.runNext();\r\n            }\r\n        }\r\n        catch (err) {\r\n            this._active--;\r\n            next.reject(err);\r\n            this.runNext();\r\n        }\r\n    }\r\n}\r\nexports.Semaphore = Semaphore;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = void 0;\r\nconst ral_1 = require(\"./ral\");\r\nconst Is = require(\"./is\");\r\nconst events_1 = require(\"./events\");\r\nconst semaphore_1 = require(\"./semaphore\");\r\nvar MessageReader;\r\n(function (MessageReader) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);\r\n    }\r\n    MessageReader.is = is;\r\n})(MessageReader || (exports.MessageReader = MessageReader = {}));\r\nclass AbstractMessageReader {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n        this.partialMessageEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error) {\r\n        this.errorEmitter.fire(this.asError(error));\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    get onPartialMessage() {\r\n        return this.partialMessageEmitter.event;\r\n    }\r\n    firePartialMessage(info) {\r\n        this.partialMessageEmitter.fire(info);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageReader = AbstractMessageReader;\r\nvar ResolvedMessageReaderOptions;\r\n(function (ResolvedMessageReaderOptions) {\r\n    function fromOptions(options) {\r\n        let charset;\r\n        let result;\r\n        let contentDecoder;\r\n        const contentDecoders = new Map();\r\n        let contentTypeDecoder;\r\n        const contentTypeDecoders = new Map();\r\n        if (options === undefined || typeof options === 'string') {\r\n            charset = options ?? 'utf-8';\r\n        }\r\n        else {\r\n            charset = options.charset ?? 'utf-8';\r\n            if (options.contentDecoder !== undefined) {\r\n                contentDecoder = options.contentDecoder;\r\n                contentDecoders.set(contentDecoder.name, contentDecoder);\r\n            }\r\n            if (options.contentDecoders !== undefined) {\r\n                for (const decoder of options.contentDecoders) {\r\n                    contentDecoders.set(decoder.name, decoder);\r\n                }\r\n            }\r\n            if (options.contentTypeDecoder !== undefined) {\r\n                contentTypeDecoder = options.contentTypeDecoder;\r\n                contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\r\n            }\r\n            if (options.contentTypeDecoders !== undefined) {\r\n                for (const decoder of options.contentTypeDecoders) {\r\n                    contentTypeDecoders.set(decoder.name, decoder);\r\n                }\r\n            }\r\n        }\r\n        if (contentTypeDecoder === undefined) {\r\n            contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;\r\n            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);\r\n        }\r\n        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };\r\n    }\r\n    ResolvedMessageReaderOptions.fromOptions = fromOptions;\r\n})(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));\r\nclass ReadableStreamMessageReader extends AbstractMessageReader {\r\n    constructor(readable, options) {\r\n        super();\r\n        this.readable = readable;\r\n        this.options = ResolvedMessageReaderOptions.fromOptions(options);\r\n        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);\r\n        this._partialMessageTimeout = 10000;\r\n        this.nextMessageLength = -1;\r\n        this.messageToken = 0;\r\n        this.readSemaphore = new semaphore_1.Semaphore(1);\r\n    }\r\n    set partialMessageTimeout(timeout) {\r\n        this._partialMessageTimeout = timeout;\r\n    }\r\n    get partialMessageTimeout() {\r\n        return this._partialMessageTimeout;\r\n    }\r\n    listen(callback) {\r\n        this.nextMessageLength = -1;\r\n        this.messageToken = 0;\r\n        this.partialMessageTimer = undefined;\r\n        this.callback = callback;\r\n        const result = this.readable.onData((data) => {\r\n            this.onData(data);\r\n        });\r\n        this.readable.onError((error) => this.fireError(error));\r\n        this.readable.onClose(() => this.fireClose());\r\n        return result;\r\n    }\r\n    onData(data) {\r\n        try {\r\n            this.buffer.append(data);\r\n            while (true) {\r\n                if (this.nextMessageLength === -1) {\r\n                    const headers = this.buffer.tryReadHeaders(true);\r\n                    if (!headers) {\r\n                        return;\r\n                    }\r\n                    const contentLength = headers.get('content-length');\r\n                    if (!contentLength) {\r\n                        this.fireError(new Error(`Header must provide a Content-Length property.\\n${JSON.stringify(Object.fromEntries(headers))}`));\r\n                        return;\r\n                    }\r\n                    const length = parseInt(contentLength);\r\n                    if (isNaN(length)) {\r\n                        this.fireError(new Error(`Content-Length value must be a number. Got ${contentLength}`));\r\n                        return;\r\n                    }\r\n                    this.nextMessageLength = length;\r\n                }\r\n                const body = this.buffer.tryReadBody(this.nextMessageLength);\r\n                if (body === undefined) {\r\n                    /** We haven't received the full message yet. */\r\n                    this.setPartialMessageTimer();\r\n                    return;\r\n                }\r\n                this.clearPartialMessageTimer();\r\n                this.nextMessageLength = -1;\r\n                // Make sure that we convert one received message after the\r\n                // other. Otherwise it could happen that a decoding of a second\r\n                // smaller message finished before the decoding of a first larger\r\n                // message and then we would deliver the second message first.\r\n                this.readSemaphore.lock(async () => {\r\n                    const bytes = this.options.contentDecoder !== undefined\r\n                        ? await this.options.contentDecoder.decode(body)\r\n                        : body;\r\n                    const message = await this.options.contentTypeDecoder.decode(bytes, this.options);\r\n                    this.callback(message);\r\n                }).catch((error) => {\r\n                    this.fireError(error);\r\n                });\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.fireError(error);\r\n        }\r\n    }\r\n    clearPartialMessageTimer() {\r\n        if (this.partialMessageTimer) {\r\n            this.partialMessageTimer.dispose();\r\n            this.partialMessageTimer = undefined;\r\n        }\r\n    }\r\n    setPartialMessageTimer() {\r\n        this.clearPartialMessageTimer();\r\n        if (this._partialMessageTimeout <= 0) {\r\n            return;\r\n        }\r\n        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {\r\n            this.partialMessageTimer = undefined;\r\n            if (token === this.messageToken) {\r\n                this.firePartialMessage({ messageToken: token, waitingTime: timeout });\r\n                this.setPartialMessageTimer();\r\n            }\r\n        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);\r\n    }\r\n}\r\nexports.ReadableStreamMessageReader = ReadableStreamMessageReader;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = void 0;\r\nconst ral_1 = require(\"./ral\");\r\nconst Is = require(\"./is\");\r\nconst semaphore_1 = require(\"./semaphore\");\r\nconst events_1 = require(\"./events\");\r\nconst ContentLength = 'Content-Length: ';\r\nconst CRLF = '\\r\\n';\r\nvar MessageWriter;\r\n(function (MessageWriter) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) &&\r\n            Is.func(candidate.onError) && Is.func(candidate.write);\r\n    }\r\n    MessageWriter.is = is;\r\n})(MessageWriter || (exports.MessageWriter = MessageWriter = {}));\r\nclass AbstractMessageWriter {\r\n    constructor() {\r\n        this.errorEmitter = new events_1.Emitter();\r\n        this.closeEmitter = new events_1.Emitter();\r\n    }\r\n    dispose() {\r\n        this.errorEmitter.dispose();\r\n        this.closeEmitter.dispose();\r\n    }\r\n    get onError() {\r\n        return this.errorEmitter.event;\r\n    }\r\n    fireError(error, message, count) {\r\n        this.errorEmitter.fire([this.asError(error), message, count]);\r\n    }\r\n    get onClose() {\r\n        return this.closeEmitter.event;\r\n    }\r\n    fireClose() {\r\n        this.closeEmitter.fire(undefined);\r\n    }\r\n    asError(error) {\r\n        if (error instanceof Error) {\r\n            return error;\r\n        }\r\n        else {\r\n            return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : 'unknown'}`);\r\n        }\r\n    }\r\n}\r\nexports.AbstractMessageWriter = AbstractMessageWriter;\r\nvar ResolvedMessageWriterOptions;\r\n(function (ResolvedMessageWriterOptions) {\r\n    function fromOptions(options) {\r\n        if (options === undefined || typeof options === 'string') {\r\n            return { charset: options ?? 'utf-8', contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };\r\n        }\r\n        else {\r\n            return { charset: options.charset ?? 'utf-8', contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };\r\n        }\r\n    }\r\n    ResolvedMessageWriterOptions.fromOptions = fromOptions;\r\n})(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));\r\nclass WriteableStreamMessageWriter extends AbstractMessageWriter {\r\n    constructor(writable, options) {\r\n        super();\r\n        this.writable = writable;\r\n        this.options = ResolvedMessageWriterOptions.fromOptions(options);\r\n        this.errorCount = 0;\r\n        this.writeSemaphore = new semaphore_1.Semaphore(1);\r\n        this.writable.onError((error) => this.fireError(error));\r\n        this.writable.onClose(() => this.fireClose());\r\n    }\r\n    async write(msg) {\r\n        return this.writeSemaphore.lock(async () => {\r\n            const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {\r\n                if (this.options.contentEncoder !== undefined) {\r\n                    return this.options.contentEncoder.encode(buffer);\r\n                }\r\n                else {\r\n                    return buffer;\r\n                }\r\n            });\r\n            return payload.then((buffer) => {\r\n                const headers = [];\r\n                headers.push(ContentLength, buffer.byteLength.toString(), CRLF);\r\n                headers.push(CRLF);\r\n                return this.doWrite(msg, headers, buffer);\r\n            }, (error) => {\r\n                this.fireError(error);\r\n                throw error;\r\n            });\r\n        });\r\n    }\r\n    async doWrite(msg, headers, data) {\r\n        try {\r\n            await this.writable.write(headers.join(''), 'ascii');\r\n            return this.writable.write(data);\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n            return Promise.reject(error);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n    end() {\r\n        this.writable.end();\r\n    }\r\n}\r\nexports.WriteableStreamMessageWriter = WriteableStreamMessageWriter;\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AbstractMessageBuffer = void 0;\r\nconst CR = 13;\r\nconst LF = 10;\r\nconst CRLF = '\\r\\n';\r\nclass AbstractMessageBuffer {\r\n    constructor(encoding = 'utf-8') {\r\n        this._encoding = encoding;\r\n        this._chunks = [];\r\n        this._totalLength = 0;\r\n    }\r\n    get encoding() {\r\n        return this._encoding;\r\n    }\r\n    append(chunk) {\r\n        const toAppend = typeof chunk === 'string' ? this.fromString(chunk, this._encoding) : chunk;\r\n        this._chunks.push(toAppend);\r\n        this._totalLength += toAppend.byteLength;\r\n    }\r\n    tryReadHeaders(lowerCaseKeys = false) {\r\n        if (this._chunks.length === 0) {\r\n            return undefined;\r\n        }\r\n        let state = 0;\r\n        let chunkIndex = 0;\r\n        let offset = 0;\r\n        let chunkBytesRead = 0;\r\n        row: while (chunkIndex < this._chunks.length) {\r\n            const chunk = this._chunks[chunkIndex];\r\n            offset = 0;\r\n            column: while (offset < chunk.length) {\r\n                const value = chunk[offset];\r\n                switch (value) {\r\n                    case CR:\r\n                        switch (state) {\r\n                            case 0:\r\n                                state = 1;\r\n                                break;\r\n                            case 2:\r\n                                state = 3;\r\n                                break;\r\n                            default:\r\n                                state = 0;\r\n                        }\r\n                        break;\r\n                    case LF:\r\n                        switch (state) {\r\n                            case 1:\r\n                                state = 2;\r\n                                break;\r\n                            case 3:\r\n                                state = 4;\r\n                                offset++;\r\n                                break row;\r\n                            default:\r\n                                state = 0;\r\n                        }\r\n                        break;\r\n                    default:\r\n                        state = 0;\r\n                }\r\n                offset++;\r\n            }\r\n            chunkBytesRead += chunk.byteLength;\r\n            chunkIndex++;\r\n        }\r\n        if (state !== 4) {\r\n            return undefined;\r\n        }\r\n        // The buffer contains the two CRLF at the end. So we will\r\n        // have two empty lines after the split at the end as well.\r\n        const buffer = this._read(chunkBytesRead + offset);\r\n        const result = new Map();\r\n        const headers = this.toString(buffer, 'ascii').split(CRLF);\r\n        if (headers.length < 2) {\r\n            return result;\r\n        }\r\n        for (let i = 0; i < headers.length - 2; i++) {\r\n            const header = headers[i];\r\n            const index = header.indexOf(':');\r\n            if (index === -1) {\r\n                throw new Error(`Message header must separate key and value using ':'\\n${header}`);\r\n            }\r\n            const key = header.substr(0, index);\r\n            const value = header.substr(index + 1).trim();\r\n            result.set(lowerCaseKeys ? key.toLowerCase() : key, value);\r\n        }\r\n        return result;\r\n    }\r\n    tryReadBody(length) {\r\n        if (this._totalLength < length) {\r\n            return undefined;\r\n        }\r\n        return this._read(length);\r\n    }\r\n    get numberOfBytes() {\r\n        return this._totalLength;\r\n    }\r\n    _read(byteCount) {\r\n        if (byteCount === 0) {\r\n            return this.emptyBuffer();\r\n        }\r\n        if (byteCount > this._totalLength) {\r\n            throw new Error(`Cannot read so many bytes!`);\r\n        }\r\n        if (this._chunks[0].byteLength === byteCount) {\r\n            // super fast path, precisely first chunk must be returned\r\n            const chunk = this._chunks[0];\r\n            this._chunks.shift();\r\n            this._totalLength -= byteCount;\r\n            return this.asNative(chunk);\r\n        }\r\n        if (this._chunks[0].byteLength > byteCount) {\r\n            // fast path, the reading is entirely within the first chunk\r\n            const chunk = this._chunks[0];\r\n            const result = this.asNative(chunk, byteCount);\r\n            this._chunks[0] = chunk.slice(byteCount);\r\n            this._totalLength -= byteCount;\r\n            return result;\r\n        }\r\n        const result = this.allocNative(byteCount);\r\n        let resultOffset = 0;\r\n        let chunkIndex = 0;\r\n        while (byteCount > 0) {\r\n            const chunk = this._chunks[chunkIndex];\r\n            if (chunk.byteLength > byteCount) {\r\n                // this chunk will survive\r\n                const chunkPart = chunk.slice(0, byteCount);\r\n                result.set(chunkPart, resultOffset);\r\n                resultOffset += byteCount;\r\n                this._chunks[chunkIndex] = chunk.slice(byteCount);\r\n                this._totalLength -= byteCount;\r\n                byteCount -= byteCount;\r\n            }\r\n            else {\r\n                // this chunk will be entirely read\r\n                result.set(chunk, resultOffset);\r\n                resultOffset += chunk.byteLength;\r\n                this._chunks.shift();\r\n                this._totalLength -= chunk.byteLength;\r\n                byteCount -= chunk.byteLength;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n}\r\nexports.AbstractMessageBuffer = AbstractMessageBuffer;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createMessageConnection = exports.ConnectionOptions = exports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.RequestCancellationReceiverStrategy = exports.IdCancellationReceiverStrategy = exports.ConnectionStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = exports.NullLogger = exports.ProgressType = exports.ProgressToken = void 0;\r\nconst ral_1 = require(\"./ral\");\r\nconst Is = require(\"./is\");\r\nconst messages_1 = require(\"./messages\");\r\nconst linkedMap_1 = require(\"./linkedMap\");\r\nconst events_1 = require(\"./events\");\r\nconst cancellation_1 = require(\"./cancellation\");\r\nvar CancelNotification;\r\n(function (CancelNotification) {\r\n    CancelNotification.type = new messages_1.NotificationType('$/cancelRequest');\r\n})(CancelNotification || (CancelNotification = {}));\r\nvar ProgressToken;\r\n(function (ProgressToken) {\r\n    function is(value) {\r\n        return typeof value === 'string' || typeof value === 'number';\r\n    }\r\n    ProgressToken.is = is;\r\n})(ProgressToken || (exports.ProgressToken = ProgressToken = {}));\r\nvar ProgressNotification;\r\n(function (ProgressNotification) {\r\n    ProgressNotification.type = new messages_1.NotificationType('$/progress');\r\n})(ProgressNotification || (ProgressNotification = {}));\r\nclass ProgressType {\r\n    constructor() {\r\n    }\r\n}\r\nexports.ProgressType = ProgressType;\r\nvar StarRequestHandler;\r\n(function (StarRequestHandler) {\r\n    function is(value) {\r\n        return Is.func(value);\r\n    }\r\n    StarRequestHandler.is = is;\r\n})(StarRequestHandler || (StarRequestHandler = {}));\r\nexports.NullLogger = Object.freeze({\r\n    error: () => { },\r\n    warn: () => { },\r\n    info: () => { },\r\n    log: () => { }\r\n});\r\nvar Trace;\r\n(function (Trace) {\r\n    Trace[Trace[\"Off\"] = 0] = \"Off\";\r\n    Trace[Trace[\"Messages\"] = 1] = \"Messages\";\r\n    Trace[Trace[\"Compact\"] = 2] = \"Compact\";\r\n    Trace[Trace[\"Verbose\"] = 3] = \"Verbose\";\r\n})(Trace || (exports.Trace = Trace = {}));\r\nvar TraceValues;\r\n(function (TraceValues) {\r\n    /**\r\n     * Turn tracing off.\r\n     */\r\n    TraceValues.Off = 'off';\r\n    /**\r\n     * Trace messages only.\r\n     */\r\n    TraceValues.Messages = 'messages';\r\n    /**\r\n     * Compact message tracing.\r\n     */\r\n    TraceValues.Compact = 'compact';\r\n    /**\r\n     * Verbose message tracing.\r\n     */\r\n    TraceValues.Verbose = 'verbose';\r\n})(TraceValues || (exports.TraceValues = TraceValues = {}));\r\n(function (Trace) {\r\n    function fromString(value) {\r\n        if (!Is.string(value)) {\r\n            return Trace.Off;\r\n        }\r\n        value = value.toLowerCase();\r\n        switch (value) {\r\n            case 'off':\r\n                return Trace.Off;\r\n            case 'messages':\r\n                return Trace.Messages;\r\n            case 'compact':\r\n                return Trace.Compact;\r\n            case 'verbose':\r\n                return Trace.Verbose;\r\n            default:\r\n                return Trace.Off;\r\n        }\r\n    }\r\n    Trace.fromString = fromString;\r\n    function toString(value) {\r\n        switch (value) {\r\n            case Trace.Off:\r\n                return 'off';\r\n            case Trace.Messages:\r\n                return 'messages';\r\n            case Trace.Compact:\r\n                return 'compact';\r\n            case Trace.Verbose:\r\n                return 'verbose';\r\n            default:\r\n                return 'off';\r\n        }\r\n    }\r\n    Trace.toString = toString;\r\n})(Trace || (exports.Trace = Trace = {}));\r\nvar TraceFormat;\r\n(function (TraceFormat) {\r\n    TraceFormat[\"Text\"] = \"text\";\r\n    TraceFormat[\"JSON\"] = \"json\";\r\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\r\n(function (TraceFormat) {\r\n    function fromString(value) {\r\n        if (!Is.string(value)) {\r\n            return TraceFormat.Text;\r\n        }\r\n        value = value.toLowerCase();\r\n        if (value === 'json') {\r\n            return TraceFormat.JSON;\r\n        }\r\n        else {\r\n            return TraceFormat.Text;\r\n        }\r\n    }\r\n    TraceFormat.fromString = fromString;\r\n})(TraceFormat || (exports.TraceFormat = TraceFormat = {}));\r\nvar SetTraceNotification;\r\n(function (SetTraceNotification) {\r\n    SetTraceNotification.type = new messages_1.NotificationType('$/setTrace');\r\n})(SetTraceNotification || (exports.SetTraceNotification = SetTraceNotification = {}));\r\nvar LogTraceNotification;\r\n(function (LogTraceNotification) {\r\n    LogTraceNotification.type = new messages_1.NotificationType('$/logTrace');\r\n})(LogTraceNotification || (exports.LogTraceNotification = LogTraceNotification = {}));\r\nvar ConnectionErrors;\r\n(function (ConnectionErrors) {\r\n    /**\r\n     * The connection is closed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Closed\"] = 1] = \"Closed\";\r\n    /**\r\n     * The connection got disposed.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"Disposed\"] = 2] = \"Disposed\";\r\n    /**\r\n     * The connection is already in listening mode.\r\n     */\r\n    ConnectionErrors[ConnectionErrors[\"AlreadyListening\"] = 3] = \"AlreadyListening\";\r\n})(ConnectionErrors || (exports.ConnectionErrors = ConnectionErrors = {}));\r\nclass ConnectionError extends Error {\r\n    constructor(code, message) {\r\n        super(message);\r\n        this.code = code;\r\n        Object.setPrototypeOf(this, ConnectionError.prototype);\r\n    }\r\n}\r\nexports.ConnectionError = ConnectionError;\r\nvar ConnectionStrategy;\r\n(function (ConnectionStrategy) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && Is.func(candidate.cancelUndispatched);\r\n    }\r\n    ConnectionStrategy.is = is;\r\n})(ConnectionStrategy || (exports.ConnectionStrategy = ConnectionStrategy = {}));\r\nvar IdCancellationReceiverStrategy;\r\n(function (IdCancellationReceiverStrategy) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && (candidate.kind === undefined || candidate.kind === 'id') && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\r\n    }\r\n    IdCancellationReceiverStrategy.is = is;\r\n})(IdCancellationReceiverStrategy || (exports.IdCancellationReceiverStrategy = IdCancellationReceiverStrategy = {}));\r\nvar RequestCancellationReceiverStrategy;\r\n(function (RequestCancellationReceiverStrategy) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && candidate.kind === 'request' && Is.func(candidate.createCancellationTokenSource) && (candidate.dispose === undefined || Is.func(candidate.dispose));\r\n    }\r\n    RequestCancellationReceiverStrategy.is = is;\r\n})(RequestCancellationReceiverStrategy || (exports.RequestCancellationReceiverStrategy = RequestCancellationReceiverStrategy = {}));\r\nvar CancellationReceiverStrategy;\r\n(function (CancellationReceiverStrategy) {\r\n    CancellationReceiverStrategy.Message = Object.freeze({\r\n        createCancellationTokenSource(_) {\r\n            return new cancellation_1.CancellationTokenSource();\r\n        }\r\n    });\r\n    function is(value) {\r\n        return IdCancellationReceiverStrategy.is(value) || RequestCancellationReceiverStrategy.is(value);\r\n    }\r\n    CancellationReceiverStrategy.is = is;\r\n})(CancellationReceiverStrategy || (exports.CancellationReceiverStrategy = CancellationReceiverStrategy = {}));\r\nvar CancellationSenderStrategy;\r\n(function (CancellationSenderStrategy) {\r\n    CancellationSenderStrategy.Message = Object.freeze({\r\n        sendCancellation(conn, id) {\r\n            return conn.sendNotification(CancelNotification.type, { id });\r\n        },\r\n        cleanup(_) { }\r\n    });\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);\r\n    }\r\n    CancellationSenderStrategy.is = is;\r\n})(CancellationSenderStrategy || (exports.CancellationSenderStrategy = CancellationSenderStrategy = {}));\r\nvar CancellationStrategy;\r\n(function (CancellationStrategy) {\r\n    CancellationStrategy.Message = Object.freeze({\r\n        receiver: CancellationReceiverStrategy.Message,\r\n        sender: CancellationSenderStrategy.Message\r\n    });\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);\r\n    }\r\n    CancellationStrategy.is = is;\r\n})(CancellationStrategy || (exports.CancellationStrategy = CancellationStrategy = {}));\r\nvar MessageStrategy;\r\n(function (MessageStrategy) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && Is.func(candidate.handleMessage);\r\n    }\r\n    MessageStrategy.is = is;\r\n})(MessageStrategy || (exports.MessageStrategy = MessageStrategy = {}));\r\nvar ConnectionOptions;\r\n(function (ConnectionOptions) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy) || MessageStrategy.is(candidate.messageStrategy));\r\n    }\r\n    ConnectionOptions.is = is;\r\n})(ConnectionOptions || (exports.ConnectionOptions = ConnectionOptions = {}));\r\nvar ConnectionState;\r\n(function (ConnectionState) {\r\n    ConnectionState[ConnectionState[\"New\"] = 1] = \"New\";\r\n    ConnectionState[ConnectionState[\"Listening\"] = 2] = \"Listening\";\r\n    ConnectionState[ConnectionState[\"Closed\"] = 3] = \"Closed\";\r\n    ConnectionState[ConnectionState[\"Disposed\"] = 4] = \"Disposed\";\r\n})(ConnectionState || (ConnectionState = {}));\r\nfunction createMessageConnection(messageReader, messageWriter, _logger, options) {\r\n    const logger = _logger !== undefined ? _logger : exports.NullLogger;\r\n    let sequenceNumber = 0;\r\n    let notificationSequenceNumber = 0;\r\n    let unknownResponseSequenceNumber = 0;\r\n    const version = '2.0';\r\n    let starRequestHandler = undefined;\r\n    const requestHandlers = new Map();\r\n    let starNotificationHandler = undefined;\r\n    const notificationHandlers = new Map();\r\n    const progressHandlers = new Map();\r\n    let timer;\r\n    let messageQueue = new linkedMap_1.LinkedMap();\r\n    let responsePromises = new Map();\r\n    let knownCanceledRequests = new Set();\r\n    let requestTokens = new Map();\r\n    let trace = Trace.Off;\r\n    let traceFormat = TraceFormat.Text;\r\n    let tracer;\r\n    let state = ConnectionState.New;\r\n    const errorEmitter = new events_1.Emitter();\r\n    const closeEmitter = new events_1.Emitter();\r\n    const unhandledNotificationEmitter = new events_1.Emitter();\r\n    const unhandledProgressEmitter = new events_1.Emitter();\r\n    const disposeEmitter = new events_1.Emitter();\r\n    const cancellationStrategy = (options && options.cancellationStrategy) ? options.cancellationStrategy : CancellationStrategy.Message;\r\n    function createRequestQueueKey(id) {\r\n        if (id === null) {\r\n            throw new Error(`Can't send requests with id null since the response can't be correlated.`);\r\n        }\r\n        return 'req-' + id.toString();\r\n    }\r\n    function createResponseQueueKey(id) {\r\n        if (id === null) {\r\n            return 'res-unknown-' + (++unknownResponseSequenceNumber).toString();\r\n        }\r\n        else {\r\n            return 'res-' + id.toString();\r\n        }\r\n    }\r\n    function createNotificationQueueKey() {\r\n        return 'not-' + (++notificationSequenceNumber).toString();\r\n    }\r\n    function addMessageToQueue(queue, message) {\r\n        if (messages_1.Message.isRequest(message)) {\r\n            queue.set(createRequestQueueKey(message.id), message);\r\n        }\r\n        else if (messages_1.Message.isResponse(message)) {\r\n            queue.set(createResponseQueueKey(message.id), message);\r\n        }\r\n        else {\r\n            queue.set(createNotificationQueueKey(), message);\r\n        }\r\n    }\r\n    function cancelUndispatched(_message) {\r\n        return undefined;\r\n    }\r\n    function isListening() {\r\n        return state === ConnectionState.Listening;\r\n    }\r\n    function isClosed() {\r\n        return state === ConnectionState.Closed;\r\n    }\r\n    function isDisposed() {\r\n        return state === ConnectionState.Disposed;\r\n    }\r\n    function closeHandler() {\r\n        if (state === ConnectionState.New || state === ConnectionState.Listening) {\r\n            state = ConnectionState.Closed;\r\n            closeEmitter.fire(undefined);\r\n        }\r\n        // If the connection is disposed don't sent close events.\r\n    }\r\n    function readErrorHandler(error) {\r\n        errorEmitter.fire([error, undefined, undefined]);\r\n    }\r\n    function writeErrorHandler(data) {\r\n        errorEmitter.fire(data);\r\n    }\r\n    messageReader.onClose(closeHandler);\r\n    messageReader.onError(readErrorHandler);\r\n    messageWriter.onClose(closeHandler);\r\n    messageWriter.onError(writeErrorHandler);\r\n    function triggerMessageQueue() {\r\n        if (timer || messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        timer = (0, ral_1.default)().timer.setImmediate(() => {\r\n            timer = undefined;\r\n            processMessageQueue();\r\n        });\r\n    }\r\n    function handleMessage(message) {\r\n        if (messages_1.Message.isRequest(message)) {\r\n            handleRequest(message);\r\n        }\r\n        else if (messages_1.Message.isNotification(message)) {\r\n            handleNotification(message);\r\n        }\r\n        else if (messages_1.Message.isResponse(message)) {\r\n            handleResponse(message);\r\n        }\r\n        else {\r\n            handleInvalidMessage(message);\r\n        }\r\n    }\r\n    function processMessageQueue() {\r\n        if (messageQueue.size === 0) {\r\n            return;\r\n        }\r\n        const message = messageQueue.shift();\r\n        try {\r\n            const messageStrategy = options?.messageStrategy;\r\n            if (MessageStrategy.is(messageStrategy)) {\r\n                messageStrategy.handleMessage(message, handleMessage);\r\n            }\r\n            else {\r\n                handleMessage(message);\r\n            }\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    }\r\n    const callback = (message) => {\r\n        try {\r\n            // We have received a cancellation message. Check if the message is still in the queue\r\n            // and cancel it if allowed to do so.\r\n            if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {\r\n                const cancelId = message.params.id;\r\n                const key = createRequestQueueKey(cancelId);\r\n                const toCancel = messageQueue.get(key);\r\n                if (messages_1.Message.isRequest(toCancel)) {\r\n                    const strategy = options?.connectionStrategy;\r\n                    const response = (strategy && strategy.cancelUndispatched) ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);\r\n                    if (response && (response.error !== undefined || response.result !== undefined)) {\r\n                        messageQueue.delete(key);\r\n                        requestTokens.delete(cancelId);\r\n                        response.id = toCancel.id;\r\n                        traceSendingResponse(response, message.method, Date.now());\r\n                        messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));\r\n                        return;\r\n                    }\r\n                }\r\n                const cancellationToken = requestTokens.get(cancelId);\r\n                // The request is already running. Cancel the token\r\n                if (cancellationToken !== undefined) {\r\n                    cancellationToken.cancel();\r\n                    traceReceivedNotification(message);\r\n                    return;\r\n                }\r\n                else {\r\n                    // Remember the cancel but still queue the message to\r\n                    // clean up state in process message.\r\n                    knownCanceledRequests.add(cancelId);\r\n                }\r\n            }\r\n            addMessageToQueue(messageQueue, message);\r\n        }\r\n        finally {\r\n            triggerMessageQueue();\r\n        }\r\n    };\r\n    function handleRequest(requestMessage) {\r\n        if (isDisposed()) {\r\n            // we return here silently since we fired an event when the\r\n            // connection got disposed.\r\n            return;\r\n        }\r\n        function reply(resultOrError, method, startTime) {\r\n            const message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id\r\n            };\r\n            if (resultOrError instanceof messages_1.ResponseError) {\r\n                message.error = resultOrError.toJson();\r\n            }\r\n            else {\r\n                message.result = resultOrError === undefined ? null : resultOrError;\r\n            }\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\r\n        }\r\n        function replyError(error, method, startTime) {\r\n            const message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                error: error.toJson()\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\r\n        }\r\n        function replySuccess(result, method, startTime) {\r\n            // The JSON RPC defines that a response must either have a result or an error\r\n            // So we can't treat undefined as a valid response result.\r\n            if (result === undefined) {\r\n                result = null;\r\n            }\r\n            const message = {\r\n                jsonrpc: version,\r\n                id: requestMessage.id,\r\n                result: result\r\n            };\r\n            traceSendingResponse(message, method, startTime);\r\n            messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));\r\n        }\r\n        traceReceivedRequest(requestMessage);\r\n        const element = requestHandlers.get(requestMessage.method);\r\n        let type;\r\n        let requestHandler;\r\n        if (element) {\r\n            type = element.type;\r\n            requestHandler = element.handler;\r\n        }\r\n        const startTime = Date.now();\r\n        if (requestHandler || starRequestHandler) {\r\n            const tokenKey = requestMessage.id ?? String(Date.now()); //\r\n            const cancellationSource = IdCancellationReceiverStrategy.is(cancellationStrategy.receiver)\r\n                ? cancellationStrategy.receiver.createCancellationTokenSource(tokenKey)\r\n                : cancellationStrategy.receiver.createCancellationTokenSource(requestMessage);\r\n            if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {\r\n                cancellationSource.cancel();\r\n            }\r\n            if (requestMessage.id !== null) {\r\n                requestTokens.set(tokenKey, cancellationSource);\r\n            }\r\n            try {\r\n                let handlerResult;\r\n                if (requestHandler) {\r\n                    if (requestMessage.params === undefined) {\r\n                        if (type !== undefined && type.numberOfParams !== 0) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);\r\n                            return;\r\n                        }\r\n                        handlerResult = requestHandler(cancellationSource.token);\r\n                    }\r\n                    else if (Array.isArray(requestMessage.params)) {\r\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byName) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);\r\n                            return;\r\n                        }\r\n                        handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);\r\n                    }\r\n                    else {\r\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);\r\n                            return;\r\n                        }\r\n                        handlerResult = requestHandler(requestMessage.params, cancellationSource.token);\r\n                    }\r\n                }\r\n                else if (starRequestHandler) {\r\n                    handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);\r\n                }\r\n                const promise = handlerResult;\r\n                if (!handlerResult) {\r\n                    requestTokens.delete(tokenKey);\r\n                    replySuccess(handlerResult, requestMessage.method, startTime);\r\n                }\r\n                else if (promise.then) {\r\n                    promise.then((resultOrError) => {\r\n                        requestTokens.delete(tokenKey);\r\n                        reply(resultOrError, requestMessage.method, startTime);\r\n                    }, error => {\r\n                        requestTokens.delete(tokenKey);\r\n                        if (error instanceof messages_1.ResponseError) {\r\n                            replyError(error, requestMessage.method, startTime);\r\n                        }\r\n                        else if (error && Is.string(error.message)) {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                        }\r\n                        else {\r\n                            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                        }\r\n                    });\r\n                }\r\n                else {\r\n                    requestTokens.delete(tokenKey);\r\n                    reply(handlerResult, requestMessage.method, startTime);\r\n                }\r\n            }\r\n            catch (error) {\r\n                requestTokens.delete(tokenKey);\r\n                if (error instanceof messages_1.ResponseError) {\r\n                    reply(error, requestMessage.method, startTime);\r\n                }\r\n                else if (error && Is.string(error.message)) {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);\r\n                }\r\n                else {\r\n                    replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);\r\n        }\r\n    }\r\n    function handleResponse(responseMessage) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        if (responseMessage.id === null) {\r\n            if (responseMessage.error) {\r\n                logger.error(`Received response message without id: Error is: \\n${JSON.stringify(responseMessage.error, undefined, 4)}`);\r\n            }\r\n            else {\r\n                logger.error(`Received response message without id. No further error information provided.`);\r\n            }\r\n        }\r\n        else {\r\n            const key = responseMessage.id;\r\n            const responsePromise = responsePromises.get(key);\r\n            traceReceivedResponse(responseMessage, responsePromise);\r\n            if (responsePromise !== undefined) {\r\n                responsePromises.delete(key);\r\n                try {\r\n                    if (responseMessage.error) {\r\n                        const error = responseMessage.error;\r\n                        responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));\r\n                    }\r\n                    else if (responseMessage.result !== undefined) {\r\n                        responsePromise.resolve(responseMessage.result);\r\n                    }\r\n                    else {\r\n                        throw new Error('Should never happen.');\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    if (error.message) {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);\r\n                    }\r\n                    else {\r\n                        logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function handleNotification(message) {\r\n        if (isDisposed()) {\r\n            // See handle request.\r\n            return;\r\n        }\r\n        let type = undefined;\r\n        let notificationHandler;\r\n        if (message.method === CancelNotification.type.method) {\r\n            const cancelId = message.params.id;\r\n            knownCanceledRequests.delete(cancelId);\r\n            traceReceivedNotification(message);\r\n            return;\r\n        }\r\n        else {\r\n            const element = notificationHandlers.get(message.method);\r\n            if (element) {\r\n                notificationHandler = element.handler;\r\n                type = element.type;\r\n            }\r\n        }\r\n        if (notificationHandler || starNotificationHandler) {\r\n            try {\r\n                traceReceivedNotification(message);\r\n                if (notificationHandler) {\r\n                    if (message.params === undefined) {\r\n                        if (type !== undefined) {\r\n                            if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {\r\n                                logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);\r\n                            }\r\n                        }\r\n                        notificationHandler();\r\n                    }\r\n                    else if (Array.isArray(message.params)) {\r\n                        // There are JSON-RPC libraries that send progress message as positional params although\r\n                        // specified as named. So convert them if this is the case.\r\n                        const params = message.params;\r\n                        if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {\r\n                            notificationHandler({ token: params[0], value: params[1] });\r\n                        }\r\n                        else {\r\n                            if (type !== undefined) {\r\n                                if (type.parameterStructures === messages_1.ParameterStructures.byName) {\r\n                                    logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);\r\n                                }\r\n                                if (type.numberOfParams !== message.params.length) {\r\n                                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);\r\n                                }\r\n                            }\r\n                            notificationHandler(...params);\r\n                        }\r\n                    }\r\n                    else {\r\n                        if (type !== undefined && type.parameterStructures === messages_1.ParameterStructures.byPosition) {\r\n                            logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);\r\n                        }\r\n                        notificationHandler(message.params);\r\n                    }\r\n                }\r\n                else if (starNotificationHandler) {\r\n                    starNotificationHandler(message.method, message.params);\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error.message) {\r\n                    logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);\r\n                }\r\n                else {\r\n                    logger.error(`Notification handler '${message.method}' failed unexpectedly.`);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            unhandledNotificationEmitter.fire(message);\r\n        }\r\n    }\r\n    function handleInvalidMessage(message) {\r\n        if (!message) {\r\n            logger.error('Received empty message.');\r\n            return;\r\n        }\r\n        logger.error(`Received message which is neither a response nor a notification message:\\n${JSON.stringify(message, null, 4)}`);\r\n        // Test whether we find an id to reject the promise\r\n        const responseMessage = message;\r\n        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {\r\n            const key = responseMessage.id;\r\n            const responseHandler = responsePromises.get(key);\r\n            if (responseHandler) {\r\n                responseHandler.reject(new Error('The received response has neither a result nor an error property.'));\r\n            }\r\n        }\r\n    }\r\n    function stringifyTrace(params) {\r\n        if (params === undefined || params === null) {\r\n            return undefined;\r\n        }\r\n        switch (trace) {\r\n            case Trace.Verbose:\r\n                return JSON.stringify(params, null, 4);\r\n            case Trace.Compact:\r\n                return JSON.stringify(params);\r\n            default:\r\n                return undefined;\r\n        }\r\n    }\r\n    function traceSendingRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\r\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\r\n            }\r\n            tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-request', message);\r\n        }\r\n    }\r\n    function traceSendingNotification(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\r\n                if (message.params) {\r\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Sending notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-notification', message);\r\n        }\r\n    }\r\n    function traceSendingResponse(message, method, startTime) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === undefined) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('send-response', message);\r\n        }\r\n    }\r\n    function traceReceivedRequest(message) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {\r\n                data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\r\n            }\r\n            tracer.log(`Received request '${message.method} - (${message.id})'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-request', message);\r\n        }\r\n    }\r\n    function traceReceivedNotification(message) {\r\n        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\r\n                if (message.params) {\r\n                    data = `Params: ${stringifyTrace(message.params)}\\n\\n`;\r\n                }\r\n                else {\r\n                    data = 'No parameters provided.\\n\\n';\r\n                }\r\n            }\r\n            tracer.log(`Received notification '${message.method}'.`, data);\r\n        }\r\n        else {\r\n            logLSPMessage('receive-notification', message);\r\n        }\r\n    }\r\n    function traceReceivedResponse(message, responsePromise) {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        if (traceFormat === TraceFormat.Text) {\r\n            let data = undefined;\r\n            if (trace === Trace.Verbose || trace === Trace.Compact) {\r\n                if (message.error && message.error.data) {\r\n                    data = `Error data: ${stringifyTrace(message.error.data)}\\n\\n`;\r\n                }\r\n                else {\r\n                    if (message.result) {\r\n                        data = `Result: ${stringifyTrace(message.result)}\\n\\n`;\r\n                    }\r\n                    else if (message.error === undefined) {\r\n                        data = 'No result returned.\\n\\n';\r\n                    }\r\n                }\r\n            }\r\n            if (responsePromise) {\r\n                const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : '';\r\n                tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);\r\n            }\r\n            else {\r\n                tracer.log(`Received response ${message.id} without active response promise.`, data);\r\n            }\r\n        }\r\n        else {\r\n            logLSPMessage('receive-response', message);\r\n        }\r\n    }\r\n    function logLSPMessage(type, message) {\r\n        if (!tracer || trace === Trace.Off) {\r\n            return;\r\n        }\r\n        const lspMessage = {\r\n            isLSPMessage: true,\r\n            type,\r\n            message,\r\n            timestamp: Date.now()\r\n        };\r\n        tracer.log(lspMessage);\r\n    }\r\n    function throwIfClosedOrDisposed() {\r\n        if (isClosed()) {\r\n            throw new ConnectionError(ConnectionErrors.Closed, 'Connection is closed.');\r\n        }\r\n        if (isDisposed()) {\r\n            throw new ConnectionError(ConnectionErrors.Disposed, 'Connection is disposed.');\r\n        }\r\n    }\r\n    function throwIfListening() {\r\n        if (isListening()) {\r\n            throw new ConnectionError(ConnectionErrors.AlreadyListening, 'Connection is already listening');\r\n        }\r\n    }\r\n    function throwIfNotListening() {\r\n        if (!isListening()) {\r\n            throw new Error('Call listen() first.');\r\n        }\r\n    }\r\n    function undefinedToNull(param) {\r\n        if (param === undefined) {\r\n            return null;\r\n        }\r\n        else {\r\n            return param;\r\n        }\r\n    }\r\n    function nullToUndefined(param) {\r\n        if (param === null) {\r\n            return undefined;\r\n        }\r\n        else {\r\n            return param;\r\n        }\r\n    }\r\n    function isNamedParam(param) {\r\n        return param !== undefined && param !== null && !Array.isArray(param) && typeof param === 'object';\r\n    }\r\n    function computeSingleParam(parameterStructures, param) {\r\n        switch (parameterStructures) {\r\n            case messages_1.ParameterStructures.auto:\r\n                if (isNamedParam(param)) {\r\n                    return nullToUndefined(param);\r\n                }\r\n                else {\r\n                    return [undefinedToNull(param)];\r\n                }\r\n            case messages_1.ParameterStructures.byName:\r\n                if (!isNamedParam(param)) {\r\n                    throw new Error(`Received parameters by name but param is not an object literal.`);\r\n                }\r\n                return nullToUndefined(param);\r\n            case messages_1.ParameterStructures.byPosition:\r\n                return [undefinedToNull(param)];\r\n            default:\r\n                throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);\r\n        }\r\n    }\r\n    function computeMessageParams(type, params) {\r\n        let result;\r\n        const numberOfParams = type.numberOfParams;\r\n        switch (numberOfParams) {\r\n            case 0:\r\n                result = undefined;\r\n                break;\r\n            case 1:\r\n                result = computeSingleParam(type.parameterStructures, params[0]);\r\n                break;\r\n            default:\r\n                result = [];\r\n                for (let i = 0; i < params.length && i < numberOfParams; i++) {\r\n                    result.push(undefinedToNull(params[i]));\r\n                }\r\n                if (params.length < numberOfParams) {\r\n                    for (let i = params.length; i < numberOfParams; i++) {\r\n                        result.push(null);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        return result;\r\n    }\r\n    const connection = {\r\n        sendNotification: (type, ...args) => {\r\n            throwIfClosedOrDisposed();\r\n            let method;\r\n            let messageParams;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                const first = args[0];\r\n                let paramStart = 0;\r\n                let parameterStructures = messages_1.ParameterStructures.auto;\r\n                if (messages_1.ParameterStructures.is(first)) {\r\n                    paramStart = 1;\r\n                    parameterStructures = first;\r\n                }\r\n                let paramEnd = args.length;\r\n                const numberOfParams = paramEnd - paramStart;\r\n                switch (numberOfParams) {\r\n                    case 0:\r\n                        messageParams = undefined;\r\n                        break;\r\n                    case 1:\r\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\r\n                        break;\r\n                    default:\r\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\r\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);\r\n                        }\r\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                const params = args;\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n            }\r\n            const notificationMessage = {\r\n                jsonrpc: version,\r\n                method: method,\r\n                params: messageParams\r\n            };\r\n            traceSendingNotification(notificationMessage);\r\n            return messageWriter.write(notificationMessage).catch((error) => {\r\n                logger.error(`Sending notification failed.`);\r\n                throw error;\r\n            });\r\n        },\r\n        onNotification: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            let method;\r\n            if (Is.func(type)) {\r\n                starNotificationHandler = type;\r\n            }\r\n            else if (handler) {\r\n                if (Is.string(type)) {\r\n                    method = type;\r\n                    notificationHandlers.set(type, { type: undefined, handler });\r\n                }\r\n                else {\r\n                    method = type.method;\r\n                    notificationHandlers.set(type.method, { type, handler });\r\n                }\r\n            }\r\n            return {\r\n                dispose: () => {\r\n                    if (method !== undefined) {\r\n                        notificationHandlers.delete(method);\r\n                    }\r\n                    else {\r\n                        starNotificationHandler = undefined;\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        onProgress: (_type, token, handler) => {\r\n            if (progressHandlers.has(token)) {\r\n                throw new Error(`Progress handler for token ${token} already registered`);\r\n            }\r\n            progressHandlers.set(token, handler);\r\n            return {\r\n                dispose: () => {\r\n                    progressHandlers.delete(token);\r\n                }\r\n            };\r\n        },\r\n        sendProgress: (_type, token, value) => {\r\n            // This should not await but simple return to ensure that we don't have another\r\n            // async scheduling. Otherwise one send could overtake another send.\r\n            return connection.sendNotification(ProgressNotification.type, { token, value });\r\n        },\r\n        onUnhandledProgress: unhandledProgressEmitter.event,\r\n        sendRequest: (type, ...args) => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfNotListening();\r\n            let method;\r\n            let messageParams;\r\n            let token = undefined;\r\n            if (Is.string(type)) {\r\n                method = type;\r\n                const first = args[0];\r\n                const last = args[args.length - 1];\r\n                let paramStart = 0;\r\n                let parameterStructures = messages_1.ParameterStructures.auto;\r\n                if (messages_1.ParameterStructures.is(first)) {\r\n                    paramStart = 1;\r\n                    parameterStructures = first;\r\n                }\r\n                let paramEnd = args.length;\r\n                if (cancellation_1.CancellationToken.is(last)) {\r\n                    paramEnd = paramEnd - 1;\r\n                    token = last;\r\n                }\r\n                const numberOfParams = paramEnd - paramStart;\r\n                switch (numberOfParams) {\r\n                    case 0:\r\n                        messageParams = undefined;\r\n                        break;\r\n                    case 1:\r\n                        messageParams = computeSingleParam(parameterStructures, args[paramStart]);\r\n                        break;\r\n                    default:\r\n                        if (parameterStructures === messages_1.ParameterStructures.byName) {\r\n                            throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);\r\n                        }\r\n                        messageParams = args.slice(paramStart, paramEnd).map(value => undefinedToNull(value));\r\n                        break;\r\n                }\r\n            }\r\n            else {\r\n                const params = args;\r\n                method = type.method;\r\n                messageParams = computeMessageParams(type, params);\r\n                const numberOfParams = type.numberOfParams;\r\n                token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : undefined;\r\n            }\r\n            const id = sequenceNumber++;\r\n            let disposable;\r\n            if (token) {\r\n                disposable = token.onCancellationRequested(() => {\r\n                    const p = cancellationStrategy.sender.sendCancellation(connection, id);\r\n                    if (p === undefined) {\r\n                        logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);\r\n                        return Promise.resolve();\r\n                    }\r\n                    else {\r\n                        return p.catch(() => {\r\n                            logger.log(`Sending cancellation messages for id ${id} failed`);\r\n                        });\r\n                    }\r\n                });\r\n            }\r\n            const requestMessage = {\r\n                jsonrpc: version,\r\n                id: id,\r\n                method: method,\r\n                params: messageParams\r\n            };\r\n            traceSendingRequest(requestMessage);\r\n            if (typeof cancellationStrategy.sender.enableCancellation === 'function') {\r\n                cancellationStrategy.sender.enableCancellation(requestMessage);\r\n            }\r\n            return new Promise(async (resolve, reject) => {\r\n                const resolveWithCleanup = (r) => {\r\n                    resolve(r);\r\n                    cancellationStrategy.sender.cleanup(id);\r\n                    disposable?.dispose();\r\n                };\r\n                const rejectWithCleanup = (r) => {\r\n                    reject(r);\r\n                    cancellationStrategy.sender.cleanup(id);\r\n                    disposable?.dispose();\r\n                };\r\n                const responsePromise = { method: method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };\r\n                try {\r\n                    await messageWriter.write(requestMessage);\r\n                    responsePromises.set(id, responsePromise);\r\n                }\r\n                catch (error) {\r\n                    logger.error(`Sending request failed.`);\r\n                    // Writing the message failed. So we need to reject the promise.\r\n                    responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, error.message ? error.message : 'Unknown reason'));\r\n                    throw error;\r\n                }\r\n            });\r\n        },\r\n        onRequest: (type, handler) => {\r\n            throwIfClosedOrDisposed();\r\n            let method = null;\r\n            if (StarRequestHandler.is(type)) {\r\n                method = undefined;\r\n                starRequestHandler = type;\r\n            }\r\n            else if (Is.string(type)) {\r\n                method = null;\r\n                if (handler !== undefined) {\r\n                    method = type;\r\n                    requestHandlers.set(type, { handler: handler, type: undefined });\r\n                }\r\n            }\r\n            else {\r\n                if (handler !== undefined) {\r\n                    method = type.method;\r\n                    requestHandlers.set(type.method, { type, handler });\r\n                }\r\n            }\r\n            return {\r\n                dispose: () => {\r\n                    if (method === null) {\r\n                        return;\r\n                    }\r\n                    if (method !== undefined) {\r\n                        requestHandlers.delete(method);\r\n                    }\r\n                    else {\r\n                        starRequestHandler = undefined;\r\n                    }\r\n                }\r\n            };\r\n        },\r\n        hasPendingResponse: () => {\r\n            return responsePromises.size > 0;\r\n        },\r\n        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {\r\n            let _sendNotification = false;\r\n            let _traceFormat = TraceFormat.Text;\r\n            if (sendNotificationOrTraceOptions !== undefined) {\r\n                if (Is.boolean(sendNotificationOrTraceOptions)) {\r\n                    _sendNotification = sendNotificationOrTraceOptions;\r\n                }\r\n                else {\r\n                    _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;\r\n                    _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;\r\n                }\r\n            }\r\n            trace = _value;\r\n            traceFormat = _traceFormat;\r\n            if (trace === Trace.Off) {\r\n                tracer = undefined;\r\n            }\r\n            else {\r\n                tracer = _tracer;\r\n            }\r\n            if (_sendNotification && !isClosed() && !isDisposed()) {\r\n                await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });\r\n            }\r\n        },\r\n        onError: errorEmitter.event,\r\n        onClose: closeEmitter.event,\r\n        onUnhandledNotification: unhandledNotificationEmitter.event,\r\n        onDispose: disposeEmitter.event,\r\n        end: () => {\r\n            messageWriter.end();\r\n        },\r\n        dispose: () => {\r\n            if (isDisposed()) {\r\n                return;\r\n            }\r\n            state = ConnectionState.Disposed;\r\n            disposeEmitter.fire(undefined);\r\n            const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, 'Pending response rejected since connection got disposed');\r\n            for (const promise of responsePromises.values()) {\r\n                promise.reject(error);\r\n            }\r\n            responsePromises = new Map();\r\n            requestTokens = new Map();\r\n            knownCanceledRequests = new Set();\r\n            messageQueue = new linkedMap_1.LinkedMap();\r\n            // Test for backwards compatibility\r\n            if (Is.func(messageWriter.dispose)) {\r\n                messageWriter.dispose();\r\n            }\r\n            if (Is.func(messageReader.dispose)) {\r\n                messageReader.dispose();\r\n            }\r\n        },\r\n        listen: () => {\r\n            throwIfClosedOrDisposed();\r\n            throwIfListening();\r\n            state = ConnectionState.Listening;\r\n            messageReader.listen(callback);\r\n        },\r\n        inspect: () => {\r\n            // eslint-disable-next-line no-console\r\n            (0, ral_1.default)().console.log('inspect');\r\n        }\r\n    };\r\n    connection.onNotification(LogTraceNotification.type, (params) => {\r\n        if (trace === Trace.Off || !tracer) {\r\n            return;\r\n        }\r\n        const verbose = trace === Trace.Verbose || trace === Trace.Compact;\r\n        tracer.log(params.message, verbose ? params.verbose : undefined);\r\n    });\r\n    connection.onNotification(ProgressNotification.type, (params) => {\r\n        const handler = progressHandlers.get(params.token);\r\n        if (handler) {\r\n            handler(params.value);\r\n        }\r\n        else {\r\n            unhandledProgressEmitter.fire(params);\r\n        }\r\n    });\r\n    return connection;\r\n}\r\nexports.createMessageConnection = createMessageConnection;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n/// <reference path=\"../../typings/thenable.d.ts\" />\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProgressType = exports.ProgressToken = exports.createMessageConnection = exports.NullLogger = exports.ConnectionOptions = exports.ConnectionStrategy = exports.AbstractMessageBuffer = exports.WriteableStreamMessageWriter = exports.AbstractMessageWriter = exports.MessageWriter = exports.ReadableStreamMessageReader = exports.AbstractMessageReader = exports.MessageReader = exports.SharedArrayReceiverStrategy = exports.SharedArraySenderStrategy = exports.CancellationToken = exports.CancellationTokenSource = exports.Emitter = exports.Event = exports.Disposable = exports.LRUCache = exports.Touch = exports.LinkedMap = exports.ParameterStructures = exports.NotificationType9 = exports.NotificationType8 = exports.NotificationType7 = exports.NotificationType6 = exports.NotificationType5 = exports.NotificationType4 = exports.NotificationType3 = exports.NotificationType2 = exports.NotificationType1 = exports.NotificationType0 = exports.NotificationType = exports.ErrorCodes = exports.ResponseError = exports.RequestType9 = exports.RequestType8 = exports.RequestType7 = exports.RequestType6 = exports.RequestType5 = exports.RequestType4 = exports.RequestType3 = exports.RequestType2 = exports.RequestType1 = exports.RequestType0 = exports.RequestType = exports.Message = exports.RAL = void 0;\r\nexports.MessageStrategy = exports.CancellationStrategy = exports.CancellationSenderStrategy = exports.CancellationReceiverStrategy = exports.ConnectionError = exports.ConnectionErrors = exports.LogTraceNotification = exports.SetTraceNotification = exports.TraceFormat = exports.TraceValues = exports.Trace = void 0;\r\nconst messages_1 = require(\"./messages\");\r\nObject.defineProperty(exports, \"Message\", { enumerable: true, get: function () { return messages_1.Message; } });\r\nObject.defineProperty(exports, \"RequestType\", { enumerable: true, get: function () { return messages_1.RequestType; } });\r\nObject.defineProperty(exports, \"RequestType0\", { enumerable: true, get: function () { return messages_1.RequestType0; } });\r\nObject.defineProperty(exports, \"RequestType1\", { enumerable: true, get: function () { return messages_1.RequestType1; } });\r\nObject.defineProperty(exports, \"RequestType2\", { enumerable: true, get: function () { return messages_1.RequestType2; } });\r\nObject.defineProperty(exports, \"RequestType3\", { enumerable: true, get: function () { return messages_1.RequestType3; } });\r\nObject.defineProperty(exports, \"RequestType4\", { enumerable: true, get: function () { return messages_1.RequestType4; } });\r\nObject.defineProperty(exports, \"RequestType5\", { enumerable: true, get: function () { return messages_1.RequestType5; } });\r\nObject.defineProperty(exports, \"RequestType6\", { enumerable: true, get: function () { return messages_1.RequestType6; } });\r\nObject.defineProperty(exports, \"RequestType7\", { enumerable: true, get: function () { return messages_1.RequestType7; } });\r\nObject.defineProperty(exports, \"RequestType8\", { enumerable: true, get: function () { return messages_1.RequestType8; } });\r\nObject.defineProperty(exports, \"RequestType9\", { enumerable: true, get: function () { return messages_1.RequestType9; } });\r\nObject.defineProperty(exports, \"ResponseError\", { enumerable: true, get: function () { return messages_1.ResponseError; } });\r\nObject.defineProperty(exports, \"ErrorCodes\", { enumerable: true, get: function () { return messages_1.ErrorCodes; } });\r\nObject.defineProperty(exports, \"NotificationType\", { enumerable: true, get: function () { return messages_1.NotificationType; } });\r\nObject.defineProperty(exports, \"NotificationType0\", { enumerable: true, get: function () { return messages_1.NotificationType0; } });\r\nObject.defineProperty(exports, \"NotificationType1\", { enumerable: true, get: function () { return messages_1.NotificationType1; } });\r\nObject.defineProperty(exports, \"NotificationType2\", { enumerable: true, get: function () { return messages_1.NotificationType2; } });\r\nObject.defineProperty(exports, \"NotificationType3\", { enumerable: true, get: function () { return messages_1.NotificationType3; } });\r\nObject.defineProperty(exports, \"NotificationType4\", { enumerable: true, get: function () { return messages_1.NotificationType4; } });\r\nObject.defineProperty(exports, \"NotificationType5\", { enumerable: true, get: function () { return messages_1.NotificationType5; } });\r\nObject.defineProperty(exports, \"NotificationType6\", { enumerable: true, get: function () { return messages_1.NotificationType6; } });\r\nObject.defineProperty(exports, \"NotificationType7\", { enumerable: true, get: function () { return messages_1.NotificationType7; } });\r\nObject.defineProperty(exports, \"NotificationType8\", { enumerable: true, get: function () { return messages_1.NotificationType8; } });\r\nObject.defineProperty(exports, \"NotificationType9\", { enumerable: true, get: function () { return messages_1.NotificationType9; } });\r\nObject.defineProperty(exports, \"ParameterStructures\", { enumerable: true, get: function () { return messages_1.ParameterStructures; } });\r\nconst linkedMap_1 = require(\"./linkedMap\");\r\nObject.defineProperty(exports, \"LinkedMap\", { enumerable: true, get: function () { return linkedMap_1.LinkedMap; } });\r\nObject.defineProperty(exports, \"LRUCache\", { enumerable: true, get: function () { return linkedMap_1.LRUCache; } });\r\nObject.defineProperty(exports, \"Touch\", { enumerable: true, get: function () { return linkedMap_1.Touch; } });\r\nconst disposable_1 = require(\"./disposable\");\r\nObject.defineProperty(exports, \"Disposable\", { enumerable: true, get: function () { return disposable_1.Disposable; } });\r\nconst events_1 = require(\"./events\");\r\nObject.defineProperty(exports, \"Event\", { enumerable: true, get: function () { return events_1.Event; } });\r\nObject.defineProperty(exports, \"Emitter\", { enumerable: true, get: function () { return events_1.Emitter; } });\r\nconst cancellation_1 = require(\"./cancellation\");\r\nObject.defineProperty(exports, \"CancellationTokenSource\", { enumerable: true, get: function () { return cancellation_1.CancellationTokenSource; } });\r\nObject.defineProperty(exports, \"CancellationToken\", { enumerable: true, get: function () { return cancellation_1.CancellationToken; } });\r\nconst sharedArrayCancellation_1 = require(\"./sharedArrayCancellation\");\r\nObject.defineProperty(exports, \"SharedArraySenderStrategy\", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArraySenderStrategy; } });\r\nObject.defineProperty(exports, \"SharedArrayReceiverStrategy\", { enumerable: true, get: function () { return sharedArrayCancellation_1.SharedArrayReceiverStrategy; } });\r\nconst messageReader_1 = require(\"./messageReader\");\r\nObject.defineProperty(exports, \"MessageReader\", { enumerable: true, get: function () { return messageReader_1.MessageReader; } });\r\nObject.defineProperty(exports, \"AbstractMessageReader\", { enumerable: true, get: function () { return messageReader_1.AbstractMessageReader; } });\r\nObject.defineProperty(exports, \"ReadableStreamMessageReader\", { enumerable: true, get: function () { return messageReader_1.ReadableStreamMessageReader; } });\r\nconst messageWriter_1 = require(\"./messageWriter\");\r\nObject.defineProperty(exports, \"MessageWriter\", { enumerable: true, get: function () { return messageWriter_1.MessageWriter; } });\r\nObject.defineProperty(exports, \"AbstractMessageWriter\", { enumerable: true, get: function () { return messageWriter_1.AbstractMessageWriter; } });\r\nObject.defineProperty(exports, \"WriteableStreamMessageWriter\", { enumerable: true, get: function () { return messageWriter_1.WriteableStreamMessageWriter; } });\r\nconst messageBuffer_1 = require(\"./messageBuffer\");\r\nObject.defineProperty(exports, \"AbstractMessageBuffer\", { enumerable: true, get: function () { return messageBuffer_1.AbstractMessageBuffer; } });\r\nconst connection_1 = require(\"./connection\");\r\nObject.defineProperty(exports, \"ConnectionStrategy\", { enumerable: true, get: function () { return connection_1.ConnectionStrategy; } });\r\nObject.defineProperty(exports, \"ConnectionOptions\", { enumerable: true, get: function () { return connection_1.ConnectionOptions; } });\r\nObject.defineProperty(exports, \"NullLogger\", { enumerable: true, get: function () { return connection_1.NullLogger; } });\r\nObject.defineProperty(exports, \"createMessageConnection\", { enumerable: true, get: function () { return connection_1.createMessageConnection; } });\r\nObject.defineProperty(exports, \"ProgressToken\", { enumerable: true, get: function () { return connection_1.ProgressToken; } });\r\nObject.defineProperty(exports, \"ProgressType\", { enumerable: true, get: function () { return connection_1.ProgressType; } });\r\nObject.defineProperty(exports, \"Trace\", { enumerable: true, get: function () { return connection_1.Trace; } });\r\nObject.defineProperty(exports, \"TraceValues\", { enumerable: true, get: function () { return connection_1.TraceValues; } });\r\nObject.defineProperty(exports, \"TraceFormat\", { enumerable: true, get: function () { return connection_1.TraceFormat; } });\r\nObject.defineProperty(exports, \"SetTraceNotification\", { enumerable: true, get: function () { return connection_1.SetTraceNotification; } });\r\nObject.defineProperty(exports, \"LogTraceNotification\", { enumerable: true, get: function () { return connection_1.LogTraceNotification; } });\r\nObject.defineProperty(exports, \"ConnectionErrors\", { enumerable: true, get: function () { return connection_1.ConnectionErrors; } });\r\nObject.defineProperty(exports, \"ConnectionError\", { enumerable: true, get: function () { return connection_1.ConnectionError; } });\r\nObject.defineProperty(exports, \"CancellationReceiverStrategy\", { enumerable: true, get: function () { return connection_1.CancellationReceiverStrategy; } });\r\nObject.defineProperty(exports, \"CancellationSenderStrategy\", { enumerable: true, get: function () { return connection_1.CancellationSenderStrategy; } });\r\nObject.defineProperty(exports, \"CancellationStrategy\", { enumerable: true, get: function () { return connection_1.CancellationStrategy; } });\r\nObject.defineProperty(exports, \"MessageStrategy\", { enumerable: true, get: function () { return connection_1.MessageStrategy; } });\r\nconst ral_1 = require(\"./ral\");\r\nexports.RAL = ral_1.default;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst util_1 = require(\"util\");\r\nconst api_1 = require(\"../common/api\");\r\nclass MessageBuffer extends api_1.AbstractMessageBuffer {\r\n    constructor(encoding = 'utf-8') {\r\n        super(encoding);\r\n    }\r\n    emptyBuffer() {\r\n        return MessageBuffer.emptyBuffer;\r\n    }\r\n    fromString(value, encoding) {\r\n        return Buffer.from(value, encoding);\r\n    }\r\n    toString(value, encoding) {\r\n        if (value instanceof Buffer) {\r\n            return value.toString(encoding);\r\n        }\r\n        else {\r\n            return new util_1.TextDecoder(encoding).decode(value);\r\n        }\r\n    }\r\n    asNative(buffer, length) {\r\n        if (length === undefined) {\r\n            return buffer instanceof Buffer ? buffer : Buffer.from(buffer);\r\n        }\r\n        else {\r\n            return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);\r\n        }\r\n    }\r\n    allocNative(length) {\r\n        return Buffer.allocUnsafe(length);\r\n    }\r\n}\r\nMessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);\r\nclass ReadableStreamWrapper {\r\n    constructor(stream) {\r\n        this.stream = stream;\r\n    }\r\n    onClose(listener) {\r\n        this.stream.on('close', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('close', listener));\r\n    }\r\n    onError(listener) {\r\n        this.stream.on('error', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('error', listener));\r\n    }\r\n    onEnd(listener) {\r\n        this.stream.on('end', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('end', listener));\r\n    }\r\n    onData(listener) {\r\n        this.stream.on('data', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('data', listener));\r\n    }\r\n}\r\nclass WritableStreamWrapper {\r\n    constructor(stream) {\r\n        this.stream = stream;\r\n    }\r\n    onClose(listener) {\r\n        this.stream.on('close', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('close', listener));\r\n    }\r\n    onError(listener) {\r\n        this.stream.on('error', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('error', listener));\r\n    }\r\n    onEnd(listener) {\r\n        this.stream.on('end', listener);\r\n        return api_1.Disposable.create(() => this.stream.off('end', listener));\r\n    }\r\n    write(data, encoding) {\r\n        return new Promise((resolve, reject) => {\r\n            const callback = (error) => {\r\n                if (error === undefined || error === null) {\r\n                    resolve();\r\n                }\r\n                else {\r\n                    reject(error);\r\n                }\r\n            };\r\n            if (typeof data === 'string') {\r\n                this.stream.write(data, encoding, callback);\r\n            }\r\n            else {\r\n                this.stream.write(data, callback);\r\n            }\r\n        });\r\n    }\r\n    end() {\r\n        this.stream.end();\r\n    }\r\n}\r\nconst _ril = Object.freeze({\r\n    messageBuffer: Object.freeze({\r\n        create: (encoding) => new MessageBuffer(encoding)\r\n    }),\r\n    applicationJson: Object.freeze({\r\n        encoder: Object.freeze({\r\n            name: 'application/json',\r\n            encode: (msg, options) => {\r\n                try {\r\n                    return Promise.resolve(Buffer.from(JSON.stringify(msg, undefined, 0), options.charset));\r\n                }\r\n                catch (err) {\r\n                    return Promise.reject(err);\r\n                }\r\n            }\r\n        }),\r\n        decoder: Object.freeze({\r\n            name: 'application/json',\r\n            decode: (buffer, options) => {\r\n                try {\r\n                    if (buffer instanceof Buffer) {\r\n                        return Promise.resolve(JSON.parse(buffer.toString(options.charset)));\r\n                    }\r\n                    else {\r\n                        return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));\r\n                    }\r\n                }\r\n                catch (err) {\r\n                    return Promise.reject(err);\r\n                }\r\n            }\r\n        })\r\n    }),\r\n    stream: Object.freeze({\r\n        asReadableStream: (stream) => new ReadableStreamWrapper(stream),\r\n        asWritableStream: (stream) => new WritableStreamWrapper(stream)\r\n    }),\r\n    console: console,\r\n    timer: Object.freeze({\r\n        setTimeout(callback, ms, ...args) {\r\n            const handle = setTimeout(callback, ms, ...args);\r\n            return { dispose: () => clearTimeout(handle) };\r\n        },\r\n        setImmediate(callback, ...args) {\r\n            const handle = setImmediate(callback, ...args);\r\n            return { dispose: () => clearImmediate(handle) };\r\n        },\r\n        setInterval(callback, ms, ...args) {\r\n            const handle = setInterval(callback, ms, ...args);\r\n            return { dispose: () => clearInterval(handle) };\r\n        }\r\n    })\r\n});\r\nfunction RIL() {\r\n    return _ril;\r\n}\r\n(function (RIL) {\r\n    function install() {\r\n        api_1.RAL.install(_ril);\r\n    }\r\n    RIL.install = install;\r\n})(RIL || (RIL = {}));\r\nexports.default = RIL;\r\n", "\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createMessageConnection = exports.createServerSocketTransport = exports.createClientSocketTransport = exports.createServerPipeTransport = exports.createClientPipeTransport = exports.generateRandomPipeName = exports.StreamMessageWriter = exports.StreamMessageReader = exports.SocketMessageWriter = exports.SocketMessageReader = exports.PortMessageWriter = exports.PortMessageReader = exports.IPCMessageWriter = exports.IPCMessageReader = void 0;\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ----------------------------------------------------------------------------------------- */\r\nconst ril_1 = require(\"./ril\");\r\n// Install the node runtime abstract.\r\nril_1.default.install();\r\nconst path = require(\"path\");\r\nconst os = require(\"os\");\r\nconst crypto_1 = require(\"crypto\");\r\nconst net_1 = require(\"net\");\r\nconst api_1 = require(\"../common/api\");\r\n__exportStar(require(\"../common/api\"), exports);\r\nclass IPCMessageReader extends api_1.AbstractMessageReader {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        let eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose());\r\n    }\r\n    listen(callback) {\r\n        this.process.on('message', callback);\r\n        return api_1.Disposable.create(() => this.process.off('message', callback));\r\n    }\r\n}\r\nexports.IPCMessageReader = IPCMessageReader;\r\nclass IPCMessageWriter extends api_1.AbstractMessageWriter {\r\n    constructor(process) {\r\n        super();\r\n        this.process = process;\r\n        this.errorCount = 0;\r\n        const eventEmitter = this.process;\r\n        eventEmitter.on('error', (error) => this.fireError(error));\r\n        eventEmitter.on('close', () => this.fireClose);\r\n    }\r\n    write(msg) {\r\n        try {\r\n            if (typeof this.process.send === 'function') {\r\n                this.process.send(msg, undefined, undefined, (error) => {\r\n                    if (error) {\r\n                        this.errorCount++;\r\n                        this.handleError(error, msg);\r\n                    }\r\n                    else {\r\n                        this.errorCount = 0;\r\n                    }\r\n                });\r\n            }\r\n            return Promise.resolve();\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n            return Promise.reject(error);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n    end() {\r\n    }\r\n}\r\nexports.IPCMessageWriter = IPCMessageWriter;\r\nclass PortMessageReader extends api_1.AbstractMessageReader {\r\n    constructor(port) {\r\n        super();\r\n        this.onData = new api_1.Emitter;\r\n        port.on('close', () => this.fireClose);\r\n        port.on('error', (error) => this.fireError(error));\r\n        port.on('message', (message) => {\r\n            this.onData.fire(message);\r\n        });\r\n    }\r\n    listen(callback) {\r\n        return this.onData.event(callback);\r\n    }\r\n}\r\nexports.PortMessageReader = PortMessageReader;\r\nclass PortMessageWriter extends api_1.AbstractMessageWriter {\r\n    constructor(port) {\r\n        super();\r\n        this.port = port;\r\n        this.errorCount = 0;\r\n        port.on('close', () => this.fireClose());\r\n        port.on('error', (error) => this.fireError(error));\r\n    }\r\n    write(msg) {\r\n        try {\r\n            this.port.postMessage(msg);\r\n            return Promise.resolve();\r\n        }\r\n        catch (error) {\r\n            this.handleError(error, msg);\r\n            return Promise.reject(error);\r\n        }\r\n    }\r\n    handleError(error, msg) {\r\n        this.errorCount++;\r\n        this.fireError(error, msg, this.errorCount);\r\n    }\r\n    end() {\r\n    }\r\n}\r\nexports.PortMessageWriter = PortMessageWriter;\r\nclass SocketMessageReader extends api_1.ReadableStreamMessageReader {\r\n    constructor(socket, encoding = 'utf-8') {\r\n        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);\r\n    }\r\n}\r\nexports.SocketMessageReader = SocketMessageReader;\r\nclass SocketMessageWriter extends api_1.WriteableStreamMessageWriter {\r\n    constructor(socket, options) {\r\n        super((0, ril_1.default)().stream.asWritableStream(socket), options);\r\n        this.socket = socket;\r\n    }\r\n    dispose() {\r\n        super.dispose();\r\n        this.socket.destroy();\r\n    }\r\n}\r\nexports.SocketMessageWriter = SocketMessageWriter;\r\nclass StreamMessageReader extends api_1.ReadableStreamMessageReader {\r\n    constructor(readable, encoding) {\r\n        super((0, ril_1.default)().stream.asReadableStream(readable), encoding);\r\n    }\r\n}\r\nexports.StreamMessageReader = StreamMessageReader;\r\nclass StreamMessageWriter extends api_1.WriteableStreamMessageWriter {\r\n    constructor(writable, options) {\r\n        super((0, ril_1.default)().stream.asWritableStream(writable), options);\r\n    }\r\n}\r\nexports.StreamMessageWriter = StreamMessageWriter;\r\nconst XDG_RUNTIME_DIR = process.env['XDG_RUNTIME_DIR'];\r\nconst safeIpcPathLengths = new Map([\r\n    ['linux', 107],\r\n    ['darwin', 103]\r\n]);\r\nfunction generateRandomPipeName() {\r\n    const randomSuffix = (0, crypto_1.randomBytes)(21).toString('hex');\r\n    if (process.platform === 'win32') {\r\n        return `\\\\\\\\.\\\\pipe\\\\vscode-jsonrpc-${randomSuffix}-sock`;\r\n    }\r\n    let result;\r\n    if (XDG_RUNTIME_DIR) {\r\n        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);\r\n    }\r\n    else {\r\n        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);\r\n    }\r\n    const limit = safeIpcPathLengths.get(process.platform);\r\n    if (limit !== undefined && result.length > limit) {\r\n        (0, ril_1.default)().console.warn(`WARNING: IPC handle \"${result}\" is longer than ${limit} characters.`);\r\n    }\r\n    return result;\r\n}\r\nexports.generateRandomPipeName = generateRandomPipeName;\r\nfunction createClientPipeTransport(pipeName, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    const connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        let server = (0, net_1.createServer)((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new SocketMessageReader(socket, encoding),\r\n                new SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(pipeName, () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientPipeTransport = createClientPipeTransport;\r\nfunction createServerPipeTransport(pipeName, encoding = 'utf-8') {\r\n    const socket = (0, net_1.createConnection)(pipeName);\r\n    return [\r\n        new SocketMessageReader(socket, encoding),\r\n        new SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerPipeTransport = createServerPipeTransport;\r\nfunction createClientSocketTransport(port, encoding = 'utf-8') {\r\n    let connectResolve;\r\n    const connected = new Promise((resolve, _reject) => {\r\n        connectResolve = resolve;\r\n    });\r\n    return new Promise((resolve, reject) => {\r\n        const server = (0, net_1.createServer)((socket) => {\r\n            server.close();\r\n            connectResolve([\r\n                new SocketMessageReader(socket, encoding),\r\n                new SocketMessageWriter(socket, encoding)\r\n            ]);\r\n        });\r\n        server.on('error', reject);\r\n        server.listen(port, '127.0.0.1', () => {\r\n            server.removeListener('error', reject);\r\n            resolve({\r\n                onConnected: () => { return connected; }\r\n            });\r\n        });\r\n    });\r\n}\r\nexports.createClientSocketTransport = createClientSocketTransport;\r\nfunction createServerSocketTransport(port, encoding = 'utf-8') {\r\n    const socket = (0, net_1.createConnection)(port, '127.0.0.1');\r\n    return [\r\n        new SocketMessageReader(socket, encoding),\r\n        new SocketMessageWriter(socket, encoding)\r\n    ];\r\n}\r\nexports.createServerSocketTransport = createServerSocketTransport;\r\nfunction isReadableStream(value) {\r\n    const candidate = value;\r\n    return candidate.read !== undefined && candidate.addListener !== undefined;\r\n}\r\nfunction isWritableStream(value) {\r\n    const candidate = value;\r\n    return candidate.write !== undefined && candidate.addListener !== undefined;\r\n}\r\nfunction createMessageConnection(input, output, logger, options) {\r\n    if (!logger) {\r\n        logger = api_1.NullLogger;\r\n    }\r\n    const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;\r\n    const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;\r\n    if (api_1.ConnectionStrategy.is(options)) {\r\n        options = { connectionStrategy: options };\r\n    }\r\n    return (0, api_1.createMessageConnection)(reader, writer, logger, options);\r\n}\r\nexports.createMessageConnection = createMessageConnection;\r\n", "/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ----------------------------------------------------------------------------------------- */\r\n'use strict';\r\n\r\nmodule.exports = require('./lib/node/main');", "(function (factory) {\r\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\r\n        var v = factory(require, exports);\r\n        if (v !== undefined) module.exports = v;\r\n    }\r\n    else if (typeof define === \"function\" && define.amd) {\r\n        define([\"require\", \"exports\"], factory);\r\n    }\r\n})(function (require, exports) {\r\n    /* --------------------------------------------------------------------------------------------\r\n     * Copyright (c) Microsoft Corporation. All rights reserved.\r\n     * Licensed under the MIT License. See License.txt in the project root for license information.\r\n     * ------------------------------------------------------------------------------------------ */\r\n    'use strict';\r\n    Object.defineProperty(exports, \"__esModule\", { value: true });\r\n    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;\r\n    var DocumentUri;\r\n    (function (DocumentUri) {\r\n        function is(value) {\r\n            return typeof value === 'string';\r\n        }\r\n        DocumentUri.is = is;\r\n    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));\r\n    var URI;\r\n    (function (URI) {\r\n        function is(value) {\r\n            return typeof value === 'string';\r\n        }\r\n        URI.is = is;\r\n    })(URI || (exports.URI = URI = {}));\r\n    var integer;\r\n    (function (integer) {\r\n        integer.MIN_VALUE = -2147483648;\r\n        integer.MAX_VALUE = 2147483647;\r\n        function is(value) {\r\n            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\r\n        }\r\n        integer.is = is;\r\n    })(integer || (exports.integer = integer = {}));\r\n    var uinteger;\r\n    (function (uinteger) {\r\n        uinteger.MIN_VALUE = 0;\r\n        uinteger.MAX_VALUE = 2147483647;\r\n        function is(value) {\r\n            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\r\n        }\r\n        uinteger.is = is;\r\n    })(uinteger || (exports.uinteger = uinteger = {}));\r\n    /**\r\n     * The Position namespace provides helper functions to work with\r\n     * {@link Position} literals.\r\n     */\r\n    var Position;\r\n    (function (Position) {\r\n        /**\r\n         * Creates a new Position literal from the given line and character.\r\n         * @param line The position's line.\r\n         * @param character The position's character.\r\n         */\r\n        function create(line, character) {\r\n            if (line === Number.MAX_VALUE) {\r\n                line = uinteger.MAX_VALUE;\r\n            }\r\n            if (character === Number.MAX_VALUE) {\r\n                character = uinteger.MAX_VALUE;\r\n            }\r\n            return { line: line, character: character };\r\n        }\r\n        Position.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link Position} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\r\n        }\r\n        Position.is = is;\r\n    })(Position || (exports.Position = Position = {}));\r\n    /**\r\n     * The Range namespace provides helper functions to work with\r\n     * {@link Range} literals.\r\n     */\r\n    var Range;\r\n    (function (Range) {\r\n        function create(one, two, three, four) {\r\n            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\r\n                return { start: Position.create(one, two), end: Position.create(three, four) };\r\n            }\r\n            else if (Position.is(one) && Position.is(two)) {\r\n                return { start: one, end: two };\r\n            }\r\n            else {\r\n                throw new Error(\"Range#create called with invalid arguments[\".concat(one, \", \").concat(two, \", \").concat(three, \", \").concat(four, \"]\"));\r\n            }\r\n        }\r\n        Range.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link Range} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n        }\r\n        Range.is = is;\r\n    })(Range || (exports.Range = Range = {}));\r\n    /**\r\n     * The Location namespace provides helper functions to work with\r\n     * {@link Location} literals.\r\n     */\r\n    var Location;\r\n    (function (Location) {\r\n        /**\r\n         * Creates a Location literal.\r\n         * @param uri The location's uri.\r\n         * @param range The location's range.\r\n         */\r\n        function create(uri, range) {\r\n            return { uri: uri, range: range };\r\n        }\r\n        Location.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link Location} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n        }\r\n        Location.is = is;\r\n    })(Location || (exports.Location = Location = {}));\r\n    /**\r\n     * The LocationLink namespace provides helper functions to work with\r\n     * {@link LocationLink} literals.\r\n     */\r\n    var LocationLink;\r\n    (function (LocationLink) {\r\n        /**\r\n         * Creates a LocationLink literal.\r\n         * @param targetUri The definition's uri.\r\n         * @param targetRange The full range of the definition.\r\n         * @param targetSelectionRange The span of the symbol definition at the target.\r\n         * @param originSelectionRange The span of the symbol being defined in the originating source file.\r\n         */\r\n        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\r\n            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };\r\n        }\r\n        LocationLink.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link LocationLink} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\r\n                && Range.is(candidate.targetSelectionRange)\r\n                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\r\n        }\r\n        LocationLink.is = is;\r\n    })(LocationLink || (exports.LocationLink = LocationLink = {}));\r\n    /**\r\n     * The Color namespace provides helper functions to work with\r\n     * {@link Color} literals.\r\n     */\r\n    var Color;\r\n    (function (Color) {\r\n        /**\r\n         * Creates a new Color literal.\r\n         */\r\n        function create(red, green, blue, alpha) {\r\n            return {\r\n                red: red,\r\n                green: green,\r\n                blue: blue,\r\n                alpha: alpha,\r\n            };\r\n        }\r\n        Color.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link Color} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\r\n                && Is.numberRange(candidate.green, 0, 1)\r\n                && Is.numberRange(candidate.blue, 0, 1)\r\n                && Is.numberRange(candidate.alpha, 0, 1);\r\n        }\r\n        Color.is = is;\r\n    })(Color || (exports.Color = Color = {}));\r\n    /**\r\n     * The ColorInformation namespace provides helper functions to work with\r\n     * {@link ColorInformation} literals.\r\n     */\r\n    var ColorInformation;\r\n    (function (ColorInformation) {\r\n        /**\r\n         * Creates a new ColorInformation literal.\r\n         */\r\n        function create(range, color) {\r\n            return {\r\n                range: range,\r\n                color: color,\r\n            };\r\n        }\r\n        ColorInformation.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\r\n        }\r\n        ColorInformation.is = is;\r\n    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));\r\n    /**\r\n     * The Color namespace provides helper functions to work with\r\n     * {@link ColorPresentation} literals.\r\n     */\r\n    var ColorPresentation;\r\n    (function (ColorPresentation) {\r\n        /**\r\n         * Creates a new ColorInformation literal.\r\n         */\r\n        function create(label, textEdit, additionalTextEdits) {\r\n            return {\r\n                label: label,\r\n                textEdit: textEdit,\r\n                additionalTextEdits: additionalTextEdits,\r\n            };\r\n        }\r\n        ColorPresentation.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link ColorInformation} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Is.string(candidate.label)\r\n                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\r\n                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n        }\r\n        ColorPresentation.is = is;\r\n    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));\r\n    /**\r\n     * A set of predefined range kinds.\r\n     */\r\n    var FoldingRangeKind;\r\n    (function (FoldingRangeKind) {\r\n        /**\r\n         * Folding range for a comment\r\n         */\r\n        FoldingRangeKind.Comment = 'comment';\r\n        /**\r\n         * Folding range for an import or include\r\n         */\r\n        FoldingRangeKind.Imports = 'imports';\r\n        /**\r\n         * Folding range for a region (e.g. `#region`)\r\n         */\r\n        FoldingRangeKind.Region = 'region';\r\n    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));\r\n    /**\r\n     * The folding range namespace provides helper functions to work with\r\n     * {@link FoldingRange} literals.\r\n     */\r\n    var FoldingRange;\r\n    (function (FoldingRange) {\r\n        /**\r\n         * Creates a new FoldingRange literal.\r\n         */\r\n        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\r\n            var result = {\r\n                startLine: startLine,\r\n                endLine: endLine\r\n            };\r\n            if (Is.defined(startCharacter)) {\r\n                result.startCharacter = startCharacter;\r\n            }\r\n            if (Is.defined(endCharacter)) {\r\n                result.endCharacter = endCharacter;\r\n            }\r\n            if (Is.defined(kind)) {\r\n                result.kind = kind;\r\n            }\r\n            if (Is.defined(collapsedText)) {\r\n                result.collapsedText = collapsedText;\r\n            }\r\n            return result;\r\n        }\r\n        FoldingRange.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link FoldingRange} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\r\n                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\r\n                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\r\n                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n        }\r\n        FoldingRange.is = is;\r\n    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));\r\n    /**\r\n     * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n     * {@link DiagnosticRelatedInformation} literals.\r\n     */\r\n    var DiagnosticRelatedInformation;\r\n    (function (DiagnosticRelatedInformation) {\r\n        /**\r\n         * Creates a new DiagnosticRelatedInformation literal.\r\n         */\r\n        function create(location, message) {\r\n            return {\r\n                location: location,\r\n                message: message\r\n            };\r\n        }\r\n        DiagnosticRelatedInformation.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n        }\r\n        DiagnosticRelatedInformation.is = is;\r\n    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));\r\n    /**\r\n     * The diagnostic's severity.\r\n     */\r\n    var DiagnosticSeverity;\r\n    (function (DiagnosticSeverity) {\r\n        /**\r\n         * Reports an error.\r\n         */\r\n        DiagnosticSeverity.Error = 1;\r\n        /**\r\n         * Reports a warning.\r\n         */\r\n        DiagnosticSeverity.Warning = 2;\r\n        /**\r\n         * Reports an information.\r\n         */\r\n        DiagnosticSeverity.Information = 3;\r\n        /**\r\n         * Reports a hint.\r\n         */\r\n        DiagnosticSeverity.Hint = 4;\r\n    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));\r\n    /**\r\n     * The diagnostic tags.\r\n     *\r\n     * @since 3.15.0\r\n     */\r\n    var DiagnosticTag;\r\n    (function (DiagnosticTag) {\r\n        /**\r\n         * Unused or unnecessary code.\r\n         *\r\n         * Clients are allowed to render diagnostics with this tag faded out instead of having\r\n         * an error squiggle.\r\n         */\r\n        DiagnosticTag.Unnecessary = 1;\r\n        /**\r\n         * Deprecated or obsolete code.\r\n         *\r\n         * Clients are allowed to rendered diagnostics with this tag strike through.\r\n         */\r\n        DiagnosticTag.Deprecated = 2;\r\n    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));\r\n    /**\r\n     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\r\n     *\r\n     * @since 3.16.0\r\n     */\r\n    var CodeDescription;\r\n    (function (CodeDescription) {\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Is.string(candidate.href);\r\n        }\r\n        CodeDescription.is = is;\r\n    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));\r\n    /**\r\n     * The Diagnostic namespace provides helper functions to work with\r\n     * {@link Diagnostic} literals.\r\n     */\r\n    var Diagnostic;\r\n    (function (Diagnostic) {\r\n        /**\r\n         * Creates a new Diagnostic literal.\r\n         */\r\n        function create(range, message, severity, code, source, relatedInformation) {\r\n            var result = { range: range, message: message };\r\n            if (Is.defined(severity)) {\r\n                result.severity = severity;\r\n            }\r\n            if (Is.defined(code)) {\r\n                result.code = code;\r\n            }\r\n            if (Is.defined(source)) {\r\n                result.source = source;\r\n            }\r\n            if (Is.defined(relatedInformation)) {\r\n                result.relatedInformation = relatedInformation;\r\n            }\r\n            return result;\r\n        }\r\n        Diagnostic.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link Diagnostic} interface.\r\n         */\r\n        function is(value) {\r\n            var _a;\r\n            var candidate = value;\r\n            return Is.defined(candidate)\r\n                && Range.is(candidate.range)\r\n                && Is.string(candidate.message)\r\n                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\r\n                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\r\n                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\r\n                && (Is.string(candidate.source) || Is.undefined(candidate.source))\r\n                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n        }\r\n        Diagnostic.is = is;\r\n    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));\r\n    /**\r\n     * The Command namespace provides helper functions to work with\r\n     * {@link Command} literals.\r\n     */\r\n    var Command;\r\n    (function (Command) {\r\n        /**\r\n         * Creates a new Command literal.\r\n         */\r\n        function create(title, command) {\r\n            var args = [];\r\n            for (var _i = 2; _i < arguments.length; _i++) {\r\n                args[_i - 2] = arguments[_i];\r\n            }\r\n            var result = { title: title, command: command };\r\n            if (Is.defined(args) && args.length > 0) {\r\n                result.arguments = args;\r\n            }\r\n            return result;\r\n        }\r\n        Command.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link Command} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n        }\r\n        Command.is = is;\r\n    })(Command || (exports.Command = Command = {}));\r\n    /**\r\n     * The TextEdit namespace provides helper function to create replace,\r\n     * insert and delete edits more easily.\r\n     */\r\n    var TextEdit;\r\n    (function (TextEdit) {\r\n        /**\r\n         * Creates a replace text edit.\r\n         * @param range The range of text to be replaced.\r\n         * @param newText The new text.\r\n         */\r\n        function replace(range, newText) {\r\n            return { range: range, newText: newText };\r\n        }\r\n        TextEdit.replace = replace;\r\n        /**\r\n         * Creates an insert text edit.\r\n         * @param position The position to insert the text at.\r\n         * @param newText The text to be inserted.\r\n         */\r\n        function insert(position, newText) {\r\n            return { range: { start: position, end: position }, newText: newText };\r\n        }\r\n        TextEdit.insert = insert;\r\n        /**\r\n         * Creates a delete text edit.\r\n         * @param range The range of text to be deleted.\r\n         */\r\n        function del(range) {\r\n            return { range: range, newText: '' };\r\n        }\r\n        TextEdit.del = del;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate)\r\n                && Is.string(candidate.newText)\r\n                && Range.is(candidate.range);\r\n        }\r\n        TextEdit.is = is;\r\n    })(TextEdit || (exports.TextEdit = TextEdit = {}));\r\n    var ChangeAnnotation;\r\n    (function (ChangeAnnotation) {\r\n        function create(label, needsConfirmation, description) {\r\n            var result = { label: label };\r\n            if (needsConfirmation !== undefined) {\r\n                result.needsConfirmation = needsConfirmation;\r\n            }\r\n            if (description !== undefined) {\r\n                result.description = description;\r\n            }\r\n            return result;\r\n        }\r\n        ChangeAnnotation.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\r\n                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\r\n                (Is.string(candidate.description) || candidate.description === undefined);\r\n        }\r\n        ChangeAnnotation.is = is;\r\n    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));\r\n    var ChangeAnnotationIdentifier;\r\n    (function (ChangeAnnotationIdentifier) {\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.string(candidate);\r\n        }\r\n        ChangeAnnotationIdentifier.is = is;\r\n    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));\r\n    var AnnotatedTextEdit;\r\n    (function (AnnotatedTextEdit) {\r\n        /**\r\n         * Creates an annotated replace text edit.\r\n         *\r\n         * @param range The range of text to be replaced.\r\n         * @param newText The new text.\r\n         * @param annotation The annotation.\r\n         */\r\n        function replace(range, newText, annotation) {\r\n            return { range: range, newText: newText, annotationId: annotation };\r\n        }\r\n        AnnotatedTextEdit.replace = replace;\r\n        /**\r\n         * Creates an annotated insert text edit.\r\n         *\r\n         * @param position The position to insert the text at.\r\n         * @param newText The text to be inserted.\r\n         * @param annotation The annotation.\r\n         */\r\n        function insert(position, newText, annotation) {\r\n            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };\r\n        }\r\n        AnnotatedTextEdit.insert = insert;\r\n        /**\r\n         * Creates an annotated delete text edit.\r\n         *\r\n         * @param range The range of text to be deleted.\r\n         * @param annotation The annotation.\r\n         */\r\n        function del(range, annotation) {\r\n            return { range: range, newText: '', annotationId: annotation };\r\n        }\r\n        AnnotatedTextEdit.del = del;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n        }\r\n        AnnotatedTextEdit.is = is;\r\n    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));\r\n    /**\r\n     * The TextDocumentEdit namespace provides helper function to create\r\n     * an edit that manipulates a text document.\r\n     */\r\n    var TextDocumentEdit;\r\n    (function (TextDocumentEdit) {\r\n        /**\r\n         * Creates a new `TextDocumentEdit`\r\n         */\r\n        function create(textDocument, edits) {\r\n            return { textDocument: textDocument, edits: edits };\r\n        }\r\n        TextDocumentEdit.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate)\r\n                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\r\n                && Array.isArray(candidate.edits);\r\n        }\r\n        TextDocumentEdit.is = is;\r\n    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));\r\n    var CreateFile;\r\n    (function (CreateFile) {\r\n        function create(uri, options, annotation) {\r\n            var result = {\r\n                kind: 'create',\r\n                uri: uri\r\n            };\r\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\r\n                result.options = options;\r\n            }\r\n            if (annotation !== undefined) {\r\n                result.annotationId = annotation;\r\n            }\r\n            return result;\r\n        }\r\n        CreateFile.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\r\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n        }\r\n        CreateFile.is = is;\r\n    })(CreateFile || (exports.CreateFile = CreateFile = {}));\r\n    var RenameFile;\r\n    (function (RenameFile) {\r\n        function create(oldUri, newUri, options, annotation) {\r\n            var result = {\r\n                kind: 'rename',\r\n                oldUri: oldUri,\r\n                newUri: newUri\r\n            };\r\n            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\r\n                result.options = options;\r\n            }\r\n            if (annotation !== undefined) {\r\n                result.annotationId = annotation;\r\n            }\r\n            return result;\r\n        }\r\n        RenameFile.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\r\n                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n        }\r\n        RenameFile.is = is;\r\n    })(RenameFile || (exports.RenameFile = RenameFile = {}));\r\n    var DeleteFile;\r\n    (function (DeleteFile) {\r\n        function create(uri, options, annotation) {\r\n            var result = {\r\n                kind: 'delete',\r\n                uri: uri\r\n            };\r\n            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\r\n                result.options = options;\r\n            }\r\n            if (annotation !== undefined) {\r\n                result.annotationId = annotation;\r\n            }\r\n            return result;\r\n        }\r\n        DeleteFile.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\r\n                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n        }\r\n        DeleteFile.is = is;\r\n    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));\r\n    var WorkspaceEdit;\r\n    (function (WorkspaceEdit) {\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate &&\r\n                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\r\n                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {\r\n                    if (Is.string(change.kind)) {\r\n                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n                    }\r\n                    else {\r\n                        return TextDocumentEdit.is(change);\r\n                    }\r\n                }));\r\n        }\r\n        WorkspaceEdit.is = is;\r\n    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));\r\n    var TextEditChangeImpl = /** @class */ (function () {\r\n        function TextEditChangeImpl(edits, changeAnnotations) {\r\n            this.edits = edits;\r\n            this.changeAnnotations = changeAnnotations;\r\n        }\r\n        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {\r\n            var edit;\r\n            var id;\r\n            if (annotation === undefined) {\r\n                edit = TextEdit.insert(position, newText);\r\n            }\r\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\r\n                id = annotation;\r\n                edit = AnnotatedTextEdit.insert(position, newText, annotation);\r\n            }\r\n            else {\r\n                this.assertChangeAnnotations(this.changeAnnotations);\r\n                id = this.changeAnnotations.manage(annotation);\r\n                edit = AnnotatedTextEdit.insert(position, newText, id);\r\n            }\r\n            this.edits.push(edit);\r\n            if (id !== undefined) {\r\n                return id;\r\n            }\r\n        };\r\n        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {\r\n            var edit;\r\n            var id;\r\n            if (annotation === undefined) {\r\n                edit = TextEdit.replace(range, newText);\r\n            }\r\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\r\n                id = annotation;\r\n                edit = AnnotatedTextEdit.replace(range, newText, annotation);\r\n            }\r\n            else {\r\n                this.assertChangeAnnotations(this.changeAnnotations);\r\n                id = this.changeAnnotations.manage(annotation);\r\n                edit = AnnotatedTextEdit.replace(range, newText, id);\r\n            }\r\n            this.edits.push(edit);\r\n            if (id !== undefined) {\r\n                return id;\r\n            }\r\n        };\r\n        TextEditChangeImpl.prototype.delete = function (range, annotation) {\r\n            var edit;\r\n            var id;\r\n            if (annotation === undefined) {\r\n                edit = TextEdit.del(range);\r\n            }\r\n            else if (ChangeAnnotationIdentifier.is(annotation)) {\r\n                id = annotation;\r\n                edit = AnnotatedTextEdit.del(range, annotation);\r\n            }\r\n            else {\r\n                this.assertChangeAnnotations(this.changeAnnotations);\r\n                id = this.changeAnnotations.manage(annotation);\r\n                edit = AnnotatedTextEdit.del(range, id);\r\n            }\r\n            this.edits.push(edit);\r\n            if (id !== undefined) {\r\n                return id;\r\n            }\r\n        };\r\n        TextEditChangeImpl.prototype.add = function (edit) {\r\n            this.edits.push(edit);\r\n        };\r\n        TextEditChangeImpl.prototype.all = function () {\r\n            return this.edits;\r\n        };\r\n        TextEditChangeImpl.prototype.clear = function () {\r\n            this.edits.splice(0, this.edits.length);\r\n        };\r\n        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {\r\n            if (value === undefined) {\r\n                throw new Error(\"Text edit change is not configured to manage change annotations.\");\r\n            }\r\n        };\r\n        return TextEditChangeImpl;\r\n    }());\r\n    /**\r\n     * A helper class\r\n     */\r\n    var ChangeAnnotations = /** @class */ (function () {\r\n        function ChangeAnnotations(annotations) {\r\n            this._annotations = annotations === undefined ? Object.create(null) : annotations;\r\n            this._counter = 0;\r\n            this._size = 0;\r\n        }\r\n        ChangeAnnotations.prototype.all = function () {\r\n            return this._annotations;\r\n        };\r\n        Object.defineProperty(ChangeAnnotations.prototype, \"size\", {\r\n            get: function () {\r\n                return this._size;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {\r\n            var id;\r\n            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\r\n                id = idOrAnnotation;\r\n            }\r\n            else {\r\n                id = this.nextId();\r\n                annotation = idOrAnnotation;\r\n            }\r\n            if (this._annotations[id] !== undefined) {\r\n                throw new Error(\"Id \".concat(id, \" is already in use.\"));\r\n            }\r\n            if (annotation === undefined) {\r\n                throw new Error(\"No annotation provided for id \".concat(id));\r\n            }\r\n            this._annotations[id] = annotation;\r\n            this._size++;\r\n            return id;\r\n        };\r\n        ChangeAnnotations.prototype.nextId = function () {\r\n            this._counter++;\r\n            return this._counter.toString();\r\n        };\r\n        return ChangeAnnotations;\r\n    }());\r\n    /**\r\n     * A workspace change helps constructing changes to a workspace.\r\n     */\r\n    var WorkspaceChange = /** @class */ (function () {\r\n        function WorkspaceChange(workspaceEdit) {\r\n            var _this = this;\r\n            this._textEditChanges = Object.create(null);\r\n            if (workspaceEdit !== undefined) {\r\n                this._workspaceEdit = workspaceEdit;\r\n                if (workspaceEdit.documentChanges) {\r\n                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\r\n                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();\r\n                    workspaceEdit.documentChanges.forEach(function (change) {\r\n                        if (TextDocumentEdit.is(change)) {\r\n                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);\r\n                            _this._textEditChanges[change.textDocument.uri] = textEditChange;\r\n                        }\r\n                    });\r\n                }\r\n                else if (workspaceEdit.changes) {\r\n                    Object.keys(workspaceEdit.changes).forEach(function (key) {\r\n                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\r\n                        _this._textEditChanges[key] = textEditChange;\r\n                    });\r\n                }\r\n            }\r\n            else {\r\n                this._workspaceEdit = {};\r\n            }\r\n        }\r\n        Object.defineProperty(WorkspaceChange.prototype, \"edit\", {\r\n            /**\r\n             * Returns the underlying {@link WorkspaceEdit} literal\r\n             * use to be returned from a workspace edit operation like rename.\r\n             */\r\n            get: function () {\r\n                this.initDocumentChanges();\r\n                if (this._changeAnnotations !== undefined) {\r\n                    if (this._changeAnnotations.size === 0) {\r\n                        this._workspaceEdit.changeAnnotations = undefined;\r\n                    }\r\n                    else {\r\n                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\r\n                    }\r\n                }\r\n                return this._workspaceEdit;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        WorkspaceChange.prototype.getTextEditChange = function (key) {\r\n            if (OptionalVersionedTextDocumentIdentifier.is(key)) {\r\n                this.initDocumentChanges();\r\n                if (this._workspaceEdit.documentChanges === undefined) {\r\n                    throw new Error('Workspace edit is not configured for document changes.');\r\n                }\r\n                var textDocument = { uri: key.uri, version: key.version };\r\n                var result = this._textEditChanges[textDocument.uri];\r\n                if (!result) {\r\n                    var edits = [];\r\n                    var textDocumentEdit = {\r\n                        textDocument: textDocument,\r\n                        edits: edits\r\n                    };\r\n                    this._workspaceEdit.documentChanges.push(textDocumentEdit);\r\n                    result = new TextEditChangeImpl(edits, this._changeAnnotations);\r\n                    this._textEditChanges[textDocument.uri] = result;\r\n                }\r\n                return result;\r\n            }\r\n            else {\r\n                this.initChanges();\r\n                if (this._workspaceEdit.changes === undefined) {\r\n                    throw new Error('Workspace edit is not configured for normal text edit changes.');\r\n                }\r\n                var result = this._textEditChanges[key];\r\n                if (!result) {\r\n                    var edits = [];\r\n                    this._workspaceEdit.changes[key] = edits;\r\n                    result = new TextEditChangeImpl(edits);\r\n                    this._textEditChanges[key] = result;\r\n                }\r\n                return result;\r\n            }\r\n        };\r\n        WorkspaceChange.prototype.initDocumentChanges = function () {\r\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\r\n                this._changeAnnotations = new ChangeAnnotations();\r\n                this._workspaceEdit.documentChanges = [];\r\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\r\n            }\r\n        };\r\n        WorkspaceChange.prototype.initChanges = function () {\r\n            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\r\n                this._workspaceEdit.changes = Object.create(null);\r\n            }\r\n        };\r\n        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {\r\n            this.initDocumentChanges();\r\n            if (this._workspaceEdit.documentChanges === undefined) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var annotation;\r\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\r\n                annotation = optionsOrAnnotation;\r\n            }\r\n            else {\r\n                options = optionsOrAnnotation;\r\n            }\r\n            var operation;\r\n            var id;\r\n            if (annotation === undefined) {\r\n                operation = CreateFile.create(uri, options);\r\n            }\r\n            else {\r\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\r\n                operation = CreateFile.create(uri, options, id);\r\n            }\r\n            this._workspaceEdit.documentChanges.push(operation);\r\n            if (id !== undefined) {\r\n                return id;\r\n            }\r\n        };\r\n        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {\r\n            this.initDocumentChanges();\r\n            if (this._workspaceEdit.documentChanges === undefined) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var annotation;\r\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\r\n                annotation = optionsOrAnnotation;\r\n            }\r\n            else {\r\n                options = optionsOrAnnotation;\r\n            }\r\n            var operation;\r\n            var id;\r\n            if (annotation === undefined) {\r\n                operation = RenameFile.create(oldUri, newUri, options);\r\n            }\r\n            else {\r\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\r\n                operation = RenameFile.create(oldUri, newUri, options, id);\r\n            }\r\n            this._workspaceEdit.documentChanges.push(operation);\r\n            if (id !== undefined) {\r\n                return id;\r\n            }\r\n        };\r\n        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {\r\n            this.initDocumentChanges();\r\n            if (this._workspaceEdit.documentChanges === undefined) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            var annotation;\r\n            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\r\n                annotation = optionsOrAnnotation;\r\n            }\r\n            else {\r\n                options = optionsOrAnnotation;\r\n            }\r\n            var operation;\r\n            var id;\r\n            if (annotation === undefined) {\r\n                operation = DeleteFile.create(uri, options);\r\n            }\r\n            else {\r\n                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\r\n                operation = DeleteFile.create(uri, options, id);\r\n            }\r\n            this._workspaceEdit.documentChanges.push(operation);\r\n            if (id !== undefined) {\r\n                return id;\r\n            }\r\n        };\r\n        return WorkspaceChange;\r\n    }());\r\n    exports.WorkspaceChange = WorkspaceChange;\r\n    /**\r\n     * The TextDocumentIdentifier namespace provides helper functions to work with\r\n     * {@link TextDocumentIdentifier} literals.\r\n     */\r\n    var TextDocumentIdentifier;\r\n    (function (TextDocumentIdentifier) {\r\n        /**\r\n         * Creates a new TextDocumentIdentifier literal.\r\n         * @param uri The document's uri.\r\n         */\r\n        function create(uri) {\r\n            return { uri: uri };\r\n        }\r\n        TextDocumentIdentifier.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.string(candidate.uri);\r\n        }\r\n        TextDocumentIdentifier.is = is;\r\n    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));\r\n    /**\r\n     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n     * {@link VersionedTextDocumentIdentifier} literals.\r\n     */\r\n    var VersionedTextDocumentIdentifier;\r\n    (function (VersionedTextDocumentIdentifier) {\r\n        /**\r\n         * Creates a new VersionedTextDocumentIdentifier literal.\r\n         * @param uri The document's uri.\r\n         * @param version The document's version.\r\n         */\r\n        function create(uri, version) {\r\n            return { uri: uri, version: version };\r\n        }\r\n        VersionedTextDocumentIdentifier.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\r\n        }\r\n        VersionedTextDocumentIdentifier.is = is;\r\n    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));\r\n    /**\r\n     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n     * {@link OptionalVersionedTextDocumentIdentifier} literals.\r\n     */\r\n    var OptionalVersionedTextDocumentIdentifier;\r\n    (function (OptionalVersionedTextDocumentIdentifier) {\r\n        /**\r\n         * Creates a new OptionalVersionedTextDocumentIdentifier literal.\r\n         * @param uri The document's uri.\r\n         * @param version The document's version.\r\n         */\r\n        function create(uri, version) {\r\n            return { uri: uri, version: version };\r\n        }\r\n        OptionalVersionedTextDocumentIdentifier.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\r\n        }\r\n        OptionalVersionedTextDocumentIdentifier.is = is;\r\n    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));\r\n    /**\r\n     * The TextDocumentItem namespace provides helper functions to work with\r\n     * {@link TextDocumentItem} literals.\r\n     */\r\n    var TextDocumentItem;\r\n    (function (TextDocumentItem) {\r\n        /**\r\n         * Creates a new TextDocumentItem literal.\r\n         * @param uri The document's uri.\r\n         * @param languageId The document's language identifier.\r\n         * @param version The document's version number.\r\n         * @param text The document's text.\r\n         */\r\n        function create(uri, languageId, version, text) {\r\n            return { uri: uri, languageId: languageId, version: version, text: text };\r\n        }\r\n        TextDocumentItem.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\r\n        }\r\n        TextDocumentItem.is = is;\r\n    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));\r\n    /**\r\n     * Describes the content type that a client supports in various\r\n     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n     *\r\n     * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n     * are reserved for internal usage.\r\n     */\r\n    var MarkupKind;\r\n    (function (MarkupKind) {\r\n        /**\r\n         * Plain text is supported as a content format\r\n         */\r\n        MarkupKind.PlainText = 'plaintext';\r\n        /**\r\n         * Markdown is supported as a content format\r\n         */\r\n        MarkupKind.Markdown = 'markdown';\r\n        /**\r\n         * Checks whether the given value is a value of the {@link MarkupKind} type.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\r\n        }\r\n        MarkupKind.is = is;\r\n    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));\r\n    var MarkupContent;\r\n    (function (MarkupContent) {\r\n        /**\r\n         * Checks whether the given value conforms to the {@link MarkupContent} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n        }\r\n        MarkupContent.is = is;\r\n    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));\r\n    /**\r\n     * The kind of a completion entry.\r\n     */\r\n    var CompletionItemKind;\r\n    (function (CompletionItemKind) {\r\n        CompletionItemKind.Text = 1;\r\n        CompletionItemKind.Method = 2;\r\n        CompletionItemKind.Function = 3;\r\n        CompletionItemKind.Constructor = 4;\r\n        CompletionItemKind.Field = 5;\r\n        CompletionItemKind.Variable = 6;\r\n        CompletionItemKind.Class = 7;\r\n        CompletionItemKind.Interface = 8;\r\n        CompletionItemKind.Module = 9;\r\n        CompletionItemKind.Property = 10;\r\n        CompletionItemKind.Unit = 11;\r\n        CompletionItemKind.Value = 12;\r\n        CompletionItemKind.Enum = 13;\r\n        CompletionItemKind.Keyword = 14;\r\n        CompletionItemKind.Snippet = 15;\r\n        CompletionItemKind.Color = 16;\r\n        CompletionItemKind.File = 17;\r\n        CompletionItemKind.Reference = 18;\r\n        CompletionItemKind.Folder = 19;\r\n        CompletionItemKind.EnumMember = 20;\r\n        CompletionItemKind.Constant = 21;\r\n        CompletionItemKind.Struct = 22;\r\n        CompletionItemKind.Event = 23;\r\n        CompletionItemKind.Operator = 24;\r\n        CompletionItemKind.TypeParameter = 25;\r\n    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));\r\n    /**\r\n     * Defines whether the insert text in a completion item should be interpreted as\r\n     * plain text or a snippet.\r\n     */\r\n    var InsertTextFormat;\r\n    (function (InsertTextFormat) {\r\n        /**\r\n         * The primary text to be inserted is treated as a plain string.\r\n         */\r\n        InsertTextFormat.PlainText = 1;\r\n        /**\r\n         * The primary text to be inserted is treated as a snippet.\r\n         *\r\n         * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n         * the end of the snippet. Placeholders with equal identifiers are linked,\r\n         * that is typing in one will update others too.\r\n         *\r\n         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\r\n         */\r\n        InsertTextFormat.Snippet = 2;\r\n    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));\r\n    /**\r\n     * Completion item tags are extra annotations that tweak the rendering of a completion\r\n     * item.\r\n     *\r\n     * @since 3.15.0\r\n     */\r\n    var CompletionItemTag;\r\n    (function (CompletionItemTag) {\r\n        /**\r\n         * Render a completion as obsolete, usually using a strike-out.\r\n         */\r\n        CompletionItemTag.Deprecated = 1;\r\n    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));\r\n    /**\r\n     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\r\n     *\r\n     * @since 3.16.0\r\n     */\r\n    var InsertReplaceEdit;\r\n    (function (InsertReplaceEdit) {\r\n        /**\r\n         * Creates a new insert / replace edit\r\n         */\r\n        function create(newText, insert, replace) {\r\n            return { newText: newText, insert: insert, replace: replace };\r\n        }\r\n        InsertReplaceEdit.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\r\n        }\r\n        InsertReplaceEdit.is = is;\r\n    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));\r\n    /**\r\n     * How whitespace and indentation is handled during completion\r\n     * item insertion.\r\n     *\r\n     * @since 3.16.0\r\n     */\r\n    var InsertTextMode;\r\n    (function (InsertTextMode) {\r\n        /**\r\n         * The insertion or replace strings is taken as it is. If the\r\n         * value is multi line the lines below the cursor will be\r\n         * inserted using the indentation defined in the string value.\r\n         * The client will not apply any kind of adjustments to the\r\n         * string.\r\n         */\r\n        InsertTextMode.asIs = 1;\r\n        /**\r\n         * The editor adjusts leading whitespace of new lines so that\r\n         * they match the indentation up to the cursor of the line for\r\n         * which the item is accepted.\r\n         *\r\n         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\r\n         * multi line completion item is indented using 2 tabs and all\r\n         * following lines inserted will be indented using 2 tabs as well.\r\n         */\r\n        InsertTextMode.adjustIndentation = 2;\r\n    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));\r\n    var CompletionItemLabelDetails;\r\n    (function (CompletionItemLabelDetails) {\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\r\n                (Is.string(candidate.description) || candidate.description === undefined);\r\n        }\r\n        CompletionItemLabelDetails.is = is;\r\n    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));\r\n    /**\r\n     * The CompletionItem namespace provides functions to deal with\r\n     * completion items.\r\n     */\r\n    var CompletionItem;\r\n    (function (CompletionItem) {\r\n        /**\r\n         * Create a completion item and seed it with a label.\r\n         * @param label The completion item's label\r\n         */\r\n        function create(label) {\r\n            return { label: label };\r\n        }\r\n        CompletionItem.create = create;\r\n    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));\r\n    /**\r\n     * The CompletionList namespace provides functions to deal with\r\n     * completion lists.\r\n     */\r\n    var CompletionList;\r\n    (function (CompletionList) {\r\n        /**\r\n         * Creates a new completion list.\r\n         *\r\n         * @param items The completion items.\r\n         * @param isIncomplete The list is not complete.\r\n         */\r\n        function create(items, isIncomplete) {\r\n            return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n        }\r\n        CompletionList.create = create;\r\n    })(CompletionList || (exports.CompletionList = CompletionList = {}));\r\n    var MarkedString;\r\n    (function (MarkedString) {\r\n        /**\r\n         * Creates a marked string from plain text.\r\n         *\r\n         * @param plainText The plain text.\r\n         */\r\n        function fromPlainText(plainText) {\r\n            return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n        }\r\n        MarkedString.fromPlainText = fromPlainText;\r\n        /**\r\n         * Checks whether the given value conforms to the {@link MarkedString} type.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\r\n        }\r\n        MarkedString.is = is;\r\n    })(MarkedString || (exports.MarkedString = MarkedString = {}));\r\n    var Hover;\r\n    (function (Hover) {\r\n        /**\r\n         * Checks whether the given value conforms to the {@link Hover} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\r\n                MarkedString.is(candidate.contents) ||\r\n                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\r\n        }\r\n        Hover.is = is;\r\n    })(Hover || (exports.Hover = Hover = {}));\r\n    /**\r\n     * The ParameterInformation namespace provides helper functions to work with\r\n     * {@link ParameterInformation} literals.\r\n     */\r\n    var ParameterInformation;\r\n    (function (ParameterInformation) {\r\n        /**\r\n         * Creates a new parameter information literal.\r\n         *\r\n         * @param label A label string.\r\n         * @param documentation A doc string.\r\n         */\r\n        function create(label, documentation) {\r\n            return documentation ? { label: label, documentation: documentation } : { label: label };\r\n        }\r\n        ParameterInformation.create = create;\r\n    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));\r\n    /**\r\n     * The SignatureInformation namespace provides helper functions to work with\r\n     * {@link SignatureInformation} literals.\r\n     */\r\n    var SignatureInformation;\r\n    (function (SignatureInformation) {\r\n        function create(label, documentation) {\r\n            var parameters = [];\r\n            for (var _i = 2; _i < arguments.length; _i++) {\r\n                parameters[_i - 2] = arguments[_i];\r\n            }\r\n            var result = { label: label };\r\n            if (Is.defined(documentation)) {\r\n                result.documentation = documentation;\r\n            }\r\n            if (Is.defined(parameters)) {\r\n                result.parameters = parameters;\r\n            }\r\n            else {\r\n                result.parameters = [];\r\n            }\r\n            return result;\r\n        }\r\n        SignatureInformation.create = create;\r\n    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));\r\n    /**\r\n     * A document highlight kind.\r\n     */\r\n    var DocumentHighlightKind;\r\n    (function (DocumentHighlightKind) {\r\n        /**\r\n         * A textual occurrence.\r\n         */\r\n        DocumentHighlightKind.Text = 1;\r\n        /**\r\n         * Read-access of a symbol, like reading a variable.\r\n         */\r\n        DocumentHighlightKind.Read = 2;\r\n        /**\r\n         * Write-access of a symbol, like writing to a variable.\r\n         */\r\n        DocumentHighlightKind.Write = 3;\r\n    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));\r\n    /**\r\n     * DocumentHighlight namespace to provide helper functions to work with\r\n     * {@link DocumentHighlight} literals.\r\n     */\r\n    var DocumentHighlight;\r\n    (function (DocumentHighlight) {\r\n        /**\r\n         * Create a DocumentHighlight object.\r\n         * @param range The range the highlight applies to.\r\n         * @param kind The highlight kind\r\n         */\r\n        function create(range, kind) {\r\n            var result = { range: range };\r\n            if (Is.number(kind)) {\r\n                result.kind = kind;\r\n            }\r\n            return result;\r\n        }\r\n        DocumentHighlight.create = create;\r\n    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));\r\n    /**\r\n     * A symbol kind.\r\n     */\r\n    var SymbolKind;\r\n    (function (SymbolKind) {\r\n        SymbolKind.File = 1;\r\n        SymbolKind.Module = 2;\r\n        SymbolKind.Namespace = 3;\r\n        SymbolKind.Package = 4;\r\n        SymbolKind.Class = 5;\r\n        SymbolKind.Method = 6;\r\n        SymbolKind.Property = 7;\r\n        SymbolKind.Field = 8;\r\n        SymbolKind.Constructor = 9;\r\n        SymbolKind.Enum = 10;\r\n        SymbolKind.Interface = 11;\r\n        SymbolKind.Function = 12;\r\n        SymbolKind.Variable = 13;\r\n        SymbolKind.Constant = 14;\r\n        SymbolKind.String = 15;\r\n        SymbolKind.Number = 16;\r\n        SymbolKind.Boolean = 17;\r\n        SymbolKind.Array = 18;\r\n        SymbolKind.Object = 19;\r\n        SymbolKind.Key = 20;\r\n        SymbolKind.Null = 21;\r\n        SymbolKind.EnumMember = 22;\r\n        SymbolKind.Struct = 23;\r\n        SymbolKind.Event = 24;\r\n        SymbolKind.Operator = 25;\r\n        SymbolKind.TypeParameter = 26;\r\n    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));\r\n    /**\r\n     * Symbol tags are extra annotations that tweak the rendering of a symbol.\r\n     *\r\n     * @since 3.16\r\n     */\r\n    var SymbolTag;\r\n    (function (SymbolTag) {\r\n        /**\r\n         * Render a symbol as obsolete, usually using a strike-out.\r\n         */\r\n        SymbolTag.Deprecated = 1;\r\n    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));\r\n    var SymbolInformation;\r\n    (function (SymbolInformation) {\r\n        /**\r\n         * Creates a new symbol information literal.\r\n         *\r\n         * @param name The name of the symbol.\r\n         * @param kind The kind of the symbol.\r\n         * @param range The range of the location of the symbol.\r\n         * @param uri The resource of the location of symbol.\r\n         * @param containerName The name of the symbol containing the symbol.\r\n         */\r\n        function create(name, kind, range, uri, containerName) {\r\n            var result = {\r\n                name: name,\r\n                kind: kind,\r\n                location: { uri: uri, range: range }\r\n            };\r\n            if (containerName) {\r\n                result.containerName = containerName;\r\n            }\r\n            return result;\r\n        }\r\n        SymbolInformation.create = create;\r\n    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));\r\n    var WorkspaceSymbol;\r\n    (function (WorkspaceSymbol) {\r\n        /**\r\n         * Create a new workspace symbol.\r\n         *\r\n         * @param name The name of the symbol.\r\n         * @param kind The kind of the symbol.\r\n         * @param uri The resource of the location of the symbol.\r\n         * @param range An options range of the location.\r\n         * @returns A WorkspaceSymbol.\r\n         */\r\n        function create(name, kind, uri, range) {\r\n            return range !== undefined\r\n                ? { name: name, kind: kind, location: { uri: uri, range: range } }\r\n                : { name: name, kind: kind, location: { uri: uri } };\r\n        }\r\n        WorkspaceSymbol.create = create;\r\n    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));\r\n    var DocumentSymbol;\r\n    (function (DocumentSymbol) {\r\n        /**\r\n         * Creates a new symbol information literal.\r\n         *\r\n         * @param name The name of the symbol.\r\n         * @param detail The detail of the symbol.\r\n         * @param kind The kind of the symbol.\r\n         * @param range The range of the symbol.\r\n         * @param selectionRange The selectionRange of the symbol.\r\n         * @param children Children of the symbol.\r\n         */\r\n        function create(name, detail, kind, range, selectionRange, children) {\r\n            var result = {\r\n                name: name,\r\n                detail: detail,\r\n                kind: kind,\r\n                range: range,\r\n                selectionRange: selectionRange\r\n            };\r\n            if (children !== undefined) {\r\n                result.children = children;\r\n            }\r\n            return result;\r\n        }\r\n        DocumentSymbol.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate &&\r\n                Is.string(candidate.name) && Is.number(candidate.kind) &&\r\n                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\r\n                (candidate.detail === undefined || Is.string(candidate.detail)) &&\r\n                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\r\n                (candidate.children === undefined || Array.isArray(candidate.children)) &&\r\n                (candidate.tags === undefined || Array.isArray(candidate.tags));\r\n        }\r\n        DocumentSymbol.is = is;\r\n    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));\r\n    /**\r\n     * A set of predefined code action kinds\r\n     */\r\n    var CodeActionKind;\r\n    (function (CodeActionKind) {\r\n        /**\r\n         * Empty kind.\r\n         */\r\n        CodeActionKind.Empty = '';\r\n        /**\r\n         * Base kind for quickfix actions: 'quickfix'\r\n         */\r\n        CodeActionKind.QuickFix = 'quickfix';\r\n        /**\r\n         * Base kind for refactoring actions: 'refactor'\r\n         */\r\n        CodeActionKind.Refactor = 'refactor';\r\n        /**\r\n         * Base kind for refactoring extraction actions: 'refactor.extract'\r\n         *\r\n         * Example extract actions:\r\n         *\r\n         * - Extract method\r\n         * - Extract function\r\n         * - Extract variable\r\n         * - Extract interface from class\r\n         * - ...\r\n         */\r\n        CodeActionKind.RefactorExtract = 'refactor.extract';\r\n        /**\r\n         * Base kind for refactoring inline actions: 'refactor.inline'\r\n         *\r\n         * Example inline actions:\r\n         *\r\n         * - Inline function\r\n         * - Inline variable\r\n         * - Inline constant\r\n         * - ...\r\n         */\r\n        CodeActionKind.RefactorInline = 'refactor.inline';\r\n        /**\r\n         * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n         *\r\n         * Example rewrite actions:\r\n         *\r\n         * - Convert JavaScript function to class\r\n         * - Add or remove parameter\r\n         * - Encapsulate field\r\n         * - Make method static\r\n         * - Move method to base class\r\n         * - ...\r\n         */\r\n        CodeActionKind.RefactorRewrite = 'refactor.rewrite';\r\n        /**\r\n         * Base kind for source actions: `source`\r\n         *\r\n         * Source code actions apply to the entire file.\r\n         */\r\n        CodeActionKind.Source = 'source';\r\n        /**\r\n         * Base kind for an organize imports source action: `source.organizeImports`\r\n         */\r\n        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\r\n        /**\r\n         * Base kind for auto-fix source actions: `source.fixAll`.\r\n         *\r\n         * Fix all actions automatically fix errors that have a clear fix that do not require user input.\r\n         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\r\n         *\r\n         * @since 3.15.0\r\n         */\r\n        CodeActionKind.SourceFixAll = 'source.fixAll';\r\n    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));\r\n    /**\r\n     * The reason why code actions were requested.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    var CodeActionTriggerKind;\r\n    (function (CodeActionTriggerKind) {\r\n        /**\r\n         * Code actions were explicitly requested by the user or by an extension.\r\n         */\r\n        CodeActionTriggerKind.Invoked = 1;\r\n        /**\r\n         * Code actions were requested automatically.\r\n         *\r\n         * This typically happens when current selection in a file changes, but can\r\n         * also be triggered when file content changes.\r\n         */\r\n        CodeActionTriggerKind.Automatic = 2;\r\n    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));\r\n    /**\r\n     * The CodeActionContext namespace provides helper functions to work with\r\n     * {@link CodeActionContext} literals.\r\n     */\r\n    var CodeActionContext;\r\n    (function (CodeActionContext) {\r\n        /**\r\n         * Creates a new CodeActionContext literal.\r\n         */\r\n        function create(diagnostics, only, triggerKind) {\r\n            var result = { diagnostics: diagnostics };\r\n            if (only !== undefined && only !== null) {\r\n                result.only = only;\r\n            }\r\n            if (triggerKind !== undefined && triggerKind !== null) {\r\n                result.triggerKind = triggerKind;\r\n            }\r\n            return result;\r\n        }\r\n        CodeActionContext.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\r\n                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\r\n                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\r\n        }\r\n        CodeActionContext.is = is;\r\n    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));\r\n    var CodeAction;\r\n    (function (CodeAction) {\r\n        function create(title, kindOrCommandOrEdit, kind) {\r\n            var result = { title: title };\r\n            var checkKind = true;\r\n            if (typeof kindOrCommandOrEdit === 'string') {\r\n                checkKind = false;\r\n                result.kind = kindOrCommandOrEdit;\r\n            }\r\n            else if (Command.is(kindOrCommandOrEdit)) {\r\n                result.command = kindOrCommandOrEdit;\r\n            }\r\n            else {\r\n                result.edit = kindOrCommandOrEdit;\r\n            }\r\n            if (checkKind && kind !== undefined) {\r\n                result.kind = kind;\r\n            }\r\n            return result;\r\n        }\r\n        CodeAction.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate && Is.string(candidate.title) &&\r\n                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\r\n                (candidate.kind === undefined || Is.string(candidate.kind)) &&\r\n                (candidate.edit !== undefined || candidate.command !== undefined) &&\r\n                (candidate.command === undefined || Command.is(candidate.command)) &&\r\n                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\r\n                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\r\n        }\r\n        CodeAction.is = is;\r\n    })(CodeAction || (exports.CodeAction = CodeAction = {}));\r\n    /**\r\n     * The CodeLens namespace provides helper functions to work with\r\n     * {@link CodeLens} literals.\r\n     */\r\n    var CodeLens;\r\n    (function (CodeLens) {\r\n        /**\r\n         * Creates a new CodeLens literal.\r\n         */\r\n        function create(range, data) {\r\n            var result = { range: range };\r\n            if (Is.defined(data)) {\r\n                result.data = data;\r\n            }\r\n            return result;\r\n        }\r\n        CodeLens.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link CodeLens} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n        }\r\n        CodeLens.is = is;\r\n    })(CodeLens || (exports.CodeLens = CodeLens = {}));\r\n    /**\r\n     * The FormattingOptions namespace provides helper functions to work with\r\n     * {@link FormattingOptions} literals.\r\n     */\r\n    var FormattingOptions;\r\n    (function (FormattingOptions) {\r\n        /**\r\n         * Creates a new FormattingOptions literal.\r\n         */\r\n        function create(tabSize, insertSpaces) {\r\n            return { tabSize: tabSize, insertSpaces: insertSpaces };\r\n        }\r\n        FormattingOptions.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n        }\r\n        FormattingOptions.is = is;\r\n    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));\r\n    /**\r\n     * The DocumentLink namespace provides helper functions to work with\r\n     * {@link DocumentLink} literals.\r\n     */\r\n    var DocumentLink;\r\n    (function (DocumentLink) {\r\n        /**\r\n         * Creates a new DocumentLink literal.\r\n         */\r\n        function create(range, target, data) {\r\n            return { range: range, target: target, data: data };\r\n        }\r\n        DocumentLink.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link DocumentLink} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n        }\r\n        DocumentLink.is = is;\r\n    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));\r\n    /**\r\n     * The SelectionRange namespace provides helper function to work with\r\n     * SelectionRange literals.\r\n     */\r\n    var SelectionRange;\r\n    (function (SelectionRange) {\r\n        /**\r\n         * Creates a new SelectionRange\r\n         * @param range the range.\r\n         * @param parent an optional parent.\r\n         */\r\n        function create(range, parent) {\r\n            return { range: range, parent: parent };\r\n        }\r\n        SelectionRange.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\r\n        }\r\n        SelectionRange.is = is;\r\n    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));\r\n    /**\r\n     * A set of predefined token types. This set is not fixed\r\n     * an clients can specify additional token types via the\r\n     * corresponding client capabilities.\r\n     *\r\n     * @since 3.16.0\r\n     */\r\n    var SemanticTokenTypes;\r\n    (function (SemanticTokenTypes) {\r\n        SemanticTokenTypes[\"namespace\"] = \"namespace\";\r\n        /**\r\n         * Represents a generic type. Acts as a fallback for types which can't be mapped to\r\n         * a specific type like class or enum.\r\n         */\r\n        SemanticTokenTypes[\"type\"] = \"type\";\r\n        SemanticTokenTypes[\"class\"] = \"class\";\r\n        SemanticTokenTypes[\"enum\"] = \"enum\";\r\n        SemanticTokenTypes[\"interface\"] = \"interface\";\r\n        SemanticTokenTypes[\"struct\"] = \"struct\";\r\n        SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\r\n        SemanticTokenTypes[\"parameter\"] = \"parameter\";\r\n        SemanticTokenTypes[\"variable\"] = \"variable\";\r\n        SemanticTokenTypes[\"property\"] = \"property\";\r\n        SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\r\n        SemanticTokenTypes[\"event\"] = \"event\";\r\n        SemanticTokenTypes[\"function\"] = \"function\";\r\n        SemanticTokenTypes[\"method\"] = \"method\";\r\n        SemanticTokenTypes[\"macro\"] = \"macro\";\r\n        SemanticTokenTypes[\"keyword\"] = \"keyword\";\r\n        SemanticTokenTypes[\"modifier\"] = \"modifier\";\r\n        SemanticTokenTypes[\"comment\"] = \"comment\";\r\n        SemanticTokenTypes[\"string\"] = \"string\";\r\n        SemanticTokenTypes[\"number\"] = \"number\";\r\n        SemanticTokenTypes[\"regexp\"] = \"regexp\";\r\n        SemanticTokenTypes[\"operator\"] = \"operator\";\r\n        /**\r\n         * @since 3.17.0\r\n         */\r\n        SemanticTokenTypes[\"decorator\"] = \"decorator\";\r\n    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));\r\n    /**\r\n     * A set of predefined token modifiers. This set is not fixed\r\n     * an clients can specify additional token types via the\r\n     * corresponding client capabilities.\r\n     *\r\n     * @since 3.16.0\r\n     */\r\n    var SemanticTokenModifiers;\r\n    (function (SemanticTokenModifiers) {\r\n        SemanticTokenModifiers[\"declaration\"] = \"declaration\";\r\n        SemanticTokenModifiers[\"definition\"] = \"definition\";\r\n        SemanticTokenModifiers[\"readonly\"] = \"readonly\";\r\n        SemanticTokenModifiers[\"static\"] = \"static\";\r\n        SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\r\n        SemanticTokenModifiers[\"abstract\"] = \"abstract\";\r\n        SemanticTokenModifiers[\"async\"] = \"async\";\r\n        SemanticTokenModifiers[\"modification\"] = \"modification\";\r\n        SemanticTokenModifiers[\"documentation\"] = \"documentation\";\r\n        SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\r\n    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));\r\n    /**\r\n     * @since 3.16.0\r\n     */\r\n    var SemanticTokens;\r\n    (function (SemanticTokens) {\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\r\n                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\r\n        }\r\n        SemanticTokens.is = is;\r\n    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));\r\n    /**\r\n     * The InlineValueText namespace provides functions to deal with InlineValueTexts.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    var InlineValueText;\r\n    (function (InlineValueText) {\r\n        /**\r\n         * Creates a new InlineValueText literal.\r\n         */\r\n        function create(range, text) {\r\n            return { range: range, text: text };\r\n        }\r\n        InlineValueText.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\r\n        }\r\n        InlineValueText.is = is;\r\n    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));\r\n    /**\r\n     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    var InlineValueVariableLookup;\r\n    (function (InlineValueVariableLookup) {\r\n        /**\r\n         * Creates a new InlineValueText literal.\r\n         */\r\n        function create(range, variableName, caseSensitiveLookup) {\r\n            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };\r\n        }\r\n        InlineValueVariableLookup.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\r\n                && (Is.string(candidate.variableName) || candidate.variableName === undefined);\r\n        }\r\n        InlineValueVariableLookup.is = is;\r\n    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));\r\n    /**\r\n     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    var InlineValueEvaluatableExpression;\r\n    (function (InlineValueEvaluatableExpression) {\r\n        /**\r\n         * Creates a new InlineValueEvaluatableExpression literal.\r\n         */\r\n        function create(range, expression) {\r\n            return { range: range, expression: expression };\r\n        }\r\n        InlineValueEvaluatableExpression.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return candidate !== undefined && candidate !== null && Range.is(candidate.range)\r\n                && (Is.string(candidate.expression) || candidate.expression === undefined);\r\n        }\r\n        InlineValueEvaluatableExpression.is = is;\r\n    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));\r\n    /**\r\n     * The InlineValueContext namespace provides helper functions to work with\r\n     * {@link InlineValueContext} literals.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    var InlineValueContext;\r\n    (function (InlineValueContext) {\r\n        /**\r\n         * Creates a new InlineValueContext literal.\r\n         */\r\n        function create(frameId, stoppedLocation) {\r\n            return { frameId: frameId, stoppedLocation: stoppedLocation };\r\n        }\r\n        InlineValueContext.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Range.is(value.stoppedLocation);\r\n        }\r\n        InlineValueContext.is = is;\r\n    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));\r\n    /**\r\n     * Inlay hint kinds.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    var InlayHintKind;\r\n    (function (InlayHintKind) {\r\n        /**\r\n         * An inlay hint that for a type annotation.\r\n         */\r\n        InlayHintKind.Type = 1;\r\n        /**\r\n         * An inlay hint that is for a parameter.\r\n         */\r\n        InlayHintKind.Parameter = 2;\r\n        function is(value) {\r\n            return value === 1 || value === 2;\r\n        }\r\n        InlayHintKind.is = is;\r\n    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));\r\n    var InlayHintLabelPart;\r\n    (function (InlayHintLabelPart) {\r\n        function create(value) {\r\n            return { value: value };\r\n        }\r\n        InlayHintLabelPart.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate)\r\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\r\n                && (candidate.location === undefined || Location.is(candidate.location))\r\n                && (candidate.command === undefined || Command.is(candidate.command));\r\n        }\r\n        InlayHintLabelPart.is = is;\r\n    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));\r\n    var InlayHint;\r\n    (function (InlayHint) {\r\n        function create(position, label, kind) {\r\n            var result = { position: position, label: label };\r\n            if (kind !== undefined) {\r\n                result.kind = kind;\r\n            }\r\n            return result;\r\n        }\r\n        InlayHint.create = create;\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && Position.is(candidate.position)\r\n                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\r\n                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\r\n                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\r\n                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\r\n                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\r\n                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\r\n        }\r\n        InlayHint.is = is;\r\n    })(InlayHint || (exports.InlayHint = InlayHint = {}));\r\n    var StringValue;\r\n    (function (StringValue) {\r\n        function createSnippet(value) {\r\n            return { kind: 'snippet', value: value };\r\n        }\r\n        StringValue.createSnippet = createSnippet;\r\n    })(StringValue || (exports.StringValue = StringValue = {}));\r\n    var InlineCompletionItem;\r\n    (function (InlineCompletionItem) {\r\n        function create(insertText, filterText, range, command) {\r\n            return { insertText: insertText, filterText: filterText, range: range, command: command };\r\n        }\r\n        InlineCompletionItem.create = create;\r\n    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));\r\n    var InlineCompletionList;\r\n    (function (InlineCompletionList) {\r\n        function create(items) {\r\n            return { items: items };\r\n        }\r\n        InlineCompletionList.create = create;\r\n    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));\r\n    /**\r\n     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\r\n     *\r\n     * @since 3.18.0\r\n     * @proposed\r\n     */\r\n    var InlineCompletionTriggerKind;\r\n    (function (InlineCompletionTriggerKind) {\r\n        /**\r\n         * Completion was triggered explicitly by a user gesture.\r\n         */\r\n        InlineCompletionTriggerKind.Invoked = 0;\r\n        /**\r\n         * Completion was triggered automatically while editing.\r\n         */\r\n        InlineCompletionTriggerKind.Automatic = 1;\r\n    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));\r\n    var SelectedCompletionInfo;\r\n    (function (SelectedCompletionInfo) {\r\n        function create(range, text) {\r\n            return { range: range, text: text };\r\n        }\r\n        SelectedCompletionInfo.create = create;\r\n    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));\r\n    var InlineCompletionContext;\r\n    (function (InlineCompletionContext) {\r\n        function create(triggerKind, selectedCompletionInfo) {\r\n            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };\r\n        }\r\n        InlineCompletionContext.create = create;\r\n    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));\r\n    var WorkspaceFolder;\r\n    (function (WorkspaceFolder) {\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\r\n        }\r\n        WorkspaceFolder.is = is;\r\n    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));\r\n    exports.EOL = ['\\n', '\\r\\n', '\\r'];\r\n    /**\r\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\r\n     */\r\n    var TextDocument;\r\n    (function (TextDocument) {\r\n        /**\r\n         * Creates a new ITextDocument literal from the given uri and content.\r\n         * @param uri The document's uri.\r\n         * @param languageId The document's language Id.\r\n         * @param version The document's version.\r\n         * @param content The document's content.\r\n         */\r\n        function create(uri, languageId, version, content) {\r\n            return new FullTextDocument(uri, languageId, version, content);\r\n        }\r\n        TextDocument.create = create;\r\n        /**\r\n         * Checks whether the given literal conforms to the {@link ITextDocument} interface.\r\n         */\r\n        function is(value) {\r\n            var candidate = value;\r\n            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\r\n                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n        }\r\n        TextDocument.is = is;\r\n        function applyEdits(document, edits) {\r\n            var text = document.getText();\r\n            var sortedEdits = mergeSort(edits, function (a, b) {\r\n                var diff = a.range.start.line - b.range.start.line;\r\n                if (diff === 0) {\r\n                    return a.range.start.character - b.range.start.character;\r\n                }\r\n                return diff;\r\n            });\r\n            var lastModifiedOffset = text.length;\r\n            for (var i = sortedEdits.length - 1; i >= 0; i--) {\r\n                var e = sortedEdits[i];\r\n                var startOffset = document.offsetAt(e.range.start);\r\n                var endOffset = document.offsetAt(e.range.end);\r\n                if (endOffset <= lastModifiedOffset) {\r\n                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n                }\r\n                else {\r\n                    throw new Error('Overlapping edit');\r\n                }\r\n                lastModifiedOffset = startOffset;\r\n            }\r\n            return text;\r\n        }\r\n        TextDocument.applyEdits = applyEdits;\r\n        function mergeSort(data, compare) {\r\n            if (data.length <= 1) {\r\n                // sorted\r\n                return data;\r\n            }\r\n            var p = (data.length / 2) | 0;\r\n            var left = data.slice(0, p);\r\n            var right = data.slice(p);\r\n            mergeSort(left, compare);\r\n            mergeSort(right, compare);\r\n            var leftIdx = 0;\r\n            var rightIdx = 0;\r\n            var i = 0;\r\n            while (leftIdx < left.length && rightIdx < right.length) {\r\n                var ret = compare(left[leftIdx], right[rightIdx]);\r\n                if (ret <= 0) {\r\n                    // smaller_equal -> take left to preserve order\r\n                    data[i++] = left[leftIdx++];\r\n                }\r\n                else {\r\n                    // greater -> take right\r\n                    data[i++] = right[rightIdx++];\r\n                }\r\n            }\r\n            while (leftIdx < left.length) {\r\n                data[i++] = left[leftIdx++];\r\n            }\r\n            while (rightIdx < right.length) {\r\n                data[i++] = right[rightIdx++];\r\n            }\r\n            return data;\r\n        }\r\n    })(TextDocument || (exports.TextDocument = TextDocument = {}));\r\n    /**\r\n     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\r\n     */\r\n    var FullTextDocument = /** @class */ (function () {\r\n        function FullTextDocument(uri, languageId, version, content) {\r\n            this._uri = uri;\r\n            this._languageId = languageId;\r\n            this._version = version;\r\n            this._content = content;\r\n            this._lineOffsets = undefined;\r\n        }\r\n        Object.defineProperty(FullTextDocument.prototype, \"uri\", {\r\n            get: function () {\r\n                return this._uri;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FullTextDocument.prototype, \"languageId\", {\r\n            get: function () {\r\n                return this._languageId;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        Object.defineProperty(FullTextDocument.prototype, \"version\", {\r\n            get: function () {\r\n                return this._version;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        FullTextDocument.prototype.getText = function (range) {\r\n            if (range) {\r\n                var start = this.offsetAt(range.start);\r\n                var end = this.offsetAt(range.end);\r\n                return this._content.substring(start, end);\r\n            }\r\n            return this._content;\r\n        };\r\n        FullTextDocument.prototype.update = function (event, version) {\r\n            this._content = event.text;\r\n            this._version = version;\r\n            this._lineOffsets = undefined;\r\n        };\r\n        FullTextDocument.prototype.getLineOffsets = function () {\r\n            if (this._lineOffsets === undefined) {\r\n                var lineOffsets = [];\r\n                var text = this._content;\r\n                var isLineStart = true;\r\n                for (var i = 0; i < text.length; i++) {\r\n                    if (isLineStart) {\r\n                        lineOffsets.push(i);\r\n                        isLineStart = false;\r\n                    }\r\n                    var ch = text.charAt(i);\r\n                    isLineStart = (ch === '\\r' || ch === '\\n');\r\n                    if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\r\n                        i++;\r\n                    }\r\n                }\r\n                if (isLineStart && text.length > 0) {\r\n                    lineOffsets.push(text.length);\r\n                }\r\n                this._lineOffsets = lineOffsets;\r\n            }\r\n            return this._lineOffsets;\r\n        };\r\n        FullTextDocument.prototype.positionAt = function (offset) {\r\n            offset = Math.max(Math.min(offset, this._content.length), 0);\r\n            var lineOffsets = this.getLineOffsets();\r\n            var low = 0, high = lineOffsets.length;\r\n            if (high === 0) {\r\n                return Position.create(0, offset);\r\n            }\r\n            while (low < high) {\r\n                var mid = Math.floor((low + high) / 2);\r\n                if (lineOffsets[mid] > offset) {\r\n                    high = mid;\r\n                }\r\n                else {\r\n                    low = mid + 1;\r\n                }\r\n            }\r\n            // low is the least x for which the line offset is larger than the current offset\r\n            // or array.length if no line offset is larger than the current offset\r\n            var line = low - 1;\r\n            return Position.create(line, offset - lineOffsets[line]);\r\n        };\r\n        FullTextDocument.prototype.offsetAt = function (position) {\r\n            var lineOffsets = this.getLineOffsets();\r\n            if (position.line >= lineOffsets.length) {\r\n                return this._content.length;\r\n            }\r\n            else if (position.line < 0) {\r\n                return 0;\r\n            }\r\n            var lineOffset = lineOffsets[position.line];\r\n            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n        };\r\n        Object.defineProperty(FullTextDocument.prototype, \"lineCount\", {\r\n            get: function () {\r\n                return this.getLineOffsets().length;\r\n            },\r\n            enumerable: false,\r\n            configurable: true\r\n        });\r\n        return FullTextDocument;\r\n    }());\r\n    var Is;\r\n    (function (Is) {\r\n        var toString = Object.prototype.toString;\r\n        function defined(value) {\r\n            return typeof value !== 'undefined';\r\n        }\r\n        Is.defined = defined;\r\n        function undefined(value) {\r\n            return typeof value === 'undefined';\r\n        }\r\n        Is.undefined = undefined;\r\n        function boolean(value) {\r\n            return value === true || value === false;\r\n        }\r\n        Is.boolean = boolean;\r\n        function string(value) {\r\n            return toString.call(value) === '[object String]';\r\n        }\r\n        Is.string = string;\r\n        function number(value) {\r\n            return toString.call(value) === '[object Number]';\r\n        }\r\n        Is.number = number;\r\n        function numberRange(value, min, max) {\r\n            return toString.call(value) === '[object Number]' && min <= value && value <= max;\r\n        }\r\n        Is.numberRange = numberRange;\r\n        function integer(value) {\r\n            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\r\n        }\r\n        Is.integer = integer;\r\n        function uinteger(value) {\r\n            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\r\n        }\r\n        Is.uinteger = uinteger;\r\n        function func(value) {\r\n            return toString.call(value) === '[object Function]';\r\n        }\r\n        Is.func = func;\r\n        function objectLiteral(value) {\r\n            // Strictly speaking class instances pass this check as well. Since the LSP\r\n            // doesn't use classes we ignore this for now. If we do we need to add something\r\n            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n            return value !== null && typeof value === 'object';\r\n        }\r\n        Is.objectLiteral = objectLiteral;\r\n        function typedArray(value, check) {\r\n            return Array.isArray(value) && value.every(check);\r\n        }\r\n        Is.typedArray = typedArray;\r\n    })(Is || (Is = {}));\r\n});\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ProtocolNotificationType = exports.ProtocolNotificationType0 = exports.ProtocolRequestType = exports.ProtocolRequestType0 = exports.RegistrationType = exports.MessageDirection = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nvar MessageDirection;\r\n(function (MessageDirection) {\r\n    MessageDirection[\"clientToServer\"] = \"clientToServer\";\r\n    MessageDirection[\"serverToClient\"] = \"serverToClient\";\r\n    MessageDirection[\"both\"] = \"both\";\r\n})(MessageDirection || (exports.MessageDirection = MessageDirection = {}));\r\nclass RegistrationType {\r\n    constructor(method) {\r\n        this.method = method;\r\n    }\r\n}\r\nexports.RegistrationType = RegistrationType;\r\nclass ProtocolRequestType0 extends vscode_jsonrpc_1.RequestType0 {\r\n    constructor(method) {\r\n        super(method);\r\n    }\r\n}\r\nexports.ProtocolRequestType0 = ProtocolRequestType0;\r\nclass ProtocolRequestType extends vscode_jsonrpc_1.RequestType {\r\n    constructor(method) {\r\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\r\n    }\r\n}\r\nexports.ProtocolRequestType = ProtocolRequestType;\r\nclass ProtocolNotificationType0 extends vscode_jsonrpc_1.NotificationType0 {\r\n    constructor(method) {\r\n        super(method);\r\n    }\r\n}\r\nexports.ProtocolNotificationType0 = ProtocolNotificationType0;\r\nclass ProtocolNotificationType extends vscode_jsonrpc_1.NotificationType {\r\n    constructor(method) {\r\n        super(method, vscode_jsonrpc_1.ParameterStructures.byName);\r\n    }\r\n}\r\nexports.ProtocolNotificationType = ProtocolNotificationType;\r\n", "/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.objectLiteral = exports.typedArray = exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;\r\nfunction boolean(value) {\r\n    return value === true || value === false;\r\n}\r\nexports.boolean = boolean;\r\nfunction string(value) {\r\n    return typeof value === 'string' || value instanceof String;\r\n}\r\nexports.string = string;\r\nfunction number(value) {\r\n    return typeof value === 'number' || value instanceof Number;\r\n}\r\nexports.number = number;\r\nfunction error(value) {\r\n    return value instanceof Error;\r\n}\r\nexports.error = error;\r\nfunction func(value) {\r\n    return typeof value === 'function';\r\n}\r\nexports.func = func;\r\nfunction array(value) {\r\n    return Array.isArray(value);\r\n}\r\nexports.array = array;\r\nfunction stringArray(value) {\r\n    return array(value) && value.every(elem => string(elem));\r\n}\r\nexports.stringArray = stringArray;\r\nfunction typedArray(value, check) {\r\n    return Array.isArray(value) && value.every(check);\r\n}\r\nexports.typedArray = typedArray;\r\nfunction objectLiteral(value) {\r\n    // Strictly speaking class instances pass this check as well. Since the LSP\r\n    // doesn't use classes we ignore this for now. If we do we need to add something\r\n    // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n    return value !== null && typeof value === 'object';\r\n}\r\nexports.objectLiteral = objectLiteral;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ImplementationRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * A request to resolve the implementation locations of a symbol at a given text\r\n * document position. The request's parameter is of type {@link TextDocumentPositionParams}\r\n * the response is of type {@link Definition} or a Thenable that resolves to such.\r\n */\r\nvar ImplementationRequest;\r\n(function (ImplementationRequest) {\r\n    ImplementationRequest.method = 'textDocument/implementation';\r\n    ImplementationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    ImplementationRequest.type = new messages_1.ProtocolRequestType(ImplementationRequest.method);\r\n})(ImplementationRequest || (exports.ImplementationRequest = ImplementationRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TypeDefinitionRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n// @ts-ignore: to avoid inlining LocatioLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * A request to resolve the type definition locations of a symbol at a given text\r\n * document position. The request's parameter is of type {@link TextDocumentPositionParams}\r\n * the response is of type {@link Definition} or a Thenable that resolves to such.\r\n */\r\nvar TypeDefinitionRequest;\r\n(function (TypeDefinitionRequest) {\r\n    TypeDefinitionRequest.method = 'textDocument/typeDefinition';\r\n    TypeDefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    TypeDefinitionRequest.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest.method);\r\n})(TypeDefinitionRequest || (exports.TypeDefinitionRequest = TypeDefinitionRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * The `workspace/workspaceFolders` is sent from the server to the client to fetch the open workspace folders.\r\n */\r\nvar WorkspaceFoldersRequest;\r\n(function (WorkspaceFoldersRequest) {\r\n    WorkspaceFoldersRequest.method = 'workspace/workspaceFolders';\r\n    WorkspaceFoldersRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    WorkspaceFoldersRequest.type = new messages_1.ProtocolRequestType0(WorkspaceFoldersRequest.method);\r\n})(WorkspaceFoldersRequest || (exports.WorkspaceFoldersRequest = WorkspaceFoldersRequest = {}));\r\n/**\r\n * The `workspace/didChangeWorkspaceFolders` notification is sent from the client to the server when the workspace\r\n * folder configuration changes.\r\n */\r\nvar DidChangeWorkspaceFoldersNotification;\r\n(function (DidChangeWorkspaceFoldersNotification) {\r\n    DidChangeWorkspaceFoldersNotification.method = 'workspace/didChangeWorkspaceFolders';\r\n    DidChangeWorkspaceFoldersNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidChangeWorkspaceFoldersNotification.type = new messages_1.ProtocolNotificationType(DidChangeWorkspaceFoldersNotification.method);\r\n})(DidChangeWorkspaceFoldersNotification || (exports.DidChangeWorkspaceFoldersNotification = DidChangeWorkspaceFoldersNotification = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConfigurationRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n//---- Get Configuration request ----\r\n/**\r\n * The 'workspace/configuration' request is sent from the server to the client to fetch a certain\r\n * configuration setting.\r\n *\r\n * This pull model replaces the old push model were the client signaled configuration change via an\r\n * event. If the server still needs to react to configuration changes (since the server caches the\r\n * result of `workspace/configuration` requests) the server should register for an empty configuration\r\n * change event and empty the cache if such an event is received.\r\n */\r\nvar ConfigurationRequest;\r\n(function (ConfigurationRequest) {\r\n    ConfigurationRequest.method = 'workspace/configuration';\r\n    ConfigurationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    ConfigurationRequest.type = new messages_1.ProtocolRequestType(ConfigurationRequest.method);\r\n})(ConfigurationRequest || (exports.ConfigurationRequest = ConfigurationRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ColorPresentationRequest = exports.DocumentColorRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to list all color symbols found in a given text document. The request's\r\n * parameter is of type {@link DocumentColorParams} the\r\n * response is of type {@link ColorInformation ColorInformation[]} or a Thenable\r\n * that resolves to such.\r\n */\r\nvar DocumentColorRequest;\r\n(function (DocumentColorRequest) {\r\n    DocumentColorRequest.method = 'textDocument/documentColor';\r\n    DocumentColorRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentColorRequest.type = new messages_1.ProtocolRequestType(DocumentColorRequest.method);\r\n})(DocumentColorRequest || (exports.DocumentColorRequest = DocumentColorRequest = {}));\r\n/**\r\n * A request to list all presentation for a color. The request's\r\n * parameter is of type {@link ColorPresentationParams} the\r\n * response is of type {@link ColorInformation ColorInformation[]} or a Thenable\r\n * that resolves to such.\r\n */\r\nvar ColorPresentationRequest;\r\n(function (ColorPresentationRequest) {\r\n    ColorPresentationRequest.method = 'textDocument/colorPresentation';\r\n    ColorPresentationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    ColorPresentationRequest.type = new messages_1.ProtocolRequestType(ColorPresentationRequest.method);\r\n})(ColorPresentationRequest || (exports.ColorPresentationRequest = ColorPresentationRequest = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to provide folding ranges in a document. The request's\r\n * parameter is of type {@link FoldingRangeParams}, the\r\n * response is of type {@link FoldingRangeList} or a Thenable\r\n * that resolves to such.\r\n */\r\nvar FoldingRangeRequest;\r\n(function (FoldingRangeRequest) {\r\n    FoldingRangeRequest.method = 'textDocument/foldingRange';\r\n    FoldingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    FoldingRangeRequest.type = new messages_1.ProtocolRequestType(FoldingRangeRequest.method);\r\n})(FoldingRangeRequest || (exports.FoldingRangeRequest = FoldingRangeRequest = {}));\r\n/**\r\n * @since 3.18.0\r\n * @proposed\r\n */\r\nvar FoldingRangeRefreshRequest;\r\n(function (FoldingRangeRefreshRequest) {\r\n    FoldingRangeRefreshRequest.method = `workspace/foldingRange/refresh`;\r\n    FoldingRangeRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    FoldingRangeRefreshRequest.type = new messages_1.ProtocolRequestType0(FoldingRangeRefreshRequest.method);\r\n})(FoldingRangeRefreshRequest || (exports.FoldingRangeRefreshRequest = FoldingRangeRefreshRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DeclarationRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * A request to resolve the type definition locations of a symbol at a given text\r\n * document position. The request's parameter is of type {@link TextDocumentPositionParams}\r\n * the response is of type {@link Declaration} or a typed array of {@link DeclarationLink}\r\n * or a Thenable that resolves to such.\r\n */\r\nvar DeclarationRequest;\r\n(function (DeclarationRequest) {\r\n    DeclarationRequest.method = 'textDocument/declaration';\r\n    DeclarationRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DeclarationRequest.type = new messages_1.ProtocolRequestType(DeclarationRequest.method);\r\n})(DeclarationRequest || (exports.DeclarationRequest = DeclarationRequest = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SelectionRangeRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to provide selection ranges in a document. The request's\r\n * parameter is of type {@link SelectionRangeParams}, the\r\n * response is of type {@link SelectionRange SelectionRange[]} or a Thenable\r\n * that resolves to such.\r\n */\r\nvar SelectionRangeRequest;\r\n(function (SelectionRangeRequest) {\r\n    SelectionRangeRequest.method = 'textDocument/selectionRange';\r\n    SelectionRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    SelectionRangeRequest.type = new messages_1.ProtocolRequestType(SelectionRangeRequest.method);\r\n})(SelectionRangeRequest || (exports.SelectionRangeRequest = SelectionRangeRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst messages_1 = require(\"./messages\");\r\nvar WorkDoneProgress;\r\n(function (WorkDoneProgress) {\r\n    WorkDoneProgress.type = new vscode_jsonrpc_1.ProgressType();\r\n    function is(value) {\r\n        return value === WorkDoneProgress.type;\r\n    }\r\n    WorkDoneProgress.is = is;\r\n})(WorkDoneProgress || (exports.WorkDoneProgress = WorkDoneProgress = {}));\r\n/**\r\n * The `window/workDoneProgress/create` request is sent from the server to the client to initiate progress\r\n * reporting from the server.\r\n */\r\nvar WorkDoneProgressCreateRequest;\r\n(function (WorkDoneProgressCreateRequest) {\r\n    WorkDoneProgressCreateRequest.method = 'window/workDoneProgress/create';\r\n    WorkDoneProgressCreateRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    WorkDoneProgressCreateRequest.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest.method);\r\n})(WorkDoneProgressCreateRequest || (exports.WorkDoneProgressCreateRequest = WorkDoneProgressCreateRequest = {}));\r\n/**\r\n * The `window/workDoneProgress/cancel` notification is sent from  the client to the server to cancel a progress\r\n * initiated on the server side.\r\n */\r\nvar WorkDoneProgressCancelNotification;\r\n(function (WorkDoneProgressCancelNotification) {\r\n    WorkDoneProgressCancelNotification.method = 'window/workDoneProgress/cancel';\r\n    WorkDoneProgressCancelNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WorkDoneProgressCancelNotification.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification.method);\r\n})(WorkDoneProgressCancelNotification || (exports.WorkDoneProgressCancelNotification = WorkDoneProgressCancelNotification = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) TypeFox, Microsoft and others. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.CallHierarchyPrepareRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to result a `CallHierarchyItem` in a document at a given position.\r\n * Can be used as an input to an incoming or outgoing call hierarchy.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar CallHierarchyPrepareRequest;\r\n(function (CallHierarchyPrepareRequest) {\r\n    CallHierarchyPrepareRequest.method = 'textDocument/prepareCallHierarchy';\r\n    CallHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CallHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest.method);\r\n})(CallHierarchyPrepareRequest || (exports.CallHierarchyPrepareRequest = CallHierarchyPrepareRequest = {}));\r\n/**\r\n * A request to resolve the incoming calls for a given `CallHierarchyItem`.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar CallHierarchyIncomingCallsRequest;\r\n(function (CallHierarchyIncomingCallsRequest) {\r\n    CallHierarchyIncomingCallsRequest.method = 'callHierarchy/incomingCalls';\r\n    CallHierarchyIncomingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CallHierarchyIncomingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest.method);\r\n})(CallHierarchyIncomingCallsRequest || (exports.CallHierarchyIncomingCallsRequest = CallHierarchyIncomingCallsRequest = {}));\r\n/**\r\n * A request to resolve the outgoing calls for a given `CallHierarchyItem`.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar CallHierarchyOutgoingCallsRequest;\r\n(function (CallHierarchyOutgoingCallsRequest) {\r\n    CallHierarchyOutgoingCallsRequest.method = 'callHierarchy/outgoingCalls';\r\n    CallHierarchyOutgoingCallsRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CallHierarchyOutgoingCallsRequest.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest.method);\r\n})(CallHierarchyOutgoingCallsRequest || (exports.CallHierarchyOutgoingCallsRequest = CallHierarchyOutgoingCallsRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.SemanticTokensRegistrationType = exports.TokenFormat = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n//------- 'textDocument/semanticTokens' -----\r\nvar TokenFormat;\r\n(function (TokenFormat) {\r\n    TokenFormat.Relative = 'relative';\r\n})(TokenFormat || (exports.TokenFormat = TokenFormat = {}));\r\nvar SemanticTokensRegistrationType;\r\n(function (SemanticTokensRegistrationType) {\r\n    SemanticTokensRegistrationType.method = 'textDocument/semanticTokens';\r\n    SemanticTokensRegistrationType.type = new messages_1.RegistrationType(SemanticTokensRegistrationType.method);\r\n})(SemanticTokensRegistrationType || (exports.SemanticTokensRegistrationType = SemanticTokensRegistrationType = {}));\r\n/**\r\n * @since 3.16.0\r\n */\r\nvar SemanticTokensRequest;\r\n(function (SemanticTokensRequest) {\r\n    SemanticTokensRequest.method = 'textDocument/semanticTokens/full';\r\n    SemanticTokensRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    SemanticTokensRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRequest.method);\r\n    SemanticTokensRequest.registrationMethod = SemanticTokensRegistrationType.method;\r\n})(SemanticTokensRequest || (exports.SemanticTokensRequest = SemanticTokensRequest = {}));\r\n/**\r\n * @since 3.16.0\r\n */\r\nvar SemanticTokensDeltaRequest;\r\n(function (SemanticTokensDeltaRequest) {\r\n    SemanticTokensDeltaRequest.method = 'textDocument/semanticTokens/full/delta';\r\n    SemanticTokensDeltaRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    SemanticTokensDeltaRequest.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest.method);\r\n    SemanticTokensDeltaRequest.registrationMethod = SemanticTokensRegistrationType.method;\r\n})(SemanticTokensDeltaRequest || (exports.SemanticTokensDeltaRequest = SemanticTokensDeltaRequest = {}));\r\n/**\r\n * @since 3.16.0\r\n */\r\nvar SemanticTokensRangeRequest;\r\n(function (SemanticTokensRangeRequest) {\r\n    SemanticTokensRangeRequest.method = 'textDocument/semanticTokens/range';\r\n    SemanticTokensRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    SemanticTokensRangeRequest.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest.method);\r\n    SemanticTokensRangeRequest.registrationMethod = SemanticTokensRegistrationType.method;\r\n})(SemanticTokensRangeRequest || (exports.SemanticTokensRangeRequest = SemanticTokensRangeRequest = {}));\r\n/**\r\n * @since 3.16.0\r\n */\r\nvar SemanticTokensRefreshRequest;\r\n(function (SemanticTokensRefreshRequest) {\r\n    SemanticTokensRefreshRequest.method = `workspace/semanticTokens/refresh`;\r\n    SemanticTokensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    SemanticTokensRefreshRequest.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest.method);\r\n})(SemanticTokensRefreshRequest || (exports.SemanticTokensRefreshRequest = SemanticTokensRefreshRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ShowDocumentRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to show a document. This request might open an\r\n * external program depending on the value of the URI to open.\r\n * For example a request to open `https://code.visualstudio.com/`\r\n * will very likely open the URI in a WEB browser.\r\n *\r\n * @since 3.16.0\r\n*/\r\nvar ShowDocumentRequest;\r\n(function (ShowDocumentRequest) {\r\n    ShowDocumentRequest.method = 'window/showDocument';\r\n    ShowDocumentRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    ShowDocumentRequest.type = new messages_1.ProtocolRequestType(ShowDocumentRequest.method);\r\n})(ShowDocumentRequest || (exports.ShowDocumentRequest = ShowDocumentRequest = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LinkedEditingRangeRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to provide ranges that can be edited together.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar LinkedEditingRangeRequest;\r\n(function (LinkedEditingRangeRequest) {\r\n    LinkedEditingRangeRequest.method = 'textDocument/linkedEditingRange';\r\n    LinkedEditingRangeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    LinkedEditingRangeRequest.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest.method);\r\n})(LinkedEditingRangeRequest || (exports.LinkedEditingRangeRequest = LinkedEditingRangeRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.DidRenameFilesNotification = exports.WillRenameFilesRequest = exports.DidCreateFilesNotification = exports.WillCreateFilesRequest = exports.FileOperationPatternKind = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A pattern kind describing if a glob pattern matches a file a folder or\r\n * both.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar FileOperationPatternKind;\r\n(function (FileOperationPatternKind) {\r\n    /**\r\n     * The pattern matches a file only.\r\n     */\r\n    FileOperationPatternKind.file = 'file';\r\n    /**\r\n     * The pattern matches a folder only.\r\n     */\r\n    FileOperationPatternKind.folder = 'folder';\r\n})(FileOperationPatternKind || (exports.FileOperationPatternKind = FileOperationPatternKind = {}));\r\n/**\r\n * The will create files request is sent from the client to the server before files are actually\r\n * created as long as the creation is triggered from within the client.\r\n *\r\n * The request can return a `WorkspaceEdit` which will be applied to workspace before the\r\n * files are created. Hence the `WorkspaceEdit` can not manipulate the content of the file\r\n * to be created.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar WillCreateFilesRequest;\r\n(function (WillCreateFilesRequest) {\r\n    WillCreateFilesRequest.method = 'workspace/willCreateFiles';\r\n    WillCreateFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WillCreateFilesRequest.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest.method);\r\n})(WillCreateFilesRequest || (exports.WillCreateFilesRequest = WillCreateFilesRequest = {}));\r\n/**\r\n * The did create files notification is sent from the client to the server when\r\n * files were created from within the client.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar DidCreateFilesNotification;\r\n(function (DidCreateFilesNotification) {\r\n    DidCreateFilesNotification.method = 'workspace/didCreateFiles';\r\n    DidCreateFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidCreateFilesNotification.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification.method);\r\n})(DidCreateFilesNotification || (exports.DidCreateFilesNotification = DidCreateFilesNotification = {}));\r\n/**\r\n * The will rename files request is sent from the client to the server before files are actually\r\n * renamed as long as the rename is triggered from within the client.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar WillRenameFilesRequest;\r\n(function (WillRenameFilesRequest) {\r\n    WillRenameFilesRequest.method = 'workspace/willRenameFiles';\r\n    WillRenameFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WillRenameFilesRequest.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest.method);\r\n})(WillRenameFilesRequest || (exports.WillRenameFilesRequest = WillRenameFilesRequest = {}));\r\n/**\r\n * The did rename files notification is sent from the client to the server when\r\n * files were renamed from within the client.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar DidRenameFilesNotification;\r\n(function (DidRenameFilesNotification) {\r\n    DidRenameFilesNotification.method = 'workspace/didRenameFiles';\r\n    DidRenameFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidRenameFilesNotification.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification.method);\r\n})(DidRenameFilesNotification || (exports.DidRenameFilesNotification = DidRenameFilesNotification = {}));\r\n/**\r\n * The will delete files request is sent from the client to the server before files are actually\r\n * deleted as long as the deletion is triggered from within the client.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar DidDeleteFilesNotification;\r\n(function (DidDeleteFilesNotification) {\r\n    DidDeleteFilesNotification.method = 'workspace/didDeleteFiles';\r\n    DidDeleteFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidDeleteFilesNotification.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification.method);\r\n})(DidDeleteFilesNotification || (exports.DidDeleteFilesNotification = DidDeleteFilesNotification = {}));\r\n/**\r\n * The did delete files notification is sent from the client to the server when\r\n * files were deleted from within the client.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar WillDeleteFilesRequest;\r\n(function (WillDeleteFilesRequest) {\r\n    WillDeleteFilesRequest.method = 'workspace/willDeleteFiles';\r\n    WillDeleteFilesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WillDeleteFilesRequest.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest.method);\r\n})(WillDeleteFilesRequest || (exports.WillDeleteFilesRequest = WillDeleteFilesRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * Moniker uniqueness level to define scope of the moniker.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar UniquenessLevel;\r\n(function (UniquenessLevel) {\r\n    /**\r\n     * The moniker is only unique inside a document\r\n     */\r\n    UniquenessLevel.document = 'document';\r\n    /**\r\n     * The moniker is unique inside a project for which a dump got created\r\n     */\r\n    UniquenessLevel.project = 'project';\r\n    /**\r\n     * The moniker is unique inside the group to which a project belongs\r\n     */\r\n    UniquenessLevel.group = 'group';\r\n    /**\r\n     * The moniker is unique inside the moniker scheme.\r\n     */\r\n    UniquenessLevel.scheme = 'scheme';\r\n    /**\r\n     * The moniker is globally unique\r\n     */\r\n    UniquenessLevel.global = 'global';\r\n})(UniquenessLevel || (exports.UniquenessLevel = UniquenessLevel = {}));\r\n/**\r\n * The moniker kind.\r\n *\r\n * @since 3.16.0\r\n */\r\nvar MonikerKind;\r\n(function (MonikerKind) {\r\n    /**\r\n     * The moniker represent a symbol that is imported into a project\r\n     */\r\n    MonikerKind.$import = 'import';\r\n    /**\r\n     * The moniker represents a symbol that is exported from a project\r\n     */\r\n    MonikerKind.$export = 'export';\r\n    /**\r\n     * The moniker represents a symbol that is local to a project (e.g. a local\r\n     * variable of a function, a class not visible outside the project, ...)\r\n     */\r\n    MonikerKind.local = 'local';\r\n})(MonikerKind || (exports.MonikerKind = MonikerKind = {}));\r\n/**\r\n * A request to get the moniker of a symbol at a given text document position.\r\n * The request parameter is of type {@link TextDocumentPositionParams}.\r\n * The response is of type {@link Moniker Moniker[]} or `null`.\r\n */\r\nvar MonikerRequest;\r\n(function (MonikerRequest) {\r\n    MonikerRequest.method = 'textDocument/moniker';\r\n    MonikerRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    MonikerRequest.type = new messages_1.ProtocolRequestType(MonikerRequest.method);\r\n})(MonikerRequest || (exports.MonikerRequest = MonikerRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) TypeFox, Microsoft and others. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TypeHierarchySubtypesRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchyPrepareRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to result a `TypeHierarchyItem` in a document at a given position.\r\n * Can be used as an input to a subtypes or supertypes type hierarchy.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar TypeHierarchyPrepareRequest;\r\n(function (TypeHierarchyPrepareRequest) {\r\n    TypeHierarchyPrepareRequest.method = 'textDocument/prepareTypeHierarchy';\r\n    TypeHierarchyPrepareRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    TypeHierarchyPrepareRequest.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest.method);\r\n})(TypeHierarchyPrepareRequest || (exports.TypeHierarchyPrepareRequest = TypeHierarchyPrepareRequest = {}));\r\n/**\r\n * A request to resolve the supertypes for a given `TypeHierarchyItem`.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar TypeHierarchySupertypesRequest;\r\n(function (TypeHierarchySupertypesRequest) {\r\n    TypeHierarchySupertypesRequest.method = 'typeHierarchy/supertypes';\r\n    TypeHierarchySupertypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    TypeHierarchySupertypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest.method);\r\n})(TypeHierarchySupertypesRequest || (exports.TypeHierarchySupertypesRequest = TypeHierarchySupertypesRequest = {}));\r\n/**\r\n * A request to resolve the subtypes for a given `TypeHierarchyItem`.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar TypeHierarchySubtypesRequest;\r\n(function (TypeHierarchySubtypesRequest) {\r\n    TypeHierarchySubtypesRequest.method = 'typeHierarchy/subtypes';\r\n    TypeHierarchySubtypesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    TypeHierarchySubtypesRequest.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest.method);\r\n})(TypeHierarchySubtypesRequest || (exports.TypeHierarchySubtypesRequest = TypeHierarchySubtypesRequest = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InlineValueRefreshRequest = exports.InlineValueRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to provide inline values in a document. The request's parameter is of\r\n * type {@link InlineValueParams}, the response is of type\r\n * {@link InlineValue InlineValue[]} or a Thenable that resolves to such.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar InlineValueRequest;\r\n(function (InlineValueRequest) {\r\n    InlineValueRequest.method = 'textDocument/inlineValue';\r\n    InlineValueRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    InlineValueRequest.type = new messages_1.ProtocolRequestType(InlineValueRequest.method);\r\n})(InlineValueRequest || (exports.InlineValueRequest = InlineValueRequest = {}));\r\n/**\r\n * @since 3.17.0\r\n */\r\nvar InlineValueRefreshRequest;\r\n(function (InlineValueRefreshRequest) {\r\n    InlineValueRefreshRequest.method = `workspace/inlineValue/refresh`;\r\n    InlineValueRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    InlineValueRefreshRequest.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest.method);\r\n})(InlineValueRefreshRequest || (exports.InlineValueRefreshRequest = InlineValueRefreshRequest = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to provide inlay hints in a document. The request's parameter is of\r\n * type {@link InlayHintsParams}, the response is of type\r\n * {@link InlayHint InlayHint[]} or a Thenable that resolves to such.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar InlayHintRequest;\r\n(function (InlayHintRequest) {\r\n    InlayHintRequest.method = 'textDocument/inlayHint';\r\n    InlayHintRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    InlayHintRequest.type = new messages_1.ProtocolRequestType(InlayHintRequest.method);\r\n})(InlayHintRequest || (exports.InlayHintRequest = InlayHintRequest = {}));\r\n/**\r\n * A request to resolve additional properties for an inlay hint.\r\n * The request's parameter is of type {@link InlayHint}, the response is\r\n * of type {@link InlayHint} or a Thenable that resolves to such.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar InlayHintResolveRequest;\r\n(function (InlayHintResolveRequest) {\r\n    InlayHintResolveRequest.method = 'inlayHint/resolve';\r\n    InlayHintResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    InlayHintResolveRequest.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest.method);\r\n})(InlayHintResolveRequest || (exports.InlayHintResolveRequest = InlayHintResolveRequest = {}));\r\n/**\r\n * @since 3.17.0\r\n */\r\nvar InlayHintRefreshRequest;\r\n(function (InlayHintRefreshRequest) {\r\n    InlayHintRefreshRequest.method = `workspace/inlayHint/refresh`;\r\n    InlayHintRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    InlayHintRefreshRequest.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest.method);\r\n})(InlayHintRefreshRequest || (exports.InlayHintRefreshRequest = InlayHintRefreshRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nconst Is = require(\"./utils/is\");\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * @since 3.17.0\r\n */\r\nvar DiagnosticServerCancellationData;\r\n(function (DiagnosticServerCancellationData) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && Is.boolean(candidate.retriggerRequest);\r\n    }\r\n    DiagnosticServerCancellationData.is = is;\r\n})(DiagnosticServerCancellationData || (exports.DiagnosticServerCancellationData = DiagnosticServerCancellationData = {}));\r\n/**\r\n * The document diagnostic report kinds.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar DocumentDiagnosticReportKind;\r\n(function (DocumentDiagnosticReportKind) {\r\n    /**\r\n     * A diagnostic report with a full\r\n     * set of problems.\r\n     */\r\n    DocumentDiagnosticReportKind.Full = 'full';\r\n    /**\r\n     * A report indicating that the last\r\n     * returned report is still accurate.\r\n     */\r\n    DocumentDiagnosticReportKind.Unchanged = 'unchanged';\r\n})(DocumentDiagnosticReportKind || (exports.DocumentDiagnosticReportKind = DocumentDiagnosticReportKind = {}));\r\n/**\r\n * The document diagnostic request definition.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar DocumentDiagnosticRequest;\r\n(function (DocumentDiagnosticRequest) {\r\n    DocumentDiagnosticRequest.method = 'textDocument/diagnostic';\r\n    DocumentDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentDiagnosticRequest.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest.method);\r\n    DocumentDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();\r\n})(DocumentDiagnosticRequest || (exports.DocumentDiagnosticRequest = DocumentDiagnosticRequest = {}));\r\n/**\r\n * The workspace diagnostic request definition.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar WorkspaceDiagnosticRequest;\r\n(function (WorkspaceDiagnosticRequest) {\r\n    WorkspaceDiagnosticRequest.method = 'workspace/diagnostic';\r\n    WorkspaceDiagnosticRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WorkspaceDiagnosticRequest.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest.method);\r\n    WorkspaceDiagnosticRequest.partialResult = new vscode_jsonrpc_1.ProgressType();\r\n})(WorkspaceDiagnosticRequest || (exports.WorkspaceDiagnosticRequest = WorkspaceDiagnosticRequest = {}));\r\n/**\r\n * The diagnostic refresh request definition.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar DiagnosticRefreshRequest;\r\n(function (DiagnosticRefreshRequest) {\r\n    DiagnosticRefreshRequest.method = `workspace/diagnostic/refresh`;\r\n    DiagnosticRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    DiagnosticRefreshRequest.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest.method);\r\n})(DiagnosticRefreshRequest || (exports.DiagnosticRefreshRequest = DiagnosticRefreshRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = void 0;\r\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\r\nconst Is = require(\"./utils/is\");\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A notebook cell kind.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar NotebookCellKind;\r\n(function (NotebookCellKind) {\r\n    /**\r\n     * A markup-cell is formatted source that is used for display.\r\n     */\r\n    NotebookCellKind.Markup = 1;\r\n    /**\r\n     * A code-cell is source code.\r\n     */\r\n    NotebookCellKind.Code = 2;\r\n    function is(value) {\r\n        return value === 1 || value === 2;\r\n    }\r\n    NotebookCellKind.is = is;\r\n})(NotebookCellKind || (exports.NotebookCellKind = NotebookCellKind = {}));\r\nvar ExecutionSummary;\r\n(function (ExecutionSummary) {\r\n    function create(executionOrder, success) {\r\n        const result = { executionOrder };\r\n        if (success === true || success === false) {\r\n            result.success = success;\r\n        }\r\n        return result;\r\n    }\r\n    ExecutionSummary.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === undefined || Is.boolean(candidate.success));\r\n    }\r\n    ExecutionSummary.is = is;\r\n    function equals(one, other) {\r\n        if (one === other) {\r\n            return true;\r\n        }\r\n        if (one === null || one === undefined || other === null || other === undefined) {\r\n            return false;\r\n        }\r\n        return one.executionOrder === other.executionOrder && one.success === other.success;\r\n    }\r\n    ExecutionSummary.equals = equals;\r\n})(ExecutionSummary || (exports.ExecutionSummary = ExecutionSummary = {}));\r\nvar NotebookCell;\r\n(function (NotebookCell) {\r\n    function create(kind, document) {\r\n        return { kind, document };\r\n    }\r\n    NotebookCell.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) &&\r\n            (candidate.metadata === undefined || Is.objectLiteral(candidate.metadata));\r\n    }\r\n    NotebookCell.is = is;\r\n    function diff(one, two) {\r\n        const result = new Set();\r\n        if (one.document !== two.document) {\r\n            result.add('document');\r\n        }\r\n        if (one.kind !== two.kind) {\r\n            result.add('kind');\r\n        }\r\n        if (one.executionSummary !== two.executionSummary) {\r\n            result.add('executionSummary');\r\n        }\r\n        if ((one.metadata !== undefined || two.metadata !== undefined) && !equalsMetadata(one.metadata, two.metadata)) {\r\n            result.add('metadata');\r\n        }\r\n        if ((one.executionSummary !== undefined || two.executionSummary !== undefined) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {\r\n            result.add('executionSummary');\r\n        }\r\n        return result;\r\n    }\r\n    NotebookCell.diff = diff;\r\n    function equalsMetadata(one, other) {\r\n        if (one === other) {\r\n            return true;\r\n        }\r\n        if (one === null || one === undefined || other === null || other === undefined) {\r\n            return false;\r\n        }\r\n        if (typeof one !== typeof other) {\r\n            return false;\r\n        }\r\n        if (typeof one !== 'object') {\r\n            return false;\r\n        }\r\n        const oneArray = Array.isArray(one);\r\n        const otherArray = Array.isArray(other);\r\n        if (oneArray !== otherArray) {\r\n            return false;\r\n        }\r\n        if (oneArray && otherArray) {\r\n            if (one.length !== other.length) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < one.length; i++) {\r\n                if (!equalsMetadata(one[i], other[i])) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {\r\n            const oneKeys = Object.keys(one);\r\n            const otherKeys = Object.keys(other);\r\n            if (oneKeys.length !== otherKeys.length) {\r\n                return false;\r\n            }\r\n            oneKeys.sort();\r\n            otherKeys.sort();\r\n            if (!equalsMetadata(oneKeys, otherKeys)) {\r\n                return false;\r\n            }\r\n            for (let i = 0; i < oneKeys.length; i++) {\r\n                const prop = oneKeys[i];\r\n                if (!equalsMetadata(one[prop], other[prop])) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n})(NotebookCell || (exports.NotebookCell = NotebookCell = {}));\r\nvar NotebookDocument;\r\n(function (NotebookDocument) {\r\n    function create(uri, notebookType, version, cells) {\r\n        return { uri, notebookType, version, cells };\r\n    }\r\n    NotebookDocument.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);\r\n    }\r\n    NotebookDocument.is = is;\r\n})(NotebookDocument || (exports.NotebookDocument = NotebookDocument = {}));\r\nvar NotebookDocumentSyncRegistrationType;\r\n(function (NotebookDocumentSyncRegistrationType) {\r\n    NotebookDocumentSyncRegistrationType.method = 'notebookDocument/sync';\r\n    NotebookDocumentSyncRegistrationType.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    NotebookDocumentSyncRegistrationType.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType.method);\r\n})(NotebookDocumentSyncRegistrationType || (exports.NotebookDocumentSyncRegistrationType = NotebookDocumentSyncRegistrationType = {}));\r\n/**\r\n * A notification sent when a notebook opens.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar DidOpenNotebookDocumentNotification;\r\n(function (DidOpenNotebookDocumentNotification) {\r\n    DidOpenNotebookDocumentNotification.method = 'notebookDocument/didOpen';\r\n    DidOpenNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidOpenNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification.method);\r\n    DidOpenNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\r\n})(DidOpenNotebookDocumentNotification || (exports.DidOpenNotebookDocumentNotification = DidOpenNotebookDocumentNotification = {}));\r\nvar NotebookCellArrayChange;\r\n(function (NotebookCellArrayChange) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === undefined || Is.typedArray(candidate.cells, NotebookCell.is));\r\n    }\r\n    NotebookCellArrayChange.is = is;\r\n    function create(start, deleteCount, cells) {\r\n        const result = { start, deleteCount };\r\n        if (cells !== undefined) {\r\n            result.cells = cells;\r\n        }\r\n        return result;\r\n    }\r\n    NotebookCellArrayChange.create = create;\r\n})(NotebookCellArrayChange || (exports.NotebookCellArrayChange = NotebookCellArrayChange = {}));\r\nvar DidChangeNotebookDocumentNotification;\r\n(function (DidChangeNotebookDocumentNotification) {\r\n    DidChangeNotebookDocumentNotification.method = 'notebookDocument/didChange';\r\n    DidChangeNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidChangeNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification.method);\r\n    DidChangeNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\r\n})(DidChangeNotebookDocumentNotification || (exports.DidChangeNotebookDocumentNotification = DidChangeNotebookDocumentNotification = {}));\r\n/**\r\n * A notification sent when a notebook document is saved.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar DidSaveNotebookDocumentNotification;\r\n(function (DidSaveNotebookDocumentNotification) {\r\n    DidSaveNotebookDocumentNotification.method = 'notebookDocument/didSave';\r\n    DidSaveNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidSaveNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification.method);\r\n    DidSaveNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\r\n})(DidSaveNotebookDocumentNotification || (exports.DidSaveNotebookDocumentNotification = DidSaveNotebookDocumentNotification = {}));\r\n/**\r\n * A notification sent when a notebook closes.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar DidCloseNotebookDocumentNotification;\r\n(function (DidCloseNotebookDocumentNotification) {\r\n    DidCloseNotebookDocumentNotification.method = 'notebookDocument/didClose';\r\n    DidCloseNotebookDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidCloseNotebookDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification.method);\r\n    DidCloseNotebookDocumentNotification.registrationMethod = NotebookDocumentSyncRegistrationType.method;\r\n})(DidCloseNotebookDocumentNotification || (exports.DidCloseNotebookDocumentNotification = DidCloseNotebookDocumentNotification = {}));\r\n", "\"use strict\";\r\n/*---------------------------------------------------------------------------------------------\r\n *  Copyright (c) Microsoft Corporation. All rights reserved.\r\n *  Licensed under the MIT License. See License.txt in the project root for license information.\r\n *--------------------------------------------------------------------------------------------*/\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InlineCompletionRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\n/**\r\n * A request to provide inline completions in a document. The request's parameter is of\r\n * type {@link InlineCompletionParams}, the response is of type\r\n * {@link InlineCompletion InlineCompletion[]} or a Thenable that resolves to such.\r\n *\r\n * @since 3.18.0\r\n * @proposed\r\n */\r\nvar InlineCompletionRequest;\r\n(function (InlineCompletionRequest) {\r\n    InlineCompletionRequest.method = 'textDocument/inlineCompletion';\r\n    InlineCompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    InlineCompletionRequest.type = new messages_1.ProtocolRequestType(InlineCompletionRequest.method);\r\n})(InlineCompletionRequest || (exports.InlineCompletionRequest = InlineCompletionRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.WorkspaceSymbolRequest = exports.CodeActionResolveRequest = exports.CodeActionRequest = exports.DocumentSymbolRequest = exports.DocumentHighlightRequest = exports.ReferencesRequest = exports.DefinitionRequest = exports.SignatureHelpRequest = exports.SignatureHelpTriggerKind = exports.HoverRequest = exports.CompletionResolveRequest = exports.CompletionRequest = exports.CompletionTriggerKind = exports.PublishDiagnosticsNotification = exports.WatchKind = exports.RelativePattern = exports.FileChangeType = exports.DidChangeWatchedFilesNotification = exports.WillSaveTextDocumentWaitUntilRequest = exports.WillSaveTextDocumentNotification = exports.TextDocumentSaveReason = exports.DidSaveTextDocumentNotification = exports.DidCloseTextDocumentNotification = exports.DidChangeTextDocumentNotification = exports.TextDocumentContentChangeEvent = exports.DidOpenTextDocumentNotification = exports.TextDocumentSyncKind = exports.TelemetryEventNotification = exports.LogMessageNotification = exports.ShowMessageRequest = exports.ShowMessageNotification = exports.MessageType = exports.DidChangeConfigurationNotification = exports.ExitNotification = exports.ShutdownRequest = exports.InitializedNotification = exports.InitializeErrorCodes = exports.InitializeRequest = exports.WorkDoneProgressOptions = exports.TextDocumentRegistrationOptions = exports.StaticRegistrationOptions = exports.PositionEncodingKind = exports.FailureHandlingKind = exports.ResourceOperationKind = exports.UnregistrationRequest = exports.RegistrationRequest = exports.DocumentSelector = exports.NotebookCellTextDocumentFilter = exports.NotebookDocumentFilter = exports.TextDocumentFilter = void 0;\r\nexports.MonikerRequest = exports.MonikerKind = exports.UniquenessLevel = exports.WillDeleteFilesRequest = exports.DidDeleteFilesNotification = exports.WillRenameFilesRequest = exports.DidRenameFilesNotification = exports.WillCreateFilesRequest = exports.DidCreateFilesNotification = exports.FileOperationPatternKind = exports.LinkedEditingRangeRequest = exports.ShowDocumentRequest = exports.SemanticTokensRegistrationType = exports.SemanticTokensRefreshRequest = exports.SemanticTokensRangeRequest = exports.SemanticTokensDeltaRequest = exports.SemanticTokensRequest = exports.TokenFormat = exports.CallHierarchyPrepareRequest = exports.CallHierarchyOutgoingCallsRequest = exports.CallHierarchyIncomingCallsRequest = exports.WorkDoneProgressCancelNotification = exports.WorkDoneProgressCreateRequest = exports.WorkDoneProgress = exports.SelectionRangeRequest = exports.DeclarationRequest = exports.FoldingRangeRefreshRequest = exports.FoldingRangeRequest = exports.ColorPresentationRequest = exports.DocumentColorRequest = exports.ConfigurationRequest = exports.DidChangeWorkspaceFoldersNotification = exports.WorkspaceFoldersRequest = exports.TypeDefinitionRequest = exports.ImplementationRequest = exports.ApplyWorkspaceEditRequest = exports.ExecuteCommandRequest = exports.PrepareRenameRequest = exports.RenameRequest = exports.PrepareSupportDefaultBehavior = exports.DocumentOnTypeFormattingRequest = exports.DocumentRangesFormattingRequest = exports.DocumentRangeFormattingRequest = exports.DocumentFormattingRequest = exports.DocumentLinkResolveRequest = exports.DocumentLinkRequest = exports.CodeLensRefreshRequest = exports.CodeLensResolveRequest = exports.CodeLensRequest = exports.WorkspaceSymbolResolveRequest = void 0;\r\nexports.InlineCompletionRequest = exports.DidCloseNotebookDocumentNotification = exports.DidSaveNotebookDocumentNotification = exports.DidChangeNotebookDocumentNotification = exports.NotebookCellArrayChange = exports.DidOpenNotebookDocumentNotification = exports.NotebookDocumentSyncRegistrationType = exports.NotebookDocument = exports.NotebookCell = exports.ExecutionSummary = exports.NotebookCellKind = exports.DiagnosticRefreshRequest = exports.WorkspaceDiagnosticRequest = exports.DocumentDiagnosticRequest = exports.DocumentDiagnosticReportKind = exports.DiagnosticServerCancellationData = exports.InlayHintRefreshRequest = exports.InlayHintResolveRequest = exports.InlayHintRequest = exports.InlineValueRefreshRequest = exports.InlineValueRequest = exports.TypeHierarchySupertypesRequest = exports.TypeHierarchySubtypesRequest = exports.TypeHierarchyPrepareRequest = void 0;\r\nconst messages_1 = require(\"./messages\");\r\nconst vscode_languageserver_types_1 = require(\"vscode-languageserver-types\");\r\nconst Is = require(\"./utils/is\");\r\nconst protocol_implementation_1 = require(\"./protocol.implementation\");\r\nObject.defineProperty(exports, \"ImplementationRequest\", { enumerable: true, get: function () { return protocol_implementation_1.ImplementationRequest; } });\r\nconst protocol_typeDefinition_1 = require(\"./protocol.typeDefinition\");\r\nObject.defineProperty(exports, \"TypeDefinitionRequest\", { enumerable: true, get: function () { return protocol_typeDefinition_1.TypeDefinitionRequest; } });\r\nconst protocol_workspaceFolder_1 = require(\"./protocol.workspaceFolder\");\r\nObject.defineProperty(exports, \"WorkspaceFoldersRequest\", { enumerable: true, get: function () { return protocol_workspaceFolder_1.WorkspaceFoldersRequest; } });\r\nObject.defineProperty(exports, \"DidChangeWorkspaceFoldersNotification\", { enumerable: true, get: function () { return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification; } });\r\nconst protocol_configuration_1 = require(\"./protocol.configuration\");\r\nObject.defineProperty(exports, \"ConfigurationRequest\", { enumerable: true, get: function () { return protocol_configuration_1.ConfigurationRequest; } });\r\nconst protocol_colorProvider_1 = require(\"./protocol.colorProvider\");\r\nObject.defineProperty(exports, \"DocumentColorRequest\", { enumerable: true, get: function () { return protocol_colorProvider_1.DocumentColorRequest; } });\r\nObject.defineProperty(exports, \"ColorPresentationRequest\", { enumerable: true, get: function () { return protocol_colorProvider_1.ColorPresentationRequest; } });\r\nconst protocol_foldingRange_1 = require(\"./protocol.foldingRange\");\r\nObject.defineProperty(exports, \"FoldingRangeRequest\", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRequest; } });\r\nObject.defineProperty(exports, \"FoldingRangeRefreshRequest\", { enumerable: true, get: function () { return protocol_foldingRange_1.FoldingRangeRefreshRequest; } });\r\nconst protocol_declaration_1 = require(\"./protocol.declaration\");\r\nObject.defineProperty(exports, \"DeclarationRequest\", { enumerable: true, get: function () { return protocol_declaration_1.DeclarationRequest; } });\r\nconst protocol_selectionRange_1 = require(\"./protocol.selectionRange\");\r\nObject.defineProperty(exports, \"SelectionRangeRequest\", { enumerable: true, get: function () { return protocol_selectionRange_1.SelectionRangeRequest; } });\r\nconst protocol_progress_1 = require(\"./protocol.progress\");\r\nObject.defineProperty(exports, \"WorkDoneProgress\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgress; } });\r\nObject.defineProperty(exports, \"WorkDoneProgressCreateRequest\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCreateRequest; } });\r\nObject.defineProperty(exports, \"WorkDoneProgressCancelNotification\", { enumerable: true, get: function () { return protocol_progress_1.WorkDoneProgressCancelNotification; } });\r\nconst protocol_callHierarchy_1 = require(\"./protocol.callHierarchy\");\r\nObject.defineProperty(exports, \"CallHierarchyIncomingCallsRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest; } });\r\nObject.defineProperty(exports, \"CallHierarchyOutgoingCallsRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest; } });\r\nObject.defineProperty(exports, \"CallHierarchyPrepareRequest\", { enumerable: true, get: function () { return protocol_callHierarchy_1.CallHierarchyPrepareRequest; } });\r\nconst protocol_semanticTokens_1 = require(\"./protocol.semanticTokens\");\r\nObject.defineProperty(exports, \"TokenFormat\", { enumerable: true, get: function () { return protocol_semanticTokens_1.TokenFormat; } });\r\nObject.defineProperty(exports, \"SemanticTokensRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRequest; } });\r\nObject.defineProperty(exports, \"SemanticTokensDeltaRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensDeltaRequest; } });\r\nObject.defineProperty(exports, \"SemanticTokensRangeRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRangeRequest; } });\r\nObject.defineProperty(exports, \"SemanticTokensRefreshRequest\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRefreshRequest; } });\r\nObject.defineProperty(exports, \"SemanticTokensRegistrationType\", { enumerable: true, get: function () { return protocol_semanticTokens_1.SemanticTokensRegistrationType; } });\r\nconst protocol_showDocument_1 = require(\"./protocol.showDocument\");\r\nObject.defineProperty(exports, \"ShowDocumentRequest\", { enumerable: true, get: function () { return protocol_showDocument_1.ShowDocumentRequest; } });\r\nconst protocol_linkedEditingRange_1 = require(\"./protocol.linkedEditingRange\");\r\nObject.defineProperty(exports, \"LinkedEditingRangeRequest\", { enumerable: true, get: function () { return protocol_linkedEditingRange_1.LinkedEditingRangeRequest; } });\r\nconst protocol_fileOperations_1 = require(\"./protocol.fileOperations\");\r\nObject.defineProperty(exports, \"FileOperationPatternKind\", { enumerable: true, get: function () { return protocol_fileOperations_1.FileOperationPatternKind; } });\r\nObject.defineProperty(exports, \"DidCreateFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidCreateFilesNotification; } });\r\nObject.defineProperty(exports, \"WillCreateFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillCreateFilesRequest; } });\r\nObject.defineProperty(exports, \"DidRenameFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidRenameFilesNotification; } });\r\nObject.defineProperty(exports, \"WillRenameFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillRenameFilesRequest; } });\r\nObject.defineProperty(exports, \"DidDeleteFilesNotification\", { enumerable: true, get: function () { return protocol_fileOperations_1.DidDeleteFilesNotification; } });\r\nObject.defineProperty(exports, \"WillDeleteFilesRequest\", { enumerable: true, get: function () { return protocol_fileOperations_1.WillDeleteFilesRequest; } });\r\nconst protocol_moniker_1 = require(\"./protocol.moniker\");\r\nObject.defineProperty(exports, \"UniquenessLevel\", { enumerable: true, get: function () { return protocol_moniker_1.UniquenessLevel; } });\r\nObject.defineProperty(exports, \"MonikerKind\", { enumerable: true, get: function () { return protocol_moniker_1.MonikerKind; } });\r\nObject.defineProperty(exports, \"MonikerRequest\", { enumerable: true, get: function () { return protocol_moniker_1.MonikerRequest; } });\r\nconst protocol_typeHierarchy_1 = require(\"./protocol.typeHierarchy\");\r\nObject.defineProperty(exports, \"TypeHierarchyPrepareRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest; } });\r\nObject.defineProperty(exports, \"TypeHierarchySubtypesRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest; } });\r\nObject.defineProperty(exports, \"TypeHierarchySupertypesRequest\", { enumerable: true, get: function () { return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest; } });\r\nconst protocol_inlineValue_1 = require(\"./protocol.inlineValue\");\r\nObject.defineProperty(exports, \"InlineValueRequest\", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRequest; } });\r\nObject.defineProperty(exports, \"InlineValueRefreshRequest\", { enumerable: true, get: function () { return protocol_inlineValue_1.InlineValueRefreshRequest; } });\r\nconst protocol_inlayHint_1 = require(\"./protocol.inlayHint\");\r\nObject.defineProperty(exports, \"InlayHintRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRequest; } });\r\nObject.defineProperty(exports, \"InlayHintResolveRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintResolveRequest; } });\r\nObject.defineProperty(exports, \"InlayHintRefreshRequest\", { enumerable: true, get: function () { return protocol_inlayHint_1.InlayHintRefreshRequest; } });\r\nconst protocol_diagnostic_1 = require(\"./protocol.diagnostic\");\r\nObject.defineProperty(exports, \"DiagnosticServerCancellationData\", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticServerCancellationData; } });\r\nObject.defineProperty(exports, \"DocumentDiagnosticReportKind\", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticReportKind; } });\r\nObject.defineProperty(exports, \"DocumentDiagnosticRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.DocumentDiagnosticRequest; } });\r\nObject.defineProperty(exports, \"WorkspaceDiagnosticRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.WorkspaceDiagnosticRequest; } });\r\nObject.defineProperty(exports, \"DiagnosticRefreshRequest\", { enumerable: true, get: function () { return protocol_diagnostic_1.DiagnosticRefreshRequest; } });\r\nconst protocol_notebook_1 = require(\"./protocol.notebook\");\r\nObject.defineProperty(exports, \"NotebookCellKind\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellKind; } });\r\nObject.defineProperty(exports, \"ExecutionSummary\", { enumerable: true, get: function () { return protocol_notebook_1.ExecutionSummary; } });\r\nObject.defineProperty(exports, \"NotebookCell\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCell; } });\r\nObject.defineProperty(exports, \"NotebookDocument\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocument; } });\r\nObject.defineProperty(exports, \"NotebookDocumentSyncRegistrationType\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookDocumentSyncRegistrationType; } });\r\nObject.defineProperty(exports, \"DidOpenNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidOpenNotebookDocumentNotification; } });\r\nObject.defineProperty(exports, \"NotebookCellArrayChange\", { enumerable: true, get: function () { return protocol_notebook_1.NotebookCellArrayChange; } });\r\nObject.defineProperty(exports, \"DidChangeNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidChangeNotebookDocumentNotification; } });\r\nObject.defineProperty(exports, \"DidSaveNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidSaveNotebookDocumentNotification; } });\r\nObject.defineProperty(exports, \"DidCloseNotebookDocumentNotification\", { enumerable: true, get: function () { return protocol_notebook_1.DidCloseNotebookDocumentNotification; } });\r\nconst protocol_inlineCompletion_1 = require(\"./protocol.inlineCompletion\");\r\nObject.defineProperty(exports, \"InlineCompletionRequest\", { enumerable: true, get: function () { return protocol_inlineCompletion_1.InlineCompletionRequest; } });\r\n// @ts-ignore: to avoid inlining LocationLink as dynamic import\r\nlet __noDynamicImport;\r\n/**\r\n * The TextDocumentFilter namespace provides helper functions to work with\r\n * {@link TextDocumentFilter} literals.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar TextDocumentFilter;\r\n(function (TextDocumentFilter) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.string(candidate) || (Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern));\r\n    }\r\n    TextDocumentFilter.is = is;\r\n})(TextDocumentFilter || (exports.TextDocumentFilter = TextDocumentFilter = {}));\r\n/**\r\n * The NotebookDocumentFilter namespace provides helper functions to work with\r\n * {@link NotebookDocumentFilter} literals.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar NotebookDocumentFilter;\r\n(function (NotebookDocumentFilter) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));\r\n    }\r\n    NotebookDocumentFilter.is = is;\r\n})(NotebookDocumentFilter || (exports.NotebookDocumentFilter = NotebookDocumentFilter = {}));\r\n/**\r\n * The NotebookCellTextDocumentFilter namespace provides helper functions to work with\r\n * {@link NotebookCellTextDocumentFilter} literals.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar NotebookCellTextDocumentFilter;\r\n(function (NotebookCellTextDocumentFilter) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook))\r\n            && (candidate.language === undefined || Is.string(candidate.language));\r\n    }\r\n    NotebookCellTextDocumentFilter.is = is;\r\n})(NotebookCellTextDocumentFilter || (exports.NotebookCellTextDocumentFilter = NotebookCellTextDocumentFilter = {}));\r\n/**\r\n * The DocumentSelector namespace provides helper functions to work with\r\n * {@link DocumentSelector}s.\r\n */\r\nvar DocumentSelector;\r\n(function (DocumentSelector) {\r\n    function is(value) {\r\n        if (!Array.isArray(value)) {\r\n            return false;\r\n        }\r\n        for (let elem of value) {\r\n            if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    DocumentSelector.is = is;\r\n})(DocumentSelector || (exports.DocumentSelector = DocumentSelector = {}));\r\n/**\r\n * The `client/registerCapability` request is sent from the server to the client to register a new capability\r\n * handler on the client side.\r\n */\r\nvar RegistrationRequest;\r\n(function (RegistrationRequest) {\r\n    RegistrationRequest.method = 'client/registerCapability';\r\n    RegistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    RegistrationRequest.type = new messages_1.ProtocolRequestType(RegistrationRequest.method);\r\n})(RegistrationRequest || (exports.RegistrationRequest = RegistrationRequest = {}));\r\n/**\r\n * The `client/unregisterCapability` request is sent from the server to the client to unregister a previously registered capability\r\n * handler on the client side.\r\n */\r\nvar UnregistrationRequest;\r\n(function (UnregistrationRequest) {\r\n    UnregistrationRequest.method = 'client/unregisterCapability';\r\n    UnregistrationRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    UnregistrationRequest.type = new messages_1.ProtocolRequestType(UnregistrationRequest.method);\r\n})(UnregistrationRequest || (exports.UnregistrationRequest = UnregistrationRequest = {}));\r\nvar ResourceOperationKind;\r\n(function (ResourceOperationKind) {\r\n    /**\r\n     * Supports creating new files and folders.\r\n     */\r\n    ResourceOperationKind.Create = 'create';\r\n    /**\r\n     * Supports renaming existing files and folders.\r\n     */\r\n    ResourceOperationKind.Rename = 'rename';\r\n    /**\r\n     * Supports deleting existing files and folders.\r\n     */\r\n    ResourceOperationKind.Delete = 'delete';\r\n})(ResourceOperationKind || (exports.ResourceOperationKind = ResourceOperationKind = {}));\r\nvar FailureHandlingKind;\r\n(function (FailureHandlingKind) {\r\n    /**\r\n     * Applying the workspace change is simply aborted if one of the changes provided\r\n     * fails. All operations executed before the failing operation stay executed.\r\n     */\r\n    FailureHandlingKind.Abort = 'abort';\r\n    /**\r\n     * All operations are executed transactional. That means they either all\r\n     * succeed or no changes at all are applied to the workspace.\r\n     */\r\n    FailureHandlingKind.Transactional = 'transactional';\r\n    /**\r\n     * If the workspace edit contains only textual file changes they are executed transactional.\r\n     * If resource changes (create, rename or delete file) are part of the change the failure\r\n     * handling strategy is abort.\r\n     */\r\n    FailureHandlingKind.TextOnlyTransactional = 'textOnlyTransactional';\r\n    /**\r\n     * The client tries to undo the operations already executed. But there is no\r\n     * guarantee that this is succeeding.\r\n     */\r\n    FailureHandlingKind.Undo = 'undo';\r\n})(FailureHandlingKind || (exports.FailureHandlingKind = FailureHandlingKind = {}));\r\n/**\r\n * A set of predefined position encoding kinds.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar PositionEncodingKind;\r\n(function (PositionEncodingKind) {\r\n    /**\r\n     * Character offsets count UTF-8 code units (e.g. bytes).\r\n     */\r\n    PositionEncodingKind.UTF8 = 'utf-8';\r\n    /**\r\n     * Character offsets count UTF-16 code units.\r\n     *\r\n     * This is the default and must always be supported\r\n     * by servers\r\n     */\r\n    PositionEncodingKind.UTF16 = 'utf-16';\r\n    /**\r\n     * Character offsets count UTF-32 code units.\r\n     *\r\n     * Implementation note: these are the same as Unicode codepoints,\r\n     * so this `PositionEncodingKind` may also be used for an\r\n     * encoding-agnostic representation of character offsets.\r\n     */\r\n    PositionEncodingKind.UTF32 = 'utf-32';\r\n})(PositionEncodingKind || (exports.PositionEncodingKind = PositionEncodingKind = {}));\r\n/**\r\n * The StaticRegistrationOptions namespace provides helper functions to work with\r\n * {@link StaticRegistrationOptions} literals.\r\n */\r\nvar StaticRegistrationOptions;\r\n(function (StaticRegistrationOptions) {\r\n    function hasId(value) {\r\n        const candidate = value;\r\n        return candidate && Is.string(candidate.id) && candidate.id.length > 0;\r\n    }\r\n    StaticRegistrationOptions.hasId = hasId;\r\n})(StaticRegistrationOptions || (exports.StaticRegistrationOptions = StaticRegistrationOptions = {}));\r\n/**\r\n * The TextDocumentRegistrationOptions namespace provides helper functions to work with\r\n * {@link TextDocumentRegistrationOptions} literals.\r\n */\r\nvar TextDocumentRegistrationOptions;\r\n(function (TextDocumentRegistrationOptions) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));\r\n    }\r\n    TextDocumentRegistrationOptions.is = is;\r\n})(TextDocumentRegistrationOptions || (exports.TextDocumentRegistrationOptions = TextDocumentRegistrationOptions = {}));\r\n/**\r\n * The WorkDoneProgressOptions namespace provides helper functions to work with\r\n * {@link WorkDoneProgressOptions} literals.\r\n */\r\nvar WorkDoneProgressOptions;\r\n(function (WorkDoneProgressOptions) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === undefined || Is.boolean(candidate.workDoneProgress));\r\n    }\r\n    WorkDoneProgressOptions.is = is;\r\n    function hasWorkDoneProgress(value) {\r\n        const candidate = value;\r\n        return candidate && Is.boolean(candidate.workDoneProgress);\r\n    }\r\n    WorkDoneProgressOptions.hasWorkDoneProgress = hasWorkDoneProgress;\r\n})(WorkDoneProgressOptions || (exports.WorkDoneProgressOptions = WorkDoneProgressOptions = {}));\r\n/**\r\n * The initialize request is sent from the client to the server.\r\n * It is sent once as the request after starting up the server.\r\n * The requests parameter is of type {@link InitializeParams}\r\n * the response if of type {@link InitializeResult} of a Thenable that\r\n * resolves to such.\r\n */\r\nvar InitializeRequest;\r\n(function (InitializeRequest) {\r\n    InitializeRequest.method = 'initialize';\r\n    InitializeRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    InitializeRequest.type = new messages_1.ProtocolRequestType(InitializeRequest.method);\r\n})(InitializeRequest || (exports.InitializeRequest = InitializeRequest = {}));\r\n/**\r\n * Known error codes for an `InitializeErrorCodes`;\r\n */\r\nvar InitializeErrorCodes;\r\n(function (InitializeErrorCodes) {\r\n    /**\r\n     * If the protocol version provided by the client can't be handled by the server.\r\n     *\r\n     * @deprecated This initialize error got replaced by client capabilities. There is\r\n     * no version handshake in version 3.0x\r\n     */\r\n    InitializeErrorCodes.unknownProtocolVersion = 1;\r\n})(InitializeErrorCodes || (exports.InitializeErrorCodes = InitializeErrorCodes = {}));\r\n/**\r\n * The initialized notification is sent from the client to the\r\n * server after the client is fully initialized and the server\r\n * is allowed to send requests from the server to the client.\r\n */\r\nvar InitializedNotification;\r\n(function (InitializedNotification) {\r\n    InitializedNotification.method = 'initialized';\r\n    InitializedNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    InitializedNotification.type = new messages_1.ProtocolNotificationType(InitializedNotification.method);\r\n})(InitializedNotification || (exports.InitializedNotification = InitializedNotification = {}));\r\n//---- Shutdown Method ----\r\n/**\r\n * A shutdown request is sent from the client to the server.\r\n * It is sent once when the client decides to shutdown the\r\n * server. The only notification that is sent after a shutdown request\r\n * is the exit event.\r\n */\r\nvar ShutdownRequest;\r\n(function (ShutdownRequest) {\r\n    ShutdownRequest.method = 'shutdown';\r\n    ShutdownRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    ShutdownRequest.type = new messages_1.ProtocolRequestType0(ShutdownRequest.method);\r\n})(ShutdownRequest || (exports.ShutdownRequest = ShutdownRequest = {}));\r\n//---- Exit Notification ----\r\n/**\r\n * The exit event is sent from the client to the server to\r\n * ask the server to exit its process.\r\n */\r\nvar ExitNotification;\r\n(function (ExitNotification) {\r\n    ExitNotification.method = 'exit';\r\n    ExitNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    ExitNotification.type = new messages_1.ProtocolNotificationType0(ExitNotification.method);\r\n})(ExitNotification || (exports.ExitNotification = ExitNotification = {}));\r\n/**\r\n * The configuration change notification is sent from the client to the server\r\n * when the client's configuration has changed. The notification contains\r\n * the changed configuration as defined by the language client.\r\n */\r\nvar DidChangeConfigurationNotification;\r\n(function (DidChangeConfigurationNotification) {\r\n    DidChangeConfigurationNotification.method = 'workspace/didChangeConfiguration';\r\n    DidChangeConfigurationNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidChangeConfigurationNotification.type = new messages_1.ProtocolNotificationType(DidChangeConfigurationNotification.method);\r\n})(DidChangeConfigurationNotification || (exports.DidChangeConfigurationNotification = DidChangeConfigurationNotification = {}));\r\n//---- Message show and log notifications ----\r\n/**\r\n * The message type\r\n */\r\nvar MessageType;\r\n(function (MessageType) {\r\n    /**\r\n     * An error message.\r\n     */\r\n    MessageType.Error = 1;\r\n    /**\r\n     * A warning message.\r\n     */\r\n    MessageType.Warning = 2;\r\n    /**\r\n     * An information message.\r\n     */\r\n    MessageType.Info = 3;\r\n    /**\r\n     * A log message.\r\n     */\r\n    MessageType.Log = 4;\r\n    /**\r\n     * A debug message.\r\n     *\r\n     * @since 3.18.0\r\n     */\r\n    MessageType.Debug = 5;\r\n})(MessageType || (exports.MessageType = MessageType = {}));\r\n/**\r\n * The show message notification is sent from a server to a client to ask\r\n * the client to display a particular message in the user interface.\r\n */\r\nvar ShowMessageNotification;\r\n(function (ShowMessageNotification) {\r\n    ShowMessageNotification.method = 'window/showMessage';\r\n    ShowMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    ShowMessageNotification.type = new messages_1.ProtocolNotificationType(ShowMessageNotification.method);\r\n})(ShowMessageNotification || (exports.ShowMessageNotification = ShowMessageNotification = {}));\r\n/**\r\n * The show message request is sent from the server to the client to show a message\r\n * and a set of options actions to the user.\r\n */\r\nvar ShowMessageRequest;\r\n(function (ShowMessageRequest) {\r\n    ShowMessageRequest.method = 'window/showMessageRequest';\r\n    ShowMessageRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    ShowMessageRequest.type = new messages_1.ProtocolRequestType(ShowMessageRequest.method);\r\n})(ShowMessageRequest || (exports.ShowMessageRequest = ShowMessageRequest = {}));\r\n/**\r\n * The log message notification is sent from the server to the client to ask\r\n * the client to log a particular message.\r\n */\r\nvar LogMessageNotification;\r\n(function (LogMessageNotification) {\r\n    LogMessageNotification.method = 'window/logMessage';\r\n    LogMessageNotification.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    LogMessageNotification.type = new messages_1.ProtocolNotificationType(LogMessageNotification.method);\r\n})(LogMessageNotification || (exports.LogMessageNotification = LogMessageNotification = {}));\r\n//---- Telemetry notification\r\n/**\r\n * The telemetry event notification is sent from the server to the client to ask\r\n * the client to log telemetry data.\r\n */\r\nvar TelemetryEventNotification;\r\n(function (TelemetryEventNotification) {\r\n    TelemetryEventNotification.method = 'telemetry/event';\r\n    TelemetryEventNotification.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    TelemetryEventNotification.type = new messages_1.ProtocolNotificationType(TelemetryEventNotification.method);\r\n})(TelemetryEventNotification || (exports.TelemetryEventNotification = TelemetryEventNotification = {}));\r\n/**\r\n * Defines how the host (editor) should sync\r\n * document changes to the language server.\r\n */\r\nvar TextDocumentSyncKind;\r\n(function (TextDocumentSyncKind) {\r\n    /**\r\n     * Documents should not be synced at all.\r\n     */\r\n    TextDocumentSyncKind.None = 0;\r\n    /**\r\n     * Documents are synced by always sending the full content\r\n     * of the document.\r\n     */\r\n    TextDocumentSyncKind.Full = 1;\r\n    /**\r\n     * Documents are synced by sending the full content on open.\r\n     * After that only incremental updates to the document are\r\n     * send.\r\n     */\r\n    TextDocumentSyncKind.Incremental = 2;\r\n})(TextDocumentSyncKind || (exports.TextDocumentSyncKind = TextDocumentSyncKind = {}));\r\n/**\r\n * The document open notification is sent from the client to the server to signal\r\n * newly opened text documents. The document's truth is now managed by the client\r\n * and the server must not try to read the document's truth using the document's\r\n * uri. Open in this sense means it is managed by the client. It doesn't necessarily\r\n * mean that its content is presented in an editor. An open notification must not\r\n * be sent more than once without a corresponding close notification send before.\r\n * This means open and close notification must be balanced and the max open count\r\n * is one.\r\n */\r\nvar DidOpenTextDocumentNotification;\r\n(function (DidOpenTextDocumentNotification) {\r\n    DidOpenTextDocumentNotification.method = 'textDocument/didOpen';\r\n    DidOpenTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidOpenTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification.method);\r\n})(DidOpenTextDocumentNotification || (exports.DidOpenTextDocumentNotification = DidOpenTextDocumentNotification = {}));\r\nvar TextDocumentContentChangeEvent;\r\n(function (TextDocumentContentChangeEvent) {\r\n    /**\r\n     * Checks whether the information describes a delta event.\r\n     */\r\n    function isIncremental(event) {\r\n        let candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\r\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\r\n    }\r\n    TextDocumentContentChangeEvent.isIncremental = isIncremental;\r\n    /**\r\n     * Checks whether the information describes a full replacement event.\r\n     */\r\n    function isFull(event) {\r\n        let candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\r\n    }\r\n    TextDocumentContentChangeEvent.isFull = isFull;\r\n})(TextDocumentContentChangeEvent || (exports.TextDocumentContentChangeEvent = TextDocumentContentChangeEvent = {}));\r\n/**\r\n * The document change notification is sent from the client to the server to signal\r\n * changes to a text document.\r\n */\r\nvar DidChangeTextDocumentNotification;\r\n(function (DidChangeTextDocumentNotification) {\r\n    DidChangeTextDocumentNotification.method = 'textDocument/didChange';\r\n    DidChangeTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidChangeTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification.method);\r\n})(DidChangeTextDocumentNotification || (exports.DidChangeTextDocumentNotification = DidChangeTextDocumentNotification = {}));\r\n/**\r\n * The document close notification is sent from the client to the server when\r\n * the document got closed in the client. The document's truth now exists where\r\n * the document's uri points to (e.g. if the document's uri is a file uri the\r\n * truth now exists on disk). As with the open notification the close notification\r\n * is about managing the document's content. Receiving a close notification\r\n * doesn't mean that the document was open in an editor before. A close\r\n * notification requires a previous open notification to be sent.\r\n */\r\nvar DidCloseTextDocumentNotification;\r\n(function (DidCloseTextDocumentNotification) {\r\n    DidCloseTextDocumentNotification.method = 'textDocument/didClose';\r\n    DidCloseTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidCloseTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification.method);\r\n})(DidCloseTextDocumentNotification || (exports.DidCloseTextDocumentNotification = DidCloseTextDocumentNotification = {}));\r\n/**\r\n * The document save notification is sent from the client to the server when\r\n * the document got saved in the client.\r\n */\r\nvar DidSaveTextDocumentNotification;\r\n(function (DidSaveTextDocumentNotification) {\r\n    DidSaveTextDocumentNotification.method = 'textDocument/didSave';\r\n    DidSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification.method);\r\n})(DidSaveTextDocumentNotification || (exports.DidSaveTextDocumentNotification = DidSaveTextDocumentNotification = {}));\r\n/**\r\n * Represents reasons why a text document is saved.\r\n */\r\nvar TextDocumentSaveReason;\r\n(function (TextDocumentSaveReason) {\r\n    /**\r\n     * Manually triggered, e.g. by the user pressing save, by starting debugging,\r\n     * or by an API call.\r\n     */\r\n    TextDocumentSaveReason.Manual = 1;\r\n    /**\r\n     * Automatic after a delay.\r\n     */\r\n    TextDocumentSaveReason.AfterDelay = 2;\r\n    /**\r\n     * When the editor lost focus.\r\n     */\r\n    TextDocumentSaveReason.FocusOut = 3;\r\n})(TextDocumentSaveReason || (exports.TextDocumentSaveReason = TextDocumentSaveReason = {}));\r\n/**\r\n * A document will save notification is sent from the client to the server before\r\n * the document is actually saved.\r\n */\r\nvar WillSaveTextDocumentNotification;\r\n(function (WillSaveTextDocumentNotification) {\r\n    WillSaveTextDocumentNotification.method = 'textDocument/willSave';\r\n    WillSaveTextDocumentNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WillSaveTextDocumentNotification.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification.method);\r\n})(WillSaveTextDocumentNotification || (exports.WillSaveTextDocumentNotification = WillSaveTextDocumentNotification = {}));\r\n/**\r\n * A document will save request is sent from the client to the server before\r\n * the document is actually saved. The request can return an array of TextEdits\r\n * which will be applied to the text document before it is saved. Please note that\r\n * clients might drop results if computing the text edits took too long or if a\r\n * server constantly fails on this request. This is done to keep the save fast and\r\n * reliable.\r\n */\r\nvar WillSaveTextDocumentWaitUntilRequest;\r\n(function (WillSaveTextDocumentWaitUntilRequest) {\r\n    WillSaveTextDocumentWaitUntilRequest.method = 'textDocument/willSaveWaitUntil';\r\n    WillSaveTextDocumentWaitUntilRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WillSaveTextDocumentWaitUntilRequest.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest.method);\r\n})(WillSaveTextDocumentWaitUntilRequest || (exports.WillSaveTextDocumentWaitUntilRequest = WillSaveTextDocumentWaitUntilRequest = {}));\r\n/**\r\n * The watched files notification is sent from the client to the server when\r\n * the client detects changes to file watched by the language client.\r\n */\r\nvar DidChangeWatchedFilesNotification;\r\n(function (DidChangeWatchedFilesNotification) {\r\n    DidChangeWatchedFilesNotification.method = 'workspace/didChangeWatchedFiles';\r\n    DidChangeWatchedFilesNotification.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DidChangeWatchedFilesNotification.type = new messages_1.ProtocolNotificationType(DidChangeWatchedFilesNotification.method);\r\n})(DidChangeWatchedFilesNotification || (exports.DidChangeWatchedFilesNotification = DidChangeWatchedFilesNotification = {}));\r\n/**\r\n * The file event type\r\n */\r\nvar FileChangeType;\r\n(function (FileChangeType) {\r\n    /**\r\n     * The file got created.\r\n     */\r\n    FileChangeType.Created = 1;\r\n    /**\r\n     * The file got changed.\r\n     */\r\n    FileChangeType.Changed = 2;\r\n    /**\r\n     * The file got deleted.\r\n     */\r\n    FileChangeType.Deleted = 3;\r\n})(FileChangeType || (exports.FileChangeType = FileChangeType = {}));\r\nvar RelativePattern;\r\n(function (RelativePattern) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);\r\n    }\r\n    RelativePattern.is = is;\r\n})(RelativePattern || (exports.RelativePattern = RelativePattern = {}));\r\nvar WatchKind;\r\n(function (WatchKind) {\r\n    /**\r\n     * Interested in create events.\r\n     */\r\n    WatchKind.Create = 1;\r\n    /**\r\n     * Interested in change events\r\n     */\r\n    WatchKind.Change = 2;\r\n    /**\r\n     * Interested in delete events\r\n     */\r\n    WatchKind.Delete = 4;\r\n})(WatchKind || (exports.WatchKind = WatchKind = {}));\r\n/**\r\n * Diagnostics notification are sent from the server to the client to signal\r\n * results of validation runs.\r\n */\r\nvar PublishDiagnosticsNotification;\r\n(function (PublishDiagnosticsNotification) {\r\n    PublishDiagnosticsNotification.method = 'textDocument/publishDiagnostics';\r\n    PublishDiagnosticsNotification.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    PublishDiagnosticsNotification.type = new messages_1.ProtocolNotificationType(PublishDiagnosticsNotification.method);\r\n})(PublishDiagnosticsNotification || (exports.PublishDiagnosticsNotification = PublishDiagnosticsNotification = {}));\r\n/**\r\n * How a completion was triggered\r\n */\r\nvar CompletionTriggerKind;\r\n(function (CompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered by typing an identifier (24x7 code\r\n     * complete), manual invocation (e.g Ctrl+Space) or via API.\r\n     */\r\n    CompletionTriggerKind.Invoked = 1;\r\n    /**\r\n     * Completion was triggered by a trigger character specified by\r\n     * the `triggerCharacters` properties of the `CompletionRegistrationOptions`.\r\n     */\r\n    CompletionTriggerKind.TriggerCharacter = 2;\r\n    /**\r\n     * Completion was re-triggered as current completion list is incomplete\r\n     */\r\n    CompletionTriggerKind.TriggerForIncompleteCompletions = 3;\r\n})(CompletionTriggerKind || (exports.CompletionTriggerKind = CompletionTriggerKind = {}));\r\n/**\r\n * Request to request completion at a given text document position. The request's\r\n * parameter is of type {@link TextDocumentPosition} the response\r\n * is of type {@link CompletionItem CompletionItem[]} or {@link CompletionList}\r\n * or a Thenable that resolves to such.\r\n *\r\n * The request can delay the computation of the {@link CompletionItem.detail `detail`}\r\n * and {@link CompletionItem.documentation `documentation`} properties to the `completionItem/resolve`\r\n * request. However, properties that are needed for the initial sorting and filtering, like `sortText`,\r\n * `filterText`, `insertText`, and `textEdit`, must not be changed during resolve.\r\n */\r\nvar CompletionRequest;\r\n(function (CompletionRequest) {\r\n    CompletionRequest.method = 'textDocument/completion';\r\n    CompletionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CompletionRequest.type = new messages_1.ProtocolRequestType(CompletionRequest.method);\r\n})(CompletionRequest || (exports.CompletionRequest = CompletionRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given completion item.The request's\r\n * parameter is of type {@link CompletionItem} the response\r\n * is of type {@link CompletionItem} or a Thenable that resolves to such.\r\n */\r\nvar CompletionResolveRequest;\r\n(function (CompletionResolveRequest) {\r\n    CompletionResolveRequest.method = 'completionItem/resolve';\r\n    CompletionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CompletionResolveRequest.type = new messages_1.ProtocolRequestType(CompletionResolveRequest.method);\r\n})(CompletionResolveRequest || (exports.CompletionResolveRequest = CompletionResolveRequest = {}));\r\n/**\r\n * Request to request hover information at a given text document position. The request's\r\n * parameter is of type {@link TextDocumentPosition} the response is of\r\n * type {@link Hover} or a Thenable that resolves to such.\r\n */\r\nvar HoverRequest;\r\n(function (HoverRequest) {\r\n    HoverRequest.method = 'textDocument/hover';\r\n    HoverRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    HoverRequest.type = new messages_1.ProtocolRequestType(HoverRequest.method);\r\n})(HoverRequest || (exports.HoverRequest = HoverRequest = {}));\r\n/**\r\n * How a signature help was triggered.\r\n *\r\n * @since 3.15.0\r\n */\r\nvar SignatureHelpTriggerKind;\r\n(function (SignatureHelpTriggerKind) {\r\n    /**\r\n     * Signature help was invoked manually by the user or by a command.\r\n     */\r\n    SignatureHelpTriggerKind.Invoked = 1;\r\n    /**\r\n     * Signature help was triggered by a trigger character.\r\n     */\r\n    SignatureHelpTriggerKind.TriggerCharacter = 2;\r\n    /**\r\n     * Signature help was triggered by the cursor moving or by the document content changing.\r\n     */\r\n    SignatureHelpTriggerKind.ContentChange = 3;\r\n})(SignatureHelpTriggerKind || (exports.SignatureHelpTriggerKind = SignatureHelpTriggerKind = {}));\r\nvar SignatureHelpRequest;\r\n(function (SignatureHelpRequest) {\r\n    SignatureHelpRequest.method = 'textDocument/signatureHelp';\r\n    SignatureHelpRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    SignatureHelpRequest.type = new messages_1.ProtocolRequestType(SignatureHelpRequest.method);\r\n})(SignatureHelpRequest || (exports.SignatureHelpRequest = SignatureHelpRequest = {}));\r\n/**\r\n * A request to resolve the definition location of a symbol at a given text\r\n * document position. The request's parameter is of type {@link TextDocumentPosition}\r\n * the response is of either type {@link Definition} or a typed array of\r\n * {@link DefinitionLink} or a Thenable that resolves to such.\r\n */\r\nvar DefinitionRequest;\r\n(function (DefinitionRequest) {\r\n    DefinitionRequest.method = 'textDocument/definition';\r\n    DefinitionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DefinitionRequest.type = new messages_1.ProtocolRequestType(DefinitionRequest.method);\r\n})(DefinitionRequest || (exports.DefinitionRequest = DefinitionRequest = {}));\r\n/**\r\n * A request to resolve project-wide references for the symbol denoted\r\n * by the given text document position. The request's parameter is of\r\n * type {@link ReferenceParams} the response is of type\r\n * {@link Location Location[]} or a Thenable that resolves to such.\r\n */\r\nvar ReferencesRequest;\r\n(function (ReferencesRequest) {\r\n    ReferencesRequest.method = 'textDocument/references';\r\n    ReferencesRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    ReferencesRequest.type = new messages_1.ProtocolRequestType(ReferencesRequest.method);\r\n})(ReferencesRequest || (exports.ReferencesRequest = ReferencesRequest = {}));\r\n/**\r\n * Request to resolve a {@link DocumentHighlight} for a given\r\n * text document position. The request's parameter is of type {@link TextDocumentPosition}\r\n * the request response is an array of type {@link DocumentHighlight}\r\n * or a Thenable that resolves to such.\r\n */\r\nvar DocumentHighlightRequest;\r\n(function (DocumentHighlightRequest) {\r\n    DocumentHighlightRequest.method = 'textDocument/documentHighlight';\r\n    DocumentHighlightRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentHighlightRequest.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest.method);\r\n})(DocumentHighlightRequest || (exports.DocumentHighlightRequest = DocumentHighlightRequest = {}));\r\n/**\r\n * A request to list all symbols found in a given text document. The request's\r\n * parameter is of type {@link TextDocumentIdentifier} the\r\n * response is of type {@link SymbolInformation SymbolInformation[]} or a Thenable\r\n * that resolves to such.\r\n */\r\nvar DocumentSymbolRequest;\r\n(function (DocumentSymbolRequest) {\r\n    DocumentSymbolRequest.method = 'textDocument/documentSymbol';\r\n    DocumentSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentSymbolRequest.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest.method);\r\n})(DocumentSymbolRequest || (exports.DocumentSymbolRequest = DocumentSymbolRequest = {}));\r\n/**\r\n * A request to provide commands for the given text document and range.\r\n */\r\nvar CodeActionRequest;\r\n(function (CodeActionRequest) {\r\n    CodeActionRequest.method = 'textDocument/codeAction';\r\n    CodeActionRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CodeActionRequest.type = new messages_1.ProtocolRequestType(CodeActionRequest.method);\r\n})(CodeActionRequest || (exports.CodeActionRequest = CodeActionRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given code action.The request's\r\n * parameter is of type {@link CodeAction} the response\r\n * is of type {@link CodeAction} or a Thenable that resolves to such.\r\n */\r\nvar CodeActionResolveRequest;\r\n(function (CodeActionResolveRequest) {\r\n    CodeActionResolveRequest.method = 'codeAction/resolve';\r\n    CodeActionResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CodeActionResolveRequest.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest.method);\r\n})(CodeActionResolveRequest || (exports.CodeActionResolveRequest = CodeActionResolveRequest = {}));\r\n/**\r\n * A request to list project-wide symbols matching the query string given\r\n * by the {@link WorkspaceSymbolParams}. The response is\r\n * of type {@link SymbolInformation SymbolInformation[]} or a Thenable that\r\n * resolves to such.\r\n *\r\n * @since 3.17.0 - support for WorkspaceSymbol in the returned data. Clients\r\n *  need to advertise support for WorkspaceSymbols via the client capability\r\n *  `workspace.symbol.resolveSupport`.\r\n *\r\n */\r\nvar WorkspaceSymbolRequest;\r\n(function (WorkspaceSymbolRequest) {\r\n    WorkspaceSymbolRequest.method = 'workspace/symbol';\r\n    WorkspaceSymbolRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WorkspaceSymbolRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest.method);\r\n})(WorkspaceSymbolRequest || (exports.WorkspaceSymbolRequest = WorkspaceSymbolRequest = {}));\r\n/**\r\n * A request to resolve the range inside the workspace\r\n * symbol's location.\r\n *\r\n * @since 3.17.0\r\n */\r\nvar WorkspaceSymbolResolveRequest;\r\n(function (WorkspaceSymbolResolveRequest) {\r\n    WorkspaceSymbolResolveRequest.method = 'workspaceSymbol/resolve';\r\n    WorkspaceSymbolResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    WorkspaceSymbolResolveRequest.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest.method);\r\n})(WorkspaceSymbolResolveRequest || (exports.WorkspaceSymbolResolveRequest = WorkspaceSymbolResolveRequest = {}));\r\n/**\r\n * A request to provide code lens for the given text document.\r\n */\r\nvar CodeLensRequest;\r\n(function (CodeLensRequest) {\r\n    CodeLensRequest.method = 'textDocument/codeLens';\r\n    CodeLensRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CodeLensRequest.type = new messages_1.ProtocolRequestType(CodeLensRequest.method);\r\n})(CodeLensRequest || (exports.CodeLensRequest = CodeLensRequest = {}));\r\n/**\r\n * A request to resolve a command for a given code lens.\r\n */\r\nvar CodeLensResolveRequest;\r\n(function (CodeLensResolveRequest) {\r\n    CodeLensResolveRequest.method = 'codeLens/resolve';\r\n    CodeLensResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    CodeLensResolveRequest.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest.method);\r\n})(CodeLensResolveRequest || (exports.CodeLensResolveRequest = CodeLensResolveRequest = {}));\r\n/**\r\n * A request to refresh all code actions\r\n *\r\n * @since 3.16.0\r\n */\r\nvar CodeLensRefreshRequest;\r\n(function (CodeLensRefreshRequest) {\r\n    CodeLensRefreshRequest.method = `workspace/codeLens/refresh`;\r\n    CodeLensRefreshRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    CodeLensRefreshRequest.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest.method);\r\n})(CodeLensRefreshRequest || (exports.CodeLensRefreshRequest = CodeLensRefreshRequest = {}));\r\n/**\r\n * A request to provide document links\r\n */\r\nvar DocumentLinkRequest;\r\n(function (DocumentLinkRequest) {\r\n    DocumentLinkRequest.method = 'textDocument/documentLink';\r\n    DocumentLinkRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentLinkRequest.type = new messages_1.ProtocolRequestType(DocumentLinkRequest.method);\r\n})(DocumentLinkRequest || (exports.DocumentLinkRequest = DocumentLinkRequest = {}));\r\n/**\r\n * Request to resolve additional information for a given document link. The request's\r\n * parameter is of type {@link DocumentLink} the response\r\n * is of type {@link DocumentLink} or a Thenable that resolves to such.\r\n */\r\nvar DocumentLinkResolveRequest;\r\n(function (DocumentLinkResolveRequest) {\r\n    DocumentLinkResolveRequest.method = 'documentLink/resolve';\r\n    DocumentLinkResolveRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentLinkResolveRequest.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest.method);\r\n})(DocumentLinkResolveRequest || (exports.DocumentLinkResolveRequest = DocumentLinkResolveRequest = {}));\r\n/**\r\n * A request to format a whole document.\r\n */\r\nvar DocumentFormattingRequest;\r\n(function (DocumentFormattingRequest) {\r\n    DocumentFormattingRequest.method = 'textDocument/formatting';\r\n    DocumentFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest.method);\r\n})(DocumentFormattingRequest || (exports.DocumentFormattingRequest = DocumentFormattingRequest = {}));\r\n/**\r\n * A request to format a range in a document.\r\n */\r\nvar DocumentRangeFormattingRequest;\r\n(function (DocumentRangeFormattingRequest) {\r\n    DocumentRangeFormattingRequest.method = 'textDocument/rangeFormatting';\r\n    DocumentRangeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentRangeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest.method);\r\n})(DocumentRangeFormattingRequest || (exports.DocumentRangeFormattingRequest = DocumentRangeFormattingRequest = {}));\r\n/**\r\n * A request to format ranges in a document.\r\n *\r\n * @since 3.18.0\r\n * @proposed\r\n */\r\nvar DocumentRangesFormattingRequest;\r\n(function (DocumentRangesFormattingRequest) {\r\n    DocumentRangesFormattingRequest.method = 'textDocument/rangesFormatting';\r\n    DocumentRangesFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentRangesFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentRangesFormattingRequest.method);\r\n})(DocumentRangesFormattingRequest || (exports.DocumentRangesFormattingRequest = DocumentRangesFormattingRequest = {}));\r\n/**\r\n * A request to format a document on type.\r\n */\r\nvar DocumentOnTypeFormattingRequest;\r\n(function (DocumentOnTypeFormattingRequest) {\r\n    DocumentOnTypeFormattingRequest.method = 'textDocument/onTypeFormatting';\r\n    DocumentOnTypeFormattingRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    DocumentOnTypeFormattingRequest.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest.method);\r\n})(DocumentOnTypeFormattingRequest || (exports.DocumentOnTypeFormattingRequest = DocumentOnTypeFormattingRequest = {}));\r\n//---- Rename ----------------------------------------------\r\nvar PrepareSupportDefaultBehavior;\r\n(function (PrepareSupportDefaultBehavior) {\r\n    /**\r\n     * The client's default behavior is to select the identifier\r\n     * according the to language's syntax rule.\r\n     */\r\n    PrepareSupportDefaultBehavior.Identifier = 1;\r\n})(PrepareSupportDefaultBehavior || (exports.PrepareSupportDefaultBehavior = PrepareSupportDefaultBehavior = {}));\r\n/**\r\n * A request to rename a symbol.\r\n */\r\nvar RenameRequest;\r\n(function (RenameRequest) {\r\n    RenameRequest.method = 'textDocument/rename';\r\n    RenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    RenameRequest.type = new messages_1.ProtocolRequestType(RenameRequest.method);\r\n})(RenameRequest || (exports.RenameRequest = RenameRequest = {}));\r\n/**\r\n * A request to test and perform the setup necessary for a rename.\r\n *\r\n * @since 3.16 - support for default behavior\r\n */\r\nvar PrepareRenameRequest;\r\n(function (PrepareRenameRequest) {\r\n    PrepareRenameRequest.method = 'textDocument/prepareRename';\r\n    PrepareRenameRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    PrepareRenameRequest.type = new messages_1.ProtocolRequestType(PrepareRenameRequest.method);\r\n})(PrepareRenameRequest || (exports.PrepareRenameRequest = PrepareRenameRequest = {}));\r\n/**\r\n * A request send from the client to the server to execute a command. The request might return\r\n * a workspace edit which the client will apply to the workspace.\r\n */\r\nvar ExecuteCommandRequest;\r\n(function (ExecuteCommandRequest) {\r\n    ExecuteCommandRequest.method = 'workspace/executeCommand';\r\n    ExecuteCommandRequest.messageDirection = messages_1.MessageDirection.clientToServer;\r\n    ExecuteCommandRequest.type = new messages_1.ProtocolRequestType(ExecuteCommandRequest.method);\r\n})(ExecuteCommandRequest || (exports.ExecuteCommandRequest = ExecuteCommandRequest = {}));\r\n/**\r\n * A request sent from the server to the client to modified certain resources.\r\n */\r\nvar ApplyWorkspaceEditRequest;\r\n(function (ApplyWorkspaceEditRequest) {\r\n    ApplyWorkspaceEditRequest.method = 'workspace/applyEdit';\r\n    ApplyWorkspaceEditRequest.messageDirection = messages_1.MessageDirection.serverToClient;\r\n    ApplyWorkspaceEditRequest.type = new messages_1.ProtocolRequestType('workspace/applyEdit');\r\n})(ApplyWorkspaceEditRequest || (exports.ApplyWorkspaceEditRequest = ApplyWorkspaceEditRequest = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createProtocolConnection = void 0;\r\nconst vscode_jsonrpc_1 = require(\"vscode-jsonrpc\");\r\nfunction createProtocolConnection(input, output, logger, options) {\r\n    if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {\r\n        options = { connectionStrategy: options };\r\n    }\r\n    return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);\r\n}\r\nexports.createProtocolConnection = createProtocolConnection;\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LSPErrorCodes = exports.createProtocolConnection = void 0;\r\n__exportStar(require(\"vscode-jsonrpc\"), exports);\r\n__exportStar(require(\"vscode-languageserver-types\"), exports);\r\n__exportStar(require(\"./messages\"), exports);\r\n__exportStar(require(\"./protocol\"), exports);\r\nvar connection_1 = require(\"./connection\");\r\nObject.defineProperty(exports, \"createProtocolConnection\", { enumerable: true, get: function () { return connection_1.createProtocolConnection; } });\r\nvar LSPErrorCodes;\r\n(function (LSPErrorCodes) {\r\n    /**\r\n    * This is the start range of LSP reserved error codes.\r\n    * It doesn't denote a real error code.\r\n    *\r\n    * @since 3.16.0\r\n    */\r\n    LSPErrorCodes.lspReservedErrorRangeStart = -32899;\r\n    /**\r\n     * A request failed but it was syntactically correct, e.g the\r\n     * method name was known and the parameters were valid. The error\r\n     * message should contain human readable information about why\r\n     * the request failed.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    LSPErrorCodes.RequestFailed = -32803;\r\n    /**\r\n     * The server cancelled the request. This error code should\r\n     * only be used for requests that explicitly support being\r\n     * server cancellable.\r\n     *\r\n     * @since 3.17.0\r\n     */\r\n    LSPErrorCodes.ServerCancelled = -32802;\r\n    /**\r\n     * The server detected that the content of a document got\r\n     * modified outside normal conditions. A server should\r\n     * NOT send this error code if it detects a content change\r\n     * in it unprocessed messages. The result even computed\r\n     * on an older state might still be useful for the client.\r\n     *\r\n     * If a client decides that a result is not of any use anymore\r\n     * the client should cancel the request.\r\n     */\r\n    LSPErrorCodes.ContentModified = -32801;\r\n    /**\r\n     * The client has canceled a request and a server as detected\r\n     * the cancel.\r\n     */\r\n    LSPErrorCodes.RequestCancelled = -32800;\r\n    /**\r\n    * This is the end range of LSP reserved error codes.\r\n    * It doesn't denote a real error code.\r\n    *\r\n    * @since 3.16.0\r\n    */\r\n    LSPErrorCodes.lspReservedErrorRangeEnd = -32800;\r\n})(LSPErrorCodes || (exports.LSPErrorCodes = LSPErrorCodes = {}));\r\n", "\"use strict\";\r\n/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n      desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.createProtocolConnection = void 0;\r\nconst node_1 = require(\"vscode-jsonrpc/node\");\r\n__exportStar(require(\"vscode-jsonrpc/node\"), exports);\r\n__exportStar(require(\"../common/api\"), exports);\r\nfunction createProtocolConnection(input, output, logger, options) {\r\n    return (0, node_1.createMessageConnection)(input, output, logger, options);\r\n}\r\nexports.createProtocolConnection = createProtocolConnection;\r\n", "\"use strict\";\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generateUuid = exports.parse = exports.isUUID = exports.v4 = exports.empty = void 0;\nclass ValueUUID {\n    constructor(_value) {\n        this._value = _value;\n        // empty\n    }\n    asHex() {\n        return this._value;\n    }\n    equals(other) {\n        return this.asHex() === other.asHex();\n    }\n}\nclass V4UUID extends ValueUUID {\n    static _oneOf(array) {\n        return array[Math.floor(array.length * Math.random())];\n    }\n    static _randomHex() {\n        return V4UUID._oneOf(V4UUID._chars);\n    }\n    constructor() {\n        super([\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            '4',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._oneOf(V4UUID._timeHighBits),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            '-',\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n            V4UUID._randomHex(),\n        ].join(''));\n    }\n}\nV4UUID._chars = ['0', '1', '2', '3', '4', '5', '6', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'];\nV4UUID._timeHighBits = ['8', '9', 'a', 'b'];\n/**\n * An empty UUID that contains only zeros.\n */\nexports.empty = new ValueUUID('00000000-0000-0000-0000-000000000000');\nfunction v4() {\n    return new V4UUID();\n}\nexports.v4 = v4;\nconst _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;\nfunction isUUID(value) {\n    return _UUIDPattern.test(value);\n}\nexports.isUUID = isUUID;\n/**\n * Parses a UUID that is of the format xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.\n * @param value A uuid string.\n */\nfunction parse(value) {\n    if (!isUUID(value)) {\n        throw new Error('invalid uuid');\n    }\n    return new ValueUUID(value);\n}\nexports.parse = parse;\nfunction generateUuid() {\n    return v4().asHex();\n}\nexports.generateUuid = generateUuid;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.attachPartialResult = exports.ProgressFeature = exports.attachWorkDone = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst uuid_1 = require(\"./utils/uuid\");\nclass WorkDoneProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n        WorkDoneProgressReporterImpl.Instances.set(this._token, this);\n    }\n    begin(title, percentage, message, cancellable) {\n        let param = {\n            kind: 'begin',\n            title,\n            percentage,\n            message,\n            cancellable\n        };\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    report(arg0, arg1) {\n        let param = {\n            kind: 'report'\n        };\n        if (typeof arg0 === 'number') {\n            param.percentage = arg0;\n            if (arg1 !== undefined) {\n                param.message = arg1;\n            }\n        }\n        else {\n            param.message = arg0;\n        }\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);\n    }\n    done() {\n        WorkDoneProgressReporterImpl.Instances.delete(this._token);\n        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: 'end' });\n    }\n}\nWorkDoneProgressReporterImpl.Instances = new Map();\nclass WorkDoneProgressServerReporterImpl extends WorkDoneProgressReporterImpl {\n    constructor(connection, token) {\n        super(connection, token);\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n        super.done();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nclass NullProgressReporter {\n    constructor() {\n    }\n    begin() {\n    }\n    report() {\n    }\n    done() {\n    }\n}\nclass NullProgressServerReporter extends NullProgressReporter {\n    constructor() {\n        super();\n        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();\n    }\n    get token() {\n        return this._source.token;\n    }\n    done() {\n        this._source.dispose();\n    }\n    cancel() {\n        this._source.cancel();\n    }\n}\nfunction attachWorkDone(connection, params) {\n    if (params === undefined || params.workDoneToken === undefined) {\n        return new NullProgressReporter();\n    }\n    const token = params.workDoneToken;\n    delete params.workDoneToken;\n    return new WorkDoneProgressReporterImpl(connection, token);\n}\nexports.attachWorkDone = attachWorkDone;\nconst ProgressFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._progressSupported = false;\n        }\n        initialize(capabilities) {\n            super.initialize(capabilities);\n            if (capabilities?.window?.workDoneProgress === true) {\n                this._progressSupported = true;\n                this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {\n                    let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);\n                    if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {\n                        progress.cancel();\n                    }\n                });\n            }\n        }\n        attachWorkDoneProgress(token) {\n            if (token === undefined) {\n                return new NullProgressReporter();\n            }\n            else {\n                return new WorkDoneProgressReporterImpl(this.connection, token);\n            }\n        }\n        createWorkDoneProgress() {\n            if (this._progressSupported) {\n                const token = (0, uuid_1.generateUuid)();\n                return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {\n                    const result = new WorkDoneProgressServerReporterImpl(this.connection, token);\n                    return result;\n                });\n            }\n            else {\n                return Promise.resolve(new NullProgressServerReporter());\n            }\n        }\n    };\n};\nexports.ProgressFeature = ProgressFeature;\nvar ResultProgress;\n(function (ResultProgress) {\n    ResultProgress.type = new vscode_languageserver_protocol_1.ProgressType();\n})(ResultProgress || (ResultProgress = {}));\nclass ResultProgressReporterImpl {\n    constructor(_connection, _token) {\n        this._connection = _connection;\n        this._token = _token;\n    }\n    report(data) {\n        this._connection.sendProgress(ResultProgress.type, this._token, data);\n    }\n}\nfunction attachPartialResult(connection, params) {\n    if (params === undefined || params.partialResultToken === undefined) {\n        return undefined;\n    }\n    const token = params.partialResultToken;\n    delete params.partialResultToken;\n    return new ResultProgressReporterImpl(connection, token);\n}\nexports.attachPartialResult = attachPartialResult;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ConfigurationFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst Is = require(\"./utils/is\");\nconst ConfigurationFeature = (Base) => {\n    return class extends Base {\n        getConfiguration(arg) {\n            if (!arg) {\n                return this._getConfiguration({});\n            }\n            else if (Is.string(arg)) {\n                return this._getConfiguration({ section: arg });\n            }\n            else {\n                return this._getConfiguration(arg);\n            }\n        }\n        _getConfiguration(arg) {\n            let params = {\n                items: Array.isArray(arg) ? arg : [arg]\n            };\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {\n                if (Array.isArray(result)) {\n                    return Array.isArray(arg) ? result : result[0];\n                }\n                else {\n                    return Array.isArray(arg) ? [] : null;\n                }\n            });\n        }\n    };\n};\nexports.ConfigurationFeature = ConfigurationFeature;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WorkspaceFoldersFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst WorkspaceFoldersFeature = (Base) => {\n    return class extends Base {\n        constructor() {\n            super();\n            this._notificationIsAutoRegistered = false;\n        }\n        initialize(capabilities) {\n            super.initialize(capabilities);\n            let workspaceCapabilities = capabilities.workspace;\n            if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {\n                this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();\n                this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {\n                    this._onDidChangeWorkspaceFolders.fire(params.event);\n                });\n            }\n        }\n        fillServerCapabilities(capabilities) {\n            super.fillServerCapabilities(capabilities);\n            const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;\n            this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === 'string';\n        }\n        getWorkspaceFolders() {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);\n        }\n        get onDidChangeWorkspaceFolders() {\n            if (!this._onDidChangeWorkspaceFolders) {\n                throw new Error('Client doesn\\'t support sending workspace folder change events.');\n            }\n            if (!this._notificationIsAutoRegistered && !this._unregistration) {\n                this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);\n            }\n            return this._onDidChangeWorkspaceFolders.event;\n        }\n    };\n};\nexports.WorkspaceFoldersFeature = WorkspaceFoldersFeature;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CallHierarchyFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst CallHierarchyFeature = (Base) => {\n    return class extends Base {\n        get callHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onIncomingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onOutgoingCalls: (handler) => {\n                    const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.CallHierarchyFeature = CallHierarchyFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SemanticTokensBuilder = exports.SemanticTokensDiff = exports.SemanticTokensFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst SemanticTokensFeature = (Base) => {\n    return class extends Base {\n        get semanticTokens() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);\n                },\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onDelta: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onRange: (handler) => {\n                    const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.SemanticTokensFeature = SemanticTokensFeature;\nclass SemanticTokensDiff {\n    constructor(originalSequence, modifiedSequence) {\n        this.originalSequence = originalSequence;\n        this.modifiedSequence = modifiedSequence;\n    }\n    computeDiff() {\n        const originalLength = this.originalSequence.length;\n        const modifiedLength = this.modifiedSequence.length;\n        let startIndex = 0;\n        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {\n            startIndex++;\n        }\n        if (startIndex < modifiedLength && startIndex < originalLength) {\n            let originalEndIndex = originalLength - 1;\n            let modifiedEndIndex = modifiedLength - 1;\n            while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {\n                originalEndIndex--;\n                modifiedEndIndex--;\n            }\n            // if one moved behind the start index move them forward again\n            if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {\n                originalEndIndex++;\n                modifiedEndIndex++;\n            }\n            const deleteCount = originalEndIndex - startIndex + 1;\n            const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);\n            // If we moved behind the start index we could have missed a simple delete.\n            if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {\n                return [\n                    { start: startIndex, deleteCount: deleteCount - 1 }\n                ];\n            }\n            else {\n                return [\n                    { start: startIndex, deleteCount, data: newData }\n                ];\n            }\n        }\n        else if (startIndex < modifiedLength) {\n            return [\n                { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }\n            ];\n        }\n        else if (startIndex < originalLength) {\n            return [\n                { start: startIndex, deleteCount: originalLength - startIndex }\n            ];\n        }\n        else {\n            // The two arrays are the same.\n            return [];\n        }\n    }\n}\nexports.SemanticTokensDiff = SemanticTokensDiff;\nclass SemanticTokensBuilder {\n    constructor() {\n        this._prevData = undefined;\n        this.initialize();\n    }\n    initialize() {\n        this._id = Date.now();\n        this._prevLine = 0;\n        this._prevChar = 0;\n        this._data = [];\n        this._dataLen = 0;\n    }\n    push(line, char, length, tokenType, tokenModifiers) {\n        let pushLine = line;\n        let pushChar = char;\n        if (this._dataLen > 0) {\n            pushLine -= this._prevLine;\n            if (pushLine === 0) {\n                pushChar -= this._prevChar;\n            }\n        }\n        this._data[this._dataLen++] = pushLine;\n        this._data[this._dataLen++] = pushChar;\n        this._data[this._dataLen++] = length;\n        this._data[this._dataLen++] = tokenType;\n        this._data[this._dataLen++] = tokenModifiers;\n        this._prevLine = line;\n        this._prevChar = char;\n    }\n    get id() {\n        return this._id.toString();\n    }\n    previousResult(id) {\n        if (this.id === id) {\n            this._prevData = this._data;\n        }\n        this.initialize();\n    }\n    build() {\n        this._prevData = undefined;\n        return {\n            resultId: this.id,\n            data: this._data\n        };\n    }\n    canBuildEdits() {\n        return this._prevData !== undefined;\n    }\n    buildEdits() {\n        if (this._prevData !== undefined) {\n            return {\n                resultId: this.id,\n                edits: (new SemanticTokensDiff(this._prevData, this._data)).computeDiff()\n            };\n        }\n        else {\n            return this.build();\n        }\n    }\n}\nexports.SemanticTokensBuilder = SemanticTokensBuilder;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ShowDocumentFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst ShowDocumentFeature = (Base) => {\n    return class extends Base {\n        showDocument(params) {\n            return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);\n        }\n    };\n};\nexports.ShowDocumentFeature = ShowDocumentFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FileOperationsFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst FileOperationsFeature = (Base) => {\n    return class extends Base {\n        onDidCreateFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onDidRenameFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onDidDeleteFiles(handler) {\n            return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {\n                handler(params);\n            });\n        }\n        onWillCreateFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n        onWillRenameFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n        onWillDeleteFiles(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {\n                return handler(params, cancel);\n            });\n        }\n    };\n};\nexports.FileOperationsFeature = FileOperationsFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.LinkedEditingRangeFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst LinkedEditingRangeFeature = (Base) => {\n    return class extends Base {\n        onLinkedEditingRange(handler) {\n            return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {\n                return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n            });\n        }\n    };\n};\nexports.LinkedEditingRangeFeature = LinkedEditingRangeFeature;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TypeHierarchyFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst TypeHierarchyFeature = (Base) => {\n    return class extends Base {\n        get typeHierarchy() {\n            return {\n                onPrepare: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), undefined);\n                    });\n                },\n                onSupertypes: (handler) => {\n                    const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n                onSubtypes: (handler) => {\n                    const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.TypeHierarchyFeature = TypeHierarchyFeature;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineValueFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlineValueFeature = (Base) => {\n    return class extends Base {\n        get inlineValue() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlineValueFeature = InlineValueFeature;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FoldingRangeFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst FoldingRangeFeature = (Base) => {\n    return class extends Base {\n        get foldingRange() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.FoldingRangeRefreshRequest.type);\n                },\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.FoldingRangeRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.FoldingRangeFeature = FoldingRangeFeature;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlayHintFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlayHintFeature = (Base) => {\n    return class extends Base {\n        get inlayHint() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                },\n                resolve: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {\n                        return handler(params, cancel);\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlayHintFeature = InlayHintFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DiagnosticFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst DiagnosticFeature = (Base) => {\n    return class extends Base {\n        get diagnostics() {\n            return {\n                refresh: () => {\n                    return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);\n                },\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));\n                    });\n                },\n                onWorkspace: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.DiagnosticFeature = DiagnosticFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TextDocuments = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\n/**\n * A manager for simple text documents. The manager requires at a minimum that\n * the server registered for the following text document sync events in the\n * initialize handler or via dynamic registration:\n *\n * - open and close events.\n * - change events.\n *\n * Registering for save and will save events is optional.\n */\nclass TextDocuments {\n    /**\n     * Create a new text document manager.\n     */\n    constructor(configuration) {\n        this._configuration = configuration;\n        this._syncedDocuments = new Map();\n        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened.\n     */\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been opened or the content changes.\n     */\n    get onDidChangeContent() {\n        return this._onDidChangeContent.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * will be saved.\n     */\n    get onWillSave() {\n        return this._onWillSave.event;\n    }\n    /**\n     * Sets a handler that will be called if a participant wants to provide\n     * edits during a text document save.\n     */\n    onWillSaveWaitUntil(handler) {\n        this._willSaveWaitUntil = handler;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been saved.\n     */\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    /**\n     * An event that fires when a text document managed by this manager\n     * has been closed.\n     */\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Returns the document for the given URI. Returns undefined if\n     * the document is not managed by this instance.\n     *\n     * @param uri The text document's URI to retrieve.\n     * @return the text document or `undefined`.\n     */\n    get(uri) {\n        return this._syncedDocuments.get(uri);\n    }\n    /**\n     * Returns all text documents managed by this instance.\n     *\n     * @return all text documents.\n     */\n    all() {\n        return Array.from(this._syncedDocuments.values());\n    }\n    /**\n     * Returns the URIs of all text documents managed by this instance.\n     *\n     * @return the URI's of all text documents.\n     */\n    keys() {\n        return Array.from(this._syncedDocuments.keys());\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the text documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenTextDocument`, `onDidChangeTextDocument`, `onDidCloseTextDocument`,\n     * `onWillSaveTextDocument`, `onWillSaveTextDocumentWaitUntil` and `onDidSaveTextDocument`.\n     *\n     * Use the corresponding events on the TextDocuments instance instead.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;\n        const disposables = [];\n        disposables.push(connection.onDidOpenTextDocument((event) => {\n            const td = event.textDocument;\n            const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);\n            this._syncedDocuments.set(td.uri, document);\n            const toFire = Object.freeze({ document });\n            this._onDidOpen.fire(toFire);\n            this._onDidChangeContent.fire(toFire);\n        }));\n        disposables.push(connection.onDidChangeTextDocument((event) => {\n            const td = event.textDocument;\n            const changes = event.contentChanges;\n            if (changes.length === 0) {\n                return;\n            }\n            const { version } = td;\n            if (version === null || version === undefined) {\n                throw new Error(`Received document change event for ${td.uri} without valid version identifier`);\n            }\n            let syncedDocument = this._syncedDocuments.get(td.uri);\n            if (syncedDocument !== undefined) {\n                syncedDocument = this._configuration.update(syncedDocument, changes, version);\n                this._syncedDocuments.set(td.uri, syncedDocument);\n                this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        disposables.push(connection.onDidCloseTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._syncedDocuments.delete(event.textDocument.uri);\n                this._onDidClose.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        disposables.push(connection.onWillSaveTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));\n            }\n        }));\n        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined && this._willSaveWaitUntil) {\n                return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);\n            }\n            else {\n                return [];\n            }\n        }));\n        disposables.push(connection.onDidSaveTextDocument((event) => {\n            let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);\n            if (syncedDocument !== undefined) {\n                this._onDidSave.fire(Object.freeze({ document: syncedDocument }));\n            }\n        }));\n        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });\n    }\n}\nexports.TextDocuments = TextDocuments;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.NotebookDocuments = exports.NotebookSyncFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst textDocuments_1 = require(\"./textDocuments\");\nconst NotebookSyncFeature = (Base) => {\n    return class extends Base {\n        get synchronization() {\n            return {\n                onDidOpenNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidChangeNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidSaveNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                },\n                onDidCloseNotebookDocument: (handler) => {\n                    return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {\n                        handler(params);\n                    });\n                }\n            };\n        }\n    };\n};\nexports.NotebookSyncFeature = NotebookSyncFeature;\nclass CellTextDocumentConnection {\n    onDidOpenTextDocument(handler) {\n        this.openHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.openHandler = undefined; });\n    }\n    openTextDocument(params) {\n        this.openHandler && this.openHandler(params);\n    }\n    onDidChangeTextDocument(handler) {\n        this.changeHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.changeHandler = handler; });\n    }\n    changeTextDocument(params) {\n        this.changeHandler && this.changeHandler(params);\n    }\n    onDidCloseTextDocument(handler) {\n        this.closeHandler = handler;\n        return vscode_languageserver_protocol_1.Disposable.create(() => { this.closeHandler = undefined; });\n    }\n    closeTextDocument(params) {\n        this.closeHandler && this.closeHandler(params);\n    }\n    onWillSaveTextDocument() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n    onWillSaveTextDocumentWaitUntil() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n    onDidSaveTextDocument() {\n        return CellTextDocumentConnection.NULL_DISPOSE;\n    }\n}\nCellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => { } });\nclass NotebookDocuments {\n    constructor(configurationOrTextDocuments) {\n        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {\n            this._cellTextDocuments = configurationOrTextDocuments;\n        }\n        else {\n            this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);\n        }\n        this.notebookDocuments = new Map();\n        this.notebookCellMap = new Map();\n        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();\n        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();\n    }\n    get cellTextDocuments() {\n        return this._cellTextDocuments;\n    }\n    getCellTextDocument(cell) {\n        return this._cellTextDocuments.get(cell.document);\n    }\n    getNotebookDocument(uri) {\n        return this.notebookDocuments.get(uri);\n    }\n    getNotebookCell(uri) {\n        const value = this.notebookCellMap.get(uri);\n        return value && value[0];\n    }\n    findNotebookDocumentForCell(cell) {\n        const key = typeof cell === 'string' ? cell : cell.document;\n        const value = this.notebookCellMap.get(key);\n        return value && value[1];\n    }\n    get onDidOpen() {\n        return this._onDidOpen.event;\n    }\n    get onDidSave() {\n        return this._onDidSave.event;\n    }\n    get onDidChange() {\n        return this._onDidChange.event;\n    }\n    get onDidClose() {\n        return this._onDidClose.event;\n    }\n    /**\n     * Listens for `low level` notification on the given connection to\n     * update the notebook documents managed by this instance.\n     *\n     * Please note that the connection only provides handlers not an event model. Therefore\n     * listening on a connection will overwrite the following handlers on a connection:\n     * `onDidOpenNotebookDocument`, `onDidChangeNotebookDocument`, `onDidSaveNotebookDocument`,\n     *  and `onDidCloseNotebookDocument`.\n     *\n     * @param connection The connection to listen on.\n     */\n    listen(connection) {\n        const cellTextDocumentConnection = new CellTextDocumentConnection();\n        const disposables = [];\n        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));\n        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {\n            this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);\n            for (const cellTextDocument of params.cellTextDocuments) {\n                cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });\n            }\n            this.updateCellMap(params.notebookDocument);\n            this._onDidOpen.fire(params.notebookDocument);\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            notebookDocument.version = params.notebookDocument.version;\n            const oldMetadata = notebookDocument.metadata;\n            let metadataChanged = false;\n            const change = params.change;\n            if (change.metadata !== undefined) {\n                metadataChanged = true;\n                notebookDocument.metadata = change.metadata;\n            }\n            const opened = [];\n            const closed = [];\n            const data = [];\n            const text = [];\n            if (change.cells !== undefined) {\n                const changedCells = change.cells;\n                if (changedCells.structure !== undefined) {\n                    const array = changedCells.structure.array;\n                    notebookDocument.cells.splice(array.start, array.deleteCount, ...(array.cells !== undefined ? array.cells : []));\n                    // Additional open cell text documents.\n                    if (changedCells.structure.didOpen !== undefined) {\n                        for (const open of changedCells.structure.didOpen) {\n                            cellTextDocumentConnection.openTextDocument({ textDocument: open });\n                            opened.push(open.uri);\n                        }\n                    }\n                    // Additional closed cell test documents.\n                    if (changedCells.structure.didClose) {\n                        for (const close of changedCells.structure.didClose) {\n                            cellTextDocumentConnection.closeTextDocument({ textDocument: close });\n                            closed.push(close.uri);\n                        }\n                    }\n                }\n                if (changedCells.data !== undefined) {\n                    const cellUpdates = new Map(changedCells.data.map(cell => [cell.document, cell]));\n                    for (let i = 0; i <= notebookDocument.cells.length; i++) {\n                        const change = cellUpdates.get(notebookDocument.cells[i].document);\n                        if (change !== undefined) {\n                            const old = notebookDocument.cells.splice(i, 1, change);\n                            data.push({ old: old[0], new: change });\n                            cellUpdates.delete(change.document);\n                            if (cellUpdates.size === 0) {\n                                break;\n                            }\n                        }\n                    }\n                }\n                if (changedCells.textContent !== undefined) {\n                    for (const cellTextDocument of changedCells.textContent) {\n                        cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });\n                        text.push(cellTextDocument.document.uri);\n                    }\n                }\n            }\n            // Update internal data structure.\n            this.updateCellMap(notebookDocument);\n            const changeEvent = { notebookDocument };\n            if (metadataChanged) {\n                changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };\n            }\n            const added = [];\n            for (const open of opened) {\n                added.push(this.getNotebookCell(open));\n            }\n            const removed = [];\n            for (const close of closed) {\n                removed.push(this.getNotebookCell(close));\n            }\n            const textContent = [];\n            for (const change of text) {\n                textContent.push(this.getNotebookCell(change));\n            }\n            if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {\n                changeEvent.cells = { added, removed, changed: { data, textContent } };\n            }\n            if (changeEvent.metadata !== undefined || changeEvent.cells !== undefined) {\n                this._onDidChange.fire(changeEvent);\n            }\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            this._onDidSave.fire(notebookDocument);\n        }));\n        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {\n            const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);\n            if (notebookDocument === undefined) {\n                return;\n            }\n            this._onDidClose.fire(notebookDocument);\n            for (const cellTextDocument of params.cellTextDocuments) {\n                cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });\n            }\n            this.notebookDocuments.delete(params.notebookDocument.uri);\n            for (const cell of notebookDocument.cells) {\n                this.notebookCellMap.delete(cell.document);\n            }\n        }));\n        return vscode_languageserver_protocol_1.Disposable.create(() => { disposables.forEach(disposable => disposable.dispose()); });\n    }\n    updateCellMap(notebookDocument) {\n        for (const cell of notebookDocument.cells) {\n            this.notebookCellMap.set(cell.document, [cell, notebookDocument]);\n        }\n    }\n}\nexports.NotebookDocuments = NotebookDocuments;\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MonikerFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst MonikerFeature = (Base) => {\n    return class extends Base {\n        get moniker() {\n            return {\n                on: (handler) => {\n                    const type = vscode_languageserver_protocol_1.MonikerRequest.type;\n                    return this.connection.onRequest(type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));\n                    });\n                },\n            };\n        }\n    };\n};\nexports.MonikerFeature = MonikerFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = exports.combineFeatures = exports.combineNotebooksFeatures = exports.combineLanguagesFeatures = exports.combineWorkspaceFeatures = exports.combineWindowFeatures = exports.combineClientFeatures = exports.combineTracerFeatures = exports.combineTelemetryFeatures = exports.combineConsoleFeatures = exports._NotebooksImpl = exports._LanguagesImpl = exports.BulkUnregistration = exports.BulkRegistration = exports.ErrorMessageTracker = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst Is = require(\"./utils/is\");\nconst UUID = require(\"./utils/uuid\");\nconst progress_1 = require(\"./progress\");\nconst configuration_1 = require(\"./configuration\");\nconst workspaceFolder_1 = require(\"./workspaceFolder\");\nconst callHierarchy_1 = require(\"./callHierarchy\");\nconst semanticTokens_1 = require(\"./semanticTokens\");\nconst showDocument_1 = require(\"./showDocument\");\nconst fileOperations_1 = require(\"./fileOperations\");\nconst linkedEditingRange_1 = require(\"./linkedEditingRange\");\nconst typeHierarchy_1 = require(\"./typeHierarchy\");\nconst inlineValue_1 = require(\"./inlineValue\");\nconst foldingRange_1 = require(\"./foldingRange\");\n// import { InlineCompletionFeatureShape, InlineCompletionFeature } from './inlineCompletion.proposed';\nconst inlayHint_1 = require(\"./inlayHint\");\nconst diagnostic_1 = require(\"./diagnostic\");\nconst notebook_1 = require(\"./notebook\");\nconst moniker_1 = require(\"./moniker\");\nfunction null2Undefined(value) {\n    if (value === null) {\n        return undefined;\n    }\n    return value;\n}\n/**\n * Helps tracking error message. Equal occurrences of the same\n * message are only stored once. This class is for example\n * useful if text documents are validated in a loop and equal\n * error message should be folded into one.\n */\nclass ErrorMessageTracker {\n    constructor() {\n        this._messages = Object.create(null);\n    }\n    /**\n     * Add a message to the tracker.\n     *\n     * @param message The message to add.\n     */\n    add(message) {\n        let count = this._messages[message];\n        if (!count) {\n            count = 0;\n        }\n        count++;\n        this._messages[message] = count;\n    }\n    /**\n     * Send all tracked messages to the connection's window.\n     *\n     * @param connection The connection established between client and server.\n     */\n    sendErrors(connection) {\n        Object.keys(this._messages).forEach(message => {\n            connection.window.showErrorMessage(message);\n        });\n    }\n}\nexports.ErrorMessageTracker = ErrorMessageTracker;\nclass RemoteConsoleImpl {\n    constructor() {\n    }\n    rawAttach(connection) {\n        this._rawConnection = connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    initialize(_capabilities) {\n    }\n    error(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);\n    }\n    warn(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);\n    }\n    info(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);\n    }\n    log(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);\n    }\n    debug(message) {\n        this.send(vscode_languageserver_protocol_1.MessageType.Debug, message);\n    }\n    send(type, message) {\n        if (this._rawConnection) {\n            this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {\n                (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);\n            });\n        }\n    }\n}\nclass _RemoteWindowImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    showErrorMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showWarningMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n    showInformationMessage(message, ...actions) {\n        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);\n    }\n}\nconst RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));\nvar BulkRegistration;\n(function (BulkRegistration) {\n    /**\n     * Creates a new bulk registration.\n     * @return an empty bulk registration.\n     */\n    function create() {\n        return new BulkRegistrationImpl();\n    }\n    BulkRegistration.create = create;\n})(BulkRegistration || (exports.BulkRegistration = BulkRegistration = {}));\nclass BulkRegistrationImpl {\n    constructor() {\n        this._registrations = [];\n        this._registered = new Set();\n    }\n    add(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        if (this._registered.has(method)) {\n            throw new Error(`${method} is already added to this registration`);\n        }\n        const id = UUID.generateUuid();\n        this._registrations.push({\n            id: id,\n            method: method,\n            registerOptions: registerOptions || {}\n        });\n        this._registered.add(method);\n    }\n    asRegistrationParams() {\n        return {\n            registrations: this._registrations\n        };\n    }\n}\nvar BulkUnregistration;\n(function (BulkUnregistration) {\n    function create() {\n        return new BulkUnregistrationImpl(undefined, []);\n    }\n    BulkUnregistration.create = create;\n})(BulkUnregistration || (exports.BulkUnregistration = BulkUnregistration = {}));\nclass BulkUnregistrationImpl {\n    constructor(_connection, unregistrations) {\n        this._connection = _connection;\n        this._unregistrations = new Map();\n        unregistrations.forEach(unregistration => {\n            this._unregistrations.set(unregistration.method, unregistration);\n        });\n    }\n    get isAttached() {\n        return !!this._connection;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    add(unregistration) {\n        this._unregistrations.set(unregistration.method, unregistration);\n    }\n    dispose() {\n        let unregistrations = [];\n        for (let unregistration of this._unregistrations.values()) {\n            unregistrations.push(unregistration);\n        }\n        let params = {\n            unregisterations: unregistrations\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {\n            this._connection.console.info(`Bulk unregistration failed.`);\n        });\n    }\n    disposeSingle(arg) {\n        const method = Is.string(arg) ? arg : arg.method;\n        const unregistration = this._unregistrations.get(method);\n        if (!unregistration) {\n            return false;\n        }\n        let params = {\n            unregisterations: [unregistration]\n        };\n        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {\n            this._unregistrations.delete(method);\n        }, (_error) => {\n            this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);\n        });\n        return true;\n    }\n}\nclass RemoteClientImpl {\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    register(typeOrRegistrations, registerOptionsOrType, registerOptions) {\n        if (typeOrRegistrations instanceof BulkRegistrationImpl) {\n            return this.registerMany(typeOrRegistrations);\n        }\n        else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {\n            return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);\n        }\n        else {\n            return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);\n        }\n    }\n    registerSingle1(unregistration, type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        if (!unregistration.isAttached) {\n            unregistration.attach(this.connection);\n        }\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            unregistration.add({ id: id, method: method });\n            return unregistration;\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    registerSingle2(type, registerOptions) {\n        const method = Is.string(type) ? type : type.method;\n        const id = UUID.generateUuid();\n        let params = {\n            registrations: [{ id, method, registerOptions: registerOptions || {} }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {\n            return vscode_languageserver_protocol_1.Disposable.create(() => {\n                this.unregisterSingle(id, method).catch(() => { this.connection.console.info(`Un-registering capability with id ${id} failed.`); });\n            });\n        }, (_error) => {\n            this.connection.console.info(`Registering request handler for ${method} failed.`);\n            return Promise.reject(_error);\n        });\n    }\n    unregisterSingle(id, method) {\n        let params = {\n            unregisterations: [{ id, method }]\n        };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {\n            this.connection.console.info(`Un-registering request handler for ${id} failed.`);\n        });\n    }\n    registerMany(registrations) {\n        let params = registrations.asRegistrationParams();\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {\n            return new BulkUnregistrationImpl(this._connection, params.registrations.map(registration => { return { id: registration.id, method: registration.method }; }));\n        }, (_error) => {\n            this.connection.console.info(`Bulk registration failed.`);\n            return Promise.reject(_error);\n        });\n    }\n}\nclass _RemoteWorkspaceImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    applyEdit(paramOrEdit) {\n        function isApplyWorkspaceEditParams(value) {\n            return value && !!value.edit;\n        }\n        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };\n        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);\n    }\n}\nconst RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));\nclass TracerImpl {\n    constructor() {\n        this._trace = vscode_languageserver_protocol_1.Trace.Off;\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    set trace(value) {\n        this._trace = value;\n    }\n    log(message, verbose) {\n        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {\n            return;\n        }\n        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {\n            message: message,\n            verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : undefined\n        }).catch(() => {\n            // Very hard to decide what to do. We tried to send a log\n            // message which failed so we can't simply send another :-(.\n        });\n    }\n}\nclass TelemetryImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    logEvent(data) {\n        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {\n            this.connection.console.log(`Sending TelemetryEventNotification failed`);\n        });\n    }\n}\nclass _LanguagesImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return (0, progress_1.attachWorkDone)(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return (0, progress_1.attachPartialResult)(this.connection, params);\n    }\n}\nexports._LanguagesImpl = _LanguagesImpl;\nconst LanguagesImpl = (0, foldingRange_1.FoldingRangeFeature)((0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl)))))))));\nclass _NotebooksImpl {\n    constructor() {\n    }\n    attach(connection) {\n        this._connection = connection;\n    }\n    get connection() {\n        if (!this._connection) {\n            throw new Error('Remote is not attached to a connection yet.');\n        }\n        return this._connection;\n    }\n    initialize(_capabilities) {\n    }\n    fillServerCapabilities(_capabilities) {\n    }\n    attachWorkDoneProgress(params) {\n        return (0, progress_1.attachWorkDone)(this.connection, params);\n    }\n    attachPartialResultProgress(_type, params) {\n        return (0, progress_1.attachPartialResult)(this.connection, params);\n    }\n}\nexports._NotebooksImpl = _NotebooksImpl;\nconst NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);\nfunction combineConsoleFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineConsoleFeatures = combineConsoleFeatures;\nfunction combineTelemetryFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTelemetryFeatures = combineTelemetryFeatures;\nfunction combineTracerFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineTracerFeatures = combineTracerFeatures;\nfunction combineClientFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineClientFeatures = combineClientFeatures;\nfunction combineWindowFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWindowFeatures = combineWindowFeatures;\nfunction combineWorkspaceFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineWorkspaceFeatures = combineWorkspaceFeatures;\nfunction combineLanguagesFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineLanguagesFeatures = combineLanguagesFeatures;\nfunction combineNotebooksFeatures(one, two) {\n    return function (Base) {\n        return two(one(Base));\n    };\n}\nexports.combineNotebooksFeatures = combineNotebooksFeatures;\nfunction combineFeatures(one, two) {\n    function combine(one, two, func) {\n        if (one && two) {\n            return func(one, two);\n        }\n        else if (one) {\n            return one;\n        }\n        else {\n            return two;\n        }\n    }\n    let result = {\n        __brand: 'features',\n        console: combine(one.console, two.console, combineConsoleFeatures),\n        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),\n        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),\n        client: combine(one.client, two.client, combineClientFeatures),\n        window: combine(one.window, two.window, combineWindowFeatures),\n        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),\n        languages: combine(one.languages, two.languages, combineLanguagesFeatures),\n        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)\n    };\n    return result;\n}\nexports.combineFeatures = combineFeatures;\nfunction createConnection(connectionFactory, watchDog, factories) {\n    const logger = (factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl());\n    const connection = connectionFactory(logger);\n    logger.rawAttach(connection);\n    const tracer = (factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl());\n    const telemetry = (factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl());\n    const client = (factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl());\n    const remoteWindow = (factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl());\n    const workspace = (factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl());\n    const languages = (factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl());\n    const notebooks = (factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl());\n    const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];\n    function asPromise(value) {\n        if (value instanceof Promise) {\n            return value;\n        }\n        else if (Is.thenable(value)) {\n            return new Promise((resolve, reject) => {\n                value.then((resolved) => resolve(resolved), (error) => reject(error));\n            });\n        }\n        else {\n            return Promise.resolve(value);\n        }\n    }\n    let shutdownHandler = undefined;\n    let initializeHandler = undefined;\n    let exitHandler = undefined;\n    let protocolConnection = {\n        listen: () => connection.listen(),\n        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),\n        onRequest: (type, handler) => connection.onRequest(type, handler),\n        sendNotification: (type, param) => {\n            const method = Is.string(type) ? type : type.method;\n            return connection.sendNotification(method, param);\n        },\n        onNotification: (type, handler) => connection.onNotification(type, handler),\n        onProgress: connection.onProgress,\n        sendProgress: connection.sendProgress,\n        onInitialize: (handler) => {\n            initializeHandler = handler;\n            return {\n                dispose: () => {\n                    initializeHandler = undefined;\n                }\n            };\n        },\n        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),\n        onShutdown: (handler) => {\n            shutdownHandler = handler;\n            return {\n                dispose: () => {\n                    shutdownHandler = undefined;\n                }\n            };\n        },\n        onExit: (handler) => {\n            exitHandler = handler;\n            return {\n                dispose: () => {\n                    exitHandler = undefined;\n                }\n            };\n        },\n        get console() { return logger; },\n        get telemetry() { return telemetry; },\n        get tracer() { return tracer; },\n        get client() { return client; },\n        get window() { return remoteWindow; },\n        get workspace() { return workspace; },\n        get languages() { return languages; },\n        get notebooks() { return notebooks; },\n        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),\n        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),\n        __textDocumentSync: undefined,\n        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),\n        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),\n        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),\n        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),\n        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),\n        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),\n        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),\n        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),\n        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),\n        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {\n            return handler(params, cancel);\n        }),\n        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));\n        }),\n        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {\n            return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), undefined);\n        }),\n        dispose: () => connection.dispose()\n    };\n    for (let remote of allRemotes) {\n        remote.attach(protocolConnection);\n    }\n    connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {\n        watchDog.initialize(params);\n        if (Is.string(params.trace)) {\n            tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);\n        }\n        for (let remote of allRemotes) {\n            remote.initialize(params.capabilities);\n        }\n        if (initializeHandler) {\n            let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), undefined);\n            return asPromise(result).then((value) => {\n                if (value instanceof vscode_languageserver_protocol_1.ResponseError) {\n                    return value;\n                }\n                let result = value;\n                if (!result) {\n                    result = { capabilities: {} };\n                }\n                let capabilities = result.capabilities;\n                if (!capabilities) {\n                    capabilities = {};\n                    result.capabilities = capabilities;\n                }\n                if (capabilities.textDocumentSync === undefined || capabilities.textDocumentSync === null) {\n                    capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {\n                    capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;\n                }\n                for (let remote of allRemotes) {\n                    remote.fillServerCapabilities(capabilities);\n                }\n                return result;\n            });\n        }\n        else {\n            let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };\n            for (let remote of allRemotes) {\n                remote.fillServerCapabilities(result.capabilities);\n            }\n            return result;\n        }\n    });\n    connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {\n        watchDog.shutdownReceived = true;\n        if (shutdownHandler) {\n            return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);\n        }\n        else {\n            return undefined;\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {\n        try {\n            if (exitHandler) {\n                exitHandler();\n            }\n        }\n        finally {\n            if (watchDog.shutdownReceived) {\n                watchDog.exit(0);\n            }\n            else {\n                watchDog.exit(1);\n            }\n        }\n    });\n    connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {\n        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);\n    });\n    return protocolConnection;\n}\nexports.createConnection = createConnection;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.resolveModulePath = exports.FileSystem = exports.resolveGlobalYarnPath = exports.resolveGlobalNodePath = exports.resolve = exports.uriToFilePath = void 0;\nconst url = require(\"url\");\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst child_process_1 = require(\"child_process\");\n/**\n * @deprecated Use the `vscode-uri` npm module which provides a more\n * complete implementation of handling VS Code URIs.\n */\nfunction uriToFilePath(uri) {\n    let parsed = url.parse(uri);\n    if (parsed.protocol !== 'file:' || !parsed.path) {\n        return undefined;\n    }\n    let segments = parsed.path.split('/');\n    for (var i = 0, len = segments.length; i < len; i++) {\n        segments[i] = decodeURIComponent(segments[i]);\n    }\n    if (process.platform === 'win32' && segments.length > 1) {\n        let first = segments[0];\n        let second = segments[1];\n        // Do we have a drive letter and we started with a / which is the\n        // case if the first segement is empty (see split above)\n        if (first.length === 0 && second.length > 1 && second[1] === ':') {\n            // Remove first slash\n            segments.shift();\n        }\n    }\n    return path.normalize(segments.join('/'));\n}\nexports.uriToFilePath = uriToFilePath;\nfunction isWindows() {\n    return process.platform === 'win32';\n}\nfunction resolve(moduleName, nodePath, cwd, tracer) {\n    const nodePathKey = 'NODE_PATH';\n    const app = [\n        'var p = process;',\n        'p.on(\\'message\\',function(m){',\n        'if(m.c===\\'e\\'){',\n        'p.exit(0);',\n        '}',\n        'else if(m.c===\\'rs\\'){',\n        'try{',\n        'var r=require.resolve(m.a);',\n        'p.send({c:\\'r\\',s:true,r:r});',\n        '}',\n        'catch(err){',\n        'p.send({c:\\'r\\',s:false});',\n        '}',\n        '}',\n        '});'\n    ].join('');\n    return new Promise((resolve, reject) => {\n        let env = process.env;\n        let newEnv = Object.create(null);\n        Object.keys(env).forEach(key => newEnv[key] = env[key]);\n        if (nodePath && fs.existsSync(nodePath) /* see issue 545 */) {\n            if (newEnv[nodePathKey]) {\n                newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];\n            }\n            else {\n                newEnv[nodePathKey] = nodePath;\n            }\n            if (tracer) {\n                tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);\n            }\n        }\n        newEnv['ELECTRON_RUN_AS_NODE'] = '1';\n        try {\n            let cp = (0, child_process_1.fork)('', [], {\n                cwd: cwd,\n                env: newEnv,\n                execArgv: ['-e', app]\n            });\n            if (cp.pid === void 0) {\n                reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));\n                return;\n            }\n            cp.on('error', (error) => {\n                reject(error);\n            });\n            cp.on('message', (message) => {\n                if (message.c === 'r') {\n                    cp.send({ c: 'e' });\n                    if (message.s) {\n                        resolve(message.r);\n                    }\n                    else {\n                        reject(new Error(`Failed to resolve module: ${moduleName}`));\n                    }\n                }\n            });\n            let message = {\n                c: 'rs',\n                a: moduleName\n            };\n            cp.send(message);\n        }\n        catch (error) {\n            reject(error);\n        }\n    });\n}\nexports.resolve = resolve;\n/**\n * Resolve the global npm package path.\n * @deprecated Since this depends on the used package manager and their version the best is that servers\n * implement this themselves since they know best what kind of package managers to support.\n * @param tracer the tracer to use\n */\nfunction resolveGlobalNodePath(tracer) {\n    let npmCommand = 'npm';\n    const env = Object.create(null);\n    Object.keys(process.env).forEach(key => env[key] = process.env[key]);\n    env['NO_UPDATE_NOTIFIER'] = 'true';\n    const options = {\n        encoding: 'utf8',\n        env\n    };\n    if (isWindows()) {\n        npmCommand = 'npm.cmd';\n        options.shell = true;\n    }\n    let handler = () => { };\n    try {\n        process.on('SIGPIPE', handler);\n        let stdout = (0, child_process_1.spawnSync)(npmCommand, ['config', 'get', 'prefix'], options).stdout;\n        if (!stdout) {\n            if (tracer) {\n                tracer(`'npm config get prefix' didn't return a value.`);\n            }\n            return undefined;\n        }\n        let prefix = stdout.trim();\n        if (tracer) {\n            tracer(`'npm config get prefix' value is: ${prefix}`);\n        }\n        if (prefix.length > 0) {\n            if (isWindows()) {\n                return path.join(prefix, 'node_modules');\n            }\n            else {\n                return path.join(prefix, 'lib', 'node_modules');\n            }\n        }\n        return undefined;\n    }\n    catch (err) {\n        return undefined;\n    }\n    finally {\n        process.removeListener('SIGPIPE', handler);\n    }\n}\nexports.resolveGlobalNodePath = resolveGlobalNodePath;\n/*\n * Resolve the global yarn pakage path.\n * @deprecated Since this depends on the used package manager and their version the best is that servers\n * implement this themselves since they know best what kind of package managers to support.\n * @param tracer the tracer to use\n */\nfunction resolveGlobalYarnPath(tracer) {\n    let yarnCommand = 'yarn';\n    let options = {\n        encoding: 'utf8'\n    };\n    if (isWindows()) {\n        yarnCommand = 'yarn.cmd';\n        options.shell = true;\n    }\n    let handler = () => { };\n    try {\n        process.on('SIGPIPE', handler);\n        let results = (0, child_process_1.spawnSync)(yarnCommand, ['global', 'dir', '--json'], options);\n        let stdout = results.stdout;\n        if (!stdout) {\n            if (tracer) {\n                tracer(`'yarn global dir' didn't return a value.`);\n                if (results.stderr) {\n                    tracer(results.stderr);\n                }\n            }\n            return undefined;\n        }\n        let lines = stdout.trim().split(/\\r?\\n/);\n        for (let line of lines) {\n            try {\n                let yarn = JSON.parse(line);\n                if (yarn.type === 'log') {\n                    return path.join(yarn.data, 'node_modules');\n                }\n            }\n            catch (e) {\n                // Do nothing. Ignore the line\n            }\n        }\n        return undefined;\n    }\n    catch (err) {\n        return undefined;\n    }\n    finally {\n        process.removeListener('SIGPIPE', handler);\n    }\n}\nexports.resolveGlobalYarnPath = resolveGlobalYarnPath;\nvar FileSystem;\n(function (FileSystem) {\n    let _isCaseSensitive = undefined;\n    function isCaseSensitive() {\n        if (_isCaseSensitive !== void 0) {\n            return _isCaseSensitive;\n        }\n        if (process.platform === 'win32') {\n            _isCaseSensitive = false;\n        }\n        else {\n            // convert current file name to upper case / lower case and check if file exists\n            // (guards against cases when name is already all uppercase or lowercase)\n            _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());\n        }\n        return _isCaseSensitive;\n    }\n    FileSystem.isCaseSensitive = isCaseSensitive;\n    function isParent(parent, child) {\n        if (isCaseSensitive()) {\n            return path.normalize(child).indexOf(path.normalize(parent)) === 0;\n        }\n        else {\n            return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;\n        }\n    }\n    FileSystem.isParent = isParent;\n})(FileSystem || (exports.FileSystem = FileSystem = {}));\nfunction resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {\n    if (nodePath) {\n        if (!path.isAbsolute(nodePath)) {\n            nodePath = path.join(workspaceRoot, nodePath);\n        }\n        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {\n            if (FileSystem.isParent(nodePath, value)) {\n                return value;\n            }\n            else {\n                return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));\n            }\n        }).then(undefined, (_error) => {\n            return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n        });\n    }\n    else {\n        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);\n    }\n}\nexports.resolveModulePath = resolveModulePath;\n", "/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ----------------------------------------------------------------------------------------- */\r\n'use strict';\r\n\r\nmodule.exports = require('./lib/node/main');", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InlineCompletionFeature = void 0;\nconst vscode_languageserver_protocol_1 = require(\"vscode-languageserver-protocol\");\nconst InlineCompletionFeature = (Base) => {\n    return class extends Base {\n        get inlineCompletion() {\n            return {\n                on: (handler) => {\n                    return this.connection.onRequest(vscode_languageserver_protocol_1.InlineCompletionRequest.type, (params, cancel) => {\n                        return handler(params, cancel, this.attachWorkDoneProgress(params));\n                    });\n                }\n            };\n        }\n    };\n};\nexports.InlineCompletionFeature = InlineCompletionFeature;\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProposedFeatures = exports.NotebookDocuments = exports.TextDocuments = exports.SemanticTokensBuilder = void 0;\nconst semanticTokens_1 = require(\"./semanticTokens\");\nObject.defineProperty(exports, \"SemanticTokensBuilder\", { enumerable: true, get: function () { return semanticTokens_1.SemanticTokensBuilder; } });\nconst ic = require(\"./inlineCompletion.proposed\");\n__exportStar(require(\"vscode-languageserver-protocol/\"), exports);\nconst textDocuments_1 = require(\"./textDocuments\");\nObject.defineProperty(exports, \"TextDocuments\", { enumerable: true, get: function () { return textDocuments_1.TextDocuments; } });\nconst notebook_1 = require(\"./notebook\");\nObject.defineProperty(exports, \"NotebookDocuments\", { enumerable: true, get: function () { return notebook_1.NotebookDocuments; } });\n__exportStar(require(\"./server\"), exports);\nvar ProposedFeatures;\n(function (ProposedFeatures) {\n    ProposedFeatures.all = {\n        __brand: 'features',\n        languages: ic.InlineCompletionFeature\n    };\n})(ProposedFeatures || (exports.ProposedFeatures = ProposedFeatures = {}));\n", "\"use strict\";\n/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ------------------------------------------------------------------------------------------ */\n/// <reference path=\"../../typings/thenable.d.ts\" />\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createConnection = exports.Files = void 0;\nconst node_util_1 = require(\"node:util\");\nconst Is = require(\"../common/utils/is\");\nconst server_1 = require(\"../common/server\");\nconst fm = require(\"./files\");\nconst node_1 = require(\"vscode-languageserver-protocol/node\");\n__exportStar(require(\"vscode-languageserver-protocol/node\"), exports);\n__exportStar(require(\"../common/api\"), exports);\nvar Files;\n(function (Files) {\n    Files.uriToFilePath = fm.uriToFilePath;\n    Files.resolveGlobalNodePath = fm.resolveGlobalNodePath;\n    Files.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;\n    Files.resolve = fm.resolve;\n    Files.resolveModulePath = fm.resolveModulePath;\n})(Files || (exports.Files = Files = {}));\nlet _protocolConnection;\nfunction endProtocolConnection() {\n    if (_protocolConnection === undefined) {\n        return;\n    }\n    try {\n        _protocolConnection.end();\n    }\n    catch (_err) {\n        // Ignore. The client process could have already\n        // did and we can't send an end into the connection.\n    }\n}\nlet _shutdownReceived = false;\nlet exitTimer = undefined;\nfunction setupExitTimer() {\n    const argName = '--clientProcessId';\n    function runTimer(value) {\n        try {\n            let processId = parseInt(value);\n            if (!isNaN(processId)) {\n                exitTimer = setInterval(() => {\n                    try {\n                        process.kill(processId, 0);\n                    }\n                    catch (ex) {\n                        // Parent process doesn't exist anymore. Exit the server.\n                        endProtocolConnection();\n                        process.exit(_shutdownReceived ? 0 : 1);\n                    }\n                }, 3000);\n            }\n        }\n        catch (e) {\n            // Ignore errors;\n        }\n    }\n    for (let i = 2; i < process.argv.length; i++) {\n        let arg = process.argv[i];\n        if (arg === argName && i + 1 < process.argv.length) {\n            runTimer(process.argv[i + 1]);\n            return;\n        }\n        else {\n            let args = arg.split('=');\n            if (args[0] === argName) {\n                runTimer(args[1]);\n            }\n        }\n    }\n}\nsetupExitTimer();\nconst watchDog = {\n    initialize: (params) => {\n        const processId = params.processId;\n        if (Is.number(processId) && exitTimer === undefined) {\n            // We received a parent process id. Set up a timer to periodically check\n            // if the parent is still alive.\n            setInterval(() => {\n                try {\n                    process.kill(processId, 0);\n                }\n                catch (ex) {\n                    // Parent process doesn't exist anymore. Exit the server.\n                    process.exit(_shutdownReceived ? 0 : 1);\n                }\n            }, 3000);\n        }\n    },\n    get shutdownReceived() {\n        return _shutdownReceived;\n    },\n    set shutdownReceived(value) {\n        _shutdownReceived = value;\n    },\n    exit: (code) => {\n        endProtocolConnection();\n        process.exit(code);\n    }\n};\nfunction createConnection(arg1, arg2, arg3, arg4) {\n    let factories;\n    let input;\n    let output;\n    let options;\n    if (arg1 !== void 0 && arg1.__brand === 'features') {\n        factories = arg1;\n        arg1 = arg2;\n        arg2 = arg3;\n        arg3 = arg4;\n    }\n    if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {\n        options = arg1;\n    }\n    else {\n        input = arg1;\n        output = arg2;\n        options = arg3;\n    }\n    return _createConnection(input, output, options, factories);\n}\nexports.createConnection = createConnection;\nfunction _createConnection(input, output, options, factories) {\n    let stdio = false;\n    if (!input && !output && process.argv.length > 2) {\n        let port = void 0;\n        let pipeName = void 0;\n        let argv = process.argv.slice(2);\n        for (let i = 0; i < argv.length; i++) {\n            let arg = argv[i];\n            if (arg === '--node-ipc') {\n                input = new node_1.IPCMessageReader(process);\n                output = new node_1.IPCMessageWriter(process);\n                break;\n            }\n            else if (arg === '--stdio') {\n                stdio = true;\n                input = process.stdin;\n                output = process.stdout;\n                break;\n            }\n            else if (arg === '--socket') {\n                port = parseInt(argv[i + 1]);\n                break;\n            }\n            else if (arg === '--pipe') {\n                pipeName = argv[i + 1];\n                break;\n            }\n            else {\n                var args = arg.split('=');\n                if (args[0] === '--socket') {\n                    port = parseInt(args[1]);\n                    break;\n                }\n                else if (args[0] === '--pipe') {\n                    pipeName = args[1];\n                    break;\n                }\n            }\n        }\n        if (port) {\n            let transport = (0, node_1.createServerSocketTransport)(port);\n            input = transport[0];\n            output = transport[1];\n        }\n        else if (pipeName) {\n            let transport = (0, node_1.createServerPipeTransport)(pipeName);\n            input = transport[0];\n            output = transport[1];\n        }\n    }\n    var commandLineMessage = 'Use arguments of createConnection or set command line parameters: \\'--node-ipc\\', \\'--stdio\\' or \\'--socket={number}\\'';\n    if (!input) {\n        throw new Error('Connection input stream is not set. ' + commandLineMessage);\n    }\n    if (!output) {\n        throw new Error('Connection output stream is not set. ' + commandLineMessage);\n    }\n    // Backwards compatibility\n    if (Is.func(input.read) && Is.func(input.on)) {\n        let inputStream = input;\n        inputStream.on('end', () => {\n            endProtocolConnection();\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n        inputStream.on('close', () => {\n            endProtocolConnection();\n            process.exit(_shutdownReceived ? 0 : 1);\n        });\n    }\n    const connectionFactory = (logger) => {\n        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);\n        if (stdio) {\n            patchConsole(logger);\n        }\n        return result;\n    };\n    return (0, server_1.createConnection)(connectionFactory, watchDog, factories);\n}\nfunction patchConsole(logger) {\n    function serialize(args) {\n        return args.map(arg => typeof arg === 'string' ? arg : (0, node_util_1.inspect)(arg)).join(' ');\n    }\n    const counters = new Map();\n    console.assert = function assert(assertion, ...args) {\n        if (assertion) {\n            return;\n        }\n        if (args.length === 0) {\n            logger.error('Assertion failed');\n        }\n        else {\n            const [message, ...rest] = args;\n            logger.error(`Assertion failed: ${message} ${serialize(rest)}`);\n        }\n    };\n    console.count = function count(label = 'default') {\n        const message = String(label);\n        let counter = counters.get(message) ?? 0;\n        counter += 1;\n        counters.set(message, counter);\n        logger.log(`${message}: ${message}`);\n    };\n    console.countReset = function countReset(label) {\n        if (label === undefined) {\n            counters.clear();\n        }\n        else {\n            counters.delete(String(label));\n        }\n    };\n    console.debug = function debug(...args) {\n        logger.log(serialize(args));\n    };\n    console.dir = function dir(arg, options) {\n        // @ts-expect-error https://github.com/DefinitelyTyped/DefinitelyTyped/pull/66626\n        logger.log((0, node_util_1.inspect)(arg, options));\n    };\n    console.log = function log(...args) {\n        logger.log(serialize(args));\n    };\n    console.error = function error(...args) {\n        logger.error(serialize(args));\n    };\n    console.trace = function trace(...args) {\n        const stack = new Error().stack.replace(/(.+\\n){2}/, '');\n        let message = 'Trace';\n        if (args.length !== 0) {\n            message += `: ${serialize(args)}`;\n        }\n        logger.log(`${message}\\n${stack}`);\n    };\n    console.warn = function warn(...args) {\n        logger.warn(serialize(args));\n    };\n}\n", "/* --------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for license information.\n * ----------------------------------------------------------------------------------------- */\n'use strict';\n\nmodule.exports = require('./lib/node/main');", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n******************************************************************************/\r\n\r\nimport type { Connection } from 'vscode-languageserver';\r\nimport type { Module } from './dependency-injection.js';\r\nimport type { LangiumDefaultServices, LangiumDefaultSharedServices, LangiumServices, LangiumSharedServices } from './services.js';\r\nimport type { FileSystemProvider } from './workspace/file-system-provider.js';\r\nimport { TextDocuments } from 'vscode-languageserver';\r\nimport { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport { createGrammarConfig } from './grammar/grammar-config.js';\r\nimport { createCompletionParser } from './parser/completion-parser-builder.js';\r\nimport { DefaultCompletionProvider } from './lsp/completion/completion-provider.js';\r\nimport { DefaultDocumentHighlightProvider } from './lsp/document-highlight-provider.js';\r\nimport { DefaultDocumentSymbolProvider } from './lsp/document-symbol-provider.js';\r\nimport { DefaultFoldingRangeProvider } from './lsp/folding-range-provider.js';\r\nimport { DefaultFuzzyMatcher } from './lsp/fuzzy-matcher.js';\r\nimport { DefaultDefinitionProvider } from './lsp/definition-provider.js';\r\nimport { MultilineCommentHoverProvider } from './lsp/hover-provider.js';\r\nimport { DefaultLanguageServer } from './lsp/language-server.js';\r\nimport { DefaultNodeKindProvider } from './lsp/node-kind-provider.js';\r\nimport { DefaultReferencesProvider } from './lsp/references-provider.js';\r\nimport { DefaultRenameProvider } from './lsp/rename-provider.js';\r\nimport { DefaultWorkspaceSymbolProvider } from './lsp/workspace-symbol-provider.js';\r\nimport { createLangiumParser } from './parser/langium-parser-builder.js';\r\nimport { DefaultTokenBuilder } from './parser/token-builder.js';\r\nimport { DefaultValueConverter } from './parser/value-converter.js';\r\nimport { DefaultLinker } from './references/linker.js';\r\nimport { DefaultNameProvider } from './references/name-provider.js';\r\nimport { DefaultReferences } from './references/references.js';\r\nimport { DefaultScopeComputation } from './references/scope-computation.js';\r\nimport { DefaultScopeProvider } from './references/scope-provider.js';\r\nimport { DefaultJsonSerializer } from './serializer/json-serializer.js';\r\nimport { DefaultServiceRegistry } from './service-registry.js';\r\nimport { MutexLock } from './utils/promise-util.js';\r\nimport { DefaultDocumentValidator } from './validation/document-validator.js';\r\nimport { ValidationRegistry } from './validation/validation-registry.js';\r\nimport { DefaultAstNodeDescriptionProvider, DefaultReferenceDescriptionProvider } from './workspace/ast-descriptions.js';\r\nimport { DefaultAstNodeLocator } from './workspace/ast-node-locator.js';\r\nimport { DefaultConfigurationProvider } from './workspace/configuration.js';\r\nimport { DefaultDocumentBuilder } from './workspace/document-builder.js';\r\nimport { DefaultLangiumDocumentFactory, DefaultLangiumDocuments } from './workspace/documents.js';\r\nimport { DefaultIndexManager } from './workspace/index-manager.js';\r\nimport { DefaultWorkspaceManager } from './workspace/workspace-manager.js';\r\nimport { DefaultLexer } from './parser/lexer.js';\r\nimport { JSDocDocumentationProvider } from './documentation/documentation-provider.js';\r\nimport { DefaultCommentProvider } from './documentation/comment-provider.js';\r\nimport { LangiumParserErrorMessageProvider } from './parser/langium-parser.js';\r\n\r\n/**\r\n * Context required for creating the default language-specific dependency injection module.\r\n */\r\nexport interface DefaultModuleContext {\r\n    shared: LangiumSharedServices;\r\n}\r\n\r\n/**\r\n * Create a dependency injection module for the default language-specific services. This is a\r\n * set of services that are used by exactly one language.\r\n */\r\nexport function createDefaultModule(context: DefaultModuleContext): Module<LangiumServices, LangiumDefaultServices> {\r\n    return {\r\n        documentation: {\r\n            CommentProvider: (services) => new DefaultCommentProvider(services),\r\n            DocumentationProvider: (services) => new JSDocDocumentationProvider(services)\r\n        },\r\n        parser: {\r\n            GrammarConfig: (services) => createGrammarConfig(services),\r\n            LangiumParser: (services) => createLangiumParser(services),\r\n            CompletionParser: (services) => createCompletionParser(services),\r\n            ValueConverter: () => new DefaultValueConverter(),\r\n            TokenBuilder: () => new DefaultTokenBuilder(),\r\n            Lexer: (services) => new DefaultLexer(services),\r\n            ParserErrorMessageProvider: () => new LangiumParserErrorMessageProvider()\r\n        },\r\n        lsp: {\r\n            CompletionProvider: (services) => new DefaultCompletionProvider(services),\r\n            DocumentSymbolProvider: (services) => new DefaultDocumentSymbolProvider(services),\r\n            HoverProvider: (services) => new MultilineCommentHoverProvider(services),\r\n            FoldingRangeProvider: (services) => new DefaultFoldingRangeProvider(services),\r\n            ReferencesProvider: (services) => new DefaultReferencesProvider(services),\r\n            DefinitionProvider: (services) => new DefaultDefinitionProvider(services),\r\n            DocumentHighlightProvider: (services) => new DefaultDocumentHighlightProvider(services),\r\n            RenameProvider: (services) => new DefaultRenameProvider(services)\r\n        },\r\n        workspace: {\r\n            AstNodeLocator: () => new DefaultAstNodeLocator(),\r\n            AstNodeDescriptionProvider: (services) => new DefaultAstNodeDescriptionProvider(services),\r\n            ReferenceDescriptionProvider: (services) => new DefaultReferenceDescriptionProvider(services)\r\n        },\r\n        references: {\r\n            Linker: (services) => new DefaultLinker(services),\r\n            NameProvider: () => new DefaultNameProvider(),\r\n            ScopeProvider: (services) => new DefaultScopeProvider(services),\r\n            ScopeComputation: (services) => new DefaultScopeComputation(services),\r\n            References: (services) => new DefaultReferences(services)\r\n        },\r\n        serializer: {\r\n            JsonSerializer: (services) => new DefaultJsonSerializer(services)\r\n        },\r\n        validation: {\r\n            DocumentValidator: (services) => new DefaultDocumentValidator(services),\r\n            ValidationRegistry: (services) => new ValidationRegistry(services)\r\n        },\r\n        shared: () => context.shared\r\n    };\r\n}\r\n\r\n/**\r\n * Context required for creating the default shared dependency injection module.\r\n */\r\nexport interface DefaultSharedModuleContext {\r\n    /**\r\n     * Represents an abstract language server connection\r\n     */\r\n    connection?: Connection;\r\n    /**\r\n     * Factory function to create a {@link FileSystemProvider}.\r\n     *\r\n     * Langium exposes an `EmptyFileSystem` and `NodeFileSystem`, exported through `langium/node`.\r\n     * When running Langium as part of a vscode language server or a Node.js app, using the `NodeFileSystem` is recommended,\r\n     * the `EmptyFileSystem` in every other use case.\r\n     */\r\n    fileSystemProvider: (services: LangiumSharedServices) => FileSystemProvider;\r\n}\r\n\r\n/**\r\n * Create a dependency injection module for the default shared services. This is the set of\r\n * services that are shared between multiple languages.\r\n */\r\nexport function createDefaultSharedModule(context: DefaultSharedModuleContext): Module<LangiumSharedServices, LangiumDefaultSharedServices> {\r\n    return {\r\n        ServiceRegistry: () => new DefaultServiceRegistry(),\r\n        lsp: {\r\n            Connection: () => context.connection,\r\n            LanguageServer: (services) => new DefaultLanguageServer(services),\r\n            WorkspaceSymbolProvider: (services) => new DefaultWorkspaceSymbolProvider(services),\r\n            NodeKindProvider: () => new DefaultNodeKindProvider(),\r\n            FuzzyMatcher: () => new DefaultFuzzyMatcher()\r\n        },\r\n        workspace: {\r\n            LangiumDocuments: (services) => new DefaultLangiumDocuments(services),\r\n            LangiumDocumentFactory: (services) => new DefaultLangiumDocumentFactory(services),\r\n            DocumentBuilder: (services) => new DefaultDocumentBuilder(services),\r\n            TextDocuments: () => new TextDocuments(TextDocument),\r\n            IndexManager: (services) => new DefaultIndexManager(services),\r\n            WorkspaceManager: (services) => new DefaultWorkspaceManager(services),\r\n            FileSystemProvider: (services) => context.fileSystemProvider(services),\r\n            MutexLock: () => new MutexLock(),\r\n            ConfigurationProvider: (services) => new DefaultConfigurationProvider(services)\r\n        }\r\n    };\r\n}\r\n", "/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nclass FullTextDocument {\r\n    constructor(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    get uri() {\r\n        return this._uri;\r\n    }\r\n    get languageId() {\r\n        return this._languageId;\r\n    }\r\n    get version() {\r\n        return this._version;\r\n    }\r\n    getText(range) {\r\n        if (range) {\r\n            const start = this.offsetAt(range.start);\r\n            const end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    }\r\n    update(changes, version) {\r\n        for (let change of changes) {\r\n            if (FullTextDocument.isIncremental(change)) {\r\n                // makes sure start is before end\r\n                const range = getWellformedRange(change.range);\r\n                // update content\r\n                const startOffset = this.offsetAt(range.start);\r\n                const endOffset = this.offsetAt(range.end);\r\n                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);\r\n                // update the offsets\r\n                const startLine = Math.max(range.start.line, 0);\r\n                const endLine = Math.max(range.end.line, 0);\r\n                let lineOffsets = this._lineOffsets;\r\n                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);\r\n                if (endLine - startLine === addedLineOffsets.length) {\r\n                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];\r\n                    }\r\n                }\r\n                else {\r\n                    if (addedLineOffsets.length < 10000) {\r\n                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);\r\n                    }\r\n                    else { // avoid too many arguments for splice\r\n                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));\r\n                    }\r\n                }\r\n                const diff = change.text.length - (endOffset - startOffset);\r\n                if (diff !== 0) {\r\n                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {\r\n                        lineOffsets[i] = lineOffsets[i] + diff;\r\n                    }\r\n                }\r\n            }\r\n            else if (FullTextDocument.isFull(change)) {\r\n                this._content = change.text;\r\n                this._lineOffsets = undefined;\r\n            }\r\n            else {\r\n                throw new Error('Unknown change event received');\r\n            }\r\n        }\r\n        this._version = version;\r\n    }\r\n    getLineOffsets() {\r\n        if (this._lineOffsets === undefined) {\r\n            this._lineOffsets = computeLineOffsets(this._content, true);\r\n        }\r\n        return this._lineOffsets;\r\n    }\r\n    positionAt(offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        let lineOffsets = this.getLineOffsets();\r\n        let low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return { line: 0, character: offset };\r\n        }\r\n        while (low < high) {\r\n            let mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        let line = low - 1;\r\n        return { line, character: offset - lineOffsets[line] };\r\n    }\r\n    offsetAt(position) {\r\n        let lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        let lineOffset = lineOffsets[position.line];\r\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    }\r\n    get lineCount() {\r\n        return this.getLineOffsets().length;\r\n    }\r\n    static isIncremental(event) {\r\n        let candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range !== undefined &&\r\n            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');\r\n    }\r\n    static isFull(event) {\r\n        let candidate = event;\r\n        return candidate !== undefined && candidate !== null &&\r\n            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;\r\n    }\r\n}\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new text document.\r\n     *\r\n     * @param uri The document's uri.\r\n     * @param languageId  The document's language Id.\r\n     * @param version The document's initial version number.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Updates a TextDocument by modifying its content.\r\n     *\r\n     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.\r\n     * @param changes the changes to apply to the document.\r\n     * @param version the changes version for the document.\r\n     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.\r\n     *\r\n     */\r\n    function update(document, changes, version) {\r\n        if (document instanceof FullTextDocument) {\r\n            document.update(changes, version);\r\n            return document;\r\n        }\r\n        else {\r\n            throw new Error('TextDocument.update: document must be created by TextDocument.create');\r\n        }\r\n    }\r\n    TextDocument.update = update;\r\n    function applyEdits(document, edits) {\r\n        let text = document.getText();\r\n        let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {\r\n            let diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        let lastModifiedOffset = 0;\r\n        const spans = [];\r\n        for (const e of sortedEdits) {\r\n            let startOffset = document.offsetAt(e.range.start);\r\n            if (startOffset < lastModifiedOffset) {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            else if (startOffset > lastModifiedOffset) {\r\n                spans.push(text.substring(lastModifiedOffset, startOffset));\r\n            }\r\n            if (e.newText.length) {\r\n                spans.push(e.newText);\r\n            }\r\n            lastModifiedOffset = document.offsetAt(e.range.end);\r\n        }\r\n        spans.push(text.substr(lastModifiedOffset));\r\n        return spans.join('');\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n})(TextDocument || (TextDocument = {}));\r\nfunction mergeSort(data, compare) {\r\n    if (data.length <= 1) {\r\n        // sorted\r\n        return data;\r\n    }\r\n    const p = (data.length / 2) | 0;\r\n    const left = data.slice(0, p);\r\n    const right = data.slice(p);\r\n    mergeSort(left, compare);\r\n    mergeSort(right, compare);\r\n    let leftIdx = 0;\r\n    let rightIdx = 0;\r\n    let i = 0;\r\n    while (leftIdx < left.length && rightIdx < right.length) {\r\n        let ret = compare(left[leftIdx], right[rightIdx]);\r\n        if (ret <= 0) {\r\n            // smaller_equal -> take left to preserve order\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        else {\r\n            // greater -> take right\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n    }\r\n    while (leftIdx < left.length) {\r\n        data[i++] = left[leftIdx++];\r\n    }\r\n    while (rightIdx < right.length) {\r\n        data[i++] = right[rightIdx++];\r\n    }\r\n    return data;\r\n}\r\nfunction computeLineOffsets(text, isAtLineStart, textOffset = 0) {\r\n    const result = isAtLineStart ? [textOffset] : [];\r\n    for (let i = 0; i < text.length; i++) {\r\n        let ch = text.charCodeAt(i);\r\n        if (ch === 13 /* CharCode.CarriageReturn */ || ch === 10 /* CharCode.LineFeed */) {\r\n            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\r\n                i++;\r\n            }\r\n            result.push(textOffset + i + 1);\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction getWellformedRange(range) {\r\n    const start = range.start;\r\n    const end = range.end;\r\n    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {\r\n        return { start: end, end: start };\r\n    }\r\n    return range;\r\n}\r\nfunction getWellformedEdit(textEdit) {\r\n    const range = getWellformedRange(textEdit.range);\r\n    if (range !== textEdit.range) {\r\n        return { newText: textEdit.newText, range };\r\n    }\r\n    return textEdit;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { TokenType } from 'chevrotain';\r\nimport type { URI } from './utils/uri-util.js';\r\nimport type { AbstractElement } from './grammar/generated/ast.js';\r\nimport type { DocumentSegment, LangiumDocument } from './workspace/documents.js';\r\n\r\n/**\r\n * A node in the Abstract Syntax Tree (AST).\r\n */\r\nexport interface AstNode {\r\n    /** Every AST node has a type corresponding to what was specified in the grammar declaration. */\r\n    readonly $type: string;\r\n    /** The container node in the AST; every node except the root node has a container. */\r\n    readonly $container?: AstNode;\r\n    /** The property of the `$container` node that contains this node. This is either a direct reference or an array. */\r\n    readonly $containerProperty?: string;\r\n    /** In case `$containerProperty` is an array, the array index is stored here. */\r\n    readonly $containerIndex?: number;\r\n    /** The Concrete Syntax Tree (CST) node of the text range from which this node was parsed. */\r\n    readonly $cstNode?: CstNode;\r\n    /** The document containing the AST; only the root node has a direct reference to the document. */\r\n    readonly $document?: LangiumDocument;\r\n}\r\n\r\nexport function isAstNode(obj: unknown): obj is AstNode {\r\n    return typeof obj === 'object' && obj !== null && typeof (obj as AstNode).$type === 'string';\r\n}\r\n\r\nexport interface GenericAstNode extends AstNode {\r\n    [key: string]: unknown\r\n}\r\n\r\ntype SpecificNodeProperties<N extends AstNode> = keyof Omit<N, keyof AstNode | number | symbol>;\r\n\r\n/**\r\n * The property names of a given AST node type.\r\n */\r\nexport type Properties<N extends AstNode> = SpecificNodeProperties<N> extends never ? string : SpecificNodeProperties<N>\r\n\r\n/**\r\n * A cross-reference in the AST. Cross-references may or may not be successfully resolved.\r\n */\r\nexport interface Reference<T extends AstNode = AstNode> {\r\n    /**\r\n     * The target AST node of this reference. Accessing this property may trigger cross-reference\r\n     * resolution by the `Linker` in case it has not been done yet. If the reference cannot be resolved,\r\n     * the value is `undefined`.\r\n     */\r\n    readonly ref?: T;\r\n\r\n    /** If any problem occurred while resolving the reference, it is described by this property. */\r\n    readonly error?: LinkingError;\r\n    /** The CST node from which the reference was parsed */\r\n    readonly $refNode?: CstNode;\r\n    /** The actual text used to look up in the surrounding scope */\r\n    readonly $refText: string;\r\n    /** The node description for the AstNode returned by `ref`  */\r\n    readonly $nodeDescription?: AstNodeDescription;\r\n}\r\n\r\nexport function isReference(obj: unknown): obj is Reference {\r\n    return typeof obj === 'object' && obj !== null && typeof (obj as Reference).$refText === 'string';\r\n}\r\n\r\n/**\r\n * A description of an AST node is used when constructing scopes and looking up cross-reference targets.\r\n */\r\nexport interface AstNodeDescription {\r\n    /** The target node; should be present only for local references (linking to the same document). */\r\n    node?: AstNode;\r\n    /**\r\n     * The document segment that represents the range of the name of the AST node.\r\n     */\r\n    nameSegment?: DocumentSegment;\r\n    /**\r\n     * The document segment that represents the full range of the AST node.\r\n     */\r\n    selectionSegment?: DocumentSegment;\r\n    /** `$type` property value of the AST node */\r\n    type: string;\r\n    /** Name of the AST node; this is usually determined by the `NameProvider` service. */\r\n    name: string;\r\n    /** URI to the document containing the AST node */\r\n    documentUri: URI;\r\n    /** Navigation path inside the document */\r\n    path: string;\r\n}\r\n\r\nexport function isAstNodeDescription(obj: unknown): obj is AstNodeDescription {\r\n    return typeof obj === 'object' && obj !== null\r\n        && typeof (obj as AstNodeDescription).name === 'string'\r\n        && typeof (obj as AstNodeDescription).type === 'string'\r\n        && typeof (obj as AstNodeDescription).path === 'string';\r\n}\r\n\r\n/**\r\n * Information about a cross-reference. This is used when traversing references in an AST or to describe\r\n * unresolved references.\r\n */\r\nexport interface ReferenceInfo {\r\n    reference: Reference\r\n    container: AstNode\r\n    property: string\r\n    index?: number\r\n}\r\n\r\n/**\r\n * Used to collect information when the `Linker` service fails to resolve a cross-reference.\r\n */\r\nexport interface LinkingError extends ReferenceInfo {\r\n    message: string;\r\n    targetDescription?: AstNodeDescription;\r\n}\r\n\r\nexport function isLinkingError(obj: unknown): obj is LinkingError {\r\n    return typeof obj === 'object' && obj !== null\r\n        && isAstNode((obj as LinkingError).container)\r\n        && isReference((obj as LinkingError).reference)\r\n        && typeof (obj as LinkingError).message === 'string';\r\n}\r\n\r\n/**\r\n * Service used for generic access to the structure of the AST. This service is shared between\r\n * all involved languages, so it operates on the superset of types of these languages.\r\n */\r\nexport interface AstReflection {\r\n    getAllTypes(): string[]\r\n    getAllSubTypes(type: string): string[]\r\n    getReferenceType(refInfo: ReferenceInfo): string\r\n    getTypeMetaData(type: string): TypeMetaData\r\n    isInstance(node: unknown, type: string): boolean\r\n    isSubtype(subtype: string, supertype: string): boolean\r\n}\r\n\r\n/**\r\n * An abstract implementation of the {@link AstReflection} interface.\r\n * Serves to cache subtype computation results to improve performance throughout different parts of Langium.\r\n */\r\nexport abstract class AbstractAstReflection implements AstReflection {\r\n\r\n    protected subtypes: Record<string, Record<string, boolean | undefined>> = {};\r\n    protected allSubtypes: Record<string, string[] | undefined> = {};\r\n\r\n    abstract getAllTypes(): string[];\r\n    abstract getReferenceType(refInfo: ReferenceInfo): string;\r\n    abstract getTypeMetaData(type: string): TypeMetaData;\r\n    protected abstract computeIsSubtype(subtype: string, supertype: string): boolean;\r\n\r\n    isInstance(node: unknown, type: string): boolean {\r\n        return isAstNode(node) && this.isSubtype(node.$type, type);\r\n    }\r\n\r\n    isSubtype(subtype: string, supertype: string): boolean {\r\n        if (subtype === supertype) {\r\n            return true;\r\n        }\r\n        let nested = this.subtypes[subtype];\r\n        if (!nested) {\r\n            nested = this.subtypes[subtype] = {};\r\n        }\r\n        const existing = nested[supertype];\r\n        if (existing !== undefined) {\r\n            return existing;\r\n        } else {\r\n            const result = this.computeIsSubtype(subtype, supertype);\r\n            nested[supertype] = result;\r\n            return result;\r\n        }\r\n    }\r\n\r\n    getAllSubTypes(type: string): string[] {\r\n        const existing = this.allSubtypes[type];\r\n        if (existing) {\r\n            return existing;\r\n        } else {\r\n            const allTypes = this.getAllTypes();\r\n            const types: string[] = [];\r\n            for (const possibleSubType of allTypes) {\r\n                if (this.isSubtype(possibleSubType, type)) {\r\n                    types.push(possibleSubType);\r\n                }\r\n            }\r\n            this.allSubtypes[type] = types;\r\n            return types;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Represents runtime meta data about a meta model type.\r\n */\r\nexport interface TypeMetaData {\r\n    /** The name of this meta model type. Corresponds to the `AstNode.$type` value. */\r\n    name: string\r\n    /** A list of mandatory properties. These are defaults for array and boolean based properties (`[]` and `false` respectively). */\r\n    mandatory: TypeMandatoryProperty[]\r\n}\r\n\r\n/**\r\n * Mandatory properties are implicitly expected to be set in an AST node.\r\n * For example, if an AST node contains an array, but no elements of this array have been parsed, we still expect an empty array instead of `undefined`.\r\n */\r\nexport interface TypeMandatoryProperty {\r\n    name: string\r\n    type: 'array' | 'boolean'\r\n}\r\n\r\n/**\r\n * A node in the Concrete Syntax Tree (CST).\r\n */\r\nexport interface CstNode extends DocumentSegment {\r\n    /** The container node in the CST */\r\n    readonly container?: CompositeCstNode;\r\n    /** @deprecated use `container` instead. */\r\n    readonly parent?: CompositeCstNode;\r\n    /** The actual text */\r\n    readonly text: string;\r\n    /** The root CST node */\r\n    readonly root: RootCstNode;\r\n    /** The grammar element from which this node was parsed */\r\n    readonly grammarSource: AbstractElement;\r\n    /** @deprecated use `grammarSource` instead. */\r\n    readonly feature: AbstractElement;\r\n    /** The AST node created from this CST node */\r\n    readonly astNode: AstNode;\r\n    /** @deprecated use `astNode` instead. */\r\n    readonly element: AstNode;\r\n    /** Whether the token is hidden, i.e. not explicitly part of the containing grammar rule */\r\n    readonly hidden: boolean;\r\n}\r\n\r\n/**\r\n * A composite CST node contains other nodes, but no directly associated token.\r\n */\r\nexport interface CompositeCstNode extends CstNode {\r\n    readonly content: CstNode[];\r\n    /** @deprecated use `content` instead. */\r\n    readonly children: CstNode[];\r\n}\r\n\r\nexport function isCompositeCstNode(node: unknown): node is CompositeCstNode {\r\n    return typeof node === 'object' && node !== null && Array.isArray((node as CompositeCstNode).content);\r\n}\r\n\r\n/**\r\n * A leaf CST node corresponds to a token in the input token stream.\r\n */\r\nexport interface LeafCstNode extends CstNode {\r\n    readonly tokenType: TokenType;\r\n}\r\n\r\nexport function isLeafCstNode(node: unknown): node is LeafCstNode {\r\n    return typeof node === 'object' && node !== null && typeof (node as LeafCstNode).tokenType === 'object';\r\n}\r\n\r\nexport interface RootCstNode extends CompositeCstNode {\r\n    readonly fullText: string\r\n}\r\n\r\nexport function isRootCstNode(node: unknown): node is RootCstNode {\r\n    return isCompositeCstNode(node) && typeof (node as RootCstNode).fullText === 'string';\r\n}\r\n\r\n/**\r\n * Returns a type to have only properties names (!) of a type T whose property value is of a certain type K.\r\n */\r\ntype ExtractKeysOfValueType<T, K> = { [I in keyof T]: T[I] extends K ? I : never }[keyof T];\r\n\r\n/**\r\n * Returns the property names (!) of an AstNode that are cross-references.\r\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.property)`.\r\n */\r\nexport type CrossReferencesOfAstNodeType<N extends AstNode> = (\r\n    ExtractKeysOfValueType<N, Reference|undefined>\r\n    | ExtractKeysOfValueType<N, Array<Reference|undefined>|undefined>\r\n// eslint-disable-next-line @typescript-eslint/ban-types\r\n) & {};\r\n\r\n/**\r\n * Represents the enumeration-like type, that lists all AstNode types of your grammar.\r\n */\r\nexport type AstTypeList<T> = Record<keyof T, AstNode>;\r\n\r\n/**\r\n * Returns all types that contain cross-references, A is meant to be the interface `XXXAstType` fromm your generated `ast.ts` file.\r\n * Meant to be used during cross-reference resolution in combination with `assertUnreachable(context.container)`.\r\n */\r\nexport type AstNodeTypesWithCrossReferences<A extends AstTypeList<A>> = {\r\n    [T in keyof A]: CrossReferencesOfAstNodeType<A[T]> extends never ? never : A[T]\r\n}[keyof A];\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/**\r\n * A stream is a read-only sequence of values. While the contents of an array can be accessed\r\n * both sequentially and randomly (via index), a stream allows only sequential access.\r\n *\r\n * The advantage of this is that a stream can be evaluated lazily, so it does not require\r\n * to store intermediate values. This can boost performance when a large sequence is\r\n * processed via filtering, mapping etc. and accessed at most once. However, lazy\r\n * evaluation means that all processing is repeated when you access the sequence multiple\r\n * times; in such a case, it may be better to store the resulting sequence into an array.\r\n */\r\nexport interface Stream<T> extends Iterable<T> {\r\n\r\n    /**\r\n     * Returns an iterator for this stream. This is the same as calling the `Symbol.iterator` function property.\r\n     */\r\n    iterator(): IterableIterator<T>;\r\n\r\n    /**\r\n     * Determines whether this stream contains no elements.\r\n     */\r\n    isEmpty(): boolean;\r\n\r\n    /**\r\n     * Determines the number of elements in this stream.\r\n     */\r\n    count(): number;\r\n\r\n    /**\r\n     * Collects all elements of this stream into an array.\r\n     */\r\n    toArray(): T[];\r\n\r\n    /**\r\n     * Collects all elements of this stream into a Set.\r\n     */\r\n    toSet(): Set<T>;\r\n\r\n    /**\r\n     * Collects all elements of this stream into a Map, applying the provided functions to determine keys and values.\r\n     *\r\n     * @param keyFn The function to derive map keys. If omitted, the stream elements are used as keys.\r\n     * @param valueFn The function to derive map values. If omitted, the stream elements are used as values.\r\n     */\r\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V>;\r\n\r\n    /**\r\n     * Returns a string representation of a stream.\r\n     */\r\n    toString(): string;\r\n\r\n    /**\r\n     * Combines two streams by returning a new stream that yields all elements of this stream and the other stream.\r\n     *\r\n     * @param other Stream to be concatenated with this one.\r\n     */\r\n    concat<T2>(other: Iterable<T2>): Stream<T | T2>;\r\n\r\n    /**\r\n     * Adds all elements of the stream into a string, separated by the specified separator string.\r\n     *\r\n     * @param separator A string used to separate one element of the stream from the next in the resulting string.\r\n     *        If omitted, the steam elements are separated with a comma.\r\n     */\r\n    join(separator?: string): string\r\n\r\n    /**\r\n     * Returns the index of the first occurrence of a value in the stream, or -1 if it is not present.\r\n     *\r\n     * @param searchElement The value to locate in the array.\r\n     * @param fromIndex The stream index at which to begin the search. If fromIndex is omitted, the search\r\n     *        starts at index 0.\r\n     */\r\n    indexOf(searchElement: T, fromIndex?: number): number;\r\n\r\n    /**\r\n     * Determines whether all members of the stream satisfy the specified test.\r\n     *\r\n     * @param predicate This method calls the predicate function for each element in the stream until the\r\n     *        predicate returns a value which is coercible to the Boolean value `false`, or until the end\r\n     *        of the stream.\r\n     */\r\n    every<S extends T>(predicate: (value: T) => value is S): this is Stream<S>;\r\n    every(predicate: (value: T) => unknown): boolean;\r\n\r\n    /**\r\n     * Determines whether any member of the stream satisfies the specified test.\r\n     *\r\n     * @param predicate This method calls the predicate function for each element in the stream until the\r\n     *        predicate returns a value which is coercible to the Boolean value `true`, or until the end\r\n     *        of the stream.\r\n     */\r\n    some(predicate: (value: T) => unknown): boolean;\r\n\r\n    /**\r\n     * Performs the specified action for each element in the stream.\r\n     *\r\n     * @param callbackfn Function called once for each element in the stream.\r\n     */\r\n    forEach(callbackfn: (value: T, index: number) => void): void;\r\n\r\n    /**\r\n     * Returns a stream that yields the results of calling the specified callback function on each element\r\n     * of the stream. The function is called when the resulting stream elements are actually accessed, so\r\n     * accessing the resulting stream multiple times means the function is also called multiple times for\r\n     * each element of the stream.\r\n     *\r\n     * @param callbackfn Lazily evaluated function mapping stream elements.\r\n     */\r\n    map<U>(callbackfn: (value: T) => U): Stream<U>;\r\n\r\n    /**\r\n     * Returns the elements of the stream that meet the condition specified in a callback function.\r\n     * The function is called when the resulting stream elements are actually accessed, so accessing the\r\n     * resulting stream multiple times means the function is also called multiple times for each element\r\n     * of the stream.\r\n     *\r\n     * @param predicate Lazily evaluated function checking a condition on stream elements.\r\n     */\r\n    filter<S extends T>(predicate: (value: T) => value is S): Stream<S>;\r\n    filter(predicate: (value: T) => unknown): Stream<T>;\r\n\r\n    /**\r\n     * Returns the elements of the stream that are _non-nullable_, which means they are neither `undefined`\r\n     * nor `null`.\r\n     */\r\n    nonNullable(): Stream<NonNullable<T>>;\r\n\r\n    /**\r\n     * Calls the specified callback function for all elements in the stream. The return value of the\r\n     * callback function is the accumulated result, and is provided as an argument in the next call to\r\n     * the callback function.\r\n     *\r\n     * @param callbackfn This method calls the function once for each element in the stream, providing\r\n     *        the previous and current values of the reduction.\r\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\r\n     *        accumulation. The first call to the function provides this value as an argument instead\r\n     *        of a stream value.\r\n     */\r\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Calls the specified callback function for all elements in the stream, in descending order.\r\n     * The return value of the callback function is the accumulated result, and is provided as an\r\n     * argument in the next call to the callback function.\r\n     *\r\n     * @param callbackfn This method calls the function once for each element in the stream, providing\r\n     *        the previous and current values of the reduction.\r\n     * @param initialValue If specified, `initialValue` is used as the initial value to start the\r\n     *        accumulation. The first call to the function provides this value as an argument instead\r\n     *        of an array value.\r\n     */\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n\r\n    /**\r\n     * Returns the value of the first element in the stream that meets the condition, or `undefined`\r\n     * if there is no such element.\r\n     *\r\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\r\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\r\n     *        Boolean value `true`.\r\n     */\r\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\r\n    find(predicate: (value: T) => unknown): T | undefined;\r\n\r\n    /**\r\n     * Returns the index of the first element in the stream that meets the condition, or `-1`\r\n     * if there is no such element.\r\n     *\r\n     * @param predicate This method calls `predicate` once for each element of the stream, in ascending\r\n     *        order, until it finds one where `predicate` returns a value which is coercible to the\r\n     *        Boolean value `true`.\r\n     */\r\n    findIndex(predicate: (value: T) => unknown): number;\r\n\r\n    /**\r\n     * Determines whether the stream includes a certain element, returning `true` or `false` as appropriate.\r\n     *\r\n     * @param searchElement The element to search for.\r\n     */\r\n    includes(searchElement: T): boolean;\r\n\r\n    /**\r\n     * Calls a defined callback function on each element of the stream and then flattens the result into\r\n     * a new stream. This is identical to a `map` followed by `flat` with depth 1.\r\n     *\r\n     * @param callbackfn Lazily evaluated function mapping stream elements.\r\n     */\r\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U>;\r\n\r\n    /**\r\n     * Returns a new stream with all sub-stream or sub-array elements concatenated into it recursively up\r\n     * to the specified depth.\r\n     *\r\n     * @param depth The maximum recursion depth. Defaults to 1.\r\n     */\r\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D>;\r\n\r\n    /**\r\n     * Returns the first element in the stream, or `undefined` if the stream is empty.\r\n     */\r\n    head(): T | undefined;\r\n\r\n    /**\r\n     * Returns a stream that skips the first `skipCount` elements from this stream.\r\n     *\r\n     * @param skipCount The number of elements to skip. If this is larger than the number of elements in\r\n     *        the stream, an empty stream is returned. Defaults to 1.\r\n     */\r\n    tail(skipCount?: number): Stream<T>;\r\n\r\n    /**\r\n     * Returns a stream consisting of the elements of this stream, truncated to be no longer than `maxSize`\r\n     * in length.\r\n     *\r\n     * @param maxSize The number of elements the stream should be limited to\r\n     */\r\n    limit(maxSize: number): Stream<T>;\r\n\r\n    /**\r\n     * Returns a stream containing only the distinct elements from this stream.\r\n     * Equality is determined with the same rules as a standard `Set`.\r\n     *\r\n     * @param by A function returning the key used to check equality with a previous stream element.\r\n     *        If omitted, the stream elements themselves are used for comparison.\r\n     */\r\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T>;\r\n\r\n    /**\r\n     * Returns a stream that contains all elements that don't exist in the {@link other} iterable.\r\n     * Equality is determined with the same rules as a standard `Set`.\r\n     * @param other The elements that should be exluded from this stream.\r\n     * @param key A function returning the key used to check quality.\r\n     *        If omitted, the stream elements themselves are used for comparison.\r\n     */\r\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T>;\r\n\r\n}\r\n\r\nexport type FlatStream<T, Depth extends number> = {\r\n    'done': Stream<T>,\r\n    'recur': T extends Iterable<infer Content>\r\n        ? FlatStream<Content, MinusOne<Depth>>\r\n        : Stream<T>\r\n}[Depth extends 0 ? 'done' : 'recur'];\r\n\r\nexport type MinusOne<N extends number> = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20][N];\r\n\r\n/**\r\n * The default implementation of `Stream` works with two input functions:\r\n *  - The first function creates the initial state of an iteration.\r\n *  - The second function gets the current state as argument and returns an `IteratorResult`.\r\n */\r\nexport class StreamImpl<S, T> implements Stream<T> {\r\n    protected readonly startFn: () => S;\r\n    protected readonly nextFn: (state: S) => IteratorResult<T>;\r\n\r\n    constructor(startFn: () => S, nextFn: (state: S) => IteratorResult<T, undefined>) {\r\n        this.startFn = startFn;\r\n        this.nextFn = nextFn;\r\n    }\r\n\r\n    iterator(): IterableIterator<T> {\r\n        const iterator = {\r\n            state: this.startFn(),\r\n            next: () => this.nextFn(iterator.state),\r\n            [Symbol.iterator]: () => iterator\r\n        };\r\n        return iterator;\r\n    }\r\n\r\n    [Symbol.iterator](): Iterator<T> {\r\n        return this.iterator();\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        const iterator = this.iterator();\r\n        return Boolean(iterator.next().done);\r\n    }\r\n\r\n    count(): number {\r\n        const iterator = this.iterator();\r\n        let count = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            count++;\r\n            next = iterator.next();\r\n        }\r\n        return count;\r\n    }\r\n\r\n    toArray(): T[] {\r\n        const result: T[] = [];\r\n        const iterator = this.iterator();\r\n        let next: IteratorResult<T>;\r\n        do {\r\n            next = iterator.next();\r\n            if (next.value !== undefined) {\r\n                result.push(next.value);\r\n            }\r\n        } while (!next.done);\r\n        return result;\r\n    }\r\n\r\n    toSet(): Set<T> {\r\n        return new Set(this);\r\n    }\r\n\r\n    toMap<K = T, V = T>(keyFn?: (e: T) => K, valueFn?: (e: T) => V): Map<K, V> {\r\n        const entryStream = this.map(element => <[K, V]>[\r\n            keyFn ? keyFn(element) : element,\r\n            valueFn ? valueFn(element) : element\r\n        ]);\r\n        return new Map(entryStream);\r\n    }\r\n\r\n    toString(): string {\r\n        return this.join();\r\n    }\r\n\r\n    concat<T2>(other: Iterable<T2>): Stream<T | T2> {\r\n        const iterator = other[Symbol.iterator]();\r\n        return new StreamImpl<{ first: S, firstDone: boolean }, T | T2>(\r\n            () => ({ first: this.startFn(), firstDone: false }),\r\n            state => {\r\n                let result: IteratorResult<T | T2>;\r\n                if (!state.firstDone) {\r\n                    do {\r\n                        result = this.nextFn(state.first);\r\n                        if (!result.done) {\r\n                            return result;\r\n                        }\r\n                    } while (!result.done);\r\n                    state.firstDone = true;\r\n                }\r\n                do {\r\n                    result = iterator.next();\r\n                    if (!result.done) {\r\n                        return result;\r\n                    }\r\n                } while (!result.done);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    join(separator = ','): string {\r\n        const iterator = this.iterator();\r\n        let value = '';\r\n        let result: IteratorResult<T>;\r\n        let addSeparator = false;\r\n        do {\r\n            result = iterator.next();\r\n            if (!result.done) {\r\n                if (addSeparator) {\r\n                    value += separator;\r\n                }\r\n                value += toString(result.value);\r\n            }\r\n            addSeparator = true;\r\n        } while (!result.done);\r\n        return value;\r\n    }\r\n\r\n    indexOf(searchElement: T, fromIndex = 0): number {\r\n        const iterator = this.iterator();\r\n        let index = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (index >= fromIndex && next.value === searchElement) {\r\n                return index;\r\n            }\r\n            next = iterator.next();\r\n            index++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    // In the following definition the '& this' part in the return type is important\r\n    // _and_ the order within 'Stream<U> & this' is crucial!\r\n    // Otherwise Typescript would infer the type of 'this' as 'StreamImpl<S, T> & Stream<U>'\r\n    // (or '<subClass of StreamImpl<S, T> & Stream<U>') and usages like\r\n    // ```\r\n    //  const stream = new StreamImpl(...);\r\n    //  ... stream.every(<typeGuard>) & stream....\r\n    // ```\r\n    // cannot benefit from '<typeGuard>', as Typescript would priorize the signatures\r\n    // of 'StreamImpl<S, T>' (i.e. those of 'Stream<T>') over those of 'Stream<U>'.\r\n    // With the order of 'Stream<U> & this' the signatures of 'Stream<U>' get precedence.\r\n    every<U extends T>(predicate: (value: T) => value is U): this is Stream<U> & this;\r\n    every(predicate: (value: T) => unknown): boolean;\r\n    every(predicate: (value: T) => unknown): boolean {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (!predicate(next.value)) {\r\n                return false;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return true;\r\n    }\r\n\r\n    some(predicate: (value: T) => unknown): boolean {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (predicate(next.value)) {\r\n                return true;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    forEach(callbackfn: (value: T, index: number) => void): void {\r\n        const iterator = this.iterator();\r\n        let index = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            callbackfn(next.value, index);\r\n            next = iterator.next();\r\n            index++;\r\n        }\r\n    }\r\n\r\n    map<U>(callbackfn: (value: T) => U): Stream<U> {\r\n        return new StreamImpl<S, U>(\r\n            this.startFn,\r\n            (state) => {\r\n                const { done, value } = this.nextFn(state);\r\n                if (done) {\r\n                    return DONE_RESULT;\r\n                } else {\r\n                    return { done: false, value: callbackfn(value) };\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n    // for remarks on the return type definition refer to 'every<U extends T>(...)'\r\n    filter<U extends T>(predicate: (value: T) => value is U): Stream<U> & this;\r\n    filter(predicate: (value: T) => unknown): Stream<T> & this;\r\n    filter(predicate: (value: T) => unknown): Stream<T> {\r\n        return new StreamImpl<S, T>(\r\n            this.startFn,\r\n            state => {\r\n                let result: IteratorResult<T>;\r\n                do {\r\n                    result = this.nextFn(state);\r\n                    if (!result.done && predicate(result.value)) {\r\n                        return result;\r\n                    }\r\n                } while (!result.done);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    nonNullable(): Stream<NonNullable<T>> {\r\n        return this.filter(e => e !== undefined && e !== null) as Stream<NonNullable<T>>;\r\n    }\r\n\r\n    reduce(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduce<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n    reduce<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\r\n        const iterator = this.iterator();\r\n        let previousValue: U | T | undefined = initialValue;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (previousValue === undefined) {\r\n                previousValue = next.value;\r\n            } else {\r\n                previousValue = callbackfn(previousValue, next.value);\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return previousValue;\r\n    }\r\n\r\n    reduceRight(callbackfn: (previousValue: T, currentValue: T) => T): T | undefined;\r\n    reduceRight<U = T>(callbackfn: (previousValue: U, currentValue: T) => U, initialValue: U): U;\r\n    reduceRight<U>(callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\r\n        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);\r\n    }\r\n\r\n    protected recursiveReduce<U>(iterator: Iterator<T>, callbackfn: (previousValue: U | T, currentValue: T) => U, initialValue?: U): U | T | undefined {\r\n        const next = iterator.next();\r\n        if (next.done) {\r\n            return initialValue;\r\n        }\r\n        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);\r\n        if (previousValue === undefined) {\r\n            return next.value;\r\n        }\r\n        return callbackfn(previousValue, next.value);\r\n    }\r\n\r\n    find<S extends T>(predicate: (value: T) => value is S): S | undefined;\r\n    find(predicate: (value: T) => unknown): T | undefined;\r\n    find(predicate: (value: T) => unknown): T | undefined {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (predicate(next.value)) {\r\n                return next.value;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    findIndex(predicate: (value: T) => unknown): number {\r\n        const iterator = this.iterator();\r\n        let index = 0;\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (predicate(next.value)) {\r\n                return index;\r\n            }\r\n            next = iterator.next();\r\n            index++;\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    includes(searchElement: T): boolean {\r\n        const iterator = this.iterator();\r\n        let next = iterator.next();\r\n        while (!next.done) {\r\n            if (next.value === searchElement) {\r\n                return true;\r\n            }\r\n            next = iterator.next();\r\n        }\r\n        return false;\r\n    }\r\n\r\n    flatMap<U>(callbackfn: (value: T) => U | Iterable<U>): Stream<U> {\r\n        type FlatMapState = { this: S, iterator?: Iterator<U, undefined> }\r\n        return new StreamImpl<FlatMapState, U>(\r\n            () => ({ this: this.startFn() }),\r\n            (state) => {\r\n                do {\r\n                    if (state.iterator) {\r\n                        const next = state.iterator.next();\r\n                        if (next.done) {\r\n                            state.iterator = undefined;\r\n                        } else {\r\n                            return next;\r\n                        }\r\n                    }\r\n                    const { done, value } = this.nextFn(state.this);\r\n                    if (!done) {\r\n                        const mapped = callbackfn(value);\r\n                        if (isIterable(mapped)) {\r\n                            state.iterator = mapped[Symbol.iterator]();\r\n                        } else {\r\n                            return { done: false, value: mapped };\r\n                        }\r\n                    }\r\n                } while (state.iterator);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    flat<D extends number = 1>(depth?: D): FlatStream<T, D> {\r\n        if (depth === undefined) {\r\n            depth = 1 as D;\r\n        }\r\n        if (depth <= 0) {\r\n            return this as unknown as FlatStream<T, D>;\r\n        }\r\n        const stream = depth > 1 ? this.flat(depth - 1) as unknown as StreamImpl<S, T> : this;\r\n        type FlatMapState = { this: S, iterator?: Iterator<T, undefined> }\r\n        return new StreamImpl<FlatMapState, T>(\r\n            () => ({ this: stream.startFn() }),\r\n            (state) => {\r\n                do {\r\n                    if (state.iterator) {\r\n                        const next = state.iterator.next();\r\n                        if (next.done) {\r\n                            state.iterator = undefined;\r\n                        } else {\r\n                            return next;\r\n                        }\r\n                    }\r\n                    const { done, value } = stream.nextFn(state.this);\r\n                    if (!done) {\r\n                        if (isIterable(value)) {\r\n                            state.iterator = value[Symbol.iterator]() as Iterator<T>;\r\n                        } else {\r\n                            return { done: false, value: value };\r\n                        }\r\n                    }\r\n                } while (state.iterator);\r\n                return DONE_RESULT;\r\n            }\r\n        ) as unknown as FlatStream<T, D>;\r\n    }\r\n\r\n    head(): T | undefined {\r\n        const iterator = this.iterator();\r\n        const result = iterator.next();\r\n        if (result.done) {\r\n            return undefined;\r\n        }\r\n        return result.value;\r\n    }\r\n\r\n    tail(skipCount = 1): Stream<T> {\r\n        return new StreamImpl<S, T>(\r\n            () => {\r\n                const state = this.startFn();\r\n                for (let i = 0; i < skipCount; i++) {\r\n                    const next = this.nextFn(state);\r\n                    if (next.done) {\r\n                        return state;\r\n                    }\r\n                }\r\n                return state;\r\n            },\r\n            this.nextFn\r\n        );\r\n    }\r\n\r\n    limit(maxSize: number): Stream<T> {\r\n        return new StreamImpl<{ size: number, state: S }, T>(\r\n            () => ({ size: 0, state: this.startFn() }),\r\n            state => {\r\n                state.size++;\r\n                if (state.size > maxSize) {\r\n                    return DONE_RESULT;\r\n                }\r\n                return this.nextFn(state.state);\r\n            }\r\n        );\r\n    }\r\n\r\n    distinct<Key = T>(by?: (element: T) => Key): Stream<T> {\r\n        const set = new Set<T | Key>();\r\n        return this.filter(e => {\r\n            const value = by ? by(e) : e;\r\n            if (set.has(value)) {\r\n                return false;\r\n            } else {\r\n                set.add(value);\r\n                return true;\r\n            }\r\n        });\r\n    }\r\n\r\n    exclude<Key = T>(other: Iterable<T>, key?: (element: T) => Key): Stream<T> {\r\n        const otherKeySet = new Set<Key | T>();\r\n        for (const item of other) {\r\n            const value = key ? key(item) : item;\r\n            otherKeySet.add(value);\r\n        }\r\n        return this.filter(e => {\r\n            const ownKey = key ? key(e) : e;\r\n            return !otherKeySet.has(ownKey);\r\n        });\r\n    }\r\n}\r\n\r\nfunction toString(item: unknown): string {\r\n    if (typeof item === 'string') {\r\n        return item as string;\r\n    }\r\n    if (typeof item === 'undefined') {\r\n        return 'undefined';\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    if (typeof (item as any).toString === 'function') {\r\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n        return (item as any).toString();\r\n    }\r\n    return Object.prototype.toString.call(item);\r\n}\r\n\r\nfunction isIterable<T>(obj: unknown): obj is Iterable<T> {\r\n    return !!obj && typeof (obj as Iterable<T>)[Symbol.iterator] === 'function';\r\n}\r\n\r\n/**\r\n * An empty stream of any type.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport const EMPTY_STREAM: Stream<any> = new StreamImpl<undefined, any>(() => undefined, () => DONE_RESULT);\r\n\r\n/**\r\n * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.\r\n */\r\nexport const DONE_RESULT: IteratorReturnResult<undefined> = Object.freeze({ done: true, value: undefined });\r\n\r\n/**\r\n * Create a stream from one or more iterables or array-likes.\r\n */\r\nexport function stream<T>(...collections: Array<Iterable<T> | ArrayLike<T>>): Stream<T> {\r\n    if (collections.length === 1) {\r\n        const collection = collections[0];\r\n        if (collection instanceof StreamImpl) {\r\n            return collection as Stream<T>;\r\n        }\r\n        if (isIterable(collection)) {\r\n            return new StreamImpl<Iterator<T, undefined>, T>(\r\n                () => collection[Symbol.iterator](),\r\n                (iterator) => iterator.next()\r\n            );\r\n        }\r\n        if (typeof collection.length === 'number') {\r\n            return new StreamImpl<{ index: number }, T>(\r\n                () => ({ index: 0 }),\r\n                (state) => {\r\n                    if (state.index < collection.length) {\r\n                        return { done: false, value: collection[state.index++] };\r\n                    } else {\r\n                        return DONE_RESULT;\r\n                    }\r\n                }\r\n            );\r\n        }\r\n    }\r\n    if (collections.length > 1) {\r\n        type State = { collIndex: number, iterator?: Iterator<T, undefined>, array?: ArrayLike<T>, arrIndex: number };\r\n        return new StreamImpl<State, T>(\r\n            () => ({ collIndex: 0, arrIndex: 0 }),\r\n            (state) => {\r\n                do {\r\n                    if (state.iterator) {\r\n                        const next = state.iterator.next();\r\n                        if (!next.done) {\r\n                            return next;\r\n                        }\r\n                        state.iterator = undefined;\r\n                    }\r\n                    if (state.array) {\r\n                        if (state.arrIndex < state.array.length) {\r\n                            return { done: false, value: state.array[state.arrIndex++] };\r\n                        }\r\n                        state.array = undefined;\r\n                        state.arrIndex = 0;\r\n                    }\r\n                    if (state.collIndex < collections.length) {\r\n                        const collection = collections[state.collIndex++];\r\n                        if (isIterable(collection)) {\r\n                            state.iterator = collection[Symbol.iterator]();\r\n                        } else if (collection && typeof collection.length === 'number') {\r\n                            state.array = collection;\r\n                        }\r\n                    }\r\n                } while (state.iterator || state.array || state.collIndex < collections.length);\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n    return EMPTY_STREAM;\r\n}\r\n\r\n/**\r\n * A tree iterator adds the ability to prune the current iteration.\r\n */\r\nexport interface TreeIterator<T> extends IterableIterator<T> {\r\n    /**\r\n     * Skip the whole subtree below the last returned element. The iteration continues as if that\r\n     * element had no children.\r\n     */\r\n    prune(): void\r\n}\r\n\r\n/**\r\n * A tree stream is used to stream the elements of a tree, for example an AST or CST.\r\n */\r\nexport interface TreeStream<T> extends Stream<T> {\r\n    iterator(): TreeIterator<T>\r\n}\r\n\r\n/**\r\n * The default implementation of `TreeStream` takes a root element and a function that computes the\r\n * children of its argument. Whether the root node included in the stream is controlled with the\r\n * `includeRoot` option, which defaults to `false`.\r\n */\r\nexport class TreeStreamImpl<T>\r\n    extends StreamImpl<{ iterators: Array<Iterator<T>>, pruned: boolean }, T>\r\n    implements TreeStream<T> {\r\n\r\n    constructor(root: T, children: (node: T) => Iterable<T>, options?: { includeRoot?: boolean }) {\r\n        super(\r\n            () => ({\r\n                iterators: options?.includeRoot ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],\r\n                pruned: false\r\n            }),\r\n            state => {\r\n                if (state.pruned) {\r\n                    state.iterators.pop();\r\n                    state.pruned = false;\r\n                }\r\n                while (state.iterators.length > 0) {\r\n                    const iterator = state.iterators[state.iterators.length - 1];\r\n                    const next = iterator.next();\r\n                    if (next.done) {\r\n                        state.iterators.pop();\r\n                    } else {\r\n                        state.iterators.push(children(next.value)[Symbol.iterator]());\r\n                        return next;\r\n                    }\r\n                }\r\n                return DONE_RESULT;\r\n            }\r\n        );\r\n    }\r\n\r\n    override iterator(): TreeIterator<T> {\r\n        const iterator = {\r\n            state: this.startFn(),\r\n            next: () => this.nextFn(iterator.state),\r\n            prune: () => {\r\n                iterator.state.pruned = true;\r\n            },\r\n            [Symbol.iterator]: () => iterator\r\n        };\r\n        return iterator;\r\n    }\r\n}\r\n\r\n/**\r\n * A set of utility functions that reduce a stream to a single value.\r\n */\r\nexport namespace Reduction {\r\n\r\n    /**\r\n     * Compute the sum of a number stream.\r\n     */\r\n    export function sum(stream: Stream<number>): number {\r\n        return stream.reduce((a, b) => a + b, 0);\r\n    }\r\n\r\n    /**\r\n     * Compute the product of a number stream.\r\n     */\r\n    export function product(stream: Stream<number>): number {\r\n        return stream.reduce((a, b) => a * b, 0);\r\n    }\r\n\r\n    /**\r\n     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.\r\n     */\r\n    export function min(stream: Stream<number>): number | undefined {\r\n        return stream.reduce((a, b) => Math.min(a, b));\r\n    }\r\n\r\n    /**\r\n     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.\r\n     */\r\n    export function max(stream: Stream<number>): number | undefined {\r\n        return stream.reduce((a, b) => Math.max(a, b));\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken } from '@chevrotain/types';\r\nimport type { Range } from 'vscode-languageserver';\r\nimport type { CstNode, CompositeCstNode, LeafCstNode } from '../syntax-tree.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\nimport type { Stream, TreeStream } from './stream.js';\r\nimport { isCompositeCstNode, isLeafCstNode, isRootCstNode } from '../syntax-tree.js';\r\nimport { TreeStreamImpl } from './stream.js';\r\n\r\n/**\r\n * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,\r\n * including the root node itself.\r\n */\r\nexport function streamCst(node: CstNode): TreeStream<CstNode> {\r\n    return new TreeStreamImpl(node, element => {\r\n        if (isCompositeCstNode(element)) {\r\n            return element.content;\r\n        } else {\r\n            return [];\r\n        }\r\n    }, { includeRoot: true });\r\n}\r\n\r\n/**\r\n * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.\r\n */\r\nexport function flattenCst(node: CstNode): Stream<LeafCstNode> {\r\n    return streamCst(node).filter(isLeafCstNode);\r\n}\r\n\r\n/**\r\n * Determines whether the specified cst node is a child of the specified parent node.\r\n */\r\nexport function isCstChildNode(child: CstNode, parent: CstNode): boolean {\r\n    while (child.container) {\r\n        child = child.container;\r\n        if (child === parent) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function tokenToRange(token: IToken): Range {\r\n    // Chevrotain uses 1-based indices everywhere\r\n    // So we subtract 1 from every value to align with the LSP\r\n    return {\r\n        start: {\r\n            character: token.startColumn! - 1,\r\n            line: token.startLine! - 1\r\n        },\r\n        end: {\r\n            character: token.endColumn!, // endColumn uses the correct index\r\n            line: token.endLine! - 1\r\n        }\r\n    };\r\n}\r\n\r\nexport function toDocumentSegment(node: CstNode): DocumentSegment;\r\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined;\r\nexport function toDocumentSegment(node?: CstNode): DocumentSegment | undefined {\r\n    if (!node) {\r\n        return undefined;\r\n    }\r\n    const { offset, end, range } = node;\r\n    return {\r\n        range,\r\n        offset,\r\n        end,\r\n        length: end - offset\r\n    };\r\n}\r\n\r\nexport enum RangeComparison {\r\n    Before = 0,\r\n    After = 1,\r\n    OverlapFront = 2,\r\n    OverlapBack = 3,\r\n    Inside = 4\r\n}\r\n\r\nexport function compareRange(range: Range, to: Range): RangeComparison {\r\n    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character < range.start.character)) {\r\n        return RangeComparison.Before;\r\n    } else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character > to.end.character)) {\r\n        return RangeComparison.After;\r\n    }\r\n    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);\r\n    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);\r\n    if (startInside && endInside) {\r\n        return RangeComparison.Inside;\r\n    } else if (startInside) {\r\n        return RangeComparison.OverlapBack;\r\n    } else {\r\n        return RangeComparison.OverlapFront;\r\n    }\r\n}\r\n\r\nexport function inRange(range: Range, to: Range): boolean {\r\n    const comparison = compareRange(range, to);\r\n    return comparison > RangeComparison.After;\r\n}\r\n\r\n// The \\p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets\r\n// Together with \\w it matches any kind of character which can commonly appear in IDs\r\nexport const DefaultNameRegexp = /^[\\w\\p{L}]$/u;\r\n\r\n/**\r\n * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,\r\n * it will instead return the leaf node at the `offset - 1` position.\r\n *\r\n * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.\r\n */\r\nexport function findDeclarationNodeAtOffset(cstNode: CstNode | undefined, offset: number, nameRegexp = DefaultNameRegexp): LeafCstNode | undefined {\r\n    if (cstNode) {\r\n        if (offset > 0) {\r\n            const localOffset = offset - cstNode.offset;\r\n            const textAtOffset = cstNode.text.charAt(localOffset);\r\n            if (!nameRegexp.test(textAtOffset)) {\r\n                offset--;\r\n            }\r\n        }\r\n        return findLeafNodeAtOffset(cstNode, offset);\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function findCommentNode(cstNode: CstNode | undefined, commentNames: string[]): CstNode | undefined {\r\n    if (cstNode) {\r\n        const previous = getPreviousNode(cstNode, true);\r\n        if (previous && isCommentNode(previous, commentNames)) {\r\n            return previous;\r\n        }\r\n        if (isRootCstNode(cstNode)) {\r\n            // Go from the first non-hidden node through all nodes in reverse order\r\n            // We do this to find the comment node which directly precedes the root node\r\n            const endIndex = cstNode.content.findIndex(e => !e.hidden);\r\n            for (let i = endIndex - 1; i >= 0; i--) {\r\n                const child = cstNode.content[i];\r\n                if (isCommentNode(child, commentNames)) {\r\n                    return child;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function isCommentNode(cstNode: CstNode, commentNames: string[]): boolean {\r\n    return isLeafCstNode(cstNode) && commentNames.includes(cstNode.tokenType.name);\r\n}\r\n\r\n/**\r\n * Finds the leaf CST node at the specified 0-based string offset.\r\n * Note that the given offset will be within the range of the returned leaf node.\r\n *\r\n * If the offset does not point to a CST node (but just white space), this method will return `undefined`.\r\n *\r\n * @param node The CST node to search through.\r\n * @param offset The specified offset.\r\n * @returns The CST node at the specified offset.\r\n */\r\nexport function findLeafNodeAtOffset(node: CstNode, offset: number): LeafCstNode | undefined {\r\n    if (isLeafCstNode(node)) {\r\n        return node;\r\n    } else if (isCompositeCstNode(node)) {\r\n        const searchResult = binarySearch(node, offset, false);\r\n        if (searchResult) {\r\n            return findLeafNodeAtOffset(searchResult, offset);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Finds the leaf CST node at the specified 0-based string offset.\r\n * If no CST node exists at the specified position, it will return the leaf node before it.\r\n *\r\n * If there is no leaf node before the specified offset, this method will return `undefined`.\r\n *\r\n * @param node The CST node to search through.\r\n * @param offset The specified offset.\r\n * @returns The CST node closest to the specified offset.\r\n */\r\nexport function findLeafNodeBeforeOffset(node: CstNode, offset: number): LeafCstNode | undefined {\r\n    if (isLeafCstNode(node)) {\r\n        return node;\r\n    } else if (isCompositeCstNode(node)) {\r\n        const searchResult = binarySearch(node, offset, true);\r\n        if (searchResult) {\r\n            return findLeafNodeBeforeOffset(searchResult, offset);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction binarySearch(node: CompositeCstNode, offset: number, closest: boolean): CstNode | undefined {\r\n    let left = 0;\r\n    let right = node.content.length - 1;\r\n    let closestNode: CstNode | undefined = undefined;\r\n\r\n    while (left <= right) {\r\n        const middle = Math.floor((left + right) / 2);\r\n        const middleNode = node.content[middle];\r\n\r\n        if (middleNode.offset <= offset && middleNode.end > offset) {\r\n            // Found an exact match\r\n            return middleNode;\r\n        }\r\n\r\n        if (middleNode.end <= offset) {\r\n            // Update the closest node (less than offset) and move to the right half\r\n            closestNode = closest ? middleNode : undefined;\r\n            left = middle + 1;\r\n        } else {\r\n            // Move to the left half\r\n            right = middle - 1;\r\n        }\r\n    }\r\n\r\n    return closestNode;\r\n}\r\n\r\nexport function getPreviousNode(node: CstNode, hidden = true): CstNode | undefined {\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        let index = parent.content.indexOf(node);\r\n        while (index > 0) {\r\n            index--;\r\n            const previous = parent.content[index];\r\n            if (hidden || !previous.hidden) {\r\n                return previous;\r\n            }\r\n        }\r\n        node = parent;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getNextNode(node: CstNode, hidden = true): CstNode | undefined {\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        let index = parent.content.indexOf(node);\r\n        const last = parent.content.length - 1;\r\n        while (index < last) {\r\n            index++;\r\n            const next = parent.content[index];\r\n            if (hidden || !next.hidden) {\r\n                return next;\r\n            }\r\n        }\r\n        node = parent;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getStartlineNode(node: CstNode): CstNode {\r\n    if (node.range.start.character === 0) {\r\n        return node;\r\n    }\r\n    const line = node.range.start.line;\r\n    let last = node;\r\n    let index: number | undefined;\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        const selfIndex = index ?? parent.content.indexOf(node);\r\n        if (selfIndex === 0) {\r\n            node = parent;\r\n            index = undefined;\r\n        } else {\r\n            index = selfIndex - 1;\r\n            node = parent.content[index];\r\n        }\r\n        if (node.range.start.line !== line) {\r\n            break;\r\n        }\r\n        last = node;\r\n    }\r\n    return last;\r\n}\r\n\r\nexport function getInteriorNodes(start: CstNode, end: CstNode): CstNode[] {\r\n    const commonParent = getCommonParent(start, end);\r\n    if (!commonParent) {\r\n        return [];\r\n    }\r\n    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);\r\n}\r\n\r\nfunction getCommonParent(a: CstNode, b: CstNode): CommonParent | undefined {\r\n    const aParents = getParentChain(a);\r\n    const bParents = getParentChain(b);\r\n    let current: CommonParent | undefined;\r\n    for (let i = 0; i < aParents.length && i < bParents.length; i++) {\r\n        const aParent = aParents[i];\r\n        const bParent = bParents[i];\r\n        if (aParent.parent === bParent.parent) {\r\n            current = {\r\n                parent: aParent.parent,\r\n                a: aParent.index,\r\n                b: bParent.index\r\n            };\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return current;\r\n}\r\n\r\ninterface CommonParent {\r\n    parent: CompositeCstNode\r\n    a: number\r\n    b: number\r\n}\r\n\r\nfunction getParentChain(node: CstNode): ParentLink[] {\r\n    const chain: ParentLink[] = [];\r\n    while (node.container) {\r\n        const parent = node.container;\r\n        const index = parent.content.indexOf(node);\r\n        chain.push({\r\n            parent,\r\n            index\r\n        });\r\n        node = parent;\r\n    }\r\n    return chain.reverse();\r\n}\r\n\r\ninterface ParentLink {\r\n    parent: CompositeCstNode\r\n    index: number\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\n/**\r\n * A `Module<I>` is a description of possibly grouped service factories.\r\n *\r\n * Given a type I = { group: { service: A } },\r\n * Module<I> := { group: { service: (injector: I) => A } }\r\n *\r\n * Making `I` available during the creation of `I` allows us to create cyclic\r\n * dependencies.\r\n */\r\nexport type Module<I, T = I> = {\r\n    [K in keyof T]: Module<I, T[K]> | ((injector: I) => T[K])\r\n}\r\n\r\n/**\r\n * Given a set of modules, the inject function returns a lazily evaluted injector\r\n * that injects dependencies into the requested service when it is requested the\r\n * first time. Subsequent requests will return the same service.\r\n *\r\n * In the case of cyclic dependencies, an Error will be thrown. This can be fixed\r\n * by injecting a provider `() => T` instead of a `T`.\r\n *\r\n * Please note that the arguments may be objects or arrays. However, the result will\r\n * be an object. Using it with for..of will have no effect.\r\n *\r\n * @param module1 first Module\r\n * @param module2 (optional) second Module\r\n * @param module3 (optional) third Module\r\n * @param module4 (optional) fourth Module\r\n * @returns a new object of type I\r\n */\r\nexport function inject<I1, I2, I3, I4, I extends I1 & I2 & I3 & I4>(module1: Module<I, I1>, module2?: Module<I, I2>, module3?: Module<I, I3>, module4?: Module<I, I4>): I {\r\n    const module = [module1, module2, module3, module4].reduce(_merge, {}) as Module<I>;\r\n    return _inject(module);\r\n}\r\n\r\nconst isProxy = Symbol('isProxy');\r\n\r\nexport function eagerLoad(item: any): any {\r\n    if (item && item[isProxy]) {\r\n        for (const value of Object.values(item)) {\r\n            eagerLoad(value);\r\n        }\r\n    }\r\n    return item;\r\n}\r\n\r\n/**\r\n * Helper function that returns an injector by creating a proxy.\r\n * Invariant: injector is of type I. If injector is undefined, then T = I.\r\n */\r\nfunction _inject<I, T>(module: Module<I, T>, injector?: any): T {\r\n    const proxy: any = new Proxy({} as any, {\r\n        deleteProperty: () => false,\r\n        get: (obj, prop) => _resolve(obj, prop, module, injector || proxy),\r\n        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in\r\n        has: (_, prop) => prop in module, // used by ..in..\r\n        ownKeys: () => [...Reflect.ownKeys(module), isProxy] // used by for..in\r\n    });\r\n    proxy[isProxy] = true;\r\n    return proxy;\r\n}\r\n\r\n/**\r\n * Internally used to tag a requested dependency, directly before calling the factory.\r\n * This allows us to find cycles during instance creation.\r\n */\r\nconst __requested__ = Symbol();\r\n\r\n/**\r\n * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from\r\n * the module description. The result of service factories is cached. Groups are\r\n * recursively proxied.\r\n *\r\n * @param obj an object holding all group proxies and services\r\n * @param prop the key of a value within obj\r\n * @param module an object containing groups and service factories\r\n * @param injector the first level proxy that provides access to all values\r\n * @returns the requested value `obj[prop]`\r\n * @throws Error if a dependency cycle is detected\r\n */\r\nfunction _resolve<I, T>(obj: any, prop: string | symbol | number, module: Module<I, T>, injector: I): T[keyof T] | undefined {\r\n    if (prop in obj) {\r\n        if (obj[prop] instanceof Error) {\r\n            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', {cause: obj[prop]});\r\n        }\r\n        if (obj[prop] === __requested__) {\r\n            throw new Error('Cycle detected. Please make \"' + String(prop) + '\" lazy. See https://langium.org/docs/configuration-services/#resolving-cyclic-dependencies');\r\n        }\r\n        return obj[prop];\r\n    } else if (prop in module) {\r\n        const value: Module<I, T[keyof T]> | ((injector: I) => T[keyof T]) = module[prop as keyof T];\r\n        obj[prop] = __requested__;\r\n        try {\r\n            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);\r\n        } catch (error) {\r\n            obj[prop] = error instanceof Error ? error : undefined;\r\n            throw error;\r\n        }\r\n        return obj[prop];\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\n/**\r\n * Performs a deep-merge of two modules by writing source entries into the target module.\r\n *\r\n * @param target the module which is written\r\n * @param source the module which is read\r\n * @returns the target module\r\n */\r\nfunction _merge(target: Module<any>, source?: Module<any>): Module<unknown> {\r\n    if (source) {\r\n        for (const [key, value2] of Object.entries(source)) {\r\n            if (value2 !== undefined) {\r\n                const value1 = target[key];\r\n                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {\r\n                    target[key] = _merge(value1, value2);\r\n                } else {\r\n                    target[key] = value2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Stream } from './stream.js';\r\nimport { Reduction, stream } from './stream.js';\r\n\r\n/**\r\n * A multimap is a variation of a Map that has potentially multiple values for every key.\r\n */\r\nexport class MultiMap<K, V> {\r\n\r\n    private map = new Map<K, V[]>();\r\n\r\n    constructor()\r\n    constructor(elements: Array<[K, V]>)\r\n    constructor(elements?: Array<[K, V]>) {\r\n        if (elements) {\r\n            for (const [key, value] of elements) {\r\n                this.add(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * The total number of values in the multimap.\r\n     */\r\n    get size(): number {\r\n        return Reduction.sum(stream(this.map.values()).map(a => a.length));\r\n    }\r\n\r\n    /**\r\n     * Clear all entries in the multimap.\r\n     */\r\n    clear(): void {\r\n        this.map.clear();\r\n    }\r\n\r\n    /**\r\n     * Operates differently depending on whether a `value` is given:\r\n     *  * With a value, this method deletes the specific key / value pair from the multimap.\r\n     *  * Without a value, all values associated with the given key are deleted.\r\n     *\r\n     * @returns `true` if a value existed and has been removed, or `false` if the specified\r\n     *     key / value does not exist.\r\n     */\r\n    delete(key: K, value?: V): boolean {\r\n        if (value === undefined) {\r\n            return this.map.delete(key);\r\n        } else {\r\n            const values = this.map.get(key);\r\n            if (values) {\r\n                const index = values.indexOf(value);\r\n                if (index >= 0) {\r\n                    if (values.length === 1) {\r\n                        this.map.delete(key);\r\n                    } else {\r\n                        values.splice(index, 1);\r\n                    }\r\n                    return true;\r\n                }\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns an array of all values associated with the given key. If no value exists,\r\n     * an empty array is returned.\r\n     *\r\n     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a\r\n     * value and `delete` to remove a value from the multimap.\r\n     */\r\n    get(key: K): readonly V[] {\r\n        return this.map.get(key) ?? [];\r\n    }\r\n\r\n    /**\r\n     * Operates differently depending on whether a `value` is given:\r\n     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.\r\n     *  * Without a value, this method returns `true` if the given key is present in the multimap.\r\n     */\r\n    has(key: K, value?: V): boolean {\r\n        if (value === undefined) {\r\n            return this.map.has(key);\r\n        } else {\r\n            const values = this.map.get(key);\r\n            if (values) {\r\n                return values.indexOf(value) >= 0;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add the given key / value pair to the multimap.\r\n     */\r\n    add(key: K, value: V): this {\r\n        if (this.map.has(key)) {\r\n            this.map.get(key)!.push(value);\r\n        } else {\r\n            this.map.set(key, [value]);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Add the given set of key / value pairs to the multimap.\r\n     */\r\n    addAll(key: K, values: Iterable<V>): this {\r\n        if (this.map.has(key)) {\r\n            this.map.get(key)!.push(...values);\r\n        } else {\r\n            this.map.set(key, Array.from(values));\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Invokes the given callback function for every key / value pair in the multimap.\r\n     */\r\n    forEach(callbackfn: (value: V, key: K, map: this) => void): void {\r\n        this.map.forEach((array, key) =>\r\n            array.forEach(value => callbackfn(value, key, this))\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns an iterator of key, value pairs for every entry in the map.\r\n     */\r\n    [Symbol.iterator](): Iterator<[K, V]> {\r\n        return this.entries().iterator();\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of key, value pairs for every entry in the map.\r\n     */\r\n    entries(): Stream<[K, V]> {\r\n        return stream(this.map.entries())\r\n            .flatMap(([key, array]) => array.map(value => [key, value] as [K, V]));\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of keys in the map.\r\n     */\r\n    keys(): Stream<K> {\r\n        return stream(this.map.keys());\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of values in the map.\r\n     */\r\n    values(): Stream<V> {\r\n        return stream(this.map.values()).flat();\r\n    }\r\n\r\n    /**\r\n     * Returns a stream of key, value set pairs for every key in the map.\r\n     */\r\n    entriesGroupedByKey(): Stream<[K, V[]]> {\r\n        return stream(this.map.entries());\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * This file was generated by langium-cli 2.1.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\n/* eslint-disable */\r\nimport type { AstNode, Reference, ReferenceInfo, TypeMetaData } from '../../syntax-tree.js';\r\nimport { AbstractAstReflection } from '../../syntax-tree.js';\r\n\r\nexport const LangiumGrammarTerminals = {\r\n    ID: /\\^?[_a-zA-Z][\\w_]*/,\r\n    STRING: /\"(\\\\.|[^\"\\\\])*\"|'(\\\\.|[^'\\\\])*'/,\r\n    RegexLiteral: /\\/(?![*+?])(?:[^\\r\\n\\[/\\\\]|\\\\.|\\[(?:[^\\r\\n\\]\\\\]|\\\\.)*\\])+\\/[a-z]*/,\r\n    WS: /\\s+/,\r\n    ML_COMMENT: /\\/\\*[\\s\\S]*?\\*\\//,\r\n    SL_COMMENT: /\\/\\/[^\\n\\r]*/,\r\n};\r\n\r\nexport type AbstractRule = ParserRule | TerminalRule;\r\n\r\nexport const AbstractRule = 'AbstractRule';\r\n\r\nexport function isAbstractRule(item: unknown): item is AbstractRule {\r\n    return reflection.isInstance(item, AbstractRule);\r\n}\r\n\r\nexport type AbstractType = Action | Interface | ParserRule | Type;\r\n\r\nexport const AbstractType = 'AbstractType';\r\n\r\nexport function isAbstractType(item: unknown): item is AbstractType {\r\n    return reflection.isInstance(item, AbstractType);\r\n}\r\n\r\nexport type Condition = Conjunction | Disjunction | LiteralCondition | Negation | ParameterReference;\r\n\r\nexport const Condition = 'Condition';\r\n\r\nexport function isCondition(item: unknown): item is Condition {\r\n    return reflection.isInstance(item, Condition);\r\n}\r\n\r\nexport type FeatureName = 'current' | 'entry' | 'extends' | 'false' | 'fragment' | 'grammar' | 'hidden' | 'import' | 'infer' | 'infers' | 'interface' | 'returns' | 'terminal' | 'true' | 'type' | 'with' | PrimitiveType | string;\r\n\r\nexport function isFeatureName(item: unknown): item is FeatureName {\r\n    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\\^?[_a-zA-Z][\\w_]*/.test(item)));\r\n}\r\n\r\nexport type PrimitiveType = 'Date' | 'bigint' | 'boolean' | 'number' | 'string';\r\n\r\nexport function isPrimitiveType(item: unknown): item is PrimitiveType {\r\n    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';\r\n}\r\n\r\nexport type TypeDefinition = ArrayType | ReferenceType | SimpleType | UnionType;\r\n\r\nexport const TypeDefinition = 'TypeDefinition';\r\n\r\nexport function isTypeDefinition(item: unknown): item is TypeDefinition {\r\n    return reflection.isInstance(item, TypeDefinition);\r\n}\r\n\r\nexport interface AbstractElement extends AstNode {\r\n    readonly $type: 'AbstractElement' | 'Action' | 'Alternatives' | 'Assignment' | 'CharacterRange' | 'CrossReference' | 'EndOfFile' | 'Group' | 'Keyword' | 'NegatedToken' | 'RegexToken' | 'RuleCall' | 'TerminalAlternatives' | 'TerminalGroup' | 'TerminalRuleCall' | 'UnorderedGroup' | 'UntilToken' | 'Wildcard';\r\n    cardinality?: '*' | '+' | '?'\r\n    lookahead?: '?!' | '?='\r\n}\r\n\r\nexport const AbstractElement = 'AbstractElement';\r\n\r\nexport function isAbstractElement(item: unknown): item is AbstractElement {\r\n    return reflection.isInstance(item, AbstractElement);\r\n}\r\n\r\nexport interface ArrayType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'ArrayType';\r\n    elementType: TypeDefinition\r\n}\r\n\r\nexport const ArrayType = 'ArrayType';\r\n\r\nexport function isArrayType(item: unknown): item is ArrayType {\r\n    return reflection.isInstance(item, ArrayType);\r\n}\r\n\r\nexport interface Conjunction extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Conjunction';\r\n    left: Condition\r\n    right: Condition\r\n}\r\n\r\nexport const Conjunction = 'Conjunction';\r\n\r\nexport function isConjunction(item: unknown): item is Conjunction {\r\n    return reflection.isInstance(item, Conjunction);\r\n}\r\n\r\nexport interface Disjunction extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Disjunction';\r\n    left: Condition\r\n    right: Condition\r\n}\r\n\r\nexport const Disjunction = 'Disjunction';\r\n\r\nexport function isDisjunction(item: unknown): item is Disjunction {\r\n    return reflection.isInstance(item, Disjunction);\r\n}\r\n\r\nexport interface Grammar extends AstNode {\r\n    readonly $type: 'Grammar';\r\n    definesHiddenTokens: boolean\r\n    hiddenTokens: Array<Reference<AbstractRule>>\r\n    imports: Array<GrammarImport>\r\n    interfaces: Array<Interface>\r\n    isDeclared: boolean\r\n    name?: string\r\n    rules: Array<AbstractRule>\r\n    types: Array<Type>\r\n    usedGrammars: Array<Reference<Grammar>>\r\n}\r\n\r\nexport const Grammar = 'Grammar';\r\n\r\nexport function isGrammar(item: unknown): item is Grammar {\r\n    return reflection.isInstance(item, Grammar);\r\n}\r\n\r\nexport interface GrammarImport extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'GrammarImport';\r\n    path: string\r\n}\r\n\r\nexport const GrammarImport = 'GrammarImport';\r\n\r\nexport function isGrammarImport(item: unknown): item is GrammarImport {\r\n    return reflection.isInstance(item, GrammarImport);\r\n}\r\n\r\nexport interface InferredType extends AstNode {\r\n    readonly $container: Action | ParserRule;\r\n    readonly $type: 'InferredType';\r\n    name: string\r\n}\r\n\r\nexport const InferredType = 'InferredType';\r\n\r\nexport function isInferredType(item: unknown): item is InferredType {\r\n    return reflection.isInstance(item, InferredType);\r\n}\r\n\r\nexport interface Interface extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'Interface';\r\n    attributes: Array<TypeAttribute>\r\n    name: string\r\n    superTypes: Array<Reference<AbstractType>>\r\n}\r\n\r\nexport const Interface = 'Interface';\r\n\r\nexport function isInterface(item: unknown): item is Interface {\r\n    return reflection.isInstance(item, Interface);\r\n}\r\n\r\nexport interface LiteralCondition extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'LiteralCondition';\r\n    true: boolean\r\n}\r\n\r\nexport const LiteralCondition = 'LiteralCondition';\r\n\r\nexport function isLiteralCondition(item: unknown): item is LiteralCondition {\r\n    return reflection.isInstance(item, LiteralCondition);\r\n}\r\n\r\nexport interface NamedArgument extends AstNode {\r\n    readonly $container: RuleCall;\r\n    readonly $type: 'NamedArgument';\r\n    calledByName: boolean\r\n    parameter?: Reference<Parameter>\r\n    value: Condition\r\n}\r\n\r\nexport const NamedArgument = 'NamedArgument';\r\n\r\nexport function isNamedArgument(item: unknown): item is NamedArgument {\r\n    return reflection.isInstance(item, NamedArgument);\r\n}\r\n\r\nexport interface Negation extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'Negation';\r\n    value: Condition\r\n}\r\n\r\nexport const Negation = 'Negation';\r\n\r\nexport function isNegation(item: unknown): item is Negation {\r\n    return reflection.isInstance(item, Negation);\r\n}\r\n\r\nexport interface Parameter extends AstNode {\r\n    readonly $container: ParserRule;\r\n    readonly $type: 'Parameter';\r\n    name: string\r\n}\r\n\r\nexport const Parameter = 'Parameter';\r\n\r\nexport function isParameter(item: unknown): item is Parameter {\r\n    return reflection.isInstance(item, Parameter);\r\n}\r\n\r\nexport interface ParameterReference extends AstNode {\r\n    readonly $container: Conjunction | Disjunction | Group | NamedArgument | Negation;\r\n    readonly $type: 'ParameterReference';\r\n    parameter: Reference<Parameter>\r\n}\r\n\r\nexport const ParameterReference = 'ParameterReference';\r\n\r\nexport function isParameterReference(item: unknown): item is ParameterReference {\r\n    return reflection.isInstance(item, ParameterReference);\r\n}\r\n\r\nexport interface ParserRule extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'ParserRule';\r\n    dataType?: PrimitiveType\r\n    definesHiddenTokens: boolean\r\n    definition: AbstractElement\r\n    entry: boolean\r\n    fragment: boolean\r\n    hiddenTokens: Array<Reference<AbstractRule>>\r\n    inferredType?: InferredType\r\n    name: string\r\n    parameters: Array<Parameter>\r\n    returnType?: Reference<AbstractType>\r\n    wildcard: boolean\r\n}\r\n\r\nexport const ParserRule = 'ParserRule';\r\n\r\nexport function isParserRule(item: unknown): item is ParserRule {\r\n    return reflection.isInstance(item, ParserRule);\r\n}\r\n\r\nexport interface ReferenceType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'ReferenceType';\r\n    referenceType: TypeDefinition\r\n}\r\n\r\nexport const ReferenceType = 'ReferenceType';\r\n\r\nexport function isReferenceType(item: unknown): item is ReferenceType {\r\n    return reflection.isInstance(item, ReferenceType);\r\n}\r\n\r\nexport interface ReturnType extends AstNode {\r\n    readonly $container: TerminalRule;\r\n    readonly $type: 'ReturnType';\r\n    name: PrimitiveType | string\r\n}\r\n\r\nexport const ReturnType = 'ReturnType';\r\n\r\nexport function isReturnType(item: unknown): item is ReturnType {\r\n    return reflection.isInstance(item, ReturnType);\r\n}\r\n\r\nexport interface SimpleType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'SimpleType';\r\n    primitiveType?: PrimitiveType\r\n    stringType?: string\r\n    typeRef?: Reference<AbstractType>\r\n}\r\n\r\nexport const SimpleType = 'SimpleType';\r\n\r\nexport function isSimpleType(item: unknown): item is SimpleType {\r\n    return reflection.isInstance(item, SimpleType);\r\n}\r\n\r\nexport interface TerminalRule extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'TerminalRule';\r\n    definition: AbstractElement\r\n    fragment: boolean\r\n    hidden: boolean\r\n    name: string\r\n    type?: ReturnType\r\n}\r\n\r\nexport const TerminalRule = 'TerminalRule';\r\n\r\nexport function isTerminalRule(item: unknown): item is TerminalRule {\r\n    return reflection.isInstance(item, TerminalRule);\r\n}\r\n\r\nexport interface Type extends AstNode {\r\n    readonly $container: Grammar;\r\n    readonly $type: 'Type';\r\n    name: string\r\n    type: TypeDefinition\r\n}\r\n\r\nexport const Type = 'Type';\r\n\r\nexport function isType(item: unknown): item is Type {\r\n    return reflection.isInstance(item, Type);\r\n}\r\n\r\nexport interface TypeAttribute extends AstNode {\r\n    readonly $container: Interface;\r\n    readonly $type: 'TypeAttribute';\r\n    isOptional: boolean\r\n    name: FeatureName\r\n    type: TypeDefinition\r\n}\r\n\r\nexport const TypeAttribute = 'TypeAttribute';\r\n\r\nexport function isTypeAttribute(item: unknown): item is TypeAttribute {\r\n    return reflection.isInstance(item, TypeAttribute);\r\n}\r\n\r\nexport interface UnionType extends AstNode {\r\n    readonly $container: ArrayType | ReferenceType | Type | TypeAttribute | UnionType;\r\n    readonly $type: 'UnionType';\r\n    types: Array<TypeDefinition>\r\n}\r\n\r\nexport const UnionType = 'UnionType';\r\n\r\nexport function isUnionType(item: unknown): item is UnionType {\r\n    return reflection.isInstance(item, UnionType);\r\n}\r\n\r\nexport interface Action extends AbstractElement {\r\n    readonly $type: 'Action';\r\n    feature?: FeatureName\r\n    inferredType?: InferredType\r\n    operator?: '+=' | '='\r\n    type?: Reference<AbstractType>\r\n}\r\n\r\nexport const Action = 'Action';\r\n\r\nexport function isAction(item: unknown): item is Action {\r\n    return reflection.isInstance(item, Action);\r\n}\r\n\r\nexport interface Alternatives extends AbstractElement {\r\n    readonly $type: 'Alternatives';\r\n    elements: Array<AbstractElement>\r\n}\r\n\r\nexport const Alternatives = 'Alternatives';\r\n\r\nexport function isAlternatives(item: unknown): item is Alternatives {\r\n    return reflection.isInstance(item, Alternatives);\r\n}\r\n\r\nexport interface Assignment extends AbstractElement {\r\n    readonly $type: 'Assignment';\r\n    feature: FeatureName\r\n    operator: '+=' | '=' | '?='\r\n    terminal: AbstractElement\r\n}\r\n\r\nexport const Assignment = 'Assignment';\r\n\r\nexport function isAssignment(item: unknown): item is Assignment {\r\n    return reflection.isInstance(item, Assignment);\r\n}\r\n\r\nexport interface CharacterRange extends AbstractElement {\r\n    readonly $type: 'CharacterRange';\r\n    left: Keyword\r\n    right?: Keyword\r\n}\r\n\r\nexport const CharacterRange = 'CharacterRange';\r\n\r\nexport function isCharacterRange(item: unknown): item is CharacterRange {\r\n    return reflection.isInstance(item, CharacterRange);\r\n}\r\n\r\nexport interface CrossReference extends AbstractElement {\r\n    readonly $type: 'CrossReference';\r\n    deprecatedSyntax: boolean\r\n    terminal?: AbstractElement\r\n    type: Reference<AbstractType>\r\n}\r\n\r\nexport const CrossReference = 'CrossReference';\r\n\r\nexport function isCrossReference(item: unknown): item is CrossReference {\r\n    return reflection.isInstance(item, CrossReference);\r\n}\r\n\r\nexport interface EndOfFile extends AbstractElement {\r\n    readonly $type: 'EndOfFile';\r\n}\r\n\r\nexport const EndOfFile = 'EndOfFile';\r\n\r\nexport function isEndOfFile(item: unknown): item is EndOfFile {\r\n    return reflection.isInstance(item, EndOfFile);\r\n}\r\n\r\nexport interface Group extends AbstractElement {\r\n    readonly $type: 'Group';\r\n    elements: Array<AbstractElement>\r\n    guardCondition?: Condition\r\n}\r\n\r\nexport const Group = 'Group';\r\n\r\nexport function isGroup(item: unknown): item is Group {\r\n    return reflection.isInstance(item, Group);\r\n}\r\n\r\nexport interface Keyword extends AbstractElement {\r\n    readonly $container: CharacterRange;\r\n    readonly $type: 'Keyword';\r\n    value: string\r\n}\r\n\r\nexport const Keyword = 'Keyword';\r\n\r\nexport function isKeyword(item: unknown): item is Keyword {\r\n    return reflection.isInstance(item, Keyword);\r\n}\r\n\r\nexport interface NegatedToken extends AbstractElement {\r\n    readonly $type: 'NegatedToken';\r\n    terminal: AbstractElement\r\n}\r\n\r\nexport const NegatedToken = 'NegatedToken';\r\n\r\nexport function isNegatedToken(item: unknown): item is NegatedToken {\r\n    return reflection.isInstance(item, NegatedToken);\r\n}\r\n\r\nexport interface RegexToken extends AbstractElement {\r\n    readonly $type: 'RegexToken';\r\n    regex: string\r\n}\r\n\r\nexport const RegexToken = 'RegexToken';\r\n\r\nexport function isRegexToken(item: unknown): item is RegexToken {\r\n    return reflection.isInstance(item, RegexToken);\r\n}\r\n\r\nexport interface RuleCall extends AbstractElement {\r\n    readonly $type: 'RuleCall';\r\n    arguments: Array<NamedArgument>\r\n    rule: Reference<AbstractRule>\r\n}\r\n\r\nexport const RuleCall = 'RuleCall';\r\n\r\nexport function isRuleCall(item: unknown): item is RuleCall {\r\n    return reflection.isInstance(item, RuleCall);\r\n}\r\n\r\nexport interface TerminalAlternatives extends AbstractElement {\r\n    readonly $type: 'TerminalAlternatives';\r\n    elements: Array<AbstractElement>\r\n}\r\n\r\nexport const TerminalAlternatives = 'TerminalAlternatives';\r\n\r\nexport function isTerminalAlternatives(item: unknown): item is TerminalAlternatives {\r\n    return reflection.isInstance(item, TerminalAlternatives);\r\n}\r\n\r\nexport interface TerminalGroup extends AbstractElement {\r\n    readonly $type: 'TerminalGroup';\r\n    elements: Array<AbstractElement>\r\n}\r\n\r\nexport const TerminalGroup = 'TerminalGroup';\r\n\r\nexport function isTerminalGroup(item: unknown): item is TerminalGroup {\r\n    return reflection.isInstance(item, TerminalGroup);\r\n}\r\n\r\nexport interface TerminalRuleCall extends AbstractElement {\r\n    readonly $type: 'TerminalRuleCall';\r\n    rule: Reference<TerminalRule>\r\n}\r\n\r\nexport const TerminalRuleCall = 'TerminalRuleCall';\r\n\r\nexport function isTerminalRuleCall(item: unknown): item is TerminalRuleCall {\r\n    return reflection.isInstance(item, TerminalRuleCall);\r\n}\r\n\r\nexport interface UnorderedGroup extends AbstractElement {\r\n    readonly $type: 'UnorderedGroup';\r\n    elements: Array<AbstractElement>\r\n}\r\n\r\nexport const UnorderedGroup = 'UnorderedGroup';\r\n\r\nexport function isUnorderedGroup(item: unknown): item is UnorderedGroup {\r\n    return reflection.isInstance(item, UnorderedGroup);\r\n}\r\n\r\nexport interface UntilToken extends AbstractElement {\r\n    readonly $type: 'UntilToken';\r\n    terminal: AbstractElement\r\n}\r\n\r\nexport const UntilToken = 'UntilToken';\r\n\r\nexport function isUntilToken(item: unknown): item is UntilToken {\r\n    return reflection.isInstance(item, UntilToken);\r\n}\r\n\r\nexport interface Wildcard extends AbstractElement {\r\n    readonly $type: 'Wildcard';\r\n}\r\n\r\nexport const Wildcard = 'Wildcard';\r\n\r\nexport function isWildcard(item: unknown): item is Wildcard {\r\n    return reflection.isInstance(item, Wildcard);\r\n}\r\n\r\nexport type LangiumGrammarAstType = {\r\n    AbstractElement: AbstractElement\r\n    AbstractRule: AbstractRule\r\n    AbstractType: AbstractType\r\n    Action: Action\r\n    Alternatives: Alternatives\r\n    ArrayType: ArrayType\r\n    Assignment: Assignment\r\n    CharacterRange: CharacterRange\r\n    Condition: Condition\r\n    Conjunction: Conjunction\r\n    CrossReference: CrossReference\r\n    Disjunction: Disjunction\r\n    EndOfFile: EndOfFile\r\n    Grammar: Grammar\r\n    GrammarImport: GrammarImport\r\n    Group: Group\r\n    InferredType: InferredType\r\n    Interface: Interface\r\n    Keyword: Keyword\r\n    LiteralCondition: LiteralCondition\r\n    NamedArgument: NamedArgument\r\n    NegatedToken: NegatedToken\r\n    Negation: Negation\r\n    Parameter: Parameter\r\n    ParameterReference: ParameterReference\r\n    ParserRule: ParserRule\r\n    ReferenceType: ReferenceType\r\n    RegexToken: RegexToken\r\n    ReturnType: ReturnType\r\n    RuleCall: RuleCall\r\n    SimpleType: SimpleType\r\n    TerminalAlternatives: TerminalAlternatives\r\n    TerminalGroup: TerminalGroup\r\n    TerminalRule: TerminalRule\r\n    TerminalRuleCall: TerminalRuleCall\r\n    Type: Type\r\n    TypeAttribute: TypeAttribute\r\n    TypeDefinition: TypeDefinition\r\n    UnionType: UnionType\r\n    UnorderedGroup: UnorderedGroup\r\n    UntilToken: UntilToken\r\n    Wildcard: Wildcard\r\n}\r\n\r\nexport class LangiumGrammarAstReflection extends AbstractAstReflection {\r\n\r\n    getAllTypes(): string[] {\r\n        return ['AbstractElement', 'AbstractRule', 'AbstractType', 'Action', 'Alternatives', 'ArrayType', 'Assignment', 'CharacterRange', 'Condition', 'Conjunction', 'CrossReference', 'Disjunction', 'EndOfFile', 'Grammar', 'GrammarImport', 'Group', 'InferredType', 'Interface', 'Keyword', 'LiteralCondition', 'NamedArgument', 'NegatedToken', 'Negation', 'Parameter', 'ParameterReference', 'ParserRule', 'ReferenceType', 'RegexToken', 'ReturnType', 'RuleCall', 'SimpleType', 'TerminalAlternatives', 'TerminalGroup', 'TerminalRule', 'TerminalRuleCall', 'Type', 'TypeAttribute', 'TypeDefinition', 'UnionType', 'UnorderedGroup', 'UntilToken', 'Wildcard'];\r\n    }\r\n\r\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\r\n        switch (subtype) {\r\n            case Action: {\r\n                return this.isSubtype(AbstractElement, supertype) || this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case Alternatives:\r\n            case Assignment:\r\n            case CharacterRange:\r\n            case CrossReference:\r\n            case EndOfFile:\r\n            case Group:\r\n            case Keyword:\r\n            case NegatedToken:\r\n            case RegexToken:\r\n            case RuleCall:\r\n            case TerminalAlternatives:\r\n            case TerminalGroup:\r\n            case TerminalRuleCall:\r\n            case UnorderedGroup:\r\n            case UntilToken:\r\n            case Wildcard: {\r\n                return this.isSubtype(AbstractElement, supertype);\r\n            }\r\n            case ArrayType:\r\n            case ReferenceType:\r\n            case SimpleType:\r\n            case UnionType: {\r\n                return this.isSubtype(TypeDefinition, supertype);\r\n            }\r\n            case Conjunction:\r\n            case Disjunction:\r\n            case LiteralCondition:\r\n            case Negation:\r\n            case ParameterReference: {\r\n                return this.isSubtype(Condition, supertype);\r\n            }\r\n            case Interface:\r\n            case Type: {\r\n                return this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case ParserRule: {\r\n                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);\r\n            }\r\n            case TerminalRule: {\r\n                return this.isSubtype(AbstractRule, supertype);\r\n            }\r\n            default: {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    getReferenceType(refInfo: ReferenceInfo): string {\r\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\r\n        switch (referenceId) {\r\n            case 'Action:type':\r\n            case 'CrossReference:type':\r\n            case 'Interface:superTypes':\r\n            case 'ParserRule:returnType':\r\n            case 'SimpleType:typeRef': {\r\n                return AbstractType;\r\n            }\r\n            case 'Grammar:hiddenTokens':\r\n            case 'ParserRule:hiddenTokens':\r\n            case 'RuleCall:rule': {\r\n                return AbstractRule;\r\n            }\r\n            case 'Grammar:usedGrammars': {\r\n                return Grammar;\r\n            }\r\n            case 'NamedArgument:parameter':\r\n            case 'ParameterReference:parameter': {\r\n                return Parameter;\r\n            }\r\n            case 'TerminalRuleCall:rule': {\r\n                return TerminalRule;\r\n            }\r\n            default: {\r\n                throw new Error(`${referenceId} is not a valid reference id.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    getTypeMetaData(type: string): TypeMetaData {\r\n        switch (type) {\r\n            case 'Grammar': {\r\n                return {\r\n                    name: 'Grammar',\r\n                    mandatory: [\r\n                        { name: 'definesHiddenTokens', type: 'boolean' },\r\n                        { name: 'hiddenTokens', type: 'array' },\r\n                        { name: 'imports', type: 'array' },\r\n                        { name: 'interfaces', type: 'array' },\r\n                        { name: 'isDeclared', type: 'boolean' },\r\n                        { name: 'rules', type: 'array' },\r\n                        { name: 'types', type: 'array' },\r\n                        { name: 'usedGrammars', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'Interface': {\r\n                return {\r\n                    name: 'Interface',\r\n                    mandatory: [\r\n                        { name: 'attributes', type: 'array' },\r\n                        { name: 'superTypes', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'LiteralCondition': {\r\n                return {\r\n                    name: 'LiteralCondition',\r\n                    mandatory: [\r\n                        { name: 'true', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'NamedArgument': {\r\n                return {\r\n                    name: 'NamedArgument',\r\n                    mandatory: [\r\n                        { name: 'calledByName', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'ParserRule': {\r\n                return {\r\n                    name: 'ParserRule',\r\n                    mandatory: [\r\n                        { name: 'definesHiddenTokens', type: 'boolean' },\r\n                        { name: 'entry', type: 'boolean' },\r\n                        { name: 'fragment', type: 'boolean' },\r\n                        { name: 'hiddenTokens', type: 'array' },\r\n                        { name: 'parameters', type: 'array' },\r\n                        { name: 'wildcard', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'TerminalRule': {\r\n                return {\r\n                    name: 'TerminalRule',\r\n                    mandatory: [\r\n                        { name: 'fragment', type: 'boolean' },\r\n                        { name: 'hidden', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'TypeAttribute': {\r\n                return {\r\n                    name: 'TypeAttribute',\r\n                    mandatory: [\r\n                        { name: 'isOptional', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'UnionType': {\r\n                return {\r\n                    name: 'UnionType',\r\n                    mandatory: [\r\n                        { name: 'types', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'Alternatives': {\r\n                return {\r\n                    name: 'Alternatives',\r\n                    mandatory: [\r\n                        { name: 'elements', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'CrossReference': {\r\n                return {\r\n                    name: 'CrossReference',\r\n                    mandatory: [\r\n                        { name: 'deprecatedSyntax', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'Group': {\r\n                return {\r\n                    name: 'Group',\r\n                    mandatory: [\r\n                        { name: 'elements', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'RuleCall': {\r\n                return {\r\n                    name: 'RuleCall',\r\n                    mandatory: [\r\n                        { name: 'arguments', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'TerminalAlternatives': {\r\n                return {\r\n                    name: 'TerminalAlternatives',\r\n                    mandatory: [\r\n                        { name: 'elements', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'TerminalGroup': {\r\n                return {\r\n                    name: 'TerminalGroup',\r\n                    mandatory: [\r\n                        { name: 'elements', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'UnorderedGroup': {\r\n                return {\r\n                    name: 'UnorderedGroup',\r\n                    mandatory: [\r\n                        { name: 'elements', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            default: {\r\n                return {\r\n                    name: type,\r\n                    mandatory: []\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const reflection = new LangiumGrammarAstReflection();\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Range } from 'vscode-languageserver';\r\nimport type { AstNode, AstReflection, CstNode, GenericAstNode, Reference, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { Stream, TreeStream } from '../utils/stream.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { isAstNode, isReference } from '../syntax-tree.js';\r\nimport { DONE_RESULT, stream, StreamImpl, TreeStreamImpl } from '../utils/stream.js';\r\nimport { inRange } from './cst-util.js';\r\n\r\nexport type Mutable<T> = {\r\n    -readonly [P in keyof T]: T[P]\r\n};\r\n\r\n/**\r\n * Link the `$container` and other related properties of every AST node that is directly contained\r\n * in the given `node`.\r\n */\r\nexport function linkContentToContainer(node: AstNode): void {\r\n    for (const [name, value] of Object.entries(node)) {\r\n        if (!name.startsWith('$')) {\r\n            if (Array.isArray(value)) {\r\n                value.forEach((item, index) => {\r\n                    if (isAstNode(item)) {\r\n                        (item as Mutable<AstNode>).$container = node;\r\n                        (item as Mutable<AstNode>).$containerProperty = name;\r\n                        (item as Mutable<AstNode>).$containerIndex = index;\r\n                    }\r\n                });\r\n            } else if (isAstNode(value)) {\r\n                (value as Mutable<AstNode>).$container = node;\r\n                (value as Mutable<AstNode>).$containerProperty = name;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Walk along the hierarchy of containers from the given AST node to the root and return the first\r\n * node that matches the type predicate. If the start node itself matches, it is returned.\r\n * If no container matches, `undefined` is returned.\r\n */\r\nexport function getContainerOfType<T extends AstNode>(node: AstNode | undefined, typePredicate: (n: AstNode) => n is T): T | undefined {\r\n    let item = node;\r\n    while (item) {\r\n        if (typePredicate(item)) {\r\n            return item;\r\n        }\r\n        item = item.$container;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Walk along the hierarchy of containers from the given AST node to the root and check for existence\r\n * of a container that matches the given predicate. The start node is included in the checks.\r\n */\r\nexport function hasContainerOfType(node: AstNode | undefined, predicate: (n: AstNode) => boolean): boolean {\r\n    let item = node;\r\n    while (item) {\r\n        if (predicate(item)) {\r\n            return true;\r\n        }\r\n        item = item.$container;\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Retrieve the document in which the given AST node is contained. A reference to the document is\r\n * usually held by the root node of the AST.\r\n *\r\n * @throws an error if the node is not contained in a document.\r\n */\r\nexport function getDocument<T extends AstNode = AstNode>(node: AstNode): LangiumDocument<T> {\r\n    const rootNode = findRootNode(node);\r\n    const result = rootNode.$document;\r\n    if (!result) {\r\n        throw new Error('AST node has no document.');\r\n    }\r\n    return result as LangiumDocument<T>;\r\n}\r\n\r\n/**\r\n * Returns the root node of the given AST node by following the `$container` references.\r\n */\r\nexport function findRootNode(node: AstNode): AstNode {\r\n    while (node.$container) {\r\n        node = node.$container;\r\n    }\r\n    return node;\r\n}\r\n\r\nexport interface AstStreamOptions {\r\n    /**\r\n     * Optional target range that the nodes in the stream need to intersect\r\n     */\r\n    range?: Range\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly contained in the given node. This includes\r\n * single-valued as well as multi-valued (array) properties.\r\n */\r\nexport function streamContents(node: AstNode, options?: AstStreamOptions): Stream<AstNode> {\r\n    if (!node) {\r\n        throw new Error('Node must be an AstNode.');\r\n    }\r\n    const range = options?.range;\r\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\r\n    return new StreamImpl<State, AstNode>(() => ({\r\n        keys: Object.keys(node),\r\n        keyIndex: 0,\r\n        arrayIndex: 0\r\n    }), state => {\r\n        while (state.keyIndex < state.keys.length) {\r\n            const property = state.keys[state.keyIndex];\r\n            if (!property.startsWith('$')) {\r\n                const value = (node as GenericAstNode)[property];\r\n                if (isAstNode(value)) {\r\n                    state.keyIndex++;\r\n                    if (isAstNodeInRange(value, range)) {\r\n                        return { done: false, value };\r\n                    }\r\n                } else if (Array.isArray(value)) {\r\n                    while (state.arrayIndex < value.length) {\r\n                        const index = state.arrayIndex++;\r\n                        const element = value[index];\r\n                        if (isAstNode(element) && isAstNodeInRange(element, range)) {\r\n                            return { done: false, value: element };\r\n                        }\r\n                    }\r\n                    state.arrayIndex = 0;\r\n                }\r\n            }\r\n            state.keyIndex++;\r\n        }\r\n        return DONE_RESULT;\r\n    });\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.\r\n * This does not include the root node itself.\r\n */\r\nexport function streamAllContents(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\r\n    if (!root) {\r\n        throw new Error('Root node must be an AstNode.');\r\n    }\r\n    return new TreeStreamImpl(root, node => streamContents(node, options));\r\n}\r\n\r\n/**\r\n * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,\r\n * including the root node itself.\r\n */\r\nexport function streamAst(root: AstNode, options?: AstStreamOptions): TreeStream<AstNode> {\r\n    if (!root) {\r\n        throw new Error('Root node must be an AstNode.');\r\n    } else if (options?.range && !isAstNodeInRange(root, options.range)) {\r\n        // Return an empty stream if the root node isn't in range\r\n        return new TreeStreamImpl(root, () => []);\r\n    }\r\n    return new TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });\r\n}\r\n\r\nfunction isAstNodeInRange(astNode: AstNode, range?: Range): boolean {\r\n    if (!range) {\r\n        return true;\r\n    }\r\n    const nodeRange = astNode.$cstNode?.range;\r\n    if (!nodeRange) {\r\n        return false;\r\n    }\r\n    return inRange(nodeRange, range);\r\n}\r\n\r\n/**\r\n * Create a stream of all cross-references that are held by the given AST node. This includes\r\n * single-valued as well as multi-valued (array) properties.\r\n */\r\nexport function streamReferences(node: AstNode): Stream<ReferenceInfo> {\r\n    type State = { keys: string[], keyIndex: number, arrayIndex: number };\r\n    return new StreamImpl<State, ReferenceInfo>(() => ({\r\n        keys: Object.keys(node),\r\n        keyIndex: 0,\r\n        arrayIndex: 0\r\n    }), state => {\r\n        while (state.keyIndex < state.keys.length) {\r\n            const property = state.keys[state.keyIndex];\r\n            if (!property.startsWith('$')) {\r\n                const value = (node as GenericAstNode)[property];\r\n                if (isReference(value)) {\r\n                    state.keyIndex++;\r\n                    return { done: false, value: { reference: value, container: node, property } };\r\n                } else if (Array.isArray(value)) {\r\n                    while (state.arrayIndex < value.length) {\r\n                        const index = state.arrayIndex++;\r\n                        const element = value[index];\r\n                        if (isReference(element)) {\r\n                            return { done: false, value: { reference: element, container: node, property, index } };\r\n                        }\r\n                    }\r\n                    state.arrayIndex = 0;\r\n                }\r\n            }\r\n            state.keyIndex++;\r\n        }\r\n        return DONE_RESULT;\r\n    });\r\n}\r\n\r\n/**\r\n * Returns a Stream of references to the target node from the AstNode tree\r\n *\r\n * @param targetNode AstNode we are looking for\r\n * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value\r\n */\r\nexport function findLocalReferences(targetNode: AstNode, lookup = getDocument(targetNode).parseResult.value): Stream<Reference> {\r\n    const refs: Reference[] = [];\r\n    streamAst(lookup).forEach(node => {\r\n        streamReferences(node).forEach(refInfo => {\r\n            if (refInfo.reference.ref === targetNode) {\r\n                refs.push(refInfo.reference);\r\n            }\r\n        });\r\n    });\r\n    return stream(refs);\r\n}\r\n\r\n/**\r\n * Assigns all mandatory AST properties to the specified node.\r\n *\r\n * @param reflection Reflection object used to gather mandatory properties for the node.\r\n * @param node Specified node is modified in place and properties are directly assigned.\r\n */\r\nexport function assignMandatoryAstProperties(reflection: AstReflection, node: AstNode): void {\r\n    const typeMetaData = reflection.getTypeMetaData(node.$type);\r\n    const genericNode = node as GenericAstNode;\r\n    for (const mandatoryProperty of typeMetaData.mandatory) {\r\n        const value = genericNode[mandatoryProperty.name];\r\n        if (mandatoryProperty.type === 'array' && !Array.isArray(value)) {\r\n            genericNode[mandatoryProperty.name] = [];\r\n        } else if (mandatoryProperty.type === 'boolean' && value === undefined) {\r\n            genericNode[mandatoryProperty.name] = false;\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Creates a deep copy of the specified AST node.\r\n * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.\r\n *\r\n * References are copied without resolved cross reference. The specified function is used to rebuild them.\r\n */\r\nexport function copyAstNode<T extends AstNode = AstNode>(node: T, buildReference: (node: AstNode, property: string, refNode: CstNode | undefined, refText: string) => Reference<AstNode>): T {\r\n    const copy: GenericAstNode = { $type: node.$type };\r\n\r\n    for (const [name, value] of Object.entries(node)) {\r\n        if (!name.startsWith('$')) {\r\n            if (isAstNode(value)) {\r\n                copy[name] = copyAstNode(value, buildReference);\r\n            } else if (isReference(value)) {\r\n                copy[name] = buildReference(\r\n                    copy,\r\n                    name,\r\n                    value.$refNode,\r\n                    value.$refText\r\n                );\r\n            } else if (Array.isArray(value)) {\r\n                const copiedArray: unknown[] = [];\r\n                for (const element of value) {\r\n                    if (isAstNode(element)) {\r\n                        copiedArray.push(copyAstNode(element, buildReference));\r\n                    } else if (isReference(element)) {\r\n                        copiedArray.push(\r\n                            buildReference(\r\n                                copy,\r\n                                name,\r\n                                element.$refNode,\r\n                                element.$refText\r\n                            )\r\n                        );\r\n                    } else {\r\n                        copiedArray.push(element);\r\n                    }\r\n                }\r\n                copy[name] = copiedArray;\r\n            } else {\r\n                copy[name] = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    linkContentToContainer(copy);\r\n    return copy as unknown as T;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Range } from 'vscode-languageserver-textdocument';\r\nimport type { AstNodeRegionWithAssignments, AstNodeWithTextRegion } from '../serializer/json-serializer.js';\r\nimport type { AstNode, CstNode, GenericAstNode } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { findNodesForProperty } from '../utils/grammar-util.js';\r\nimport { TreeStreamImpl } from '../utils/stream.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\n\r\nexport interface TraceSourceSpec {\r\n    astNode: AstNode;\r\n    property?: string;\r\n    index?: number;\r\n}\r\n\r\nexport type SourceRegion = TextRegion | TextRegion2 | DocumentSegmentWithFileURI\r\n\r\nexport interface TextRegion {\r\n    fileURI?: string;\r\n    offset: number;\r\n    end: number;\r\n    length?: number;\r\n    range?: Range;\r\n}\r\n\r\ninterface TextRegion2 {\r\n    fileURI?: string;\r\n    offset: number;\r\n    length: number;\r\n    end?: number;\r\n    range?: Range;\r\n}\r\n\r\nexport interface TraceRegion {\r\n    sourceRegion?: TextRegion;\r\n    targetRegion: TextRegion;\r\n    children?: TraceRegion[];\r\n}\r\n\r\ninterface DocumentSegmentWithFileURI extends Omit<DocumentSegment, 'range'> {\r\n    fileURI?: string;\r\n    range?: Range;\r\n}\r\n\r\ntype SourceRegionPartial = Pick<DocumentSegmentWithFileURI, 'offset' | 'end'> & Partial<DocumentSegmentWithFileURI> // eslint-disable-next-line @typescript-eslint/indent\r\n                           | Pick<DocumentSegmentWithFileURI, 'offset' | 'length'> & Partial<DocumentSegmentWithFileURI>;\r\n\r\nexport function getSourceRegion(sourceSpec: TraceSourceSpec | undefined | SourceRegion | SourceRegion[]): DocumentSegmentWithFileURI | CstNode | undefined {\r\n    if (!sourceSpec) {\r\n        return undefined;\r\n\r\n    } else if ('astNode' in sourceSpec) {\r\n        return getSourceRegionOfAstNode(sourceSpec);\r\n\r\n    } else if (Array.isArray(sourceSpec)) {\r\n        return sourceSpec.reduce( mergeDocumentSegment, undefined ); // apply mergeDocumentSegment for single entry sourcSpec lists, too, thus start with 'undefined' as initial value\r\n\r\n    } else {\r\n        // some special treatment of cstNodes for revealing the uri of the defining DSL text file\r\n        //  is currently only done for single cstNode tracings, like \"expandTracedToNode(source.$cstNode)`...`\",\r\n        //  is _not done_ for multi node tracings like below, see if case above\r\n        //    joinTracedToNode( [\r\n        //        findNodeForKeyword(source.$cstNode, '{')!,\r\n        //        findNodeForKeyword(source.$cstNode, '}')!\r\n        //    ] )(source.children, c => c.name)\r\n\r\n        const sourceRegion: SourceRegionPartial = sourceSpec;\r\n\r\n        const sourceFileURIviaCstNode = isCstNode(sourceRegion)\r\n            ? getDocumentURIOrUndefined(sourceRegion?.root?.astNode ?? sourceRegion?.astNode) : undefined;\r\n\r\n        return copyDocumentSegment(sourceRegion, sourceFileURIviaCstNode);\r\n    }\r\n}\r\n\r\nfunction isCstNode(segment: object | undefined): segment is CstNode {\r\n    return typeof segment !== 'undefined'  && 'element' in segment && 'text' in segment;\r\n}\r\n\r\nfunction getDocumentURIOrUndefined(astNode: AstNode): string | undefined {\r\n    try {\r\n        return getDocument(astNode).uri.toString();\r\n    } catch (e) {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nfunction getSourceRegionOfAstNode(sourceSpec: TraceSourceSpec): DocumentSegmentWithFileURI | undefined {\r\n    const { astNode, property, index } = sourceSpec ?? {};\r\n    const textRegion: AstNodeRegionWithAssignments | undefined = astNode?.$cstNode ?? (astNode as AstNodeWithTextRegion)?.$textRegion;\r\n\r\n    if (astNode === undefined || textRegion === undefined) {\r\n        return undefined;\r\n\r\n    } else if (property === undefined) {\r\n        return copyDocumentSegment(textRegion, getDocumentURI(astNode));\r\n\r\n    } else {\r\n        const getSingleOrCompoundRegion = (regions: SourceRegion[]): SourceRegion | undefined => {\r\n            if (index !== undefined && index > -1 && Array.isArray((astNode as GenericAstNode)[property])) {\r\n                return index < regions.length ? regions[index] : undefined;\r\n\r\n            } else {\r\n                return regions.reduce(mergeDocumentSegment, undefined);\r\n            }\r\n        };\r\n\r\n        if (textRegion.assignments?.[property]) {\r\n            const region = getSingleOrCompoundRegion(\r\n                textRegion.assignments[property]\r\n            );\r\n            return region && copyDocumentSegment(region, getDocumentURI(astNode));\r\n\r\n        } else if (astNode.$cstNode) {\r\n            const region = getSingleOrCompoundRegion(\r\n                findNodesForProperty(astNode.$cstNode, property)\r\n            );\r\n            return region && copyDocumentSegment(region, getDocumentURI(astNode));\r\n\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n\r\nfunction getDocumentURI(astNode: AstNodeWithTextRegion): string | undefined {\r\n    if (astNode.$cstNode) {\r\n        return getDocument(astNode)?.uri?.toString();\r\n\r\n    } else if (astNode.$textRegion) {\r\n        return astNode.$textRegion.documentURI\r\n            || new TreeStreamImpl(astNode, n => n.$container ? [ n.$container ] : []).find( n => n.$textRegion?.documentURI )?.$textRegion?.documentURI;\r\n\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nfunction copyDocumentSegment(region: SourceRegionPartial, fileURI?: string): DocumentSegmentWithFileURI {\r\n    const result = <DocumentSegmentWithFileURI>{\r\n        offset: region.offset,\r\n        end:    region.end ?? region.offset + region.length!,\r\n        length: region.length ?? region.end! - region.offset,\r\n    };\r\n\r\n    if (region.range) {\r\n        result.range = region.range;\r\n    }\r\n\r\n    fileURI ??= region.fileURI;\r\n    if (fileURI) {\r\n        result.fileURI = fileURI;\r\n    }\r\n\r\n    return result;\r\n}\r\n\r\nfunction mergeDocumentSegment(prev: SourceRegionPartial | undefined, curr: SourceRegionPartial): DocumentSegmentWithFileURI {\r\n    if (!prev) {\r\n        return curr && copyDocumentSegment(curr);\r\n    } else if (!curr) {\r\n        return prev && copyDocumentSegment(prev);\r\n    }\r\n\r\n    const prevEnd = prev.end ?? prev.offset + prev.length!;\r\n    const currEnd = curr.end ?? curr.offset + curr.length!;\r\n    const offset = Math.min(prev.offset, curr.offset);\r\n    const end = Math.max(prevEnd, currEnd);\r\n    const length = end - offset;\r\n\r\n    const result = <DocumentSegmentWithFileURI>{\r\n        offset, end, length,\r\n    };\r\n\r\n    if (prev.range && curr.range) {\r\n        result.range = <Range>{\r\n            start: curr.range.start.line < prev.range.start.line\r\n                    || curr.range.start.line === prev.range.start.line && curr.range.start.character < prev.range.start.character\r\n                ? curr.range.start : prev.range.start,\r\n            end: curr.range.end.line > prev.range.end.line\r\n                    || curr.range.end.line === prev.range.end.line && curr.range.end.character > prev.range.end.character\r\n                ? curr.range.end : prev.range.end\r\n        };\r\n    }\r\n\r\n    if (prev.fileURI || curr.fileURI) {\r\n        const prevURI = prev.fileURI;\r\n        const currURI = curr.fileURI;\r\n        const fileURI = prevURI && currURI && prevURI !== currURI ? `<unmergable text regions of ${prevURI}, ${currURI}>` : prevURI ?? currURI;\r\n        result.fileURI = fileURI;\r\n    }\r\n    return result;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Position, Range } from 'vscode-languageserver-textdocument';\r\nimport type { GeneratorNode } from './generator-node.js';\r\nimport type { SourceRegion, TextRegion, TraceRegion } from './generator-tracing.js';\r\nimport { CompositeGeneratorNode, IndentNode, NewLineNode } from './generator-node.js';\r\nimport { getSourceRegion } from './generator-tracing.js';\r\n\r\ntype OffsetAndPosition = { offset: number } & Position\r\n\r\nclass Context {\r\n\r\n    defaultIndentation = '    ';\r\n    pendingIndent = true;\r\n    readonly currentIndents: IndentNode[] = [];\r\n    readonly recentNonImmediateIndents: IndentNode[] = [];\r\n\r\n    private traceData: InternalTraceRegion[] = [];\r\n\r\n    private lines: string[][] = [[]];\r\n    private length: number = 0;\r\n\r\n    constructor(defaultIndent?: string | number) {\r\n        if (typeof defaultIndent === 'string') {\r\n            this.defaultIndentation = defaultIndent;\r\n        } else if (typeof defaultIndent === 'number') {\r\n            this.defaultIndentation = ''.padStart(defaultIndent);\r\n        }\r\n    }\r\n\r\n    get content(): string {\r\n        return this.lines.map(e => e.join('')).join('');\r\n    }\r\n\r\n    get contentLength(): number {\r\n        return this.length;\r\n    }\r\n\r\n    get currentLineNumber(): number {\r\n        return this.lines.length - 1;\r\n    }\r\n\r\n    get currentLineContent(): string {\r\n        return this.lines[this.currentLineNumber].join('');\r\n    }\r\n\r\n    get currentPosition(): OffsetAndPosition {\r\n        return {\r\n            offset: this.contentLength,\r\n            line: this.currentLineNumber,\r\n            character: this.currentLineContent.length\r\n        };\r\n    }\r\n\r\n    append(value: string, isIndent?: boolean) {\r\n        if (value.length > 0) {\r\n            const beforePos = isIndent && this.currentPosition;\r\n            this.lines[this.currentLineNumber].push(value);\r\n            this.length += value.length;\r\n            if (beforePos) {\r\n                this.indentPendingTraceRegions(beforePos);\r\n            }\r\n        }\r\n    }\r\n\r\n    private indentPendingTraceRegions(before: OffsetAndPosition) {\r\n        for (let i = this.traceData.length - 1; i >= 0; i--) {\r\n            const tr = this.traceData[i];\r\n            if (tr.targetStart && tr.targetStart.offset === before.offset /* tr.targetStart.line == before.line && tr.targetStart.character === before.character*/)\r\n                tr.targetStart = this.currentPosition;\r\n        }\r\n    }\r\n\r\n    increaseIndent(node: IndentNode) {\r\n        this.currentIndents.push(node);\r\n        if (!node.indentImmediately) {\r\n            this.recentNonImmediateIndents.push(node);\r\n        }\r\n    }\r\n\r\n    decreaseIndent() {\r\n        this.currentIndents.pop();\r\n    }\r\n\r\n    get relevantIndents() {\r\n        return this.currentIndents.filter(i => !this.recentNonImmediateIndents.includes(i));\r\n    }\r\n\r\n    resetCurrentLine() {\r\n        this.length -= this.lines[this.currentLineNumber].join('').length;\r\n        this.lines[this.currentLineNumber] = [];\r\n        this.pendingIndent = true;\r\n    }\r\n\r\n    addNewLine() {\r\n        this.pendingIndent = true;\r\n        this.lines.push([]);\r\n        this.recentNonImmediateIndents.length = 0;\r\n    }\r\n\r\n    pushTraceRegion(sourceRegion: SourceRegion | undefined): InternalTraceRegion {\r\n        const region = createTraceRegion(\r\n            sourceRegion,\r\n            this.currentPosition,\r\n            it => this.traceData[this.traceData.length - 1]?.children?.push(it));\r\n        this.traceData.push(region);\r\n        return region;\r\n    }\r\n\r\n    popTraceRegion(expected: TraceRegion): InternalTraceRegion {\r\n        const traceRegion = this.traceData.pop()!;\r\n        // the following assertion can be dropped once the tracing is considered stable\r\n        this.assertTrue(traceRegion === expected, 'Trace region mismatch!');\r\n\r\n        return traceRegion;\r\n    }\r\n\r\n    getParentTraceSourceFileURI() {\r\n        for (let i = this.traceData.length - 1; i > -1; i--) {\r\n            const fileUri = this.traceData[i].sourceRegion?.fileURI;\r\n            if (fileUri)\r\n                return fileUri;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private assertTrue(condition: boolean, msg: string): asserts condition is true {\r\n        if (!condition) {\r\n            throw new Error(msg);\r\n        }\r\n    }\r\n}\r\n\r\ninterface InternalTraceRegion extends TraceRegion {\r\n    targetStart?: OffsetAndPosition;\r\n    complete?: (targetEnd: OffsetAndPosition) => TraceRegion;\r\n}\r\n\r\nfunction createTraceRegion(sourceRegion: SourceRegion | undefined, targetStart: OffsetAndPosition, accept: (it: TraceRegion) => void): TraceRegion {\r\n    const result = <InternalTraceRegion>{\r\n        sourceRegion,\r\n        targetRegion: undefined!,\r\n        children: [],\r\n        targetStart,\r\n        complete: (targetEnd: OffsetAndPosition) => {\r\n            result.targetRegion = <TextRegion>{\r\n                offset: result.targetStart!.offset,\r\n                end: targetEnd.offset,\r\n                length: targetEnd.offset - result.targetStart!.offset,\r\n                range: <Range>{\r\n                    start: {\r\n                        line: result.targetStart!.line,\r\n                        character: result.targetStart!.character\r\n                    },\r\n                    end: {\r\n                        line: targetEnd.line,\r\n                        character: targetEnd.character\r\n                    },\r\n                }\r\n            };\r\n            delete result.targetStart;\r\n            if (result.children?.length === 0) {\r\n                delete result.children;\r\n            }\r\n            if (result.targetRegion?.length) {\r\n                accept(result);\r\n            }\r\n            delete result.complete;\r\n            return result;\r\n        }\r\n    };\r\n    return result;\r\n}\r\n\r\nexport function processGeneratorNode(node: GeneratorNode, defaultIndentation?: string | number): { text: string, trace: TraceRegion } {\r\n    const context = new Context(defaultIndentation);\r\n    const trace = context.pushTraceRegion(undefined);\r\n\r\n    processNodeInternal(node, context);\r\n\r\n    context.popTraceRegion(trace);\r\n    trace.complete && trace.complete(context.currentPosition);\r\n\r\n    const singleChild = trace.children && trace.children.length === 1 ? trace.children[0] : undefined;\r\n    const singleChildTargetRegion = singleChild?.targetRegion;\r\n    const rootTargetRegion = trace.targetRegion;\r\n\r\n    if (singleChildTargetRegion && singleChild.sourceRegion\r\n            && singleChildTargetRegion.offset === rootTargetRegion.offset\r\n            && singleChildTargetRegion.length === rootTargetRegion.length) {\r\n        // some optimization:\r\n        // if (the root) `node` is traced (`singleChild.sourceRegion` !== undefined) and spans the entire `context.content`\r\n        //  we skip the wrapping root trace object created above at the beginning of this method\r\n        return { text: context.content, trace: singleChild };\r\n\r\n    } else {\r\n        return { text: context.content, trace };\r\n    }\r\n}\r\n\r\nfunction processNodeInternal(node: GeneratorNode | string, context: Context) {\r\n    if (typeof(node) === 'string') {\r\n        processStringNode(node, context);\r\n    } else if (node instanceof IndentNode) {\r\n        processIndentNode(node, context);\r\n    } else if (node instanceof CompositeGeneratorNode) {\r\n        processCompositeNode(node, context);\r\n    } else if (node instanceof NewLineNode) {\r\n        processNewLineNode(node, context);\r\n    }\r\n}\r\n\r\nfunction hasContent(node: GeneratorNode | string, ctx: Context): boolean {\r\n    if (typeof(node) === 'string') {\r\n        return node.length !== 0; // cs: do not ignore ws only content here, enclosed within other nodes it will matter!\r\n    } else if (node instanceof CompositeGeneratorNode) {\r\n        return node.contents.some(e => hasContent(e, ctx));\r\n    } else if (node instanceof NewLineNode) {\r\n        return !(node.ifNotEmpty && ctx.currentLineContent.length === 0);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction processStringNode(node: string, context: Context) {\r\n    if (node) {\r\n        if (context.pendingIndent) {\r\n            handlePendingIndent(context, false);\r\n        }\r\n        context.append(node);\r\n    }\r\n}\r\n\r\nfunction handlePendingIndent(ctx: Context, endOfLine: boolean) {\r\n    let indent = '';\r\n    for (const indentNode of ctx.relevantIndents.filter(e => e.indentEmptyLines || !endOfLine)) {\r\n        indent += indentNode.indentation ?? ctx.defaultIndentation;\r\n    }\r\n    ctx.append(indent, true);\r\n    ctx.pendingIndent = false;\r\n}\r\n\r\nfunction processCompositeNode(node: CompositeGeneratorNode, context: Context) {\r\n    let traceRegion: InternalTraceRegion | undefined = undefined;\r\n\r\n    const sourceRegion: SourceRegion | undefined = getSourceRegion(node.tracedSource);\r\n    if (sourceRegion) {\r\n        traceRegion = context.pushTraceRegion(sourceRegion);\r\n    }\r\n\r\n    for (const child of node.contents) {\r\n        processNodeInternal(child, context);\r\n    }\r\n\r\n    if (traceRegion) {\r\n        context.popTraceRegion(traceRegion);\r\n\r\n        const parentsFileURI = context.getParentTraceSourceFileURI();\r\n        if (parentsFileURI && sourceRegion?.fileURI === parentsFileURI) {\r\n            // if some parent's sourceRegion refers to the same source file uri (and no other source file was referenced inbetween)\r\n            // we can drop the file uri in order to reduce repeated strings\r\n            delete sourceRegion.fileURI;\r\n        }\r\n\r\n        traceRegion.complete && traceRegion.complete(context.currentPosition);\r\n    }\r\n}\r\n\r\nfunction processIndentNode(node: IndentNode, context: Context) {\r\n    if (hasContent(node, context)) {\r\n        if (node.indentImmediately && !context.pendingIndent) {\r\n            context.append(node.indentation ?? context.defaultIndentation, true);\r\n        }\r\n        try {\r\n            context.increaseIndent(node);\r\n            processCompositeNode(node, context);\r\n        } finally {\r\n            context.decreaseIndent();\r\n        }\r\n    }\r\n}\r\n\r\nfunction processNewLineNode(node: NewLineNode, context: Context) {\r\n    if (node.ifNotEmpty && !hasNonWhitespace(context.currentLineContent)) {\r\n        context.resetCurrentLine();\r\n    } else {\r\n        if (context.pendingIndent) {\r\n            handlePendingIndent(context, true);\r\n        }\r\n        context.append(node.lineDelimiter);\r\n        context.addNewLine();\r\n    }\r\n}\r\n\r\nfunction hasNonWhitespace(text: string) {\r\n    return text.trimStart() !== '';\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { EOL, toString } from './generator-node.js';\r\n\r\nexport function expandToStringWithNL(staticParts: TemplateStringsArray, ...substitutions: unknown[]): string {\r\n    return expandToString(staticParts, ...substitutions) + EOL;\r\n}\r\n\r\nexport function expandToStringLFWithNL(staticParts: TemplateStringsArray, ...substitutions: unknown[]): string {\r\n    return expandToStringLF(staticParts, ...substitutions) + '\\n';\r\n}\r\n\r\n/**\r\n * A tag function that automatically aligns embedded multiline strings.\r\n * Multiple lines are joined with the platform-specific line separator.\r\n *\r\n * @param staticParts the static parts of a tagged template literal\r\n * @param substitutions the variable parts of a tagged template literal\r\n * @returns an aligned string that consists of the given parts\r\n */\r\nexport function expandToString(staticParts: TemplateStringsArray, ...substitutions: unknown[]): string {\r\n    return internalExpandToString(EOL, staticParts, ...substitutions);\r\n}\r\n\r\n/**\r\n * A tag function that automatically aligns embedded multiline strings.\r\n * Multiple lines are joined with the LINE_FEED (`\\n`) line separator.\r\n *\r\n * @param staticParts the static parts of a tagged template literal\r\n * @param substitutions the variable parts of a tagged template literal\r\n * @returns an aligned string that consists of the given parts\r\n */\r\nexport function expandToStringLF(staticParts: TemplateStringsArray, ...substitutions: unknown[]): string {\r\n    return internalExpandToString('\\n', staticParts, ...substitutions);\r\n}\r\n\r\nfunction internalExpandToString(lineSep: string, staticParts: TemplateStringsArray, ...substitutions: unknown[]): string {\r\n    let lines = substitutions\r\n        // align substitutions and fuse them with static parts\r\n        .reduce((acc: string, subst: unknown, i: number) => acc + (subst === undefined ? SNLE : align(toString(subst), acc)) + (staticParts[i + 1] ?? ''), staticParts[0])\r\n        // converts text to lines\r\n        .split(NEWLINE_REGEXP)\r\n        .filter(l => l.trim() !== SNLE)\r\n        // whitespace-only lines are empty (preserving leading whitespace)\r\n        .map(l => l.replace(SNLE, '').trimRight());\r\n\r\n    // in order to nicely handle single line templates with the leading and trailing termintators (``) on separate lines, like\r\n    //   expandToString`foo\r\n    //   `,\r\n    //   expandToString`\r\n    //      foo\r\n    //   `,\r\n    //   expandToString`\r\n    //      foo`,\r\n    // the same way as true single line templates like\r\n    //   expandToString`foo`\r\n    // ...\r\n\r\n    // ... drop initial linebreak if the first line is empty or contains white space only, ...\r\n    const containsLeadingLinebreak = lines.length > 1 && lines[0].trim().length === 0;\r\n    lines = containsLeadingLinebreak ? lines.slice(1) : lines;\r\n\r\n    // .. and drop the last linebreak if it's the last charactor or is followed by white space\r\n    const containsTrailingLinebreak = lines.length !== 0 && lines[lines.length-1].trimRight().length === 0;\r\n    lines = containsTrailingLinebreak ? lines.slice(0, lines.length-1) : lines;\r\n\r\n    // finds the minimum indentation\r\n    const indent = findIndentation(lines);\r\n    return lines\r\n        // shifts lines to the left\r\n        .map(line => line.slice(indent).trimEnd())\r\n        // convert lines to string\r\n        .join(lineSep);\r\n}\r\n\r\nexport const SNLE = Object.freeze('__\u00ABSKIP^NEW^LINE^IF^EMPTY\u00BB__');\r\nexport const NEWLINE_REGEXP = /\\r?\\n/gm;\r\nconst nonWhitespace = /\\S|$/;\r\n\r\n// add the alignment of the previous static part to all lines of the following substitution\r\nfunction align(subst: string, acc: string): string {\r\n    const length = Math.max(0, acc.length - acc.lastIndexOf('\\n') - 1);\r\n    const indent = ' '.repeat(length);\r\n    return subst.replace(NEWLINE_REGEXP, EOL + indent);\r\n}\r\n\r\n// finds the indentation of a text block represented by a sequence of lines\r\nexport function findIndentation(lines: string[]): number {\r\n    const indents = lines.filter(line => line.length > 0).map(line => line.search(nonWhitespace));\r\n    const min = indents.length === 0 ? 0 : Math.min(...indents); // min(...[]) = min() = Infinity\r\n    return Math.max(0, min);\r\n}\r\n\r\nexport function normalizeEOL(input: string): string {\r\n    return input.replace(NEWLINE_REGEXP, EOL);\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode, Properties } from '../syntax-tree.js';\r\nimport type { Generated, GeneratorNode, IndentNode } from './generator-node.js';\r\nimport type { SourceRegion } from './generator-tracing.js';\r\nimport { CompositeGeneratorNode, isGeneratorNode, traceToNode } from './generator-node.js';\r\nimport { findIndentation, NEWLINE_REGEXP } from './template-string.js';\r\n\r\n/**\r\n * A tag function that attaches the template's content to a {@link CompositeGeneratorNode}.\r\n *\r\n * This is done segment by segment, and static template portions as well as substitutions\r\n * are added individually to the returned {@link CompositeGeneratorNode}.\r\n * At that common leading indentation of all the template's static parts is trimmed,\r\n * whereas additional indentations of particular lines within that static parts as well as\r\n * any line breaks and indentation within the substitutions are kept.\r\n *\r\n * For the sake of good readability and good composability of results of this function like\r\n * in the following example, the subsequent rule is applied.\r\n *\r\n * ```ts\r\n *  expandToNode`\r\n *   This is the beginning of something\r\n *\r\n *   ${foo.bar ? expandToNode`\r\n *     bla bla bla ${foo.bar}\r\n *\r\n *   `: undefined\r\n *   }\r\n *   end of template\r\n *  `\r\n * ```\r\n *\r\n * Rule:\r\n * In case of a multiline template the content of the first line including its terminating\r\n * line break is ignored, if and only if it is empty of contains whitespace only. Futhermore,\r\n * in case of a multiline template the content of the last line including its preceding line break\r\n * (last one within the template) is ignored, if and only if it is empty of contains whitespace only.\r\n * Thus, the result of all of the following invocations is identical and equal to `generatedContent`.\r\n * ```ts\r\n *  expandToNode`generatedContent`\r\n *  expandToNode`generatedContent\r\n *  `\r\n *  expandToNode`\r\n *    generatedContent`\r\n *  expandToNode`\r\n *    generatedContent\r\n *  `\r\n * ```\r\n *\r\n * In addition, a second rule is applied in the handling of line breaks:\r\n * If a line's last substitution contributes `undefined` or an object of type {@link GeneratorNode},\r\n * the subsequent line break will be appended via {@link CompositeGeneratorNode.appendNewLineIfNotEmpty}.\r\n * Hence, if all other segments of that line contribute whitespace characters only,\r\n * the entire line will be omitted while rendering the desired output.\r\n * Otherwise, linebreaks will be added via {@link CompositeGeneratorNode.appendNewLine}.\r\n * That holds in particular, if the last substitution contributes an empty string. In consequence,\r\n * adding `${''}` to the end of a line consisting of whitespace and substitions only\r\n * enforces the line break to be rendered, no matter what the substitions actually contribute.\r\n *\r\n * @param staticParts the static parts of a tagged template literal\r\n * @param substitutions the variable parts of a tagged template literal\r\n * @returns a 'CompositeGeneratorNode' containing the particular aligned lines\r\n *             after resolving and inserting the substitutions into the given parts\r\n */\r\nexport function expandToNode(staticParts: TemplateStringsArray, ...substitutions: unknown[]): CompositeGeneratorNode {\r\n    // first part: determine the common indentation of all the template lines with the substitutions being ignored\r\n    const templateProps = findIndentationAndTemplateStructure(staticParts);\r\n\r\n    // 2nd part: for all the static template parts: split them and inject a NEW_LINE marker where line breaks shall be a present in the final result,\r\n    //  and create a flatten list of strings, NEW_LINE marker occurrences, and substitutions\r\n    const splitAndMerged: GeneratedOrMarker[] = splitTemplateLinesAndMergeWithSubstitutions(staticParts, substitutions, templateProps);\r\n\r\n    // eventually, inject indentation nodes and append the segments to final desired composite generator node\r\n    return composeFinalGeneratorNode(splitAndMerged);\r\n}\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of `{astNode, property?, index: undefined}` and appending content\r\n *  in form of a template.\r\n *\r\n * This function returns a tag function that takes the desired template and does the processing\r\n *  by delegating to {@link expandToNode} and {@link traceToNode} and finally returning the\r\n *  resulting generator node.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNode(entity)`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNode<T extends AstNode>(astNode: T, property?: Properties<T>): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode;\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of `{astNode, property, index}` and appending content\r\n *  in form of a template.\r\n *\r\n * This function returns a tag function that takes the desired template and does the processing\r\n *  by delegating to {@link expandToNode} and {@link traceToNode} and finally returning the\r\n *  resulting generator node.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n *\r\n * @param index the index of the value within a list property corresponding to the appended content,\r\n *  if the property contains a list of elements, is ignored otherwise\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNode(entity, 'definitions', 0)`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNode<T extends AstNode>(astNode: T, property: Properties<T>, index?: number | undefined): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode;\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of concrete coordinates and appending content\r\n *  in form of a template. Complete coordinates are provided by the {@link AstNode AstNodes}'\r\n *  corresponding {@link AstNode.$cstNode AstNode.$cstNodes}.\r\n *\r\n * This function returns a tag function that takes the desired template and does the processing\r\n *  by delegating to {@link expandToNode} and {@link traceToNode} and finally returning the\r\n *  resulting generator node.\r\n *\r\n * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n *  if `undefined` no tracing will happen\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNode(entity.$cstNode)`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNode(sourceRegion: SourceRegion | undefined): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode;\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of a list of concrete coordinates and appending content\r\n *  in form of a template. Complete coordinates are provided by the {@link AstNode AstNodes}'\r\n *  corresponding {@link AstNode.$cstNode AstNode.$cstNodes}.\r\n *\r\n * This function returns a tag function that takes the desired template and does the processing\r\n *  by delegating to {@link expandToNode} and {@link traceToNode} and finally returning the\r\n *  resulting generator node.\r\n *\r\n * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n *  of all the contained source regions.\r\n *\r\n * @param sourceRegions a list of text regions within some file in form of concrete coordinates,\r\n *  if empty no tracing will happen\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNode([\r\n *      findNodeForKeyword(entity.$cstNode, '{')!,\r\n *      findNodeForKeyword(entity.$cstNode, '}')!\r\n *   ])`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNode(sourceRegions: SourceRegion[]): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode;\r\n\r\n// implementation:\r\nexport function expandTracedToNode<T extends AstNode>(source: T | undefined | SourceRegion | SourceRegion[], property?: Properties<T>, index?: number): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode {\r\n    return (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => {\r\n        return traceToNode(source as T, property!, index)(\r\n            expandToNode(staticParts, ...substitutions)\r\n        );\r\n    };\r\n}\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of `{astNode, property?, index: undefined}` and appending content\r\n *  in form of a template, if `condition` is equal to `true`.\r\n *\r\n * If `condition` is satisfied, this function returns a tag function that takes the desired template\r\n *  and does the processing by delegating to {@link expandToNode} and {@link traceToNode} and\r\n *  finally returning the resulting generator node. Otherwise, the returned function just returns `undefined`.\r\n *\r\n * @param condition a boolean value indicating whether to evaluate the provided template.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNodeIf(entity !== undefined, entity)`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNodeIf<T extends AstNode>(condition: boolean, astNode: T, property?: Properties<T>): // eslint-disable-next-line @typescript-eslint/indent\r\n        (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode | undefined;\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of `{astNode, property, index}` and appending content\r\n *  in form of a template, if `condition` is equal to `true`.\r\n *\r\n * If `condition` is satisfied, this function returns a tag function that takes the desired template\r\n *  and does the processing by delegating to {@link expandToNode} and {@link traceToNode} and\r\n *  finally returning the resulting generator node. Otherwise, the returned function just returns `undefined`.\r\n *\r\n * @param condition a boolean value indicating whether to evaluate the provided template.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n *\r\n * @param index the index of the value within a list property corresponding to the appended content,\r\n *  if the property contains a list of elements, is ignored otherwise\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNodeIf(entity !== undefined, entity, 'definitions', 0)`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNodeIf<T extends AstNode>(condition: boolean, astNode: T, property: Properties<T>, index: number | undefined): // eslint-disable-next-line @typescript-eslint/indent\r\n        (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode | undefined;\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of concrete coordinates and appending content in form\r\n *  of a template, if `condition` is equal to `true`. Complete coordinates are provided by\r\n *  the {@link AstNode AstNodes}' corresponding {@link AstNode.$cstNode AstNode.$cstNodes}.\r\n *\r\n * This function returns a tag function that takes the desired template and does the processing\r\n *  by delegating to {@link expandToNode} and {@link traceToNode} and finally returning the\r\n *  resulting generator node.\r\n *\r\n * If `sourceRegion` is a function supplying the corresponding region, it's only called if `condition` is satisfied.\r\n *\r\n * @param condition a boolean value indicating whether to evaluate the provided template.\r\n *\r\n * @param sourceRegion a text region within some file in form of concrete coordinates or a supplier function,\r\n *  if `undefined` no tracing will happen\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNodeIf(entity !== undefined, entity.$cstNode)`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNodeIf(condition: boolean, sourceRegion: SourceRegion | undefined | (() => SourceRegion | undefined)): // eslint-disable-next-line @typescript-eslint/indent\r\n        (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode | undefined;\r\n\r\n/**\r\n * Convenience function for creating a {@link CompositeGeneratorNode} being configured with the\r\n *  provided tracing information in form of a list of concrete coordinates and appending content\r\n *  in form of a template, if `condition` is equal to `true`. Complete coordinates are provided\r\n *  by the {@link AstNode AstNodes}' corresponding {@link AstNode.$cstNode AstNode.$cstNodes}.\r\n *\r\n * This function returns a tag function that takes the desired template and does the processing\r\n *  by delegating to {@link expandToNode} and {@link traceToNode} and finally returning the\r\n *  resulting generator node.\r\n *\r\n * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n *  of all the contained source regions.\r\n * If `sourceRegions` is a function supplying the corresponding regions, it's only called if `condition` is satisfied.\r\n *\r\n * @param condition a boolean value indicating whether to evaluate the provided template.\r\n *\r\n * @param sourceRegions a list of text regions within some file in form of concrete coordinates,\r\n *  if empty no tracing will happen\r\n *\r\n * @returns a tag function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   expandTracedToNodeIf(entity !== undefined, [\r\n *      findNodeForKeyword(entity.$cstNode, '{')!,\r\n *      findNodeForKeyword(entity.$cstNode, '}')!\r\n *   ])`\r\n *       Hello ${ traceToNode(entity, 'name')(entity.name) }\r\n *   `.appendNewLine()\r\n */\r\nexport function expandTracedToNodeIf(condition: boolean, sourceRegions: SourceRegion[]): // eslint-disable-next-line @typescript-eslint/indent\r\n        (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode | undefined;\r\n\r\n// implementation:\r\nexport function expandTracedToNodeIf<T extends AstNode>(condition: boolean, source: T | undefined | SourceRegion | SourceRegion[] | (() => undefined | SourceRegion | SourceRegion[]), property?: Properties<T>, index?: number): // eslint-disable-next-line @typescript-eslint/indent\r\n        (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => CompositeGeneratorNode | undefined {\r\n    return condition ? expandTracedToNode((typeof source === 'function' ? source() : source) as T, property!, index) : () => undefined;\r\n}\r\n\r\ntype TemplateProps = {\r\n    indentation: number;\r\n    omitFirstLine: boolean;\r\n    omitLastLine: boolean;\r\n    trimLastLine?: boolean;\r\n}\r\n\r\nfunction findIndentationAndTemplateStructure(staticParts: TemplateStringsArray): TemplateProps {\r\n    const lines = staticParts.join('_').split(NEWLINE_REGEXP);\r\n    const omitFirstLine = lines.length > 1 && lines[0].trim().length === 0;\r\n    const omitLastLine = omitFirstLine && lines.length > 1 && lines[lines.length - 1].trim().length === 0;\r\n\r\n    if (lines.length === 1 || lines.length !== 0 && lines[0].trim().length !== 0 || lines.length === 2 && lines[1].trim().length === 0) {\r\n        // for cases of non-adjusted templates like\r\n        //   const n1 = expandToNode` `;\r\n        //   const n2 = expandToNode` something `;\r\n        //   const n3 = expandToNode` something\r\n        //   `;\r\n        // ... consider the indentation to be empty, and all the leading whitespace to be relevant, except for the last (empty) line of n3!\r\n        return {\r\n            indentation: 0, //''\r\n            omitFirstLine,\r\n            omitLastLine,\r\n            trimLastLine: lines.length !== 1 && lines[lines.length - 1].trim().length === 0\r\n        };\r\n    } else {\r\n        // otherwise:\r\n        // for cases of non-adjusted templates like\r\n        //   const n4 = expandToNode` abc\r\n        //     def `;\r\n        //   const n5 = expandToNode`<maybe with some WS here>\r\n        //      abc\r\n        //     def`;\r\n        //   const n6 = expandToNode`<maybe with some WS here>\r\n        //      abc\r\n        //     def\r\n        //   `;\r\n        // ... the indentation shall be determined by the non-empty lines, excluding the last line if it contains whitespace only\r\n\r\n        // if we have a multi-line template and the first line is empty, see n5, n6\r\n        //  ignore the first line;\r\n        let sliced = omitFirstLine ? lines.slice(1) : lines;\r\n\r\n        // if there're more than one line remaining and the last one only contains WS, see n6,\r\n        //  ignore the last line\r\n        sliced = omitLastLine ? sliced.slice(0, sliced.length - 1) : sliced;\r\n\r\n        // ignore empty lines during indentation calculation, as linting rules might forbid lines containing just whitespace\r\n        sliced = sliced.filter(e => e.length !== 0);\r\n\r\n        const indentation = findIndentation(sliced);\r\n        return {\r\n            indentation,\r\n            omitFirstLine,\r\n            // in the subsequent steps omit the last line only if it is empty or if it only contains whitespace of which the common indentation is not a valid prefix;\r\n            //  in other words: keep the last line if it matches the common indentation (and maybe contains non-whitespace), a non-match may be due to mistaken usage of tabs and spaces\r\n            omitLastLine: omitLastLine && (\r\n                lines[lines.length - 1].length < indentation || !lines[lines.length - 1].startsWith(sliced[0].substring(0, indentation))\r\n            )\r\n        };\r\n    }\r\n}\r\n\r\nfunction splitTemplateLinesAndMergeWithSubstitutions(\r\n    staticParts: TemplateStringsArray, substitutions: unknown[], { indentation, omitFirstLine, omitLastLine, trimLastLine }: TemplateProps\r\n): GeneratedOrMarker[] {\r\n    const splitAndMerged: GeneratedOrMarker[] = [];\r\n    staticParts.forEach((part, i) => {\r\n        splitAndMerged.push(\r\n            ...part.split(\r\n                NEWLINE_REGEXP\r\n            ).map((e, j) => j === 0 || e.length < indentation ? e : e.substring(indentation)\r\n            ).reduce<GeneratedOrMarker[]>(\r\n                // treat the particular (potentially multiple) lines of the <i>th template segment (part),\r\n                //  s.t. all the effective lines are collected and separated by the NEWLINE node\r\n                // note: different reduce functions are provided for the initial template segment vs. the remaining segments\r\n                i === 0\r\n                    ? (result, line, j) =>\r\n                        // special handling of the initial template segment, which may contain line-breaks;\r\n                        //  suppresses the injection of unintended NEWLINE indicators for templates like\r\n                        //   expandToNode`\r\n                        //    someText\r\n                        //    ${something}\r\n                        //   `\r\n                        j === 0\r\n                            ? (omitFirstLine                    // for templates with empty first lines like above (expandToNode`\\n ...`)\r\n                                ? []                            // skip adding the initial line\r\n                                : [line]                        //  take the initial line if non-empty\r\n                            )\r\n                            : (j === 1 && result.length === 0   // when looking on the 2nd line in case the first line (in the first segment) is skipped ('result' is still empty)\r\n                                ? [line]                        // skip the insertion of the NEWLINE marker and just return the current line\r\n                                : result.concat(NEWLINE, line)  // otherwise append the NEWLINE marker and the current line\r\n                            )\r\n                    : (result, line, j) =>\r\n                        // handling of the remaining template segments\r\n                        j === 0 ? [line] : result.concat(NEWLINE, line) // except for the first line in the current segment prepend each line with NEWLINE\r\n                , [] // start with an empty array\r\n            ).filter(\r\n                e => !(typeof e === 'string' && e.length === 0)         // drop empty strings, they don't contribute anything but might confuse subsequent processing\r\n            ).concat(\r\n                // append the corresponding substitution after each segment (part),\r\n                //  note that 'substitutions[i]' will be undefined for the last segment\r\n                isGeneratorNode(substitutions[i])\r\n                    // if the substitution is a generator node, take it as it is\r\n                    ? substitutions[i] as GeneratorNode\r\n                    : substitutions[i] !== undefined\r\n                        // if the substitution is something else, convert it to a string and wrap it;\r\n                        //  allows us below to distinguish template strings from substitution (esp. empty) ones\r\n                        ? { content: String(substitutions[i]) }\r\n                        : i < substitutions.length\r\n                            // if 'substitutions[i]' is undefined and we are treating a substitution \"in the middle\"\r\n                            //   we found a substitution that is assumed to not contribute anything on purpose!\r\n                            ? UNDEFINED_SEGMENT  // add a corresponding marker, see below for details on the rational\r\n                            : []                 /* don't concat anything as we passed behind the last substitution, since 'i' enumerates the indices of 'staticParts',\r\n                                                     but 'substitutions' has one entry less and 'substitutions[staticParts.length -1 ]' will always be undefined */\r\n            )\r\n        );\r\n    });\r\n\r\n    // for templates like\r\n    //   expandToNode`\r\n    //    someText\r\n    //   `\r\n\r\n    // TODO add more documentation here\r\n\r\n    const splitAndMergedLength = splitAndMerged.length;\r\n    const lastItem = splitAndMergedLength !== 0 ? splitAndMerged[splitAndMergedLength - 1] : undefined;\r\n\r\n    if ((omitLastLine || trimLastLine) && typeof lastItem === 'string' && lastItem.trim().length === 0) {\r\n        if (omitFirstLine && splitAndMergedLength !== 1 && splitAndMerged[splitAndMergedLength - 2] === NEWLINE) {\r\n            return splitAndMerged.slice(0, splitAndMergedLength - 2);\r\n        } else {\r\n            return splitAndMerged.slice(0, splitAndMergedLength - 1);\r\n        }\r\n    } else {\r\n        return splitAndMerged;\r\n    }\r\n}\r\n\r\ntype NewLineMarker = { isNewLine: true };\r\ntype UndefinedSegmentMarker = { isUndefinedSegment: true };\r\ntype SubstitutionWrapper = { content: string };\r\n\r\nconst NEWLINE = <NewLineMarker>{ isNewLine: true };\r\nconst UNDEFINED_SEGMENT = <UndefinedSegmentMarker>{ isUndefinedSegment: true };\r\n\r\nconst isNewLineMarker = (nl: unknown): nl is NewLineMarker => nl === NEWLINE;\r\nconst isUndefinedSegmentMarker = (us: unknown): us is UndefinedSegmentMarker => us === UNDEFINED_SEGMENT;\r\nconst isSubstitutionWrapper = (s: unknown): s is SubstitutionWrapper => (s as SubstitutionWrapper).content !== undefined;\r\n\r\ntype GeneratedOrMarker = Generated | NewLineMarker | UndefinedSegmentMarker | SubstitutionWrapper;\r\n\r\nfunction composeFinalGeneratorNode(splitAndMerged: GeneratedOrMarker[]): CompositeGeneratorNode {\r\n    // in order to properly handle the indentation of nested multi-line substitutions,\r\n    //  track the length of static (string) parts per line and wrap the substitution(s) in indentation nodes, if needed\r\n    //\r\n    // of course, this only works nicely if a multi-line substitution is preceded by static string parts on the same line only;\r\n    // in case of dynamic content (with a potentially unknown length) followed by a multi-line substitution\r\n    //  the latter's indentation cannot be determined properly...\r\n    const result = splitAndMerged.reduce<{\r\n        node: CompositeGeneratorNode,\r\n        indented?: IndentNode\r\n    }>(\r\n        (res, segment, i) => isUndefinedSegmentMarker(segment)\r\n            // ignore all occurrences of UNDEFINED_SEGMENT, they are just in there for the below test\r\n            //  of 'isNewLineMarker(splitAndMerged[i-1])' not to evaluate to 'truthy' in case of consecutive lines\r\n            //  with no actual content in templates like\r\n            //   expandToNode`\r\n            //     Foo\r\n            //     ${undefined} <<----- here\r\n            //     ${undefined} <<----- and here\r\n            //\r\n            //     Bar\r\n            //   `\r\n            ? res\r\n            : isNewLineMarker(segment)\r\n                ? {\r\n                    // in case of a newLine marker append an 'ifNotEmpty' newLine by default, but\r\n                    //  append an unconditional newLine if and only if:\r\n                    //   * the template starts with the current line break, i.e. the first line is empty\r\n                    //   * the current newLine marker directly follows another one, i.e. the current line is empty\r\n                    //   * the current newline marker directly follows a substitution contributing a string (or some non-GeneratorNode being converted to a string)\r\n                    //   * the current newline marker directly follows a (template static) string that\r\n                    //      * is the initial token of the template\r\n                    //      * is the initial token of the line, maybe just indentation\r\n                    //      * follows a a substitution contributing a string (or some non-GeneratorNode being converted to a string), maybe is just irrelevant trailing whitespace\r\n                    // in particular do _not_ append an unconditional newLine if the last substitution of a line contributes 'undefined' or an instance of 'GeneratorNode'\r\n                    //  which may be a newline itself or be empty or (transitively) contain a trailing newline itself\r\n                    // node: i === 0\r\n                    //     || isNewLineMarker(splitAndMerged[i - 1]) || isSubstitutionWrapper(splitAndMerged[i - 1]) /* implies: typeof content === 'string', esp. !undefined */\r\n                    //     || typeof splitAndMerged[i - 1] === 'string' && (\r\n                    //         i === 1 || isNewLineMarker(splitAndMerged[i - 2]) || isSubstitutionWrapper(splitAndMerged[i - 2]) /* implies: typeof content === 'string', esp. !undefined */\r\n                    //     )\r\n                    //     ? res.node.appendNewLine() : res.node.appendNewLineIfNotEmpty()\r\n                    //\r\n\r\n                    // UPDATE cs: inverting the logic leads to the following, I hope I didn't miss anything:\r\n                    // in case of a newLine marker append an unconditional newLine by default, but\r\n                    //  append an 'ifNotEmpty' newLine if and only if:\r\n                    //   * the template doesn't start with a newLine marker and\r\n                    //      * the current newline marker directly follows a substitution contributing an `undefined` or an instance of 'GeneratorNode', or\r\n                    //      * the current newline marker directly follows a (template static) string (containing potentially unintended trailing whitespace)\r\n                    //          that in turn directly follows a substitution contributing an `undefined` or an instance of 'GeneratorNode'\r\n                    node: i !== 0 && (isUndefinedSegmentMarker(splitAndMerged[i - 1]) || isGeneratorNode(splitAndMerged[i - 1]))\r\n                        || i > 1 && typeof splitAndMerged[i - 1] === 'string' && (isUndefinedSegmentMarker(splitAndMerged[i - 2]) || isGeneratorNode(splitAndMerged[i - 2]))\r\n                        ? res.node.appendNewLineIfNotEmpty() : res.node.appendNewLine()\r\n                } : (() => {\r\n                    // the indentation handling is supposed to handle use cases like\r\n                    //   bla bla bla {\r\n                    //      ${foo(bar)}\r\n                    //   }\r\n                    // and\r\n                    //   bla bla bla {\r\n                    //      return ${foo(bar)}\r\n                    //   }\r\n                    // assuming that ${foo(bar)} yields a multiline result;\r\n                    // the whitespace between 'return' and '${foo(bar)}' shall not add to the indentation of '${foo(bar)}'s result!\r\n                    const indent: string = (i === 0 || isNewLineMarker(splitAndMerged[i - 1])) && typeof segment === 'string' && segment.length !== 0 ? ''.padStart(segment.length - segment.trimStart().length) : '';\r\n                    const content = isSubstitutionWrapper(segment)? segment.content : segment;\r\n                    let indented: IndentNode | undefined;\r\n                    return {\r\n                        node: res.indented\r\n                            // in case an indentNode has been registered earlier for the current line,\r\n                            //  just return 'node' without manipulation, the current segment will be added to the indentNode\r\n                            ? res.node\r\n                            // otherwise (no indentNode is registered by now)...\r\n                            : indent.length !== 0\r\n                                // in case an indentation has been identified add a non-immediate indentNode to 'node' and\r\n                                //  add the current segment (containing its the indentation) to that indentNode,\r\n                                //  and keep the indentNode in a local variable 'indented' for registering below,\r\n                                //  and return 'node'\r\n                                ? res.node.indent({ indentation: indent, indentImmediately: false, indentedChildren: ind => indented = ind.append(content) })\r\n                                // otherwise just add the content to 'node' and return it\r\n                                : res.node.append(content),\r\n                        indented:\r\n                            // if an indentNode has been created in this cycle, just register it,\r\n                            //  otherwise check for a earlier registered indentNode and add the current segment to that one\r\n                            indented ?? res.indented?.append(content),\r\n                    };\r\n                })(),\r\n        { node: new CompositeGeneratorNode() }\r\n    );\r\n\r\n    return result.node;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode, Properties } from '../syntax-tree.js';\r\nimport { isAstNode } from '../syntax-tree.js';\r\nimport type { SourceRegion, TraceRegion, TraceSourceSpec } from './generator-tracing.js';\r\nimport { processGeneratorNode } from './node-processor.js';\r\nimport { expandToNode, expandTracedToNode } from './template-node.js';\r\n\r\nexport const EOL = (typeof process === 'undefined') ? '\\n' : (process.platform === 'win32') ? '\\r\\n' : '\\n';\r\n\r\n/**\r\n * Common type of expected results of functions contributing to code generation.\r\n * Includes `undefined` for allowing contributing functions to explicitely contribute\r\n * nothing, if required, in contrast to contributing empty strings,\r\n * which facilitates better formatting of the desired output, for example.\r\n */\r\nexport type Generated = GeneratorNode | string | undefined;\r\nexport type GeneratorNode = CompositeGeneratorNode | IndentNode | NewLineNode;\r\n\r\nexport interface IndentConfig {\r\n    indentedChildren?: Generated[] | ((indented: IndentNode) => void);\r\n    indentation?: string | number;\r\n    indentEmptyLines?: boolean;\r\n    indentImmediately?: boolean;\r\n}\r\n\r\nexport function isGeneratorNode(node: unknown): node is CompositeGeneratorNode | IndentNode | NewLineNode {\r\n    return node instanceof CompositeGeneratorNode\r\n        || node instanceof IndentNode\r\n        || node instanceof NewLineNode;\r\n}\r\n\r\nexport function isNewLineNode(node: unknown): node is NewLineNode {\r\n    return node instanceof NewLineNode;\r\n}\r\n\r\n/**\r\n * Converts instances of {@link GeneratorNode} into a `string`, defaults to {@link String String(...)} for any other `input`.\r\n *\r\n * @param defaultIndentation the indentation to be applied if no explicit indentation is configured\r\n *  for particular {@link IndentNode IndentNodes}, either a `string` or a `number` of repeated single spaces,\r\n *  defaults to 4 single spaces, see {@link processGeneratorNode} -> `Context`.\r\n *\r\n * @returns the plain `string` represented by the given input.\r\n */\r\nexport function toString(input: unknown, defaultIndentation?: string | number): string {\r\n    if (isGeneratorNode(input))\r\n        return processGeneratorNode(input, defaultIndentation).text;\r\n    else\r\n        return String(input);\r\n}\r\n\r\n/**\r\n * Converts instances of {@link GeneratorNode} into `text` accompanied by a corresponding `trace`.\r\n *\r\n * @param defaultIndentation the indentation to be applied if no explicit indentation is configured\r\n *  for particular {@link IndentNode IndentNodes}, either a `string` or a `number` of repeated single spaces,\r\n *  defaults to 4 single spaces, see {@link processGeneratorNode} -> `Context`.\r\n *\r\n * @returns an object of type `{ text: string, trace: TraceRegion }` containing the desired `text` and `trace` data\r\n */\r\nexport function toStringAndTrace(input: GeneratorNode, defaultIndentation?: string | number): { text: string, trace: TraceRegion } {\r\n    return processGeneratorNode(input, defaultIndentation);\r\n}\r\n\r\n/**\r\n * Implementation of {@link GeneratorNode} serving as container for `string` segments, {@link NewLineNode newline indicators},\r\n * and further {@link CompositeGeneratorNode CompositeGeneratorNodes}, esp. {@link IndentNode IndentNodes}.\r\n *\r\n * See usage examples in the `append...` methods' documentations for details.\r\n */\r\nexport class CompositeGeneratorNode {\r\n\r\n    readonly contents: Array<(GeneratorNode | string)> = [];\r\n\r\n    tracedSource?: TraceSourceSpec | SourceRegion | SourceRegion[];\r\n\r\n    /**\r\n     * Constructor.\r\n     *\r\n     * @param content a var arg mixture of `strings` and {@link GeneratorNode GeneratorNodes}\r\n     *   describing the initial content of this {@link CompositeGeneratorNode}\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode(\r\n     *      'Hello World!', NL\r\n     *   );\r\n     */\r\n    constructor(...content: Generated[]) {\r\n        this.append(...content);\r\n    }\r\n\r\n    isEmpty(): boolean {\r\n        return this.contents.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Adds tracing information in form of `{astNode, property?, index: undefined}` to `this` generator node.\r\n     * Overwrites existing trace data, if set previously.\r\n     *\r\n     * The given data are kept as they are, the actual resolution of text positions within the DSL text\r\n     * is done at the final processing of `this` node as part of {@link toStringAndTrace()}.\r\n     *\r\n     * @param astNode the AstNode corresponding to `this` node's content\r\n     *\r\n     * @param property the value property name (string) corresponding to `this` node's content,\r\n     *  e.g. if this node's content corresponds to some `string` or `number` property; is optional\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     */\r\n    trace<T extends AstNode>(astNode: T, property?: Properties<T>): this;\r\n\r\n    /**\r\n     * Adds tracing information in form of `{astNode, property, index}` to `this` generator node.\r\n     * Overwrites existing trace data, if set previously.\r\n     *\r\n     * The given data are kept as they are, the actual resolution of text positions within the DSL text\r\n     * is done at the final processing of `this` node as part of {@link toStringAndTrace()}.\r\n     *\r\n     * @param astNode the AstNode corresponding to `this` node's content\r\n     *\r\n     * @param property the value property name (string) corresponding to `this` node's content,\r\n     *  e.g. if this node's content corresponds to some `string` or `number` property\r\n     *\r\n     * @param index the index of the value within a list property corresponding to `this` node's content,\r\n     * if the property contains a list of elements, is ignored otherwise\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     */\r\n    trace<T extends AstNode>(astNode: T, property: Properties<T>, index: number | undefined): this;\r\n\r\n    /**\r\n     * Adds tracing information in form of concrete coordinates to `this` generator node. Complete coordinates\r\n     * are provided by the {@link AstNode AstNodes}' corresponding {@link AstNode.$cstNode AstNode.$cstNodes}.\r\n     * Overwrites existing trace data, if set previously.\r\n     *\r\n     * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n     *  if `undefined` no tracing will happen\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     */\r\n    trace(sourceRegion: SourceRegion | undefined): this;\r\n\r\n    /**\r\n     * Adds tracing information in form of a list of concrete coordinates to `this` generator node.\r\n     * Overwrites existing trace data, if set previously.\r\n     *\r\n     * The list of regions in `sourceRegion` is reduced to the smallest encompassing region\r\n     *  of all the contained source regions.\r\n     *\r\n     * @param sourceRegion a list of text regions within some file in form of concrete coordinates,\r\n     *  if empty no tracing will happen\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     */\r\n    trace(sourceRegion: SourceRegion[]): this;\r\n\r\n    trace<T extends AstNode>(source: T | undefined | SourceRegion | SourceRegion[], property?: Properties<T>, index?: number): this {\r\n        if (isAstNode(source)) {\r\n            this.tracedSource = <TraceSourceSpec>{ astNode: source, property, index };\r\n            if (this.tracedSource.property === undefined && this.tracedSource.index !== undefined && this.tracedSource.index > -1) {\r\n                throw new Error(\"Generation support: 'property' argument must not be 'undefined' if a non-negative value is assigned to 'index' in 'CompositeGeneratorNode.trace(...)'.\");\r\n            }\r\n        } else {\r\n            this.tracedSource = source;\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Appends `strings` and instances of {@link GeneratorNode} to `this` generator node.\r\n     *\r\n     * @param content a var arg mixture of `strings`, {@link GeneratorNode GeneratorNodes}, or single param\r\n     *  functions that are immediately called with `this` node as argument, and which may append elements themselves.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().append(\r\n     *      'Hello', ' ', `${name}!`, NL, someOtherNode, 'NL', node => generateContent(node)\r\n     *   ).append(\r\n     *      'The end!'\r\n     *   );\r\n     */\r\n    append(...content: Array<Generated | ((node: this) => void)>): this {\r\n        for (const arg of content) {\r\n            if (typeof arg === 'function') {\r\n                arg(this);\r\n            } else if (arg) {\r\n                this.contents.push(arg);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Appends `strings` and instances of {@link GeneratorNode} to `this` generator node, if `condition` is equal to `true`.\r\n     *\r\n     * If `condition` is satisfied this method delegates to {@link append}, otherwise it returns just `this`.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the elements of `args` to `this`.\r\n     *\r\n     * @param content a var arg mixture of `strings`, {@link GeneratorNode GeneratorNodes}, or single param\r\n     *  functions that are immediately called with `this` node as argument, and which may append elements themselves.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().append(\r\n     *      'Hello World!'\r\n     *   ).appendNewLine().appendIf(\r\n     *      entity !== undefined, `Hello ${entity?.name}!`\r\n     *   ).appendNewLineIfNotEmpty();\r\n     */\r\n    appendIf(condition: boolean, ...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>): this {\r\n        return condition ? this.append(...content) : this;\r\n    }\r\n\r\n    /**\r\n     * Appends a strict {@link NewLineNode} to `this` node.\r\n     * Strict {@link NewLineNode}s yield mandatory linebreaks in the derived generated text.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().append(\r\n     *      'Hello World!'\r\n     *   ).appendNewLine();\r\n     */\r\n    appendNewLine(): this {\r\n        return this.append(NL);\r\n    }\r\n\r\n    /**\r\n     * Appends a strict {@link NewLineNode} to `this` node, if `condition` is equal to `true`.\r\n     * Strict {@link NewLineNode}s yield mandatory linebreaks in the derived generated text.\r\n     *\r\n     * @param condition a boolean value indicating whether to append a {@link NewLineNode} to `this`.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().append(\r\n     *      'Hello World!'\r\n     *   ).appendNewLineIf(entity !== undefined).appendIf(\r\n     *      entity !== undefined, `Hello ${entity?.name}!`\r\n     *   )\r\n     */\r\n    appendNewLineIf(condition: boolean): this {\r\n        return condition ? this.append(NL) : this;\r\n    }\r\n\r\n    /**\r\n     * Appends a soft {@link NewLineNode} to `this` node.\r\n     * Soft {@link NewLineNode}s yield linebreaks in the derived generated text only if the preceding line is non-empty,\r\n     * i.e. there are non-whitespace characters added to the generated text since the last linebreak.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendIf(\r\n     *      entity !== undefined, `Hello ${entity?.name}!`\r\n     *   ).appendNewLineIfNotEmpty();\r\n     */\r\n    appendNewLineIfNotEmpty(): this {\r\n        return this.append(NLEmpty);\r\n    }\r\n\r\n    /**\r\n     * Appends a soft {@link NewLineNode} to `this` node, if `condition` is equal to `true`.\r\n     * Soft {@link NewLineNode}s yield linebreaks in the derived generated text only if the preceding line is non-empty,\r\n     * i.e. there are non-whitespace characters added to the generated text since the last linebreak.\r\n     *\r\n     * @param condition a boolean value indicating whether to append a {@link NewLineNode} to `this`.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().append(\r\n     *      entity.label ?? ''\r\n     *   ).appendNewLineIfNotEmptyIf(entity.description !== undefined).append(\r\n     *      entity.description\r\n     *   )\r\n     */\r\n    appendNewLineIfNotEmptyIf(condition: boolean): this {\r\n        return condition ? this.appendNewLineIfNotEmpty() : this;\r\n    }\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generation node.\r\n     *\r\n     * See {@link expandToNode} for details.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine()\r\n     */\r\n    appendTemplate(staticParts: TemplateStringsArray, ...substitutions: unknown[]): this {\r\n        return this.append(\r\n            expandToNode(staticParts, ...substitutions)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the tagged template delegates to {@link appendTemplate}, otherwise it returns just `this`.\r\n     *\r\n     * See {@link expandToNode} for details.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTemplateIf(entity !== undefined)\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTemplateIf(condition: boolean): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this {\r\n        return condition ? (staticParts, ...substitutions) => this.appendTemplate(staticParts, ...substitutions) : () => this;\r\n    }\r\n\r\n    /**\r\n     * Adds an area of indented text output.\r\n     * The content to be indented can be provided as an array consisting of strings and/or generation nodes\r\n     * (undefined is permitted), or via a callback offering the `indentingNode` to which the content shall be appended.\r\n     * Alternatively, an object satisfying {@link IndentConfig} can be provided taking the children as Array or via\r\n     * a callback as described previously via the `indentedChildren` property.\r\n     *\r\n     * The remaining properties of {@link IndentConfig} have the following effects:\r\n     *  - `indentation`: a specific indentation length or string, defaults to the global indentation setting if omitted, see {@link toString},\r\n     *  - `indentEmptyLines`: apply indentation to empty lines, defaults to `false`\r\n     *  - `indentImmediately`: apply the indentation immediately starting at the first line, defaults to `true`, might be set to `false`\r\n     *    if preceding content is not terminated by any `newline`. If `false` the indentation is inserted only after child `newline` nodes\r\n     *    followed by further content.\r\n     *\r\n     * @param childrenOrConfig an {@link Array} or callback contributing the children, or a config object satisfying {@link IndentConfig} alternatively.\r\n     *\r\n     * @returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().append(\r\n     *       '{'\r\n     *   ).indent(indentingNode =>\r\n     *       indentingNode.append(\r\n     *           'name:', name, ','\r\n     *       ).appendNewLine().appendIf(description !== undefined,\r\n     *           'description:', description\r\n     *       ).appendNewLineIfNotEmpty()\r\n     *   ).append(\r\n     *       '}'\r\n     *   );\r\n     */\r\n    indent(childrenOrConfig?: Generated[] | ((indented: IndentNode) => void) | IndentConfig ): this {\r\n        const { indentedChildren, indentation, indentEmptyLines, indentImmediately }: IndentConfig =\r\n            Array.isArray(childrenOrConfig) || typeof childrenOrConfig === 'function'\r\n                ? { indentedChildren: childrenOrConfig }\r\n                : typeof childrenOrConfig === 'object' ? childrenOrConfig : {};\r\n\r\n        const node = new IndentNode(indentation, indentImmediately, indentEmptyLines);\r\n        this.contents.push(node);\r\n\r\n        if (Array.isArray(indentedChildren)) {\r\n            node.append(...indentedChildren);\r\n        } else if (indentedChildren) {\r\n            node.append(indentedChildren);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     * in form of `{astNode, property?, index: undefined}`.\r\n     *\r\n     * This method returns a helper function that takes the desired `content` and does the processing.\r\n     * The returned function delegates to {@link append}, with the provided `content` being\r\n     *  wrapped by an additional {@link CompositeGeneratorNode} configured with the tracing information.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().append('Hello ').appendTraced(entity, 'name')(entity.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTraced<T extends AstNode>(astNode: T, property?: Properties<T>): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     * in form of `{astNode, property, index}`.\r\n     *\r\n     * This method returns a helper function that takes the desired `content` and does the processing.\r\n     * The returned function delegates to {@link append}, with the provided `content` being\r\n     *  wrapped by an additional {@link CompositeGeneratorNode} configured with the tracing information.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n     *\r\n     * @param index the index of the value within a list property corresponding to the appended content,\r\n     *  if the property contains a list of elements, is ignored otherwise\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().append('Hello ').appendTraced(entity, 'name')(entity.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTraced<T extends AstNode>(astNode: T, property: Properties<T>, index: number | undefined): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     * in form of concrete coordinates.\r\n     *\r\n     * This method returns a helper function that takes the desired `content` and does the processing.\r\n     * The returned function delegates to {@link append}, with the provided `content` being\r\n     *  wrapped by an additional {@link CompositeGeneratorNode} configured with the tracing information.\r\n     *\r\n     * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n     *  if `undefined` no tracing will happen\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().append('Hello ').appendTraced(findNodeForProperty(entity.$cstNode, 'name'))(entity.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTraced(sourceRegion: SourceRegion | undefined): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     * in form of a list of concrete coordinates.\r\n     *\r\n     * This method returns a helper function that takes the desired `content` and does the processing.\r\n     * The returned function delegates to {@link append}, with the provided `content` being\r\n     *  wrapped by an additional {@link CompositeGeneratorNode} configured with the tracing information.\r\n     *\r\n     * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n     *  of all the contained source regions.\r\n     *\r\n     * @param sourceRegions a list of text regions within some file in form of concrete coordinates,\r\n     *  if empty no tracing will happen\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().append('Hello ').appendTraced([ findNodeForProperty(entity.$cstNode, 'name') ])(entity.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTraced(sourceRegions: SourceRegion[]): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    // implementation:\r\n    appendTraced<T extends AstNode>(source: T | undefined | SourceRegion | SourceRegion[], property?: Properties<T>, index?: number): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this {\r\n        return content => {\r\n            return this.append(\r\n                new CompositeGeneratorNode().trace(source as T, property!, index).append(content)\r\n            );\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     *  in form of `{astNode, property?, index: undefined}`, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the returned function delegates to {@link appendTraced}, otherwise it returns just `this`.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendIf(entity !== undefined, 'Hello ').appendTracedIf(entity !== undefined, entity, 'name')(entity?.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedIf<T extends AstNode>(condition: boolean, astNode: T, property?: Properties<T>): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     *  in form of `{astNode, property, index}`, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the returned function delegates to {@link appendTraced}, otherwise it returns just `this`.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n     *\r\n     * @param index the index of the value within a list property corresponding to the appended content,\r\n     *  if the property contains a list of elements, is ignored otherwise\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendIf(entity !== undefined, 'Hello ').appendTracedIf(entity !== undefined, entity, 'name')(entity?.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedIf<T extends AstNode>(condition: boolean, astNode: T, property: Properties<T>, index: number | undefined): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     *  in form of concrete coordinates, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the returned function delegates to {@link appendTraced}, otherwise it returns just `this`.\r\n     *\r\n     * If `sourceRegion` is a function supplying the corresponding region, it's only called if `condition` is satisfied.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n     *  if `undefined` no tracing will happen\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendIf(entity !== undefined, 'Hello ').appendTracedIf(entity !== undefined, () => findNodeForProperty(entity.$cstNode, 'name'))(entity?.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedIf(condition: boolean, sourceRegion: SourceRegion | undefined | (() => SourceRegion | undefined)): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content to `this` generator node including tracing information\r\n     *  in form of a list of concrete coordinates, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the returned function delegates to {@link appendTraced}, otherwise it returns just `this`.\r\n     *\r\n     * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n     *  of all the contained source regions.\r\n     * If `sourceRegions` is a function supplying the corresponding regions, it's only called if `condition` is satisfied.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param sourceRegions a list of text regions within some file in form of concrete coordinates,\r\n     *  if empty no tracing will happen\r\n     *\r\n     * @returns a function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendIf(entity !== undefined, 'Hello ').appendTracedIf(entity !== undefined, () => [ findNodeForProperty(entity.$cstNode, 'name') ])(entity?.name)\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedIf(condition: boolean, sourceRegions: SourceRegion[] | (() => SourceRegion[])): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this;\r\n\r\n    // implementation:\r\n    appendTracedIf<T extends AstNode>(condition: boolean, source: T | undefined | SourceRegion | SourceRegion[] | (() => undefined | SourceRegion | SourceRegion[]), property?: Properties<T>, index?: number): (...content: Array<Generated | ((node: CompositeGeneratorNode) => void)>) => this {\r\n        return condition ? this.appendTraced((typeof source === 'function' ? source() : source) as T, property!, index) : () => this;\r\n    }\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing\r\n     *  information in form of `{astNode, property?, index: undefined}`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing by delegating to\r\n     * {@link expandTracedToNode}.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplate(entity, 'name')\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplate<T extends AstNode>(astNode: T, property?: Properties<T>): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing\r\n     *  information in form of `{astNode, property, index}`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing by delegating to\r\n     * {@link expandTracedToNode}.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n     *\r\n     * @param index the index of the value within a list property corresponding to the appended content,\r\n     *  if the property contains a list of elements, is ignored otherwise, is optinal\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplate(entity, 'name')\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplate<T extends AstNode>(astNode: T, property: Properties<T>, index: number | undefined): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing\r\n     *  information in form of concrete coordinates.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing by delegating to\r\n     * {@link expandTracedToNode}.\r\n     *\r\n     * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n     *  if `undefined` no tracing will happen\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplate(findNodeForProperty(entity.$cstNode, 'name'))\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplate(sourceRegion: SourceRegion | undefined): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing\r\n     *  information in form of concrete coordinates.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing by delegating to\r\n     * {@link expandTracedToNode}.\r\n     *\r\n     * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n     *  of all the contained source regions.\r\n     *\r\n     * @param sourceRegions a list of text regions within some file in form of concrete coordinates,\r\n     *  if empty no tracing will happen\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplate( findNodesForProperty(entity.$cstNode, 'name'))\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplate(sourceRegions: SourceRegion[]): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    // implementation:\r\n    appendTracedTemplate<T extends AstNode>(source: T | undefined | SourceRegion | SourceRegion[], property?: Properties<T>, index?: number): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this {\r\n        return (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => {\r\n            return this.append(\r\n                expandTracedToNode(source as T, property!, index)(staticParts, ...substitutions)\r\n            );\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing information\r\n     *  in form of `{astNode, property?, index: undefined}`, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the tagged template delegates to {@link appendTracedTemplate}, otherwise it returns just `this`.\r\n     * See also {@link expandTracedToNode} for details.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplateIf(entity?.name !== undefined, entity)\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplateIf<T extends AstNode>(condition: boolean, astNode: T, property?: Properties<T>): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing information\r\n     *  in form of `{astNode, property, index}`, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the tagged template delegates to {@link appendTracedTemplate}, otherwise it returns just `this`.\r\n     * See also {@link expandTracedToNode} for details.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param astNode the AstNode corresponding to the appended content\r\n     *\r\n     * @param property the value property name (string) corresponding to the appended content,\r\n     *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n     *\r\n     * @param index the index of the value within a list property corresponding to the appended content,\r\n     *  if the property contains a list of elements, is ignored otherwise\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplateIf(entity?.name !== undefined, entity)\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplateIf<T extends AstNode>(condition: boolean, astNode: T, property: Properties<T>, index: number | undefined): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing information\r\n     *  in form of concrete coordinates, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the tagged template delegates to {@link appendTracedTemplate}, otherwise it returns just `this`.\r\n     * See also {@link expandTracedToNode} for details.\r\n     *\r\n      * If `sourceRegion` is a function supplying the corresponding region, it's only called if `condition` is satisfied.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n     *  if `undefined` no tracing will happen\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplateIf(entity?.name !== undefined, entity.$cstNode)\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplateIf(condition: boolean, sourceRegion: SourceRegion | undefined | (() => SourceRegion | undefined)): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    /**\r\n     * Convenience method for appending content in form of a template to `this` generator node including tracing information\r\n     *  in form of a list of concrete coordinates, if `condition` is equal to `true`.\r\n     *\r\n     * This method returns a tag function that takes the desired template and does the processing.\r\n     *\r\n     * If `condition` is satisfied the tagged template delegates to {@link appendTracedTemplate}, otherwise it returns just `this`.\r\n     * See also {@link expandTracedToNode} for details.\r\n     *\r\n     * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n     *  of all the contained source regions.\r\n     * If `sourceRegions` is a function supplying the corresponding regions, it's only called if `condition` is satisfied.\r\n     *\r\n     * @param condition a boolean value indicating whether to append the template content to `this`.\r\n     *\r\n     * @param sourceRegions a list of text regions within some file in form of concrete coordinates,\r\n     *  if empty no tracing will happen\r\n     *\r\n     * @returns a tag function behaving as described above, which in turn returns `this` {@link CompositeGeneratorNode} for convenience.\r\n     *\r\n     * @example\r\n     *   new CompositeGeneratorNode().appendTemplate\r\n     *       `Hello World!`\r\n     *   .appendNewLine().appendTracedTemplateIf(entity?.name !== undefined, () => [ findNodeForProperty(entity.$cstNode, 'name')! ])\r\n     *       `Hello ${entity?.name}!`\r\n     *   .appendNewLineIfNotEmpty()\r\n     */\r\n    appendTracedTemplateIf(condition: boolean, sourceRegions: SourceRegion[] | (() => SourceRegion[])): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this;\r\n\r\n    // implementation:\r\n    appendTracedTemplateIf<T extends AstNode>(condition: boolean, source: T | undefined | SourceRegion | SourceRegion[] | (() => undefined | SourceRegion | SourceRegion[]), property?: Properties<T>, index?: number): (staticParts: TemplateStringsArray, ...substitutions: unknown[]) => this {\r\n        return condition ? this.appendTracedTemplate((typeof source === 'function' ? source() : source) as T, property!, index) : () => this;\r\n    }\r\n}\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of `{astNode, property?, index: undefined}`.\r\n *\r\n * This method returns a helper function that takes the desired `content` and does the processing.\r\n * The returned function will create and return a new {@link CompositeGeneratorNode} being initialized\r\n *  with the given tracing information and add some `content`, if provided.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity)\r\n *       `Hello ${ traceToNode(entity, 'name')(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNode<T extends AstNode>(astNode: T, property?: Properties<T>): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode;\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of `{astNode, property, index}`.\r\n *\r\n * This method returns a helper function that takes the desired `content` and does the processing.\r\n * The returned function will create and return a new {@link CompositeGeneratorNode} being initialized\r\n *  with the given tracing information and add some `content`, if provided.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n *\r\n * @param index the index of the value within a list property corresponding to the appended content,\r\n *  if the property contains a list of elements, is ignored otherwise\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity)\r\n *       `Hello ${ traceToNode(entity, 'name')(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNode<T extends AstNode>(astNode: T, property: Properties<T>, index: number | undefined): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode;\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of concrete coordinates.\r\n *\r\n * This method returns a helper function that takes the desired `content` and does the processing.\r\n * The returned function will create and return a new {@link CompositeGeneratorNode} being initialized\r\n *  with the given tracing information and add some `content`, if provided.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n *  if `undefined` no tracing will happen\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity.$cstNode)\r\n *       `Hello ${ traceToNode(findNodeForProperty(entity.$cstNode, 'name'))(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNode(sourceRegion: SourceRegion | undefined): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode;\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of a list of concrete coordinates.\r\n *\r\n * This method returns a helper function that takes the desired `content` and does the processing.\r\n * The returned function will create and return a new {@link CompositeGeneratorNode} being initialized\r\n *  with the given tracing information and add some `content`, if provided.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n *  of all the contained source regions.\r\n *\r\n * @param sourceRegions a list of text region within some file in form of concrete coordinates,\r\n *  if empty no tracing will happen\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity.$cstNode)\r\n *       `Hello ${ traceToNode(findNodesForProperty(entity.$cstNode, 'name'))(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNode(sourceRegions: SourceRegion[]): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode;\r\n\r\n// implementation\r\nexport function traceToNode<T extends AstNode>(astNode: T | undefined | SourceRegion | SourceRegion[], property?: Properties<T>, index?: number): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode {\r\n    return content => {\r\n        if (content instanceof CompositeGeneratorNode && content.tracedSource === undefined) {\r\n            return (content as CompositeGeneratorNode).trace(astNode as T, property!, index);\r\n        } else {\r\n            // a `content !== undefined` check is skipped here on purpose in order to let this method always return a result;\r\n            // dropping empty generator nodes is considered a post processing optimization.\r\n            return new CompositeGeneratorNode().trace(astNode as T, property!, index).append(content);\r\n        }\r\n    };\r\n}\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of `{astNode, property?, index: undefined}`, if `condition` is equal to `true`.\r\n *\r\n * If `condition` is satisfied, this method returns a helper function that takes the desired\r\n * `content` and does the processing. The returned function will create and return a new\r\n * {@link CompositeGeneratorNode} being initialized with the given tracing information and\r\n * add some `content`, if provided. Otherwise, the returned function just returns `undefined`.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * @param condition a boolean value indicating whether to apply the provided tracing information to the desired content.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`, is optional\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity)\r\n *       `Hello ${ traceToNodeIf(!!entity.name, entity, 'name')(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNodeIf<T extends AstNode>(condition: boolean, astNode: T, property?: Properties<T>): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode | undefined;\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of `{astNode, property, index}`, if `condition` is equal to `true`.\r\n *\r\n * If `condition` is satisfied, this method returns a helper function that takes the desired\r\n * `content` and does the processing. The returned function will create and return a new\r\n * {@link CompositeGeneratorNode} being initialized with the given tracing information and\r\n * add some `content`, if provided. Otherwise, the returned function just returns `undefined`.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * @param condition a boolean value indicating whether to apply the provided tracing information to the desired content.\r\n *\r\n * @param astNode the AstNode corresponding to the appended content\r\n *\r\n * @param property the value property name (string) corresponding to the appended content,\r\n *  if e.g. the content corresponds to some `string` or `number` property of `astNode`\r\n *\r\n * @param index the index of the value within a list property corresponding to the appended content,\r\n *  if the property contains a list of elements, is ignored otherwise\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity)\r\n *       `Hello ${ traceToNodeIf(!!entity.name, entity, 'name')(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNodeIf<T extends AstNode>(condition: boolean, astNode: T, property: Properties<T>, index: number | undefined): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode | undefined;\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of concrete coordinates, if `condition` is equal to `true`.\r\n *\r\n * If `condition` is satisfied, this method returns a helper function that takes the desired\r\n * `content` and does the processing. The returned function will create and return a new\r\n * {@link CompositeGeneratorNode} being initialized with the given tracing information and\r\n * add some `content`, if provided. Otherwise, the returned function just returns `undefined`.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * If `sourceRegions` is a function supplying the corresponding regions, it's only called if `condition` is satisfied.\r\n *\r\n * @param condition a boolean value indicating whether to apply the provided tracing information to the desired content.\r\n *\r\n * @param sourceRegion a text region within some file in form of concrete coordinates,\r\n *  if `undefined` no tracing will happen\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity.$cstNode)\r\n *       `Hello ${ traceToNodeIf(!!entity.name, () => findNodeForProperty(entity.$cstNode, 'name'))(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNodeIf(condition: boolean, sourceRegion: SourceRegion | undefined | (() => SourceRegion | undefined)): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode | undefined;\r\n\r\n/**\r\n * Convenience function for attaching tracing information to content of type `Generated`,\r\n *  in form of a list of concrete coordinates, if `condition` is equal to `true`.\r\n *\r\n * If `condition` is satisfied, this method returns a helper function that takes the desired\r\n * `content` and does the processing. The returned function will create and return a new\r\n * {@link CompositeGeneratorNode} being initialized with the given tracing information and\r\n * add some `content`, if provided. Otherwise, the returned function just returns `undefined`.\r\n *\r\n * Exception: if `content` is already a {@link CompositeGeneratorNode} containing no tracing information,\r\n *  that node is enriched with the given tracing information and returned, and no wrapping node is created.\r\n *\r\n * The list of regions in `sourceRegions` will later be reduced to the smallest encompassing region\r\n *  of all the contained source regions.\r\n * If `sourceRegions` is a function supplying the corresponding regions, it's only called if `condition` is satisfied.\r\n *\r\n * @param condition a boolean value indicating whether to apply the provided tracing information to the desired content.\r\n *\r\n * @param sourceRegions a list of text region within some file in form of concrete coordinates,\r\n *  if empty no tracing will happen\r\n *\r\n * @returns a function behaving as described above, which in turn returns a {@link CompositeGeneratorNode}.\r\n *\r\n * @example\r\n *   new CompositeGeneratorNode().appendTemplate\r\n *       `Hello World!`\r\n *   .appendNewLine().appendTracedTemplate(entity.$cstNode)\r\n *       `Hello ${ traceToNodeIf(!!entity.name, () => findNodesForProperty(entity.$cstNode, 'name'))(entity.name) }`\r\n *   .appendNewLineIfNotEmpty()\r\n */\r\nexport function traceToNodeIf(condition: boolean, sourceRegions: SourceRegion[] | (() => SourceRegion[])): (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode | undefined;\r\n\r\n// implementation\r\nexport function traceToNodeIf<T extends AstNode>(condition: boolean, source: T | undefined | SourceRegion | SourceRegion[] | (() => undefined | SourceRegion | SourceRegion[]), property?: Properties<T>, index?: number): // eslint-disable-next-line @typescript-eslint/indent\r\n        (content?: Generated | ((node: CompositeGeneratorNode) => void)) => CompositeGeneratorNode | undefined {\r\n    return condition ? traceToNode((typeof source === 'function' ? source() : source) as T, property!, index) : () => undefined;\r\n}\r\n\r\n/**\r\n * Implementation of @{link GeneratorNode} denoting areas within the desired generated text of common increased indentation.\r\n */\r\nexport class IndentNode extends CompositeGeneratorNode {\r\n\r\n    indentation?: string;\r\n    indentImmediately = true;\r\n    indentEmptyLines = false;\r\n\r\n    constructor(indentation?: string | number, indentImmediately = true, indentEmptyLines = false) {\r\n        super();\r\n        if (typeof (indentation) === 'string') {\r\n            this.indentation = indentation;\r\n        } else if (typeof (indentation) === 'number') {\r\n            this.indentation = ''.padStart(indentation);\r\n        }\r\n        this.indentImmediately = indentImmediately;\r\n        this.indentEmptyLines = indentEmptyLines;\r\n    }\r\n}\r\n\r\n/**\r\n * Implementation of @{link GeneratorNode} denoting linebreaks in the desired generated text.\r\n */\r\nexport class NewLineNode {\r\n\r\n    lineDelimiter: string;\r\n\r\n    ifNotEmpty = false;\r\n\r\n    constructor(lineDelimiter?: string, ifNotEmpty = false) {\r\n        this.lineDelimiter = lineDelimiter ?? EOL;\r\n        this.ifNotEmpty = ifNotEmpty;\r\n    }\r\n}\r\n\r\nexport const NL = new NewLineNode();\r\nexport const NLEmpty = new NewLineNode(undefined, true);\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CstNode } from '../../../syntax-tree.js';\r\nimport type { Assignment, Action, TypeAttribute } from '../../generated/ast.js';\r\nimport { CompositeGeneratorNode, NL, toString } from '../../../generator/generator-node.js';\r\nimport { distinctAndSorted } from '../types-util.js';\r\n\r\nexport interface Property {\r\n    name: string,\r\n    optional: boolean,\r\n    type: PropertyType,\r\n    astNodes: Set<Assignment | Action | TypeAttribute>,\r\n}\r\n\r\nexport type PropertyType =\r\n    | ReferenceType\r\n    | ArrayType\r\n    | PropertyUnion\r\n    | ValueType\r\n    | PrimitiveType\r\n    | StringType;\r\n\r\nexport interface ReferenceType {\r\n    referenceType: PropertyType\r\n}\r\n\r\nexport function isReferenceType(propertyType: PropertyType): propertyType is ReferenceType {\r\n    return 'referenceType' in propertyType;\r\n}\r\n\r\nexport interface ArrayType {\r\n    elementType: PropertyType\r\n}\r\n\r\nexport function isArrayType(propertyType: PropertyType): propertyType is ArrayType {\r\n    return 'elementType' in propertyType;\r\n}\r\n\r\nexport interface PropertyUnion {\r\n    types: PropertyType[]\r\n}\r\n\r\nexport function isPropertyUnion(propertyType: PropertyType): propertyType is PropertyUnion {\r\n    return 'types' in propertyType;\r\n}\r\n\r\nexport function flattenPropertyUnion(propertyType: PropertyType): PropertyType[] {\r\n    if (isPropertyUnion(propertyType)) {\r\n        const items: PropertyType[] = [];\r\n        for (const type of propertyType.types) {\r\n            items.push(...flattenPropertyUnion(type));\r\n        }\r\n        return items;\r\n    } else {\r\n        return [propertyType];\r\n    }\r\n}\r\n\r\nexport interface ValueType {\r\n    value: TypeOption\r\n}\r\n\r\nexport function isValueType(propertyType: PropertyType): propertyType is ValueType {\r\n    return 'value' in propertyType;\r\n}\r\n\r\nexport interface PrimitiveType {\r\n    primitive: string\r\n    regex?: string\r\n}\r\n\r\nexport function isPrimitiveType(propertyType: PropertyType): propertyType is PrimitiveType {\r\n    return 'primitive' in propertyType;\r\n}\r\n\r\nexport interface StringType {\r\n    string: string\r\n}\r\n\r\nexport function isStringType(propertyType: PropertyType): propertyType is StringType {\r\n    return 'string' in propertyType;\r\n}\r\n\r\nexport type AstTypes = {\r\n    interfaces: InterfaceType[],\r\n    unions: UnionType[],\r\n}\r\n\r\nexport function isUnionType(type: TypeOption): type is UnionType {\r\n    return type && 'type' in type;\r\n}\r\n\r\nexport function isInterfaceType(type: TypeOption): type is InterfaceType {\r\n    return type && 'properties' in type;\r\n}\r\n\r\nexport type TypeOption = InterfaceType | UnionType;\r\n\r\nexport class UnionType {\r\n    name: string;\r\n    type: PropertyType;\r\n    superTypes = new Set<TypeOption>();\r\n    subTypes = new Set<TypeOption>();\r\n    typeNames = new Set<string>();\r\n    declared: boolean;\r\n    dataType?: string;\r\n\r\n    constructor(name: string, options?: {\r\n        declared: boolean,\r\n        dataType?: string\r\n    }) {\r\n        this.name = name;\r\n        this.declared = options?.declared ?? false;\r\n        this.dataType = options?.dataType;\r\n    }\r\n\r\n    toAstTypesString(reflectionInfo: boolean): string {\r\n        const unionNode = new CompositeGeneratorNode();\r\n        unionNode.append(`export type ${this.name} = ${propertyTypeToString(this.type, 'AstType')};`, NL);\r\n\r\n        if (reflectionInfo) {\r\n            unionNode.append(NL);\r\n            pushReflectionInfo(unionNode, this.name);\r\n        }\r\n\r\n        if (this.dataType) {\r\n            pushDataTypeReflectionInfo(unionNode, this);\r\n        }\r\n\r\n        return toString(unionNode);\r\n    }\r\n\r\n    toDeclaredTypesString(reservedWords: Set<string>): string {\r\n        const unionNode = new CompositeGeneratorNode();\r\n        unionNode.append(`type ${escapeReservedWords(this.name, reservedWords)} = ${propertyTypeToString(this.type, 'DeclaredType')};`, NL);\r\n        return toString(unionNode);\r\n    }\r\n}\r\n\r\nexport class InterfaceType {\r\n    name: string;\r\n    superTypes = new Set<TypeOption>();\r\n    subTypes = new Set<TypeOption>();\r\n    containerTypes = new Set<TypeOption>();\r\n    typeNames = new Set<string>();\r\n    declared = false;\r\n    abstract = false;\r\n\r\n    properties: Property[] = [];\r\n\r\n    get superProperties(): Property[] {\r\n        return this.getSuperProperties(new Set());\r\n    }\r\n\r\n    private getSuperProperties(visited: Set<string>): Property[] {\r\n        if (visited.has(this.name)) {\r\n            return [];\r\n        } else {\r\n            visited.add(this.name);\r\n        }\r\n        const map = new Map<string, Property>();\r\n        for (const property of this.properties) {\r\n            map.set(property.name, property);\r\n        }\r\n        for (const superType of this.interfaceSuperTypes) {\r\n            const allSuperProperties = superType.getSuperProperties(visited);\r\n            for (const superProp of allSuperProperties) {\r\n                if (!map.has(superProp.name)) {\r\n                    map.set(superProp.name, superProp);\r\n                }\r\n            }\r\n        }\r\n        return Array.from(map.values());\r\n    }\r\n\r\n    get allProperties(): Property[] {\r\n        const map = new Map(this.superProperties.map(e => [e.name, e]));\r\n        for (const subType of this.subTypes) {\r\n            this.getSubTypeProperties(subType, map, new Set());\r\n        }\r\n        const superProps = Array.from(map.values());\r\n        return superProps;\r\n    }\r\n\r\n    private getSubTypeProperties(type: TypeOption, map: Map<string, Property>, visited: Set<string>): void {\r\n        if (visited.has(this.name)) {\r\n            return;\r\n        } else {\r\n            visited.add(this.name);\r\n        }\r\n        const props = isInterfaceType(type) ? type.properties : [];\r\n        for (const prop of props) {\r\n            if (!map.has(prop.name)) {\r\n                map.set(prop.name, prop);\r\n            }\r\n        }\r\n        for (const subType of type.subTypes) {\r\n            this.getSubTypeProperties(subType, map, visited);\r\n        }\r\n    }\r\n\r\n    get interfaceSuperTypes(): InterfaceType[] {\r\n        return Array.from(this.superTypes).filter((e): e is InterfaceType => e instanceof InterfaceType);\r\n    }\r\n\r\n    constructor(name: string, declared: boolean, abstract: boolean) {\r\n        this.name = name;\r\n        this.declared = declared;\r\n        this.abstract = abstract;\r\n    }\r\n\r\n    toAstTypesString(reflectionInfo: boolean): string {\r\n        const interfaceNode = new CompositeGeneratorNode();\r\n\r\n        const interfaceSuperTypes = this.interfaceSuperTypes.map(e => e.name);\r\n        const superTypes = interfaceSuperTypes.length > 0 ? distinctAndSorted([...interfaceSuperTypes]) : ['AstNode'];\r\n        interfaceNode.append(`export interface ${this.name} extends ${superTypes.join(', ')} {`, NL);\r\n\r\n        interfaceNode.indent(body => {\r\n            if (this.containerTypes.size > 0) {\r\n                body.append(`readonly $container: ${distinctAndSorted([...this.containerTypes].map(e => e.name)).join(' | ')};`, NL);\r\n            }\r\n            if (this.typeNames.size > 0) {\r\n                body.append(`readonly $type: ${distinctAndSorted([...this.typeNames]).map(e => `'${e}'`).join(' | ')};`, NL);\r\n            }\r\n            pushProperties(body, this.properties, 'AstType');\r\n        });\r\n        interfaceNode.append('}', NL);\r\n\r\n        if (reflectionInfo) {\r\n            interfaceNode.append(NL);\r\n            pushReflectionInfo(interfaceNode, this.name);\r\n        }\r\n\r\n        return toString(interfaceNode);\r\n    }\r\n\r\n    toDeclaredTypesString(reservedWords: Set<string>): string {\r\n        const interfaceNode = new CompositeGeneratorNode();\r\n\r\n        const name = escapeReservedWords(this.name, reservedWords);\r\n        const superTypes = distinctAndSorted(this.interfaceSuperTypes.map(e => e.name)).join(', ');\r\n        interfaceNode.append(`interface ${name}${superTypes.length > 0 ? ` extends ${superTypes}` : ''} {`, NL);\r\n\r\n        interfaceNode.indent(body => pushProperties(body, this.properties, 'DeclaredType', reservedWords));\r\n\r\n        interfaceNode.append('}', NL);\r\n        return toString(interfaceNode);\r\n    }\r\n}\r\n\r\nexport class TypeResolutionError extends Error {\r\n    readonly target: CstNode | undefined;\r\n\r\n    constructor(message: string, target: CstNode | undefined) {\r\n        super(message);\r\n        this.name = 'TypeResolutionError';\r\n        this.target = target;\r\n    }\r\n\r\n}\r\n\r\nexport function isTypeAssignable(from: PropertyType, to: PropertyType): boolean {\r\n    return isTypeAssignableInternal(from, to, new Map());\r\n}\r\n\r\nfunction isTypeAssignableInternal(from: PropertyType, to: PropertyType, visited: Map<string, boolean>): boolean {\r\n    const key = `${propertyTypeToKeyString(from)}\u00BB${propertyTypeToKeyString(to)}`;\r\n    let result = visited.get(key);\r\n    if (result !== undefined) {\r\n        return result;\r\n    }\r\n    visited.set(key, false);\r\n    result = false;\r\n    if (isPropertyUnion(from)) {\r\n        result = from.types.every(fromType => isTypeAssignableInternal(fromType, to, visited));\r\n    } else if (isPropertyUnion(to)) {\r\n        result = to.types.some(toType => isTypeAssignableInternal(from, toType, visited));\r\n    } else if (isValueType(to) && isUnionType(to.value)) {\r\n        if (isValueType(from) && isUnionType(from.value) && to.value.name === from.value.name) {\r\n            result = true;\r\n        } else {\r\n            result = isTypeAssignableInternal(from, to.value.type, visited);\r\n        }\r\n    } else if (isReferenceType(from)) {\r\n        result = isReferenceType(to) && isTypeAssignableInternal(from.referenceType, to.referenceType, visited);\r\n    } else if (isArrayType(from)) {\r\n        result = isArrayType(to) && isTypeAssignableInternal(from.elementType, to.elementType, visited);\r\n    } else if (isValueType(from)) {\r\n        if (isUnionType(from.value)) {\r\n            result = isTypeAssignableInternal(from.value.type, to, visited);\r\n        } else if (!isValueType(to)) {\r\n            result = false;\r\n        } else if (isUnionType(to.value)) {\r\n            result = isTypeAssignableInternal(from, to.value.type, visited);\r\n        } else {\r\n            result = isInterfaceAssignable(from.value, to.value, new Set());\r\n        }\r\n    } else if (isPrimitiveType(from)) {\r\n        result = isPrimitiveType(to) && from.primitive === to.primitive;\r\n    } else if (isStringType(from)) {\r\n        result = (isPrimitiveType(to) && to.primitive === 'string') || (isStringType(to) && to.string === from.string);\r\n    }\r\n    if (result) {\r\n        visited.set(key, result);\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction isInterfaceAssignable(from: InterfaceType, to: InterfaceType, visited: Set<string>): boolean {\r\n    const key = from.name;\r\n    if (visited.has(key)) {\r\n        return false;\r\n    } else {\r\n        visited.add(key);\r\n    }\r\n    if (from.name === to.name) {\r\n        return true;\r\n    }\r\n    for (const superType of from.superTypes) {\r\n        if (isInterfaceType(superType) && isInterfaceAssignable(superType, to, visited)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction propertyTypeToKeyString(type: PropertyType): string {\r\n    if (isReferenceType(type)) {\r\n        return `@(${propertyTypeToKeyString(type.referenceType)})}`;\r\n    } else if (isArrayType(type)) {\r\n        return `(${propertyTypeToKeyString(type.elementType)})[]`;\r\n    } else if (isPropertyUnion(type)) {\r\n        const union = type.types.map(e => propertyTypeToKeyString(e)).join(' | ');\r\n        if (type.types.length <= 1) {\r\n            return `Union<${union}>`;\r\n        }\r\n        return union;\r\n    } else if (isValueType(type)) {\r\n        return `Value<${type.value.name}>`;\r\n    } else if (isPrimitiveType(type)) {\r\n        return type.primitive;\r\n    } else if (isStringType(type)) {\r\n        return `'${type.string}'`;\r\n    }\r\n    throw new Error('Invalid type');\r\n}\r\n\r\nexport function propertyTypeToString(type: PropertyType, mode: 'AstType' | 'DeclaredType' = 'AstType'): string {\r\n    if (isReferenceType(type)) {\r\n        const refType = propertyTypeToString(type.referenceType, mode);\r\n        return mode === 'AstType' ? `Reference<${refType}>` : `@${typeParenthesis(type.referenceType, refType)}`;\r\n    } else if (isArrayType(type)) {\r\n        const arrayType = propertyTypeToString(type.elementType, mode);\r\n        return mode === 'AstType' ? `Array<${arrayType}>` : `${typeParenthesis(type.elementType, arrayType)}[]`;\r\n    } else if (isPropertyUnion(type)) {\r\n        const types = type.types.map(e => typeParenthesis(e, propertyTypeToString(e, mode)));\r\n        return distinctAndSorted(types).join(' | ');\r\n    } else if (isValueType(type)) {\r\n        return type.value.name;\r\n    } else if (isPrimitiveType(type)) {\r\n        return type.primitive;\r\n    } else if (isStringType(type)) {\r\n        const delimiter = mode === 'AstType' ? \"'\" : '\"';\r\n        return `${delimiter}${type.string}${delimiter}`;\r\n    }\r\n    throw new Error('Invalid type');\r\n}\r\n\r\nfunction typeParenthesis(type: PropertyType, name: string): string {\r\n    const needsParenthesis = isPropertyUnion(type);\r\n    if (needsParenthesis) {\r\n        name = `(${name})`;\r\n    }\r\n    return name;\r\n}\r\n\r\nfunction pushProperties(\r\n    node: CompositeGeneratorNode,\r\n    properties: Property[],\r\n    mode: 'AstType' | 'DeclaredType',\r\n    reserved = new Set<string>()\r\n) {\r\n\r\n    function propertyToString(property: Property): string {\r\n        const name = mode === 'AstType' ? property.name : escapeReservedWords(property.name, reserved);\r\n        const optional = property.optional && !isMandatoryPropertyType(property.type);\r\n        const propType = propertyTypeToString(property.type, mode);\r\n        return `${name}${optional ? '?' : ''}: ${propType}`;\r\n    }\r\n\r\n    distinctAndSorted(properties, (a, b) => a.name.localeCompare(b.name))\r\n        .forEach(property => node.append(propertyToString(property), NL));\r\n}\r\n\r\nexport function isMandatoryPropertyType(propertyType: PropertyType): boolean {\r\n    if (isArrayType(propertyType)) {\r\n        return true;\r\n    } else if (isReferenceType(propertyType)) {\r\n        return false;\r\n    } else if (isPropertyUnion(propertyType)) {\r\n        return propertyType.types.every(e => isMandatoryPropertyType(e));\r\n    } else if (isPrimitiveType(propertyType)) {\r\n        const value = propertyType.primitive;\r\n        return value === 'boolean';\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nfunction pushReflectionInfo(node: CompositeGeneratorNode, name: string) {\r\n    node.append(`export const ${name} = '${name}';`, NL);\r\n    node.append(NL);\r\n\r\n    node.append(`export function is${name}(item: unknown): item is ${name} {`, NL);\r\n    node.indent(body => body.append(`return reflection.isInstance(item, ${name});`, NL));\r\n    node.append('}', NL);\r\n}\r\n\r\nfunction pushDataTypeReflectionInfo(node: CompositeGeneratorNode, union: UnionType) {\r\n    switch (union.dataType) {\r\n        case 'string':\r\n            if (containsOnlyStringTypes(union.type)) {\r\n                const subTypes = Array.from(union.subTypes).map(e => e.name);\r\n                const strings = collectStringValuesFromDataType(union.type);\r\n                const regexes = collectRegexesFromDataType(union.type);\r\n                if (subTypes.length === 0 && strings.length === 0 && regexes.length === 0) {\r\n                    generateIsDataTypeFunction(node, union.name, `typeof item === '${union.dataType}'`);\r\n                } else {\r\n                    const returnString = createDataTypeCheckerFunctionReturnString(subTypes, strings, regexes);\r\n                    generateIsDataTypeFunction(node, union.name, returnString);\r\n                }\r\n            }\r\n            break;\r\n        case 'number':\r\n        case 'boolean':\r\n        case 'bigint':\r\n            generateIsDataTypeFunction(node, union.name, `typeof item === '${union.dataType}'`);\r\n            break;\r\n        case 'Date':\r\n            generateIsDataTypeFunction(node, union.name, 'item instanceof Date');\r\n            break;\r\n        default:\r\n            return;\r\n    }\r\n}\r\n\r\nfunction containsOnlyStringTypes(propertyType: PropertyType): boolean {\r\n    let result = true;\r\n    if (isPrimitiveType(propertyType)) {\r\n        if (propertyType.primitive === 'string') {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } else if (isStringType(propertyType)) {\r\n        return true;\r\n    } else if (!isPropertyUnion(propertyType)) {\r\n        return false;\r\n    } else {\r\n        for (const type of propertyType.types) {\r\n            if (isValueType(type)) {\r\n                if (isUnionType(type.value)) {\r\n                    if (!containsOnlyStringTypes(type.value.type)) {\r\n                        return false;\r\n                    }\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else if (isPrimitiveType(type)) {\r\n                if (type.primitive !== 'string' || !type.regex) {\r\n                    return false;\r\n                }\r\n            } else if (isPropertyUnion(type)) {\r\n                result = containsOnlyStringTypes(type);\r\n            } else if (!isStringType(type)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction createDataTypeCheckerFunctionReturnString(subTypes: string[], strings: string[], regexes: string[]): string {\r\n    const allArray = [\r\n        ...subTypes.map(e => `is${e}(item)`),\r\n        ...strings.map(e => `item === '${e}'`)\r\n    ];\r\n\r\n    if (regexes.length > 0) {\r\n        const joinedRegexes = regexes.map(e => `${e}.test(item)`).join(' || ');\r\n        allArray.push(`(typeof item === 'string' && (${joinedRegexes}))`);\r\n    }\r\n\r\n    return allArray.join(' || ');\r\n}\r\n\r\nfunction escapeReservedWords(name: string, reserved: Set<string>): string {\r\n    return reserved.has(name) ? `^${name}` : name;\r\n}\r\n\r\nfunction collectStringValuesFromDataType(propertyType: PropertyType): string[] {\r\n    const values: string[] = [];\r\n    if (isStringType(propertyType)) {\r\n        return [propertyType.string];\r\n    }\r\n    if (isPropertyUnion(propertyType)) {\r\n        for (const type of propertyType.types) {\r\n            if (isStringType(type)) {\r\n                values.push(type.string);\r\n            } else if (isPropertyUnion(type)) {\r\n                values.push(...collectStringValuesFromDataType(type));\r\n            }\r\n        }\r\n    }\r\n\r\n    return values;\r\n}\r\n\r\nfunction collectRegexesFromDataType(propertyType: PropertyType): string[] {\r\n    const regexes: string[] = [];\r\n    if (isPrimitiveType(propertyType) && propertyType.primitive === 'string' && propertyType.regex) {\r\n        regexes.push(propertyType.regex);\r\n    }\r\n    if (isPropertyUnion(propertyType)) {\r\n        for (const type of propertyType.types) {\r\n            if (isPrimitiveType(type) && type.primitive === 'string' && type.regex) {\r\n                regexes.push(type.regex);\r\n            } else if (isPropertyUnion(type)) {\r\n                regexes.push(...collectRegexesFromDataType(type));\r\n            }\r\n        }\r\n    }\r\n    return regexes;\r\n}\r\n\r\nfunction generateIsDataTypeFunction(node: CompositeGeneratorNode, unionName: string, returnString: string) {\r\n    node.append(NL, `export function is${unionName}(item: unknown): item is ${unionName} {`, NL);\r\n    node.indent(body => body.append(`return ${returnString};`, NL));\r\n    node.append('}', NL);\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { References } from '../../references/references.js';\r\nimport type { AstNodeLocator } from '../../workspace/ast-node-locator.js';\r\nimport type { LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { Interface, Type, AbstractType, TypeDefinition } from '../generated/ast.js';\r\nimport type { PlainInterface, PlainProperty } from './type-collector/plain-types.js';\r\nimport type { AstTypes, InterfaceType, PropertyType, TypeOption } from './type-collector/types.js';\r\nimport { MultiMap } from '../../utils/collections.js';\r\nimport { isInterface, isType, isUnionType, isSimpleType } from '../generated/ast.js';\r\nimport { isArrayType, isPrimitiveType, isPropertyUnion, isReferenceType, isValueType } from './type-collector/types.js';\r\n\r\n/**\r\n * Collects all properties of all interface types. Includes super type properties.\r\n * @param interfaces A topologically sorted array of interfaces.\r\n */\r\nexport function collectAllPlainProperties(interfaces: PlainInterface[]): MultiMap<string, PlainProperty> {\r\n    const map = new MultiMap<string, PlainProperty>();\r\n    for (const interfaceType of interfaces) {\r\n        map.addAll(interfaceType.name, interfaceType.properties);\r\n    }\r\n    for (const interfaceType of interfaces) {\r\n        for (const superType of interfaceType.superTypes) {\r\n            const superTypeProperties = map.get(superType);\r\n            if (superTypeProperties) {\r\n                map.addAll(interfaceType.name, superTypeProperties);\r\n            }\r\n        }\r\n    }\r\n    return map;\r\n}\r\n\r\nexport function distinctAndSorted<T>(list: T[], compareFn?: (a: T, b: T) => number): T[] {\r\n    return Array.from(new Set(list)).sort(compareFn);\r\n}\r\n\r\nexport function collectChildrenTypes(interfaceNode: Interface, references: References, langiumDocuments: LangiumDocuments, nodeLocator: AstNodeLocator): Set<Interface | Type> {\r\n    const childrenTypes = new Set<Interface | Type>();\r\n    childrenTypes.add(interfaceNode);\r\n    const refs = references.findReferences(interfaceNode, {});\r\n    refs.forEach(ref => {\r\n        const doc = langiumDocuments.getOrCreateDocument(ref.sourceUri);\r\n        const astNode = nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);\r\n        if (isInterface(astNode)) {\r\n            childrenTypes.add(astNode);\r\n            const childrenOfInterface = collectChildrenTypes(astNode, references, langiumDocuments, nodeLocator);\r\n            childrenOfInterface.forEach(child => childrenTypes.add(child));\r\n        } else if (astNode && isType(astNode.$container)) {\r\n            childrenTypes.add(astNode.$container);\r\n        }\r\n    });\r\n    return childrenTypes;\r\n}\r\n\r\nexport function collectTypeHierarchy(types: TypeOption[]): {\r\n    superTypes: MultiMap<string, string>\r\n    subTypes: MultiMap<string, string>\r\n} {\r\n    const allTypes = new Set(types);\r\n    const duplicateSuperTypes = new MultiMap<string, string>();\r\n    const duplicateSubTypes = new MultiMap<string, string>();\r\n    for (const type of allTypes) {\r\n        for (const superType of type.superTypes) {\r\n            if (allTypes.has(superType)) {\r\n                duplicateSuperTypes.add(type.name, superType.name);\r\n                duplicateSubTypes.add(superType.name, type.name);\r\n            }\r\n        }\r\n        for (const subType of type.subTypes) {\r\n            if (allTypes.has(subType)) {\r\n                duplicateSuperTypes.add(subType.name, type.name);\r\n                duplicateSubTypes.add(type.name, subType.name);\r\n            }\r\n        }\r\n    }\r\n    const superTypes = new MultiMap<string, string>();\r\n    const subTypes = new MultiMap<string, string>();\r\n    // Deduplicate and sort\r\n    for (const [name, superTypeList] of Array.from(duplicateSuperTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {\r\n        superTypes.addAll(name, Array.from(new Set(superTypeList)));\r\n    }\r\n    for (const [name, subTypeList] of Array.from(duplicateSubTypes.entriesGroupedByKey()).sort(([aName], [bName]) => aName.localeCompare(bName))) {\r\n        subTypes.addAll(name, Array.from(new Set(subTypeList)));\r\n    }\r\n    return {\r\n        superTypes,\r\n        subTypes\r\n    };\r\n}\r\n\r\nexport function collectSuperTypes(ruleNode: AbstractType): Set<Interface> {\r\n    const superTypes = new Set<Interface>();\r\n    if (isInterface(ruleNode)) {\r\n        superTypes.add(ruleNode);\r\n        ruleNode.superTypes.forEach(superType => {\r\n            if (isInterface(superType.ref)) {\r\n                superTypes.add(superType.ref);\r\n                const collectedSuperTypes = collectSuperTypes(superType.ref);\r\n                for (const superType of collectedSuperTypes) {\r\n                    superTypes.add(superType);\r\n                }\r\n            }\r\n        });\r\n    } else if (isType(ruleNode)) {\r\n        const usedTypes = collectUsedTypes(ruleNode.type);\r\n        for (const usedType of usedTypes) {\r\n            const collectedSuperTypes = collectSuperTypes(usedType);\r\n            for (const superType of collectedSuperTypes) {\r\n                superTypes.add(superType);\r\n            }\r\n        }\r\n    }\r\n    return superTypes;\r\n}\r\n\r\nfunction collectUsedTypes(typeDefinition: TypeDefinition): Array<Interface | Type> {\r\n    if (isUnionType(typeDefinition)) {\r\n        return typeDefinition.types.flatMap(e => collectUsedTypes(e));\r\n    } else if (isSimpleType(typeDefinition)) {\r\n        const value = typeDefinition.typeRef?.ref;\r\n        if (isType(value) || isInterface(value)) {\r\n            return [value];\r\n        }\r\n    }\r\n    return [];\r\n}\r\n\r\nexport function mergeInterfaces(inferred: AstTypes, declared: AstTypes): InterfaceType[] {\r\n    return inferred.interfaces.concat(declared.interfaces);\r\n}\r\n\r\nexport function mergeTypesAndInterfaces(astTypes: AstTypes): TypeOption[] {\r\n    return (astTypes.interfaces as TypeOption[]).concat(astTypes.unions);\r\n}\r\n\r\n/**\r\n * Performs topological sorting on the generated interfaces.\r\n * @param interfaces The interfaces to sort topologically.\r\n * @returns A topologically sorted set of interfaces.\r\n */\r\nexport function sortInterfacesTopologically(interfaces: PlainInterface[]): PlainInterface[] {\r\n    type TypeNode = {\r\n        value: PlainInterface;\r\n        nodes: TypeNode[];\r\n    }\r\n\r\n    const nodes: TypeNode[] = interfaces\r\n        .sort((a, b) => a.name.localeCompare(b.name))\r\n        .map(e => <TypeNode>{ value: e, nodes: [] });\r\n    for (const node of nodes) {\r\n        node.nodes = nodes.filter(e => node.value.superTypes.has(e.value.name));\r\n    }\r\n    const l: TypeNode[] = [];\r\n    const s = nodes.filter(e => e.nodes.length === 0);\r\n    while (s.length > 0) {\r\n        const n = s.shift()!;\r\n        if (!l.includes(n)) {\r\n            l.push(n);\r\n            nodes\r\n                .filter(e => e.nodes.includes(n))\r\n                .forEach(m => s.push(m));\r\n        }\r\n    }\r\n    return l.map(e => e.value);\r\n}\r\n\r\nexport function hasArrayType(type: PropertyType): boolean {\r\n    if (isPropertyUnion(type)) {\r\n        return type.types.some(e => hasArrayType(e));\r\n    } else if (isArrayType(type)) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function hasBooleanType(type: PropertyType): boolean {\r\n    if (isPropertyUnion(type)) {\r\n        return type.types.some(e => hasBooleanType(e));\r\n    } else if (isPrimitiveType(type)) {\r\n        return type.primitive === 'boolean';\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function findReferenceTypes(type: PropertyType): string[] {\r\n    if (isPropertyUnion(type)) {\r\n        return type.types.flatMap(e => findReferenceTypes(e));\r\n    } else if (isReferenceType(type)) {\r\n        const refType = type.referenceType;\r\n        if (isValueType(refType)) {\r\n            return [refType.value.name];\r\n        }\r\n    } else if (isArrayType(type)) {\r\n        return findReferenceTypes(type.elementType);\r\n    }\r\n    return [];\r\n}\r\n\r\nexport function findAstTypes(type: PropertyType): string[] {\r\n    return findAstTypesInternal(type, new Set());\r\n}\r\n\r\nexport function findAstTypesInternal(type: PropertyType, visited: Set<PropertyType>): string[] {\r\n    if (visited.has(type)) {\r\n        return [];\r\n    } else {\r\n        visited.add(type);\r\n    }\r\n    if (isPropertyUnion(type)) {\r\n        return type.types.flatMap(e => findAstTypesInternal(e, visited));\r\n    } else if (isValueType(type)) {\r\n        const value = type.value;\r\n        if ('type' in value) {\r\n            return findAstTypesInternal(value.type, visited);\r\n        } else {\r\n            return [value.name];\r\n        }\r\n    } else if (isArrayType(type)) {\r\n        return findAstTypesInternal(type.elementType, visited);\r\n    }\r\n    return [];\r\n}\r\n\r\nexport function isAstType(type: PropertyType): boolean {\r\n    if (isPropertyUnion(type)) {\r\n        return type.types.every(isAstType);\r\n    } else if (isValueType(type)) {\r\n        const value = type.value;\r\n        if ('type' in value) {\r\n            return isAstType(value.type);\r\n        } else {\r\n            // Is definitely an interface type\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport { findNodeForProperty } from '../utils/grammar-util.js';\r\n\r\nexport interface NamedAstNode extends AstNode {\r\n    name: string;\r\n}\r\n\r\nexport function isNamed(node: AstNode): node is NamedAstNode {\r\n    return typeof (node as NamedAstNode).name === 'string';\r\n}\r\n\r\n/**\r\n * Utility service for retrieving the `name` of an `AstNode` or the `CstNode` containing a `name`.\r\n */\r\nexport interface NameProvider {\r\n    /**\r\n     * Returns the `name` of a given AstNode.\r\n     * @param node Specified `AstNode` whose name node shall be retrieved.\r\n     */\r\n    getName(node: AstNode): string | undefined;\r\n    /**\r\n     * Returns the `CstNode` which contains the parsed value of the `name` assignment.\r\n     * @param node Specified `AstNode` whose name node shall be retrieved.\r\n     */\r\n    getNameNode(node: AstNode): CstNode | undefined;\r\n}\r\n\r\nexport class DefaultNameProvider implements NameProvider {\r\n    getName(node: AstNode): string | undefined {\r\n        if (isNamed(node)) {\r\n            return node.name;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    getNameNode(node: AstNode): CstNode | undefined {\r\n        return findNodeForProperty(node.$cstNode, 'name');\r\n    }\r\n}\r\n", "import type { Character, IRegExpAST, RegExpFlags } from \"../types\";\r\n\r\nexport function cc(char: string): number {\r\n  return char.charCodeAt(0);\r\n}\r\n\r\nexport function insertToSet<T>(item: T | T[], set: T[]) {\r\n  if (Array.isArray(item)) {\r\n    item.forEach(function (subItem) {\r\n      set.push(subItem);\r\n    });\r\n  } else {\r\n    set.push(item);\r\n  }\r\n}\r\n\r\nexport function addFlag(\r\n  flagObj: RegExpFlags,\r\n  flagKey: keyof Omit<RegExpFlags, keyof IRegExpAST>,\r\n) {\r\n  if (flagObj[flagKey] === true) {\r\n    throw \"duplicate flag \" + flagKey;\r\n  }\r\n\r\n  const x: boolean = flagObj[flagKey];\r\n  flagObj[flagKey] = true;\r\n}\r\n\r\nexport function ASSERT_EXISTS<T = Object>(obj: any): obj is T {\r\n  // istanbul ignore next\r\n  if (obj === undefined) {\r\n    throw Error(\"Internal Error - Should never get here!\");\r\n  }\r\n  return true;\r\n}\r\n\r\n// istanbul ignore next\r\nexport function ASSERT_NEVER_REACH_HERE(): any {\r\n  throw Error(\"Internal Error - Should never get here!\");\r\n}\r\n\r\nexport function isCharacter(obj: { type: string }): obj is Character {\r\n  return obj[\"type\"] === \"Character\";\r\n}\r\n", "import { cc } from \"./utils.js\";\r\n\r\nexport const digitsCharCodes: number[] = [];\r\nfor (let i = cc(\"0\"); i <= cc(\"9\"); i++) {\r\n  digitsCharCodes.push(i);\r\n}\r\n\r\nexport const wordCharCodes: number[] = [cc(\"_\")].concat(digitsCharCodes);\r\nfor (let i = cc(\"a\"); i <= cc(\"z\"); i++) {\r\n  wordCharCodes.push(i);\r\n}\r\n\r\nfor (let i = cc(\"A\"); i <= cc(\"Z\"); i++) {\r\n  wordCharCodes.push(i);\r\n}\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes\r\nexport const whitespaceCodes: number[] = [\r\n  cc(\" \"),\r\n  cc(\"\\f\"),\r\n  cc(\"\\n\"),\r\n  cc(\"\\r\"),\r\n  cc(\"\\t\"),\r\n  cc(\"\\v\"),\r\n  cc(\"\\t\"),\r\n  cc(\"\\u00a0\"),\r\n  cc(\"\\u1680\"),\r\n  cc(\"\\u2000\"),\r\n  cc(\"\\u2001\"),\r\n  cc(\"\\u2002\"),\r\n  cc(\"\\u2003\"),\r\n  cc(\"\\u2004\"),\r\n  cc(\"\\u2005\"),\r\n  cc(\"\\u2006\"),\r\n  cc(\"\\u2007\"),\r\n  cc(\"\\u2008\"),\r\n  cc(\"\\u2009\"),\r\n  cc(\"\\u200a\"),\r\n  cc(\"\\u2028\"),\r\n  cc(\"\\u2029\"),\r\n  cc(\"\\u202f\"),\r\n  cc(\"\\u205f\"),\r\n  cc(\"\\u3000\"),\r\n  cc(\"\\ufeff\"),\r\n];\r\n", "import type {\r\n  Alternative,\r\n  Assertion,\r\n  Atom,\r\n  Character,\r\n  Disjunction,\r\n  Group,\r\n  GroupBackReference,\r\n  Location,\r\n  Quantifier,\r\n  Range,\r\n  RegExpFlags,\r\n  RegExpPattern,\r\n  Set,\r\n  Term,\r\n} from \"../types\";\r\nimport {\r\n  addFlag,\r\n  ASSERT_EXISTS,\r\n  ASSERT_NEVER_REACH_HERE,\r\n  cc,\r\n  insertToSet,\r\n  isCharacter,\r\n} from \"./utils.js\";\r\nimport {\r\n  digitsCharCodes,\r\n  whitespaceCodes,\r\n  wordCharCodes,\r\n} from \"./character-classes.js\";\r\n\r\n// consts and utilities\r\nconst hexDigitPattern = /[0-9a-fA-F]/;\r\nconst decimalPattern = /[0-9]/;\r\nconst decimalPatternNoZero = /[1-9]/;\r\n\r\n// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983\r\n// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern\r\nexport class RegExpParser {\r\n  protected idx: number = 0;\r\n  protected input: string = \"\";\r\n  protected groupIdx: number = 0;\r\n\r\n  protected saveState() {\r\n    return {\r\n      idx: this.idx,\r\n      input: this.input,\r\n      groupIdx: this.groupIdx,\r\n    };\r\n  }\r\n\r\n  protected restoreState(newState: {\r\n    idx: number;\r\n    input: string;\r\n    groupIdx: number;\r\n  }) {\r\n    this.idx = newState.idx;\r\n    this.input = newState.input;\r\n    this.groupIdx = newState.groupIdx;\r\n  }\r\n\r\n  public pattern(input: string): RegExpPattern {\r\n    // parser state\r\n    this.idx = 0;\r\n    this.input = input;\r\n    this.groupIdx = 0;\r\n\r\n    this.consumeChar(\"/\");\r\n    const value = this.disjunction();\r\n    this.consumeChar(\"/\");\r\n\r\n    const flags: RegExpFlags = {\r\n      type: \"Flags\",\r\n      loc: { begin: this.idx, end: input.length },\r\n      global: false,\r\n      ignoreCase: false,\r\n      multiLine: false,\r\n      unicode: false,\r\n      sticky: false,\r\n    };\r\n\r\n    while (this.isRegExpFlag()) {\r\n      switch (this.popChar()) {\r\n        case \"g\":\r\n          addFlag(flags, \"global\");\r\n          break;\r\n        case \"i\":\r\n          addFlag(flags, \"ignoreCase\");\r\n          break;\r\n        case \"m\":\r\n          addFlag(flags, \"multiLine\");\r\n          break;\r\n        case \"u\":\r\n          addFlag(flags, \"unicode\");\r\n          break;\r\n        case \"y\":\r\n          addFlag(flags, \"sticky\");\r\n          break;\r\n      }\r\n    }\r\n\r\n    if (this.idx !== this.input.length) {\r\n      throw Error(\"Redundant input: \" + this.input.substring(this.idx));\r\n    }\r\n    return {\r\n      type: \"Pattern\",\r\n      flags: flags,\r\n      value: value,\r\n      loc: this.loc(0),\r\n    };\r\n  }\r\n\r\n  protected disjunction(): Disjunction {\r\n    const alts = [];\r\n    const begin = this.idx;\r\n\r\n    alts.push(this.alternative());\r\n\r\n    while (this.peekChar() === \"|\") {\r\n      this.consumeChar(\"|\");\r\n      alts.push(this.alternative());\r\n    }\r\n\r\n    return { type: \"Disjunction\", value: alts, loc: this.loc(begin) };\r\n  }\r\n\r\n  protected alternative(): Alternative {\r\n    const terms = [];\r\n    const begin = this.idx;\r\n\r\n    while (this.isTerm()) {\r\n      terms.push(this.term());\r\n    }\r\n\r\n    return { type: \"Alternative\", value: terms, loc: this.loc(begin) };\r\n  }\r\n\r\n  protected term(): Term {\r\n    if (this.isAssertion()) {\r\n      return this.assertion();\r\n    } else {\r\n      return this.atom();\r\n    }\r\n  }\r\n\r\n  protected assertion(): Assertion {\r\n    const begin = this.idx;\r\n    switch (this.popChar()) {\r\n      case \"^\":\r\n        return {\r\n          type: \"StartAnchor\",\r\n          loc: this.loc(begin),\r\n        };\r\n      case \"$\":\r\n        return { type: \"EndAnchor\", loc: this.loc(begin) };\r\n      // '\\b' or '\\B'\r\n      case \"\\\\\":\r\n        switch (this.popChar()) {\r\n          case \"b\":\r\n            return {\r\n              type: \"WordBoundary\",\r\n              loc: this.loc(begin),\r\n            };\r\n          case \"B\":\r\n            return {\r\n              type: \"NonWordBoundary\",\r\n              loc: this.loc(begin),\r\n            };\r\n        }\r\n        // istanbul ignore next\r\n        throw Error(\"Invalid Assertion Escape\");\r\n      // '(?=' or '(?!'\r\n      case \"(\":\r\n        this.consumeChar(\"?\");\r\n\r\n        let type: \"Lookahead\" | \"NegativeLookahead\" | undefined;\r\n        switch (this.popChar()) {\r\n          case \"=\":\r\n            type = \"Lookahead\";\r\n            break;\r\n          case \"!\":\r\n            type = \"NegativeLookahead\";\r\n            break;\r\n        }\r\n        ASSERT_EXISTS(type);\r\n\r\n        const disjunction = this.disjunction();\r\n\r\n        this.consumeChar(\")\");\r\n\r\n        return {\r\n          type: type!,\r\n          value: disjunction,\r\n          loc: this.loc(begin),\r\n        };\r\n    }\r\n    // istanbul ignore next\r\n    return ASSERT_NEVER_REACH_HERE();\r\n  }\r\n\r\n  protected quantifier(\r\n    isBacktracking: boolean = false,\r\n  ): Quantifier | undefined {\r\n    let range: Partial<Quantifier> | undefined = undefined;\r\n    const begin = this.idx;\r\n    switch (this.popChar()) {\r\n      case \"*\":\r\n        range = {\r\n          atLeast: 0,\r\n          atMost: Infinity,\r\n        };\r\n        break;\r\n      case \"+\":\r\n        range = {\r\n          atLeast: 1,\r\n          atMost: Infinity,\r\n        };\r\n        break;\r\n      case \"?\":\r\n        range = {\r\n          atLeast: 0,\r\n          atMost: 1,\r\n        };\r\n        break;\r\n      case \"{\":\r\n        const atLeast = this.integerIncludingZero();\r\n        switch (this.popChar()) {\r\n          case \"}\":\r\n            range = {\r\n              atLeast: atLeast,\r\n              atMost: atLeast,\r\n            };\r\n            break;\r\n          case \",\":\r\n            let atMost;\r\n            if (this.isDigit()) {\r\n              atMost = this.integerIncludingZero();\r\n              range = {\r\n                atLeast: atLeast,\r\n                atMost: atMost,\r\n              };\r\n            } else {\r\n              range = {\r\n                atLeast: atLeast,\r\n                atMost: Infinity,\r\n              };\r\n            }\r\n            this.consumeChar(\"}\");\r\n            break;\r\n        }\r\n        // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\r\n        // causes severe performance degradations\r\n        if (isBacktracking === true && range === undefined) {\r\n          return undefined;\r\n        }\r\n        ASSERT_EXISTS(range);\r\n        break;\r\n    }\r\n\r\n    // throwing exceptions from \"ASSERT_EXISTS\" during backtracking\r\n    // causes severe performance degradations\r\n    if (isBacktracking === true && range === undefined) {\r\n      return undefined;\r\n    }\r\n\r\n    // istanbul ignore else\r\n    if (ASSERT_EXISTS(range)) {\r\n      if (this.peekChar(0) === \"?\") {\r\n        this.consumeChar(\"?\");\r\n        range.greedy = false;\r\n      } else {\r\n        range.greedy = true;\r\n      }\r\n\r\n      range.type = \"Quantifier\";\r\n      range.loc = this.loc(begin);\r\n      return range as Quantifier;\r\n    }\r\n  }\r\n\r\n  protected atom(): Atom {\r\n    let atom: Omit<Atom, \"loc\" | \"type\"> | undefined;\r\n    const begin = this.idx;\r\n    switch (this.peekChar()) {\r\n      case \".\":\r\n        atom = this.dotAll();\r\n        break;\r\n      case \"\\\\\":\r\n        atom = this.atomEscape();\r\n        break;\r\n      case \"[\":\r\n        atom = this.characterClass();\r\n        break;\r\n      case \"(\":\r\n        atom = this.group();\r\n        break;\r\n    }\r\n\r\n    if (atom === undefined && this.isPatternCharacter()) {\r\n      atom = this.patternCharacter();\r\n    }\r\n\r\n    // istanbul ignore else\r\n    if (ASSERT_EXISTS<Atom>(atom)) {\r\n      atom.loc = this.loc(begin);\r\n\r\n      if (this.isQuantifier()) {\r\n        atom.quantifier = this.quantifier();\r\n      }\r\n\r\n      return atom;\r\n    }\r\n\r\n    // istanbul ignore next\r\n    return ASSERT_NEVER_REACH_HERE();\r\n  }\r\n\r\n  protected dotAll(): Omit<Set, \"loc\"> {\r\n    this.consumeChar(\".\");\r\n    return {\r\n      type: \"Set\",\r\n      complement: true,\r\n      value: [cc(\"\\n\"), cc(\"\\r\"), cc(\"\\u2028\"), cc(\"\\u2029\")],\r\n    };\r\n  }\r\n\r\n  protected atomEscape(): Omit<GroupBackReference | Set | Character, \"loc\"> {\r\n    this.consumeChar(\"\\\\\");\r\n\r\n    switch (this.peekChar()) {\r\n      case \"1\":\r\n      case \"2\":\r\n      case \"3\":\r\n      case \"4\":\r\n      case \"5\":\r\n      case \"6\":\r\n      case \"7\":\r\n      case \"8\":\r\n      case \"9\":\r\n        return this.decimalEscapeAtom();\r\n      case \"d\":\r\n      case \"D\":\r\n      case \"s\":\r\n      case \"S\":\r\n      case \"w\":\r\n      case \"W\":\r\n        return this.characterClassEscape();\r\n      case \"f\":\r\n      case \"n\":\r\n      case \"r\":\r\n      case \"t\":\r\n      case \"v\":\r\n        return this.controlEscapeAtom();\r\n      case \"c\":\r\n        return this.controlLetterEscapeAtom();\r\n      case \"0\":\r\n        return this.nulCharacterAtom();\r\n      case \"x\":\r\n        return this.hexEscapeSequenceAtom();\r\n      case \"u\":\r\n        return this.regExpUnicodeEscapeSequenceAtom();\r\n      default:\r\n        return this.identityEscapeAtom();\r\n    }\r\n  }\r\n\r\n  protected decimalEscapeAtom(): Omit<GroupBackReference, \"loc\"> {\r\n    const value = this.positiveInteger();\r\n\r\n    return { type: \"GroupBackReference\", value: value };\r\n  }\r\n\r\n  protected characterClassEscape(): Omit<Set, \"loc\"> {\r\n    let set: (number | Range)[] | undefined;\r\n    let complement = false;\r\n    switch (this.popChar()) {\r\n      case \"d\":\r\n        set = digitsCharCodes;\r\n        break;\r\n      case \"D\":\r\n        set = digitsCharCodes;\r\n        complement = true;\r\n        break;\r\n      case \"s\":\r\n        set = whitespaceCodes;\r\n        break;\r\n      case \"S\":\r\n        set = whitespaceCodes;\r\n        complement = true;\r\n        break;\r\n      case \"w\":\r\n        set = wordCharCodes;\r\n        break;\r\n      case \"W\":\r\n        set = wordCharCodes;\r\n        complement = true;\r\n        break;\r\n    }\r\n\r\n    // istanbul ignore else\r\n    if (ASSERT_EXISTS(set)) {\r\n      return { type: \"Set\", value: set, complement: complement };\r\n    }\r\n    // istanbul ignore next\r\n    return ASSERT_NEVER_REACH_HERE();\r\n  }\r\n\r\n  protected controlEscapeAtom(): Omit<Character, \"loc\"> {\r\n    let escapeCode;\r\n    switch (this.popChar()) {\r\n      case \"f\":\r\n        escapeCode = cc(\"\\f\");\r\n        break;\r\n      case \"n\":\r\n        escapeCode = cc(\"\\n\");\r\n        break;\r\n      case \"r\":\r\n        escapeCode = cc(\"\\r\");\r\n        break;\r\n      case \"t\":\r\n        escapeCode = cc(\"\\t\");\r\n        break;\r\n      case \"v\":\r\n        escapeCode = cc(\"\\v\");\r\n        break;\r\n    }\r\n\r\n    // istanbul ignore else\r\n    if (ASSERT_EXISTS(escapeCode)) {\r\n      return { type: \"Character\", value: escapeCode };\r\n    }\r\n    // istanbul ignore next\r\n    return ASSERT_NEVER_REACH_HERE();\r\n  }\r\n\r\n  protected controlLetterEscapeAtom(): Omit<Character, \"loc\"> {\r\n    this.consumeChar(\"c\");\r\n    const letter = this.popChar();\r\n    if (/[a-zA-Z]/.test(letter) === false) {\r\n      throw Error(\"Invalid \");\r\n    }\r\n\r\n    const letterCode = letter.toUpperCase().charCodeAt(0) - 64;\r\n    return { type: \"Character\", value: letterCode };\r\n  }\r\n\r\n  protected nulCharacterAtom(): Omit<Character, \"loc\"> {\r\n    // TODO implement '[lookahead \u2209 DecimalDigit]'\r\n    // TODO: for the deprecated octal escape sequence\r\n    this.consumeChar(\"0\");\r\n    return { type: \"Character\", value: cc(\"\\0\") };\r\n  }\r\n\r\n  protected hexEscapeSequenceAtom(): Omit<Character, \"loc\"> {\r\n    this.consumeChar(\"x\");\r\n    return this.parseHexDigits(2);\r\n  }\r\n\r\n  protected regExpUnicodeEscapeSequenceAtom(): Omit<Character, \"loc\"> {\r\n    this.consumeChar(\"u\");\r\n    return this.parseHexDigits(4);\r\n  }\r\n\r\n  protected identityEscapeAtom(): Omit<Character, \"loc\"> {\r\n    // TODO: implement \"SourceCharacter but not UnicodeIDContinue\"\r\n    // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments\r\n    const escapedChar = this.popChar();\r\n    return { type: \"Character\", value: cc(escapedChar) };\r\n  }\r\n\r\n  protected classPatternCharacterAtom(): Omit<Character, \"loc\"> {\r\n    switch (this.peekChar()) {\r\n      // istanbul ignore next\r\n      case \"\\n\":\r\n      // istanbul ignore next\r\n      case \"\\r\":\r\n      // istanbul ignore next\r\n      case \"\\u2028\":\r\n      // istanbul ignore next\r\n      case \"\\u2029\":\r\n      // istanbul ignore next\r\n      case \"\\\\\":\r\n      // istanbul ignore next\r\n      case \"]\":\r\n        throw Error(\"TBD\");\r\n      default:\r\n        const nextChar = this.popChar();\r\n        return { type: \"Character\", value: cc(nextChar) };\r\n    }\r\n  }\r\n\r\n  protected characterClass(): Omit<Set, \"loc\"> {\r\n    const set: (number | Range)[] = [];\r\n    let complement = false;\r\n    this.consumeChar(\"[\");\r\n    if (this.peekChar(0) === \"^\") {\r\n      this.consumeChar(\"^\");\r\n      complement = true;\r\n    }\r\n\r\n    while (this.isClassAtom()) {\r\n      const from = this.classAtom();\r\n      const isFromSingleChar = from.type === \"Character\";\r\n      if (isCharacter(from) && this.isRangeDash()) {\r\n        this.consumeChar(\"-\");\r\n        const to = this.classAtom();\r\n        const isToSingleChar = to.type === \"Character\";\r\n\r\n        // a range can only be used when both sides are single characters\r\n        if (isCharacter(to)) {\r\n          if (to.value < from.value) {\r\n            throw Error(\"Range out of order in character class\");\r\n          }\r\n          set.push({ from: from.value, to: to.value });\r\n        } else {\r\n          // literal dash\r\n          insertToSet(from.value, set);\r\n          set.push(cc(\"-\"));\r\n          insertToSet(to.value, set);\r\n        }\r\n      } else {\r\n        insertToSet(from.value, set);\r\n      }\r\n    }\r\n\r\n    this.consumeChar(\"]\");\r\n\r\n    return { type: \"Set\", complement: complement, value: set };\r\n  }\r\n\r\n  protected classAtom(): Omit<Character | Set, \"loc\"> {\r\n    switch (this.peekChar()) {\r\n      // istanbul ignore next\r\n      case \"]\":\r\n      // istanbul ignore next\r\n      case \"\\n\":\r\n      // istanbul ignore next\r\n      case \"\\r\":\r\n      // istanbul ignore next\r\n      case \"\\u2028\":\r\n      // istanbul ignore next\r\n      case \"\\u2029\":\r\n        throw Error(\"TBD\");\r\n      case \"\\\\\":\r\n        return this.classEscape();\r\n      default:\r\n        return this.classPatternCharacterAtom();\r\n    }\r\n  }\r\n\r\n  protected classEscape(): Omit<Character | Set, \"loc\"> {\r\n    this.consumeChar(\"\\\\\");\r\n    switch (this.peekChar()) {\r\n      // Matches a backspace.\r\n      // (Not to be confused with \\b word boundary outside characterClass)\r\n      case \"b\":\r\n        this.consumeChar(\"b\");\r\n        return { type: \"Character\", value: cc(\"\\u0008\") };\r\n      case \"d\":\r\n      case \"D\":\r\n      case \"s\":\r\n      case \"S\":\r\n      case \"w\":\r\n      case \"W\":\r\n        return this.characterClassEscape();\r\n      case \"f\":\r\n      case \"n\":\r\n      case \"r\":\r\n      case \"t\":\r\n      case \"v\":\r\n        return this.controlEscapeAtom();\r\n      case \"c\":\r\n        return this.controlLetterEscapeAtom();\r\n      case \"0\":\r\n        return this.nulCharacterAtom();\r\n      case \"x\":\r\n        return this.hexEscapeSequenceAtom();\r\n      case \"u\":\r\n        return this.regExpUnicodeEscapeSequenceAtom();\r\n      default:\r\n        return this.identityEscapeAtom();\r\n    }\r\n  }\r\n\r\n  protected group(): Omit<Group, \"loc\"> {\r\n    let capturing = true;\r\n    this.consumeChar(\"(\");\r\n    switch (this.peekChar(0)) {\r\n      case \"?\":\r\n        this.consumeChar(\"?\");\r\n        this.consumeChar(\":\");\r\n        capturing = false;\r\n        break;\r\n      default:\r\n        this.groupIdx++;\r\n        break;\r\n    }\r\n    const value = this.disjunction();\r\n    this.consumeChar(\")\");\r\n\r\n    const groupAst: Omit<Group, \"loc\"> = {\r\n      type: \"Group\",\r\n      capturing: capturing,\r\n      value: value,\r\n    };\r\n\r\n    if (capturing) {\r\n      groupAst[\"idx\"] = this.groupIdx;\r\n    }\r\n\r\n    return groupAst;\r\n  }\r\n\r\n  protected positiveInteger(): number {\r\n    let number = this.popChar();\r\n\r\n    // istanbul ignore next - can't ever get here due to previous lookahead checks\r\n    // still implementing this error checking in case this ever changes.\r\n    if (decimalPatternNoZero.test(number) === false) {\r\n      throw Error(\"Expecting a positive integer\");\r\n    }\r\n\r\n    while (decimalPattern.test(this.peekChar(0))) {\r\n      number += this.popChar();\r\n    }\r\n\r\n    return parseInt(number, 10);\r\n  }\r\n\r\n  protected integerIncludingZero(): number {\r\n    let number = this.popChar();\r\n    if (decimalPattern.test(number) === false) {\r\n      throw Error(\"Expecting an integer\");\r\n    }\r\n\r\n    while (decimalPattern.test(this.peekChar(0))) {\r\n      number += this.popChar();\r\n    }\r\n\r\n    return parseInt(number, 10);\r\n  }\r\n\r\n  protected patternCharacter(): Omit<Character, \"loc\"> {\r\n    const nextChar = this.popChar();\r\n    switch (nextChar) {\r\n      // istanbul ignore next\r\n      case \"\\n\":\r\n      // istanbul ignore next\r\n      case \"\\r\":\r\n      // istanbul ignore next\r\n      case \"\\u2028\":\r\n      // istanbul ignore next\r\n      case \"\\u2029\":\r\n      // istanbul ignore next\r\n      case \"^\":\r\n      // istanbul ignore next\r\n      case \"$\":\r\n      // istanbul ignore next\r\n      case \"\\\\\":\r\n      // istanbul ignore next\r\n      case \".\":\r\n      // istanbul ignore next\r\n      case \"*\":\r\n      // istanbul ignore next\r\n      case \"+\":\r\n      // istanbul ignore next\r\n      case \"?\":\r\n      // istanbul ignore next\r\n      case \"(\":\r\n      // istanbul ignore next\r\n      case \")\":\r\n      // istanbul ignore next\r\n      case \"[\":\r\n      // istanbul ignore next\r\n      case \"|\":\r\n        // istanbul ignore next\r\n        throw Error(\"TBD\");\r\n      default:\r\n        return { type: \"Character\", value: cc(nextChar) };\r\n    }\r\n  }\r\n  protected isRegExpFlag(): boolean {\r\n    switch (this.peekChar(0)) {\r\n      case \"g\":\r\n      case \"i\":\r\n      case \"m\":\r\n      case \"u\":\r\n      case \"y\":\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  protected isRangeDash(): boolean {\r\n    return this.peekChar() === \"-\" && this.isClassAtom(1);\r\n  }\r\n\r\n  protected isDigit(): boolean {\r\n    return decimalPattern.test(this.peekChar(0));\r\n  }\r\n\r\n  protected isClassAtom(howMuch = 0): boolean {\r\n    switch (this.peekChar(howMuch)) {\r\n      case \"]\":\r\n      case \"\\n\":\r\n      case \"\\r\":\r\n      case \"\\u2028\":\r\n      case \"\\u2029\":\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  protected isTerm() {\r\n    return this.isAtom() || this.isAssertion();\r\n  }\r\n\r\n  protected isAtom(): boolean {\r\n    if (this.isPatternCharacter()) {\r\n      return true;\r\n    }\r\n\r\n    switch (this.peekChar(0)) {\r\n      case \".\":\r\n      case \"\\\\\": // atomEscape\r\n      case \"[\": // characterClass\r\n      // TODO: isAtom must be called before isAssertion - disambiguate\r\n      case \"(\": // group\r\n        return true;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  protected isAssertion(): boolean {\r\n    switch (this.peekChar(0)) {\r\n      case \"^\":\r\n      case \"$\":\r\n        return true;\r\n      // '\\b' or '\\B'\r\n      case \"\\\\\":\r\n        switch (this.peekChar(1)) {\r\n          case \"b\":\r\n          case \"B\":\r\n            return true;\r\n          default:\r\n            return false;\r\n        }\r\n      // '(?=' or '(?!'\r\n      case \"(\":\r\n        return (\r\n          this.peekChar(1) === \"?\" &&\r\n          (this.peekChar(2) === \"=\" || this.peekChar(2) === \"!\")\r\n        );\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  protected isQuantifier(): boolean {\r\n    const prevState = this.saveState();\r\n    try {\r\n      return this.quantifier(true) !== undefined;\r\n    } catch (e) {\r\n      return false;\r\n    } finally {\r\n      this.restoreState(prevState);\r\n    }\r\n  }\r\n\r\n  protected isPatternCharacter(): boolean {\r\n    switch (this.peekChar()) {\r\n      case \"^\":\r\n      case \"$\":\r\n      case \"\\\\\":\r\n      case \".\":\r\n      case \"*\":\r\n      case \"+\":\r\n      case \"?\":\r\n      case \"(\":\r\n      case \")\":\r\n      case \"[\":\r\n      case \"|\":\r\n      case \"/\":\r\n      case \"\\n\":\r\n      case \"\\r\":\r\n      case \"\\u2028\":\r\n      case \"\\u2029\":\r\n        return false;\r\n      default:\r\n        return true;\r\n    }\r\n  }\r\n\r\n  protected parseHexDigits(howMany: number): Omit<Character, \"loc\"> {\r\n    let hexString = \"\";\r\n    for (let i = 0; i < howMany; i++) {\r\n      const hexChar = this.popChar();\r\n      if (hexDigitPattern.test(hexChar) === false) {\r\n        throw Error(\"Expecting a HexDecimal digits\");\r\n      }\r\n      hexString += hexChar;\r\n    }\r\n    const charCode = parseInt(hexString, 16);\r\n    return { type: \"Character\", value: charCode };\r\n  }\r\n\r\n  protected peekChar(howMuch = 0): string {\r\n    return this.input[this.idx + howMuch];\r\n  }\r\n\r\n  protected popChar(): string {\r\n    const nextChar = this.peekChar(0);\r\n    this.consumeChar(undefined);\r\n    return nextChar;\r\n  }\r\n\r\n  protected consumeChar(char: string | undefined): void {\r\n    if (char !== undefined && this.input[this.idx] !== char) {\r\n      throw Error(\r\n        \"Expected: '\" +\r\n          char +\r\n          \"' but found: '\" +\r\n          this.input[this.idx] +\r\n          \"' at offset: \" +\r\n          this.idx,\r\n      );\r\n    }\r\n\r\n    if (this.idx >= this.input.length) {\r\n      throw Error(\"Unexpected end of input\");\r\n    }\r\n    this.idx++;\r\n  }\r\n\r\n  protected loc(begin: number): Location {\r\n    return { begin: begin, end: this.idx };\r\n  }\r\n}\r\n", "import type {\r\n  Alternative,\r\n  Assertion,\r\n  Character,\r\n  Disjunction,\r\n  Group,\r\n  GroupBackReference,\r\n  IRegExpAST,\r\n  Quantifier,\r\n  RegExpAstPart,\r\n  RegExpFlags,\r\n  RegExpPattern,\r\n  Set,\r\n} from \"../types\";\r\n\r\nexport class BaseRegExpVisitor {\r\n  public visitChildren(node: IRegExpAST) {\r\n    for (const key in node) {\r\n      const child = (node as any)[key];\r\n      /* istanbul ignore else */\r\n      if (node.hasOwnProperty(key)) {\r\n        if (child.type !== undefined) {\r\n          this.visit(child);\r\n        } else if (Array.isArray(child)) {\r\n          child.forEach((subChild) => {\r\n            this.visit(subChild);\r\n          }, this);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public visit(node: RegExpAstPart): void {\r\n    switch (node.type) {\r\n      case \"Pattern\":\r\n        this.visitPattern(node);\r\n        break;\r\n      case \"Flags\":\r\n        this.visitFlags(node);\r\n        break;\r\n      case \"Disjunction\":\r\n        this.visitDisjunction(node);\r\n        break;\r\n      case \"Alternative\":\r\n        this.visitAlternative(node);\r\n        break;\r\n      case \"StartAnchor\":\r\n        this.visitStartAnchor(node);\r\n        break;\r\n      case \"EndAnchor\":\r\n        this.visitEndAnchor(node);\r\n        break;\r\n      case \"WordBoundary\":\r\n        this.visitWordBoundary(node);\r\n        break;\r\n      case \"NonWordBoundary\":\r\n        this.visitNonWordBoundary(node);\r\n        break;\r\n      case \"Lookahead\":\r\n        this.visitLookahead(node);\r\n        break;\r\n      case \"NegativeLookahead\":\r\n        this.visitNegativeLookahead(node);\r\n        break;\r\n      case \"Character\":\r\n        this.visitCharacter(node);\r\n        break;\r\n      case \"Set\":\r\n        this.visitSet(node);\r\n        break;\r\n      case \"Group\":\r\n        this.visitGroup(node);\r\n        break;\r\n      case \"GroupBackReference\":\r\n        this.visitGroupBackReference(node);\r\n        break;\r\n      case \"Quantifier\":\r\n        this.visitQuantifier(node);\r\n        break;\r\n    }\r\n\r\n    this.visitChildren(node);\r\n  }\r\n\r\n  public visitPattern(node: RegExpPattern): void {}\r\n\r\n  public visitFlags(node: RegExpFlags): void {}\r\n\r\n  public visitDisjunction(node: Disjunction): void {}\r\n\r\n  public visitAlternative(node: Alternative): void {}\r\n\r\n  // Assertion\r\n  public visitStartAnchor(node: Assertion): void {}\r\n\r\n  public visitEndAnchor(node: Assertion): void {}\r\n\r\n  public visitWordBoundary(node: Assertion): void {}\r\n\r\n  public visitNonWordBoundary(node: Assertion): void {}\r\n\r\n  public visitLookahead(node: Assertion): void {}\r\n\r\n  public visitNegativeLookahead(node: Assertion): void {}\r\n\r\n  // atoms\r\n  public visitCharacter(node: Character): void {}\r\n\r\n  public visitSet(node: Set): void {}\r\n\r\n  public visitGroup(node: Group): void {}\r\n\r\n  public visitGroupBackReference(node: GroupBackReference): void {}\r\n\r\n  public visitQuantifier(node: Quantifier): void {}\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Set, Group, Character, IRegExpAST } from '@chevrotain/regexp-to-ast';\r\nimport { RegExpParser, BaseRegExpVisitor } from '@chevrotain/regexp-to-ast';\r\n\r\nconst regexParser = new RegExpParser();\r\n\r\n/**\r\n * This class is in charge of heuristically identifying start/end tokens of terminals.\r\n *\r\n * The way this works is by doing the following:\r\n * 1. Traverse the regular expression in the \"start state\"\r\n * 2. Add any encountered sets/single characters to the \"start regex\"\r\n * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the \"end state\"\r\n * 4. In the end state, any sets/single characters are added to an \"end stack\".\r\n * 5. If we re-encounter any variable-length content we reset the end stack\r\n * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary\r\n *\r\n * After traversing a regular expression the `startRegex/endRegex` properties allow access to the stored start/end of the terminal\r\n */\r\nclass TerminalRegexVisitor extends BaseRegExpVisitor {\r\n\r\n    private isStarting = true;\r\n    startRegex: string;\r\n    private endRegexStack: string[] = [];\r\n    multiline = false;\r\n    regex: string;\r\n\r\n    get endRegex(): string {\r\n        return this.endRegexStack.join('');\r\n    }\r\n\r\n    reset(regex: string): void {\r\n        this.multiline = false;\r\n        this.regex = regex;\r\n        this.startRegex = '';\r\n        this.isStarting = true;\r\n        this.endRegexStack = [];\r\n    }\r\n\r\n    override visitGroup(node: Group) {\r\n        if (node.quantifier) {\r\n            this.isStarting = false;\r\n            this.endRegexStack = [];\r\n        }\r\n    }\r\n\r\n    override visitCharacter(node: Character): void {\r\n        const char = String.fromCharCode(node.value);\r\n        if (!this.multiline && char === '\\n') {\r\n            this.multiline = true;\r\n        }\r\n        if (node.quantifier) {\r\n            this.isStarting = false;\r\n            this.endRegexStack = [];\r\n        } else {\r\n            const escapedChar = escapeRegExp(char);\r\n            this.endRegexStack.push(escapedChar);\r\n            if (this.isStarting) {\r\n                this.startRegex += escapedChar;\r\n            }\r\n        }\r\n    }\r\n\r\n    override visitSet(node: Set): void {\r\n        if (!this.multiline) {\r\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\r\n            const regex = new RegExp(set);\r\n            this.multiline = Boolean('\\n'.match(regex));\r\n        }\r\n        if (node.quantifier) {\r\n            this.isStarting = false;\r\n            this.endRegexStack = [];\r\n        } else {\r\n            const set = this.regex.substring(node.loc.begin, node.loc.end);\r\n            this.endRegexStack.push(set);\r\n            if (this.isStarting) {\r\n                this.startRegex += set;\r\n            }\r\n        }\r\n    }\r\n\r\n    override visitChildren(node: IRegExpAST): void {\r\n        if (node.type === 'Group') {\r\n            // Ignore children of groups with quantifier (+/*/?)\r\n            // These groups are unrelated to start/end tokens of terminals\r\n            const group = node as Group;\r\n            if (group.quantifier) {\r\n                return;\r\n            }\r\n        }\r\n        super.visitChildren(node);\r\n    }\r\n}\r\n\r\nconst visitor = new TerminalRegexVisitor();\r\n\r\nexport function getTerminalParts(regex: RegExp | string): Array<{ start: string, end: string }> {\r\n    try {\r\n        if (typeof regex !== 'string') {\r\n            regex = regex.source;\r\n        }\r\n        regex = `/${regex}/`;\r\n        const pattern = regexParser.pattern(regex);\r\n        const parts: Array<{ start: string, end: string }> = [];\r\n        for (const alternative of pattern.value.value) {\r\n            visitor.reset(regex);\r\n            visitor.visit(alternative);\r\n            parts.push({\r\n                start: visitor.startRegex,\r\n                end: visitor.endRegex\r\n            });\r\n        }\r\n        return parts;\r\n    } catch {\r\n        return [];\r\n    }\r\n}\r\n\r\nexport function isMultilineComment(regex: RegExp | string): boolean {\r\n    try {\r\n        if (typeof regex === 'string') {\r\n            regex = new RegExp(regex);\r\n        }\r\n        regex = regex.toString();\r\n        visitor.reset(regex);\r\n        // Parsing the pattern might fail (since it's user code)\r\n        visitor.visit(regexParser.pattern(regex));\r\n        return visitor.multiline;\r\n    } catch {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function isWhitespaceRegExp(value: RegExp | string): boolean {\r\n    const regexp = typeof value === 'string' ? new RegExp(value) : value;\r\n    return regexp.test(' ');\r\n}\r\n\r\nexport function escapeRegExp(value: string): string {\r\n    return value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\r\n}\r\n\r\nexport function getCaseInsensitivePattern(keyword: string): string {\r\n    return Array.prototype.map.call(keyword, letter =>\r\n        /\\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)\r\n    ).join('');\r\n}\r\n\r\n/**\r\n * Determines whether the given input has a partial match with the specified regex.\r\n * @param regex The regex to partially match against\r\n * @param input The input string\r\n * @returns Whether any match exists.\r\n */\r\nexport function partialMatches(regex: RegExp | string, input: string): boolean {\r\n    const partial = partialRegex(regex);\r\n    const match = input.match(partial);\r\n    return !!match && match[0].length > 0;\r\n}\r\n\r\n/**\r\n * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.\r\n * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.\r\n * @param regex The input regex to be converted.\r\n * @returns A partial regex constructed from the input regex.\r\n */\r\nexport function partialRegex(regex: RegExp | string): RegExp {\r\n    if (typeof regex === 'string') {\r\n        regex = new RegExp(regex);\r\n    }\r\n    const re = regex, source = regex.source;\r\n    let i = 0;\r\n\r\n    function process() {\r\n        let result = '',\r\n            tmp;\r\n\r\n        function appendRaw(nbChars: number) {\r\n            result += source.substr(i, nbChars);\r\n            i += nbChars;\r\n        }\r\n\r\n        function appendOptional(nbChars: number) {\r\n            result += '(?:' + source.substr(i, nbChars) + '|$)';\r\n            i += nbChars;\r\n        }\r\n\r\n        while (i < source.length) {\r\n            switch (source[i]) {\r\n                case '\\\\':\r\n                    switch (source[i + 1]) {\r\n                        case 'c':\r\n                            appendOptional(3);\r\n                            break;\r\n                        case 'x':\r\n                            appendOptional(4);\r\n                            break;\r\n                        case 'u':\r\n                            if (re.unicode) {\r\n                                if (source[i + 2] === '{') {\r\n                                    appendOptional(source.indexOf('}', i) - i + 1);\r\n                                } else {\r\n                                    appendOptional(6);\r\n                                }\r\n                            } else {\r\n                                appendOptional(2);\r\n                            }\r\n                            break;\r\n                        case 'p':\r\n                        case 'P':\r\n                            if (re.unicode) {\r\n                                appendOptional(source.indexOf('}', i) - i + 1);\r\n                            } else {\r\n                                appendOptional(2);\r\n                            }\r\n                            break;\r\n                        case 'k':\r\n                            appendOptional(source.indexOf('>', i) - i + 1);\r\n                            break;\r\n                        default:\r\n                            appendOptional(2);\r\n                            break;\r\n                    }\r\n                    break;\r\n\r\n                case '[':\r\n                    tmp = /\\[(?:\\\\.|.)*?\\]/g;\r\n                    tmp.lastIndex = i;\r\n                    tmp = tmp.exec(source) || [];\r\n                    appendOptional(tmp[0].length);\r\n                    break;\r\n\r\n                case '|':\r\n                case '^':\r\n                case '$':\r\n                case '*':\r\n                case '+':\r\n                case '?':\r\n                    appendRaw(1);\r\n                    break;\r\n                case '{':\r\n                    tmp = /\\{\\d+,?\\d*\\}/g;\r\n                    tmp.lastIndex = i;\r\n                    tmp = tmp.exec(source);\r\n                    if (tmp) {\r\n                        appendRaw(tmp[0].length);\r\n                    } else {\r\n                        appendOptional(1);\r\n                    }\r\n                    break;\r\n                case '(':\r\n                    if (source[i + 1] === '?') {\r\n                        switch (source[i + 2]) {\r\n                            case ':':\r\n                                result += '(?:';\r\n                                i += 3;\r\n                                result += process() + '|$)';\r\n                                break;\r\n                            case '=':\r\n                                result += '(?=';\r\n                                i += 3;\r\n                                result += process() + ')';\r\n                                break;\r\n                            case '!':\r\n                                tmp = i;\r\n                                i += 3;\r\n                                process();\r\n                                result += source.substr(tmp, i - tmp);\r\n                                break;\r\n                            case '<':\r\n                                switch (source[i + 3]) {\r\n                                    case '=':\r\n                                    case '!':\r\n                                        tmp = i;\r\n                                        i += 4;\r\n                                        process();\r\n                                        result += source.substr(tmp, i - tmp);\r\n                                        break;\r\n                                    default:\r\n                                        appendRaw(source.indexOf('>', i) - i + 1);\r\n                                        result += process() + '|$)';\r\n                                        break;\r\n                                }\r\n                                break;\r\n                        }\r\n                    } else {\r\n                        appendRaw(1);\r\n                        result += process() + '|$)';\r\n                    }\r\n                    break;\r\n                case ')':\r\n                    ++i;\r\n                    return result;\r\n                default:\r\n                    appendOptional(1);\r\n                    break;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    return new RegExp(process(), regex.flags);\r\n}\r\n", "// 'path' module extracted from Node.js v8.11.1 (only the posix part)\n// transplited with Babel\n\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 /*.*/ && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          if (!matchedSlash) {\n            end = i;\n            break;\n          }\n        } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n            // If we reached a path separator that was not part of a set of path\n            // separators at the end of the string, stop now\n            if (!matchedSlash) {\n              start = i + 1;\n              break;\n            }\n          } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1)\n            startDot = i;\n          else if (preDotState !== 1)\n            preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            startPart = i + 1;\n            break;\n          }\n          continue;\n        }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46 /*.*/) {\n          // If this is our first dot, mark it as the start of our extension\n          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n        } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\n// !!!!!\n// SEE https://github.com/microsoft/vscode/blob/master/src/vs/base/common/platform.ts\n// !!!!!\n\ndeclare const process: { platform: 'win32' };\ndeclare const navigator: { userAgent: string };\n\nexport let isWindows: boolean;\n\nif (typeof process === 'object') {\n\tisWindows = process.platform === 'win32';\n} else if (typeof navigator === 'object') {\n\tlet userAgent = navigator.userAgent;\n\tisWindows = userAgent.indexOf('Windows') >= 0;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n'use strict';\n\nimport { CharCode } from './charCode'\nimport { isWindows } from './platform';\n\nconst _schemePattern = /^\\w[\\w\\d+.-]*$/;\nconst _singleSlashStart = /^\\//;\nconst _doubleSlashStart = /^\\/\\//;\n\nfunction _validateUri(ret: URI, _strict?: boolean): void {\n\n\t// scheme, must be set\n\tif (!ret.scheme && _strict) {\n\t\tthrow new Error(`[UriError]: Scheme is missing: {scheme: \"\", authority: \"${ret.authority}\", path: \"${ret.path}\", query: \"${ret.query}\", fragment: \"${ret.fragment}\"}`);\n\t}\n\n\t// scheme, https://tools.ietf.org/html/rfc3986#section-3.1\n\t// ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n\tif (ret.scheme && !_schemePattern.test(ret.scheme)) {\n\t\tthrow new Error('[UriError]: Scheme contains illegal characters.');\n\t}\n\n\t// path, http://tools.ietf.org/html/rfc3986#section-3.3\n\t// If a URI contains an authority component, then the path component\n\t// must either be empty or begin with a slash (\"/\") character.  If a URI\n\t// does not contain an authority component, then the path cannot begin\n\t// with two slash characters (\"//\").\n\tif (ret.path) {\n\t\tif (ret.authority) {\n\t\t\tif (!_singleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash (\"/\") character');\n\t\t\t}\n\t\t} else {\n\t\t\tif (_doubleSlashStart.test(ret.path)) {\n\t\t\t\tthrow new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters (\"//\")');\n\t\t\t}\n\t\t}\n\t}\n}\n\n// for a while we allowed uris *without* schemes and this is the migration\n// for them, e.g. an uri without scheme and without strict-mode warns and falls\n// back to the file-scheme. that should cause the least carnage and still be a\n// clear warning\nfunction _schemeFix(scheme: string, _strict: boolean): string {\n\tif (!scheme && !_strict) {\n\t\treturn 'file';\n\t}\n\treturn scheme;\n}\n\n// implements a bit of https://tools.ietf.org/html/rfc3986#section-5\nfunction _referenceResolution(scheme: string, path: string): string {\n\n\t// the slash-character is our 'default base' as we don't\n\t// support constructing URIs relative to other URIs. This\n\t// also means that we alter and potentially break paths.\n\t// see https://tools.ietf.org/html/rfc3986#section-5.1.4\n\tswitch (scheme) {\n\t\tcase 'https':\n\t\tcase 'http':\n\t\tcase 'file':\n\t\t\tif (!path) {\n\t\t\t\tpath = _slash;\n\t\t\t} else if (path[0] !== _slash) {\n\t\t\t\tpath = _slash + path;\n\t\t\t}\n\t\t\tbreak;\n\t}\n\treturn path;\n}\n\nconst _empty = '';\nconst _slash = '/';\nconst _regexp = /^(([^:/?#]+?):)?(\\/\\/([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?/;\n\n/**\n * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.\n * This class is a simple parser which creates the basic component parts\n * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation\n * and encoding.\n *\n * ```txt\n *       foo://example.com:8042/over/there?name=ferret#nose\n *       \\_/   \\______________/\\_________/ \\_________/ \\__/\n *        |           |            |            |        |\n *     scheme     authority       path        query   fragment\n *        |   _____________________|__\n *       / \\ /                        \\\n *       urn:example:animal:ferret:nose\n * ```\n */\nexport class URI implements UriComponents {\n\n\tstatic isUri(thing: any): thing is URI {\n\t\tif (thing instanceof URI) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!thing) {\n\t\t\treturn false;\n\t\t}\n\t\treturn typeof (<URI>thing).authority === 'string'\n\t\t\t&& typeof (<URI>thing).fragment === 'string'\n\t\t\t&& typeof (<URI>thing).path === 'string'\n\t\t\t&& typeof (<URI>thing).query === 'string'\n\t\t\t&& typeof (<URI>thing).scheme === 'string'\n\t\t\t&& typeof (<URI>thing).fsPath === 'string'\n\t\t\t&& typeof (<URI>thing).with === 'function'\n\t\t\t&& typeof (<URI>thing).toString === 'function';\n\t}\n\n\t/**\n\t * scheme is the 'http' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part before the first colon.\n\t */\n\treadonly scheme: string;\n\n\t/**\n\t * authority is the 'www.example.com' part of 'http://www.example.com/some/path?query#fragment'.\n\t * The part between the first double slashes and the next slash.\n\t */\n\treadonly authority: string;\n\n\t/**\n\t * path is the '/some/path' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly path: string;\n\n\t/**\n\t * query is the 'query' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly query: string;\n\n\t/**\n\t * fragment is the 'fragment' part of 'http://www.example.com/some/path?query#fragment'.\n\t */\n\treadonly fragment: string;\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(scheme: string, authority?: string, path?: string, query?: string, fragment?: string, _strict?: boolean);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(components: UriComponents);\n\n\t/**\n\t * @internal\n\t */\n\tprotected constructor(schemeOrData: string | UriComponents, authority?: string, path?: string, query?: string, fragment?: string, _strict: boolean = false) {\n\n\t\tif (typeof schemeOrData === 'object') {\n\t\t\tthis.scheme = schemeOrData.scheme || _empty;\n\t\t\tthis.authority = schemeOrData.authority || _empty;\n\t\t\tthis.path = schemeOrData.path || _empty;\n\t\t\tthis.query = schemeOrData.query || _empty;\n\t\t\tthis.fragment = schemeOrData.fragment || _empty;\n\t\t\t// no validation because it's this URI\n\t\t\t// that creates uri components.\n\t\t\t// _validateUri(this);\n\t\t} else {\n\t\t\tthis.scheme = _schemeFix(schemeOrData, _strict);\n\t\t\tthis.authority = authority || _empty;\n\t\t\tthis.path = _referenceResolution(this.scheme, path || _empty);\n\t\t\tthis.query = query || _empty;\n\t\t\tthis.fragment = fragment || _empty;\n\n\t\t\t_validateUri(this, _strict);\n\t\t}\n\t}\n\n\t// ---- filesystem path -----------------------\n\n\t/**\n\t * Returns a string representing the corresponding file system path of this URI.\n\t * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the\n\t * platform specific path separator.\n\t *\n\t * * Will *not* validate the path for invalid characters and semantics.\n\t * * Will *not* look at the scheme of this URI.\n\t * * The result shall *not* be used for display purposes but for accessing a file on disk.\n\t *\n\t *\n\t * The *difference* to `URI#path` is the use of the platform specific separator and the handling\n\t * of UNC paths. See the below sample of a file-uri with an authority (UNC path).\n\t *\n\t * ```ts\n\t\tconst u = URI.parse('file://server/c$/folder/file.txt')\n\t\tu.authority === 'server'\n\t\tu.path === '/shares/c$/file.txt'\n\t\tu.fsPath === '\\\\server\\c$\\folder\\file.txt'\n\t```\n\t *\n\t * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,\n\t * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working\n\t * with URIs that represent files on disk (`file` scheme).\n\t */\n\tget fsPath(): string {\n\t\t// if (this.scheme !== 'file') {\n\t\t// \tconsole.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);\n\t\t// }\n\t\treturn uriToFsPath(this, false);\n\t}\n\n\t// ---- modify to new -------------------------\n\n\twith(change: { scheme?: string; authority?: string | null; path?: string | null; query?: string | null; fragment?: string | null }): URI {\n\n\t\tif (!change) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet { scheme, authority, path, query, fragment } = change;\n\t\tif (scheme === undefined) {\n\t\t\tscheme = this.scheme;\n\t\t} else if (scheme === null) {\n\t\t\tscheme = _empty;\n\t\t}\n\t\tif (authority === undefined) {\n\t\t\tauthority = this.authority;\n\t\t} else if (authority === null) {\n\t\t\tauthority = _empty;\n\t\t}\n\t\tif (path === undefined) {\n\t\t\tpath = this.path;\n\t\t} else if (path === null) {\n\t\t\tpath = _empty;\n\t\t}\n\t\tif (query === undefined) {\n\t\t\tquery = this.query;\n\t\t} else if (query === null) {\n\t\t\tquery = _empty;\n\t\t}\n\t\tif (fragment === undefined) {\n\t\t\tfragment = this.fragment;\n\t\t} else if (fragment === null) {\n\t\t\tfragment = _empty;\n\t\t}\n\n\t\tif (scheme === this.scheme\n\t\t\t&& authority === this.authority\n\t\t\t&& path === this.path\n\t\t\t&& query === this.query\n\t\t\t&& fragment === this.fragment) {\n\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new Uri(scheme, authority, path, query, fragment);\n\t}\n\n\t// ---- parse & validate ------------------------\n\n\t/**\n\t * Creates a new URI from a string, e.g. `http://www.example.com/some/path`,\n\t * `file:///usr/home`, or `scheme:with/path`.\n\t *\n\t * @param value A string which represents an URI (see `URI#toString`).\n\t */\n\tstatic parse(value: string, _strict: boolean = false): URI {\n\t\tconst match = _regexp.exec(value);\n\t\tif (!match) {\n\t\t\treturn new Uri(_empty, _empty, _empty, _empty, _empty);\n\t\t}\n\t\treturn new Uri(\n\t\t\tmatch[2] || _empty,\n\t\t\tpercentDecode(match[4] || _empty),\n\t\t\tpercentDecode(match[5] || _empty),\n\t\t\tpercentDecode(match[7] || _empty),\n\t\t\tpercentDecode(match[9] || _empty),\n\t\t\t_strict\n\t\t);\n\t}\n\n\t/**\n\t * Creates a new URI from a file system path, e.g. `c:\\my\\files`,\n\t * `/usr/home`, or `\\\\server\\share\\some\\path`.\n\t *\n\t * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument\n\t * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**\n\t * `URI.parse('file://' + path)` because the path might contain characters that are\n\t * interpreted (# and ?). See the following sample:\n\t * ```ts\n\tconst good = URI.file('/coding/c#/project1');\n\tgood.scheme === 'file';\n\tgood.path === '/coding/c#/project1';\n\tgood.fragment === '';\n\tconst bad = URI.parse('file://' + '/coding/c#/project1');\n\tbad.scheme === 'file';\n\tbad.path === '/coding/c'; // path is now broken\n\tbad.fragment === '/project1';\n\t```\n\t *\n\t * @param path A file system path (see `URI#fsPath`)\n\t */\n\tstatic file(path: string): URI {\n\n\t\tlet authority = _empty;\n\n\t\t// normalize to fwd-slashes on windows,\n\t\t// on other systems bwd-slashes are valid\n\t\t// filename character, eg /f\\oo/ba\\r.txt\n\t\tif (isWindows) {\n\t\t\tpath = path.replace(/\\\\/g, _slash);\n\t\t}\n\n\t\t// check for authority as used in UNC shares\n\t\t// or use the path as given\n\t\tif (path[0] === _slash && path[1] === _slash) {\n\t\t\tconst idx = path.indexOf(_slash, 2);\n\t\t\tif (idx === -1) {\n\t\t\t\tauthority = path.substring(2);\n\t\t\t\tpath = _slash;\n\t\t\t} else {\n\t\t\t\tauthority = path.substring(2, idx);\n\t\t\t\tpath = path.substring(idx) || _slash;\n\t\t\t}\n\t\t}\n\n\t\treturn new Uri('file', authority, path, _empty, _empty);\n\t}\n\n\tstatic from(components: { scheme: string; authority?: string; path?: string; query?: string; fragment?: string }): URI {\n\t\tconst result = new Uri(\n\t\t\tcomponents.scheme,\n\t\t\tcomponents.authority,\n\t\t\tcomponents.path,\n\t\t\tcomponents.query,\n\t\t\tcomponents.fragment,\n\t\t);\n\t\t_validateUri(result, true);\n\t\treturn result;\n\t}\n\n\t// ---- printing/externalize ---------------------------\n\n\t/**\n\t * Creates a string representation for this URI. It's guaranteed that calling\n\t * `URI.parse` with the result of this function creates an URI which is equal\n\t * to this URI.\n\t *\n\t * * The result shall *not* be used for display purposes but for externalization or transport.\n\t * * The result will be encoded using the percentage encoding and encoding happens mostly\n\t * ignore the scheme-specific encoding rules.\n\t *\n\t * @param skipEncoding Do not encode the result, default is `false`\n\t */\n\ttoString(skipEncoding: boolean = false): string {\n\t\treturn _asFormatted(this, skipEncoding);\n\t}\n\n\ttoJSON(): UriComponents {\n\t\treturn this;\n\t}\n\n\tstatic revive(data: UriComponents | URI): URI;\n\tstatic revive(data: UriComponents | URI | undefined): URI | undefined;\n\tstatic revive(data: UriComponents | URI | null): URI | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null;\n\tstatic revive(data: UriComponents | URI | undefined | null): URI | undefined | null {\n\t\tif (!data) {\n\t\t\treturn <any>data;\n\t\t} else if (data instanceof URI) {\n\t\t\treturn data;\n\t\t} else {\n\t\t\tconst result = new Uri(data);\n\t\t\tresult._formatted = (<UriState>data).external;\n\t\t\tresult._fsPath = (<UriState>data)._sep === _pathSepMarker ? (<UriState>data).fsPath : null;\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nexport interface UriComponents {\n\tscheme: string;\n\tauthority: string;\n\tpath: string;\n\tquery: string;\n\tfragment: string;\n}\n\ninterface UriState extends UriComponents {\n\t$mid: number;\n\texternal: string;\n\tfsPath: string;\n\t_sep: 1 | undefined;\n}\n\nconst _pathSepMarker = isWindows ? 1 : undefined;\n\n// This class exists so that URI is compatible with vscode.Uri (API).\nclass Uri extends URI {\n\n\t_formatted: string | null = null;\n\t_fsPath: string | null = null;\n\n\toverride get fsPath(): string {\n\t\tif (!this._fsPath) {\n\t\t\tthis._fsPath = uriToFsPath(this, false);\n\t\t}\n\t\treturn this._fsPath;\n\t}\n\n\toverride toString(skipEncoding: boolean = false): string {\n\t\tif (!skipEncoding) {\n\t\t\tif (!this._formatted) {\n\t\t\t\tthis._formatted = _asFormatted(this, false);\n\t\t\t}\n\t\t\treturn this._formatted;\n\t\t} else {\n\t\t\t// we don't cache that\n\t\t\treturn _asFormatted(this, true);\n\t\t}\n\t}\n\n\toverride toJSON(): UriComponents {\n\t\tconst res = <UriState>{\n\t\t\t$mid: 1\n\t\t};\n\t\t// cached state\n\t\tif (this._fsPath) {\n\t\t\tres.fsPath = this._fsPath;\n\t\t\tres._sep = _pathSepMarker;\n\t\t}\n\t\tif (this._formatted) {\n\t\t\tres.external = this._formatted;\n\t\t}\n\t\t// uri components\n\t\tif (this.path) {\n\t\t\tres.path = this.path;\n\t\t}\n\t\tif (this.scheme) {\n\t\t\tres.scheme = this.scheme;\n\t\t}\n\t\tif (this.authority) {\n\t\t\tres.authority = this.authority;\n\t\t}\n\t\tif (this.query) {\n\t\t\tres.query = this.query;\n\t\t}\n\t\tif (this.fragment) {\n\t\t\tres.fragment = this.fragment;\n\t\t}\n\t\treturn res;\n\t}\n}\n\n// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2\nconst encodeTable: { [ch: number]: string } = {\n\t[CharCode.Colon]: '%3A', // gen-delims\n\t[CharCode.Slash]: '%2F',\n\t[CharCode.QuestionMark]: '%3F',\n\t[CharCode.Hash]: '%23',\n\t[CharCode.OpenSquareBracket]: '%5B',\n\t[CharCode.CloseSquareBracket]: '%5D',\n\t[CharCode.AtSign]: '%40',\n\n\t[CharCode.ExclamationMark]: '%21', // sub-delims\n\t[CharCode.DollarSign]: '%24',\n\t[CharCode.Ampersand]: '%26',\n\t[CharCode.SingleQuote]: '%27',\n\t[CharCode.OpenParen]: '%28',\n\t[CharCode.CloseParen]: '%29',\n\t[CharCode.Asterisk]: '%2A',\n\t[CharCode.Plus]: '%2B',\n\t[CharCode.Comma]: '%2C',\n\t[CharCode.Semicolon]: '%3B',\n\t[CharCode.Equals]: '%3D',\n\n\t[CharCode.Space]: '%20',\n};\n\nfunction encodeURIComponentFast(uriComponent: string, isPath: boolean, isAuthority: boolean): string {\n\tlet res: string | undefined = undefined;\n\tlet nativeEncodePos = -1;\n\n\tfor (let pos = 0; pos < uriComponent.length; pos++) {\n\t\tconst code = uriComponent.charCodeAt(pos);\n\n\t\t// unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3\n\t\tif (\n\t\t\t(code >= CharCode.a && code <= CharCode.z)\n\t\t\t|| (code >= CharCode.A && code <= CharCode.Z)\n\t\t\t|| (code >= CharCode.Digit0 && code <= CharCode.Digit9)\n\t\t\t|| code === CharCode.Dash\n\t\t\t|| code === CharCode.Period\n\t\t\t|| code === CharCode.Underline\n\t\t\t|| code === CharCode.Tilde\n\t\t\t|| (isPath && code === CharCode.Slash)\n\t\t\t|| (isAuthority && code === CharCode.OpenSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.CloseSquareBracket)\n\t\t\t|| (isAuthority && code === CharCode.Colon)\n\t\t) {\n\t\t\t// check if we are delaying native encode\n\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\tnativeEncodePos = -1;\n\t\t\t}\n\t\t\t// check if we write into a new string (by default we try to return the param)\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += uriComponent.charAt(pos);\n\t\t\t}\n\n\t\t} else {\n\t\t\t// encoding needed, we need to allocate a new string\n\t\t\tif (res === undefined) {\n\t\t\t\tres = uriComponent.substr(0, pos);\n\t\t\t}\n\n\t\t\t// check with default table first\n\t\t\tconst escaped = encodeTable[code];\n\t\t\tif (escaped !== undefined) {\n\n\t\t\t\t// check if we are delaying native encode\n\t\t\t\tif (nativeEncodePos !== -1) {\n\t\t\t\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));\n\t\t\t\t\tnativeEncodePos = -1;\n\t\t\t\t}\n\n\t\t\t\t// append escaped variant to result\n\t\t\t\tres += escaped;\n\n\t\t\t} else if (nativeEncodePos === -1) {\n\t\t\t\t// use native encode only when needed\n\t\t\t\tnativeEncodePos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (nativeEncodePos !== -1) {\n\t\tres += encodeURIComponent(uriComponent.substring(nativeEncodePos));\n\t}\n\n\treturn res !== undefined ? res : uriComponent;\n}\n\nfunction encodeURIComponentMinimal(path: string): string {\n\tlet res: string | undefined = undefined;\n\tfor (let pos = 0; pos < path.length; pos++) {\n\t\tconst code = path.charCodeAt(pos);\n\t\tif (code === CharCode.Hash || code === CharCode.QuestionMark) {\n\t\t\tif (res === undefined) {\n\t\t\t\tres = path.substr(0, pos);\n\t\t\t}\n\t\t\tres += encodeTable[code];\n\t\t} else {\n\t\t\tif (res !== undefined) {\n\t\t\t\tres += path[pos];\n\t\t\t}\n\t\t}\n\t}\n\treturn res !== undefined ? res : path;\n}\n\n/**\n * Compute `fsPath` for the given uri\n */\nexport function uriToFsPath(uri: URI, keepDriveLetterCasing: boolean): string {\n\n\tlet value: string;\n\tif (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {\n\t\t// unc path: file://shares/c$/far/boo\n\t\tvalue = `//${uri.authority}${uri.path}`;\n\t} else if (\n\t\turi.path.charCodeAt(0) === CharCode.Slash\n\t\t&& (uri.path.charCodeAt(1) >= CharCode.A && uri.path.charCodeAt(1) <= CharCode.Z || uri.path.charCodeAt(1) >= CharCode.a && uri.path.charCodeAt(1) <= CharCode.z)\n\t\t&& uri.path.charCodeAt(2) === CharCode.Colon\n\t) {\n\t\tif (!keepDriveLetterCasing) {\n\t\t\t// windows drive letter: file:///c:/far/boo\n\t\t\tvalue = uri.path[1].toLowerCase() + uri.path.substr(2);\n\t\t} else {\n\t\t\tvalue = uri.path.substr(1);\n\t\t}\n\t} else {\n\t\t// other path\n\t\tvalue = uri.path;\n\t}\n\tif (isWindows) {\n\t\tvalue = value.replace(/\\//g, '\\\\');\n\t}\n\treturn value;\n}\n\n/**\n * Create the external version of a uri\n */\nfunction _asFormatted(uri: URI, skipEncoding: boolean): string {\n\n\tconst encoder = !skipEncoding\n\t\t? encodeURIComponentFast\n\t\t: encodeURIComponentMinimal;\n\n\tlet res = '';\n\tlet { scheme, authority, path, query, fragment } = uri;\n\tif (scheme) {\n\t\tres += scheme;\n\t\tres += ':';\n\t}\n\tif (authority || scheme === 'file') {\n\t\tres += _slash;\n\t\tres += _slash;\n\t}\n\tif (authority) {\n\t\tlet idx = authority.indexOf('@');\n\t\tif (idx !== -1) {\n\t\t\t// <user>@<auth>\n\t\t\tconst userinfo = authority.substr(0, idx);\n\t\t\tauthority = authority.substr(idx + 1);\n\t\t\tidx = userinfo.lastIndexOf(':');\n\t\t\tif (idx === -1) {\n\t\t\t\tres += encoder(userinfo, false, false);\n\t\t\t} else {\n\t\t\t\t// <user>:<pass>@<auth>\n\t\t\t\tres += encoder(userinfo.substr(0, idx), false, false);\n\t\t\t\tres += ':';\n\t\t\t\tres += encoder(userinfo.substr(idx + 1), false, true);\n\t\t\t}\n\t\t\tres += '@';\n\t\t}\n\t\tauthority = authority.toLowerCase();\n\t\tidx = authority.lastIndexOf(':');\n\t\tif (idx === -1) {\n\t\t\tres += encoder(authority, false, true);\n\t\t} else {\n\t\t\t// <auth>:<port>\n\t\t\tres += encoder(authority.substr(0, idx), false, true);\n\t\t\tres += authority.substr(idx);\n\t\t}\n\t}\n\tif (path) {\n\t\t// lower-case windows drive letters in /C:/fff or C:/fff\n\t\tif (path.length >= 3 && path.charCodeAt(0) === CharCode.Slash && path.charCodeAt(2) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(1);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `/${String.fromCharCode(code + 32)}:${path.substr(3)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t} else if (path.length >= 2 && path.charCodeAt(1) === CharCode.Colon) {\n\t\t\tconst code = path.charCodeAt(0);\n\t\t\tif (code >= CharCode.A && code <= CharCode.Z) {\n\t\t\t\tpath = `${String.fromCharCode(code + 32)}:${path.substr(2)}`; // \"/c:\".length === 3\n\t\t\t}\n\t\t}\n\t\t// encode the rest of the path\n\t\tres += encoder(path, true, false);\n\t}\n\tif (query) {\n\t\tres += '?';\n\t\tres += encoder(query, false, false);\n\t}\n\tif (fragment) {\n\t\tres += '#';\n\t\tres += !skipEncoding ? encodeURIComponentFast(fragment, false, false) : fragment;\n\t}\n\treturn res;\n}\n\n// --- decode\n\nfunction decodeURIComponentGraceful(str: string): string {\n\ttry {\n\t\treturn decodeURIComponent(str);\n\t} catch {\n\t\tif (str.length > 3) {\n\t\t\treturn str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));\n\t\t} else {\n\t\t\treturn str;\n\t\t}\n\t}\n}\n\nconst _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;\n\nfunction percentDecode(str: string): string {\n\tif (!str.match(_rEncodedAsHex)) {\n\t\treturn str;\n\t}\n\treturn str.replace(_rEncodedAsHex, (match) => decodeURIComponentGraceful(match));\n}\n\n/**\n * Mapped-type that replaces all occurrences of URI with UriComponents\n */\nexport type UriDto<T> = { [K in keyof T]: T[K] extends URI\n\t? UriComponents\n\t: UriDto<T[K]> };\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n'use strict';\n\nimport { CharCode } from './charCode';\nimport { URI } from './uri';\nimport * as nodePath from 'path';\n\nconst posixPath = nodePath.posix || nodePath;\nconst slash = '/';\n\nexport namespace Utils {\n\n    /**\n     * Joins one or more input paths to the path of URI. \n     * '/' is used as the directory separation character. \n     * \n     * The resolved path will be normalized. That means:\n     *  - all '..' and '.' segments are resolved.\n     *  - multiple, sequential occurences of '/' are replaced by a single instance of '/'.\n     *  - trailing separators are preserved.\n     * \n     * @param uri The input URI.\n     * @param paths The paths to be joined with the path of URI.\n     * @returns A URI with the joined path. All other properties of the URI (scheme, authority, query, fragments, ...) will be taken from the input URI.\n     */\n    export function joinPath(uri: URI, ...paths: string[]): URI {\n        return uri.with({ path: posixPath.join(uri.path, ...paths) });\n    }\n\n\n    /**\n     * Resolves one or more paths against the path of a URI. \n     * '/' is used as the directory separation character. \n     * \n     * The resolved path will be normalized. That means:\n     *  - all '..' and '.' segments are resolved. \n     *  - multiple, sequential occurences of '/' are replaced by a single instance of '/'.\n     *  - trailing separators are removed.\n     * \n     * @param uri The input URI.\n     * @param paths The paths to resolve against the path of URI.\n     * @returns A URI with the resolved path. All other properties of the URI (scheme, authority, query, fragments, ...) will be taken from the input URI.\n     */\n    export function resolvePath(uri: URI, ...paths: string[]): URI {\n        let path = uri.path; \n        let slashAdded = false;\n        if (path[0] !== slash) {\n            path = slash + path; // make the path abstract: for posixPath.resolve the first segments has to be absolute or cwd is used.\n            slashAdded = true;\n        }\n        let resolvedPath = posixPath.resolve(path, ...paths);\n        if (slashAdded && resolvedPath[0] === slash && !uri.authority) {\n            resolvedPath = resolvedPath.substring(1);\n        }\n        return uri.with({ path: resolvedPath });\n    }\n\n    /**\n     * Returns a URI where the path is the directory name of the input uri, similar to the Unix dirname command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The orignal URI is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The last segment of the URIs path.\n     */\n    export function dirname(uri: URI): URI {\n        if (uri.path.length === 0 || uri.path === slash) {\n            return uri;\n        }\n        let path = posixPath.dirname(uri.path);\n        if (path.length === 1 && path.charCodeAt(0) === CharCode.Period) {\n            path = '';\n        }\n        return uri.with({ path });\n    }\n\n    /**\n     * Returns the last segment of the path of a URI, similar to the Unix basename command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The empty string is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The base name of the URIs path.\n     */\n    export function basename(uri: URI): string {\n        return posixPath.basename(uri.path);\n    }\n\n    /**\n     * Returns the extension name of the path of a URI, similar to the Unix extname command. \n     * In the path, '/' is recognized as the directory separation character. Trailing directory separators are ignored.\n     * The empty string is returned if the URIs path is empty or does not contain any path segments.\n     * \n     * @param uri The input URI.\n     * @return The extension name of the URIs path.\n     */\n    export function extname(uri: URI): string {\n        return posixPath.extname(uri.path);\n    }\n}", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { URI, Utils } from 'vscode-uri';\r\n\r\nexport { URI };\r\n\r\nexport namespace UriUtils {\r\n\r\n    export const basename = Utils.basename;\r\n    export const dirname = Utils.dirname;\r\n    export const extname = Utils.extname;\r\n    export const joinPath = Utils.joinPath;\r\n    export const resolvePath = Utils.resolvePath;\r\n\r\n    export function equals(a?: URI | string, b?: URI | string): boolean {\r\n        return a?.toString() === b?.toString();\r\n    }\r\n\r\n    export function relative(from: URI | string, to: URI | string): string {\r\n        const fromPath = typeof from === 'string' ? from : from.path;\r\n        const toPath = typeof to === 'string' ? to : to.path;\r\n        const fromParts = fromPath.split('/').filter(e => e.length > 0);\r\n        const toParts = toPath.split('/').filter(e => e.length > 0);\r\n        let i = 0;\r\n        for (; i < fromParts.length; i++) {\r\n            if (fromParts[i] !== toParts[i]) {\r\n                break;\r\n            }\r\n        }\r\n        const backPart = '../'.repeat(fromParts.length - i);\r\n        const toPart = toParts.slice(i).join('/');\r\n        return backPart + toPart;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @deprecated Use `UriUtils.equals` instead.\r\n */\r\nexport const equalURI = UriUtils.equals;\r\n/**\r\n * @deprecated Use `UriUtils.relative` instead.\r\n */\r\nexport const relativeURI = UriUtils.relative;\r\n", "/******************************************************************************\r\n * This file was generated by langium-cli 2.1.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\nimport type { Grammar } from './ast.js';\r\nimport { loadGrammarFromJson } from '../../utils/grammar-util.js';\r\n\r\nlet loadedLangiumGrammarGrammar: Grammar | undefined;\r\nexport const LangiumGrammarGrammar = (): Grammar => loadedLangiumGrammarGrammar ?? (loadedLangiumGrammarGrammar = loadGrammarFromJson('{\"$type\":\"Grammar\",\"isDeclared\":true,\"name\":\"LangiumGrammar\",\"rules\":[{\"$type\":\"ParserRule\",\"name\":\"Grammar\",\"entry\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"isDeclared\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"grammar\"}},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"with\"},{\"$type\":\"Assignment\",\"feature\":\"usedGrammars\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"usedGrammars\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}}],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"definesHiddenTokens\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"hidden\"}},{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"hiddenTokens\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@11\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"hiddenTokens\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@11\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}}],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\")\"}],\"cardinality\":\"?\"}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"imports\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@12\"},\"arguments\":[]},\"cardinality\":\"*\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rules\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@11\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"interfaces\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@1\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"types\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@10\"},\"arguments\":[]}}],\"cardinality\":\"+\"}]},\"definesHiddenTokens\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Interface\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"interface\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"extends\"},{\"$type\":\"Assignment\",\"feature\":\"superTypes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/types@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"superTypes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/types@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}}],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@2\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"SchemaType\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"{\"},{\"$type\":\"Assignment\",\"feature\":\"attributes\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@3\"},\"arguments\":[]},\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"}\"},{\"$type\":\"Keyword\",\"value\":\";\",\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TypeAttribute\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@59\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"isOptional\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"?\"},\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\";\",\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TypeDefinition\",\"definition\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@5\"},\"arguments\":[]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"UnionType\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TypeDefinition\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"UnionType\"},\"feature\":\"types\",\"operator\":\"+=\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"|\"},{\"$type\":\"Assignment\",\"feature\":\"types\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@6\"},\"arguments\":[]}}],\"cardinality\":\"+\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ArrayType\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TypeDefinition\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@7\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"ArrayType\"},\"feature\":\"elementType\",\"operator\":\"=\"},{\"$type\":\"Keyword\",\"value\":\"[\"},{\"$type\":\"Keyword\",\"value\":\"]\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ReferenceType\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TypeDefinition\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"ReferenceType\"}},{\"$type\":\"Keyword\",\"value\":\"@\"},{\"$type\":\"Assignment\",\"feature\":\"referenceType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@8\"},\"arguments\":[]}}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"SimpleType\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TypeDefinition\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\")\"}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"SimpleType\"}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"typeRef\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/types@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Assignment\",\"feature\":\"primitiveType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"stringType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@61\"},\"arguments\":[]}}]}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PrimitiveType\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"string\"},{\"$type\":\"Keyword\",\"value\":\"number\"},{\"$type\":\"Keyword\",\"value\":\"boolean\"},{\"$type\":\"Keyword\",\"value\":\"Date\"},{\"$type\":\"Keyword\",\"value\":\"bigint\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Type\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"type\"},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\"=\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@4\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\";\",\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"AbstractRule\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@13\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@47\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"GrammarImport\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"import\"},{\"$type\":\"Assignment\",\"feature\":\"path\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@61\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\";\",\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ParserRule\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"entry\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"entry\"}},{\"$type\":\"Assignment\",\"feature\":\"fragment\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"fragment\"}}],\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@15\"},\"arguments\":[]},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"wildcard\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"*\"}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"returns\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"returnType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/types@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Assignment\",\"feature\":\"dataType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]}}]}]},{\"$type\":\"Assignment\",\"feature\":\"inferredType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[{\"$type\":\"NamedArgument\",\"value\":{\"$type\":\"LiteralCondition\",\"true\":false},\"calledByName\":false}]}}],\"cardinality\":\"?\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"definesHiddenTokens\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"hidden\"}},{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"hiddenTokens\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@11\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"hiddenTokens\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@11\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}}],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\")\"}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"definition\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\";\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"InferredType\",\"parameters\":[{\"$type\":\"Parameter\",\"name\":\"imperative\"}],\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"guardCondition\":{\"$type\":\"ParameterReference\",\"parameter\":{\"$ref\":\"#/rules@14/parameters@0\"}},\"elements\":[{\"$type\":\"Keyword\",\"value\":\"infer\"}]},{\"$type\":\"Group\",\"guardCondition\":{\"$type\":\"Negation\",\"value\":{\"$type\":\"ParameterReference\",\"parameter\":{\"$ref\":\"#/rules@14/parameters@0\"}}},\"elements\":[{\"$type\":\"Keyword\",\"value\":\"infers\"}]}]},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"RuleNameAndParams\",\"fragment\":true,\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"<\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"parameters\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"parameters\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@16\"},\"arguments\":[]}}],\"cardinality\":\"*\"}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\">\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Parameter\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Alternatives\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Alternatives\"},\"feature\":\"elements\",\"operator\":\"+=\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"|\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@18\"},\"arguments\":[]}}],\"cardinality\":\"+\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ConditionalBranch\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@19\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Group\"}},{\"$type\":\"Keyword\",\"value\":\"<\"},{\"$type\":\"Assignment\",\"feature\":\"guardCondition\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@30\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\">\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},\"cardinality\":\"+\"}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"UnorderedGroup\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"UnorderedGroup\"},\"feature\":\"elements\",\"operator\":\"+=\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"&\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@20\"},\"arguments\":[]}}],\"cardinality\":\"+\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Group\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Group\"},\"feature\":\"elements\",\"operator\":\"+=\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@21\"},\"arguments\":[]},\"cardinality\":\"+\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"AbstractToken\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@22\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@23\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"AbstractTokenWithCardinality\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@38\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@24\"},\"arguments\":[]}]},{\"$type\":\"Assignment\",\"feature\":\"cardinality\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"+\"}]},\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Action\"}},{\"$type\":\"Keyword\",\"value\":\"{\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/types@0\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Assignment\",\"feature\":\"inferredType\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@14\"},\"arguments\":[{\"$type\":\"NamedArgument\",\"value\":{\"$type\":\"LiteralCondition\",\"true\":true},\"calledByName\":false}]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\".\"},{\"$type\":\"Assignment\",\"feature\":\"feature\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@59\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"operator\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"=\"},{\"$type\":\"Keyword\",\"value\":\"+=\"}]}},{\"$type\":\"Keyword\",\"value\":\"current\"}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"}\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"AbstractTerminal\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@26\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@27\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@44\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@36\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@37\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@45\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@25\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"EndOfFile\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"EndOfFile\"}},{\"$type\":\"Keyword\",\"value\":\"EOF\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Keyword\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@61\"},\"arguments\":[]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"RuleCall\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"rule\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@11\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"<\"},{\"$type\":\"Assignment\",\"feature\":\"arguments\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@28\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"arguments\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@28\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\">\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"NamedArgument\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"parameter\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@16\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Assignment\",\"feature\":\"calledByName\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"=\"}}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@30\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"LiteralCondition\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"true\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"true\"}},{\"$type\":\"Keyword\",\"value\":\"false\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Disjunction\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Condition\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@31\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Disjunction\"},\"feature\":\"left\",\"operator\":\"=\"},{\"$type\":\"Keyword\",\"value\":\"|\"},{\"$type\":\"Assignment\",\"feature\":\"right\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@31\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Conjunction\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Condition\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@32\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Conjunction\"},\"feature\":\"left\",\"operator\":\"=\"},{\"$type\":\"Keyword\",\"value\":\"&\"},{\"$type\":\"Assignment\",\"feature\":\"right\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@32\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Negation\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Condition\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@33\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Negation\"}},{\"$type\":\"Keyword\",\"value\":\"!\"},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@32\"},\"arguments\":[]}}]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Atom\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Condition\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@35\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@34\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@29\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ParenthesizedCondition\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Condition\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@30\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\")\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ParameterReference\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"parameter\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@16\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PredicatedKeyword\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Keyword\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"=>\"},{\"$type\":\"Keyword\",\"value\":\"->\"}]},{\"$type\":\"Assignment\",\"feature\":\"value\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@61\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PredicatedRuleCall\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"RuleCall\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"=>\"},{\"$type\":\"Keyword\",\"value\":\"->\"}]},{\"$type\":\"Assignment\",\"feature\":\"rule\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@11\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"<\"},{\"$type\":\"Assignment\",\"feature\":\"arguments\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@28\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\",\"},{\"$type\":\"Assignment\",\"feature\":\"arguments\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@28\"},\"arguments\":[]}}],\"cardinality\":\"*\"},{\"$type\":\"Keyword\",\"value\":\">\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Assignment\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Assignment\"}},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"=>\"},{\"$type\":\"Keyword\",\"value\":\"->\"}],\"cardinality\":\"?\"},{\"$type\":\"Assignment\",\"feature\":\"feature\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@59\"},\"arguments\":[]}},{\"$type\":\"Assignment\",\"feature\":\"operator\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"+=\"},{\"$type\":\"Keyword\",\"value\":\"=\"},{\"$type\":\"Keyword\",\"value\":\"?=\"}]}},{\"$type\":\"Assignment\",\"feature\":\"terminal\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@39\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"AssignableTerminal\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@26\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@27\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@40\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@42\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ParenthesizedAssignableElement\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@41\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\")\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"AssignableAlternatives\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@39\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Alternatives\"},\"feature\":\"elements\",\"operator\":\"+=\"},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"|\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@39\"},\"arguments\":[]}}],\"cardinality\":\"+\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CrossReference\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"CrossReference\"}},{\"$type\":\"Keyword\",\"value\":\"[\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/types@0\"},\"deprecatedSyntax\":false}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"deprecatedSyntax\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"|\"}},{\"$type\":\"Keyword\",\"value\":\":\"}]},{\"$type\":\"Assignment\",\"feature\":\"terminal\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@43\"},\"arguments\":[]}}],\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"]\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CrossReferenceableTerminal\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@26\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@27\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ParenthesizedElement\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\")\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"PredicatedGroup\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Group\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"=>\"},{\"$type\":\"Keyword\",\"value\":\"->\"}]},{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@17\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\")\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ReturnType\",\"definition\":{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}]}},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TerminalRule\",\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"hidden\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"hidden\"},\"cardinality\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"terminal\"},{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"fragment\",\"operator\":\"?=\",\"terminal\":{\"$type\":\"Keyword\",\"value\":\"fragment\"}},{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}}]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Assignment\",\"feature\":\"name\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"returns\"},{\"$type\":\"Assignment\",\"feature\":\"type\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@46\"},\"arguments\":[]}}],\"cardinality\":\"?\"}]}]},{\"$type\":\"Keyword\",\"value\":\":\"},{\"$type\":\"Assignment\",\"feature\":\"definition\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@48\"},\"arguments\":[]}},{\"$type\":\"Keyword\",\"value\":\";\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TerminalAlternatives\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@49\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TerminalAlternatives\"},\"feature\":\"elements\",\"operator\":\"+=\"},{\"$type\":\"Keyword\",\"value\":\"|\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@49\"},\"arguments\":[]}}],\"cardinality\":\"*\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TerminalGroup\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@50\"},\"arguments\":[]},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TerminalGroup\"},\"feature\":\"elements\",\"operator\":\"+=\"},{\"$type\":\"Assignment\",\"feature\":\"elements\",\"operator\":\"+=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@50\"},\"arguments\":[]},\"cardinality\":\"+\"}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TerminalToken\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@51\"},\"arguments\":[]},{\"$type\":\"Assignment\",\"feature\":\"cardinality\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"?\"},{\"$type\":\"Keyword\",\"value\":\"*\"},{\"$type\":\"Keyword\",\"value\":\"+\"}]},\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TerminalTokenElement\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@58\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@53\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@52\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@54\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@55\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@56\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@57\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"ParenthesizedTerminalElement\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"(\"},{\"$type\":\"Assignment\",\"feature\":\"lookahead\",\"operator\":\"=\",\"terminal\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"?=\"},{\"$type\":\"Keyword\",\"value\":\"?!\"}]},\"cardinality\":\"?\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@48\"},\"arguments\":[]},{\"$type\":\"Keyword\",\"value\":\")\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"TerminalRuleCall\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"TerminalRuleCall\"}},{\"$type\":\"Assignment\",\"feature\":\"rule\",\"operator\":\"=\",\"terminal\":{\"$type\":\"CrossReference\",\"type\":{\"$ref\":\"#/rules@47\"},\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]},\"deprecatedSyntax\":false}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"NegatedToken\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"NegatedToken\"}},{\"$type\":\"Keyword\",\"value\":\"!\"},{\"$type\":\"Assignment\",\"feature\":\"terminal\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@51\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"UntilToken\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"UntilToken\"}},{\"$type\":\"Keyword\",\"value\":\"->\"},{\"$type\":\"Assignment\",\"feature\":\"terminal\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@51\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"RegexToken\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"RegexToken\"}},{\"$type\":\"Assignment\",\"feature\":\"regex\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@62\"},\"arguments\":[]}}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"Wildcard\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"Wildcard\"}},{\"$type\":\"Keyword\",\"value\":\".\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"CharacterRange\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"AbstractElement\"},\"definition\":{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Action\",\"inferredType\":{\"$type\":\"InferredType\",\"name\":\"CharacterRange\"}},{\"$type\":\"Assignment\",\"feature\":\"left\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@26\"},\"arguments\":[]}},{\"$type\":\"Group\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"..\"},{\"$type\":\"Assignment\",\"feature\":\"right\",\"operator\":\"=\",\"terminal\":{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@26\"},\"arguments\":[]}}],\"cardinality\":\"?\"}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"ParserRule\",\"name\":\"FeatureName\",\"dataType\":\"string\",\"definition\":{\"$type\":\"Alternatives\",\"elements\":[{\"$type\":\"Keyword\",\"value\":\"current\"},{\"$type\":\"Keyword\",\"value\":\"entry\"},{\"$type\":\"Keyword\",\"value\":\"extends\"},{\"$type\":\"Keyword\",\"value\":\"false\"},{\"$type\":\"Keyword\",\"value\":\"fragment\"},{\"$type\":\"Keyword\",\"value\":\"grammar\"},{\"$type\":\"Keyword\",\"value\":\"hidden\"},{\"$type\":\"Keyword\",\"value\":\"import\"},{\"$type\":\"Keyword\",\"value\":\"interface\"},{\"$type\":\"Keyword\",\"value\":\"returns\"},{\"$type\":\"Keyword\",\"value\":\"terminal\"},{\"$type\":\"Keyword\",\"value\":\"true\"},{\"$type\":\"Keyword\",\"value\":\"type\"},{\"$type\":\"Keyword\",\"value\":\"infer\"},{\"$type\":\"Keyword\",\"value\":\"infers\"},{\"$type\":\"Keyword\",\"value\":\"with\"},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@9\"},\"arguments\":[]},{\"$type\":\"RuleCall\",\"rule\":{\"$ref\":\"#/rules@60\"},\"arguments\":[]}]},\"definesHiddenTokens\":false,\"entry\":false,\"fragment\":false,\"hiddenTokens\":[],\"parameters\":[],\"wildcard\":false},{\"$type\":\"TerminalRule\",\"name\":\"ID\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\^?[_a-zA-Z][\\\\\\\\w_]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"STRING\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\"(\\\\\\\\\\\\\\\\.|[^\\\\\"\\\\\\\\\\\\\\\\])*\\\\\"|\\'(\\\\\\\\\\\\\\\\.|[^\\'\\\\\\\\\\\\\\\\])*\\'/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"name\":\"RegexLiteral\",\"type\":{\"$type\":\"ReturnType\",\"name\":\"string\"},\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\/(?![*+?])(?:[^\\\\\\\\r\\\\\\\\n\\\\\\\\[/\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.|\\\\\\\\[(?:[^\\\\\\\\r\\\\\\\\n\\\\\\\\]\\\\\\\\\\\\\\\\]|\\\\\\\\\\\\\\\\.)*\\\\\\\\])+\\\\\\\\/[a-z]*/\"},\"fragment\":false,\"hidden\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"WS\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\s+/\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"ML_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\/\\\\\\\\*[\\\\\\\\s\\\\\\\\S]*?\\\\\\\\*\\\\\\\\//\"},\"fragment\":false},{\"$type\":\"TerminalRule\",\"hidden\":true,\"name\":\"SL_COMMENT\",\"definition\":{\"$type\":\"RegexToken\",\"regex\":\"/\\\\\\\\/\\\\\\\\/[^\\\\\\\\n\\\\\\\\r]*/\"},\"fragment\":false}],\"types\":[{\"$type\":\"Type\",\"name\":\"AbstractType\",\"type\":{\"$type\":\"UnionType\",\"types\":[{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@1\"}},{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@10\"}},{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@23/definition/elements@0\"}},{\"$type\":\"SimpleType\",\"typeRef\":{\"$ref\":\"#/rules@13\"}}]}}],\"definesHiddenTokens\":false,\"hiddenTokens\":[],\"imports\":[],\"interfaces\":[],\"usedGrammars\":[]}'));\r\n", "/* --------------------------------------------------------------------------------------------\r\n * Copyright (c) Microsoft Corporation. All rights reserved.\r\n * Licensed under the MIT License. See License.txt in the project root for license information.\r\n * ------------------------------------------------------------------------------------------ */\r\n'use strict';\r\nexport var DocumentUri;\r\n(function (DocumentUri) {\r\n    function is(value) {\r\n        return typeof value === 'string';\r\n    }\r\n    DocumentUri.is = is;\r\n})(DocumentUri || (DocumentUri = {}));\r\nexport var URI;\r\n(function (URI) {\r\n    function is(value) {\r\n        return typeof value === 'string';\r\n    }\r\n    URI.is = is;\r\n})(URI || (URI = {}));\r\nexport var integer;\r\n(function (integer) {\r\n    integer.MIN_VALUE = -2147483648;\r\n    integer.MAX_VALUE = 2147483647;\r\n    function is(value) {\r\n        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;\r\n    }\r\n    integer.is = is;\r\n})(integer || (integer = {}));\r\nexport var uinteger;\r\n(function (uinteger) {\r\n    uinteger.MIN_VALUE = 0;\r\n    uinteger.MAX_VALUE = 2147483647;\r\n    function is(value) {\r\n        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;\r\n    }\r\n    uinteger.is = is;\r\n})(uinteger || (uinteger = {}));\r\n/**\r\n * The Position namespace provides helper functions to work with\r\n * {@link Position} literals.\r\n */\r\nexport var Position;\r\n(function (Position) {\r\n    /**\r\n     * Creates a new Position literal from the given line and character.\r\n     * @param line The position's line.\r\n     * @param character The position's character.\r\n     */\r\n    function create(line, character) {\r\n        if (line === Number.MAX_VALUE) {\r\n            line = uinteger.MAX_VALUE;\r\n        }\r\n        if (character === Number.MAX_VALUE) {\r\n            character = uinteger.MAX_VALUE;\r\n        }\r\n        return { line, character };\r\n    }\r\n    Position.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link Position} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);\r\n    }\r\n    Position.is = is;\r\n})(Position || (Position = {}));\r\n/**\r\n * The Range namespace provides helper functions to work with\r\n * {@link Range} literals.\r\n */\r\nexport var Range;\r\n(function (Range) {\r\n    function create(one, two, three, four) {\r\n        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {\r\n            return { start: Position.create(one, two), end: Position.create(three, four) };\r\n        }\r\n        else if (Position.is(one) && Position.is(two)) {\r\n            return { start: one, end: two };\r\n        }\r\n        else {\r\n            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);\r\n        }\r\n    }\r\n    Range.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link Range} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);\r\n    }\r\n    Range.is = is;\r\n})(Range || (Range = {}));\r\n/**\r\n * The Location namespace provides helper functions to work with\r\n * {@link Location} literals.\r\n */\r\nexport var Location;\r\n(function (Location) {\r\n    /**\r\n     * Creates a Location literal.\r\n     * @param uri The location's uri.\r\n     * @param range The location's range.\r\n     */\r\n    function create(uri, range) {\r\n        return { uri, range };\r\n    }\r\n    Location.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link Location} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));\r\n    }\r\n    Location.is = is;\r\n})(Location || (Location = {}));\r\n/**\r\n * The LocationLink namespace provides helper functions to work with\r\n * {@link LocationLink} literals.\r\n */\r\nexport var LocationLink;\r\n(function (LocationLink) {\r\n    /**\r\n     * Creates a LocationLink literal.\r\n     * @param targetUri The definition's uri.\r\n     * @param targetRange The full range of the definition.\r\n     * @param targetSelectionRange The span of the symbol definition at the target.\r\n     * @param originSelectionRange The span of the symbol being defined in the originating source file.\r\n     */\r\n    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {\r\n        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };\r\n    }\r\n    LocationLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link LocationLink} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)\r\n            && Range.is(candidate.targetSelectionRange)\r\n            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));\r\n    }\r\n    LocationLink.is = is;\r\n})(LocationLink || (LocationLink = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * {@link Color} literals.\r\n */\r\nexport var Color;\r\n(function (Color) {\r\n    /**\r\n     * Creates a new Color literal.\r\n     */\r\n    function create(red, green, blue, alpha) {\r\n        return {\r\n            red,\r\n            green,\r\n            blue,\r\n            alpha,\r\n        };\r\n    }\r\n    Color.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link Color} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)\r\n            && Is.numberRange(candidate.green, 0, 1)\r\n            && Is.numberRange(candidate.blue, 0, 1)\r\n            && Is.numberRange(candidate.alpha, 0, 1);\r\n    }\r\n    Color.is = is;\r\n})(Color || (Color = {}));\r\n/**\r\n * The ColorInformation namespace provides helper functions to work with\r\n * {@link ColorInformation} literals.\r\n */\r\nexport var ColorInformation;\r\n(function (ColorInformation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(range, color) {\r\n        return {\r\n            range,\r\n            color,\r\n        };\r\n    }\r\n    ColorInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);\r\n    }\r\n    ColorInformation.is = is;\r\n})(ColorInformation || (ColorInformation = {}));\r\n/**\r\n * The Color namespace provides helper functions to work with\r\n * {@link ColorPresentation} literals.\r\n */\r\nexport var ColorPresentation;\r\n(function (ColorPresentation) {\r\n    /**\r\n     * Creates a new ColorInformation literal.\r\n     */\r\n    function create(label, textEdit, additionalTextEdits) {\r\n        return {\r\n            label,\r\n            textEdit,\r\n            additionalTextEdits,\r\n        };\r\n    }\r\n    ColorPresentation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link ColorInformation} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.string(candidate.label)\r\n            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))\r\n            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));\r\n    }\r\n    ColorPresentation.is = is;\r\n})(ColorPresentation || (ColorPresentation = {}));\r\n/**\r\n * A set of predefined range kinds.\r\n */\r\nexport var FoldingRangeKind;\r\n(function (FoldingRangeKind) {\r\n    /**\r\n     * Folding range for a comment\r\n     */\r\n    FoldingRangeKind.Comment = 'comment';\r\n    /**\r\n     * Folding range for an import or include\r\n     */\r\n    FoldingRangeKind.Imports = 'imports';\r\n    /**\r\n     * Folding range for a region (e.g. `#region`)\r\n     */\r\n    FoldingRangeKind.Region = 'region';\r\n})(FoldingRangeKind || (FoldingRangeKind = {}));\r\n/**\r\n * The folding range namespace provides helper functions to work with\r\n * {@link FoldingRange} literals.\r\n */\r\nexport var FoldingRange;\r\n(function (FoldingRange) {\r\n    /**\r\n     * Creates a new FoldingRange literal.\r\n     */\r\n    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {\r\n        const result = {\r\n            startLine,\r\n            endLine\r\n        };\r\n        if (Is.defined(startCharacter)) {\r\n            result.startCharacter = startCharacter;\r\n        }\r\n        if (Is.defined(endCharacter)) {\r\n            result.endCharacter = endCharacter;\r\n        }\r\n        if (Is.defined(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        if (Is.defined(collapsedText)) {\r\n            result.collapsedText = collapsedText;\r\n        }\r\n        return result;\r\n    }\r\n    FoldingRange.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link FoldingRange} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)\r\n            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))\r\n            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))\r\n            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));\r\n    }\r\n    FoldingRange.is = is;\r\n})(FoldingRange || (FoldingRange = {}));\r\n/**\r\n * The DiagnosticRelatedInformation namespace provides helper functions to work with\r\n * {@link DiagnosticRelatedInformation} literals.\r\n */\r\nexport var DiagnosticRelatedInformation;\r\n(function (DiagnosticRelatedInformation) {\r\n    /**\r\n     * Creates a new DiagnosticRelatedInformation literal.\r\n     */\r\n    function create(location, message) {\r\n        return {\r\n            location,\r\n            message\r\n        };\r\n    }\r\n    DiagnosticRelatedInformation.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);\r\n    }\r\n    DiagnosticRelatedInformation.is = is;\r\n})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));\r\n/**\r\n * The diagnostic's severity.\r\n */\r\nexport var DiagnosticSeverity;\r\n(function (DiagnosticSeverity) {\r\n    /**\r\n     * Reports an error.\r\n     */\r\n    DiagnosticSeverity.Error = 1;\r\n    /**\r\n     * Reports a warning.\r\n     */\r\n    DiagnosticSeverity.Warning = 2;\r\n    /**\r\n     * Reports an information.\r\n     */\r\n    DiagnosticSeverity.Information = 3;\r\n    /**\r\n     * Reports a hint.\r\n     */\r\n    DiagnosticSeverity.Hint = 4;\r\n})(DiagnosticSeverity || (DiagnosticSeverity = {}));\r\n/**\r\n * The diagnostic tags.\r\n *\r\n * @since 3.15.0\r\n */\r\nexport var DiagnosticTag;\r\n(function (DiagnosticTag) {\r\n    /**\r\n     * Unused or unnecessary code.\r\n     *\r\n     * Clients are allowed to render diagnostics with this tag faded out instead of having\r\n     * an error squiggle.\r\n     */\r\n    DiagnosticTag.Unnecessary = 1;\r\n    /**\r\n     * Deprecated or obsolete code.\r\n     *\r\n     * Clients are allowed to rendered diagnostics with this tag strike through.\r\n     */\r\n    DiagnosticTag.Deprecated = 2;\r\n})(DiagnosticTag || (DiagnosticTag = {}));\r\n/**\r\n * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.\r\n *\r\n * @since 3.16.0\r\n */\r\nexport var CodeDescription;\r\n(function (CodeDescription) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.string(candidate.href);\r\n    }\r\n    CodeDescription.is = is;\r\n})(CodeDescription || (CodeDescription = {}));\r\n/**\r\n * The Diagnostic namespace provides helper functions to work with\r\n * {@link Diagnostic} literals.\r\n */\r\nexport var Diagnostic;\r\n(function (Diagnostic) {\r\n    /**\r\n     * Creates a new Diagnostic literal.\r\n     */\r\n    function create(range, message, severity, code, source, relatedInformation) {\r\n        let result = { range, message };\r\n        if (Is.defined(severity)) {\r\n            result.severity = severity;\r\n        }\r\n        if (Is.defined(code)) {\r\n            result.code = code;\r\n        }\r\n        if (Is.defined(source)) {\r\n            result.source = source;\r\n        }\r\n        if (Is.defined(relatedInformation)) {\r\n            result.relatedInformation = relatedInformation;\r\n        }\r\n        return result;\r\n    }\r\n    Diagnostic.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link Diagnostic} interface.\r\n     */\r\n    function is(value) {\r\n        var _a;\r\n        let candidate = value;\r\n        return Is.defined(candidate)\r\n            && Range.is(candidate.range)\r\n            && Is.string(candidate.message)\r\n            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))\r\n            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))\r\n            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))\r\n            && (Is.string(candidate.source) || Is.undefined(candidate.source))\r\n            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));\r\n    }\r\n    Diagnostic.is = is;\r\n})(Diagnostic || (Diagnostic = {}));\r\n/**\r\n * The Command namespace provides helper functions to work with\r\n * {@link Command} literals.\r\n */\r\nexport var Command;\r\n(function (Command) {\r\n    /**\r\n     * Creates a new Command literal.\r\n     */\r\n    function create(title, command, ...args) {\r\n        let result = { title, command };\r\n        if (Is.defined(args) && args.length > 0) {\r\n            result.arguments = args;\r\n        }\r\n        return result;\r\n    }\r\n    Command.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link Command} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);\r\n    }\r\n    Command.is = is;\r\n})(Command || (Command = {}));\r\n/**\r\n * The TextEdit namespace provides helper function to create replace,\r\n * insert and delete edits more easily.\r\n */\r\nexport var TextEdit;\r\n(function (TextEdit) {\r\n    /**\r\n     * Creates a replace text edit.\r\n     * @param range The range of text to be replaced.\r\n     * @param newText The new text.\r\n     */\r\n    function replace(range, newText) {\r\n        return { range, newText };\r\n    }\r\n    TextEdit.replace = replace;\r\n    /**\r\n     * Creates an insert text edit.\r\n     * @param position The position to insert the text at.\r\n     * @param newText The text to be inserted.\r\n     */\r\n    function insert(position, newText) {\r\n        return { range: { start: position, end: position }, newText };\r\n    }\r\n    TextEdit.insert = insert;\r\n    /**\r\n     * Creates a delete text edit.\r\n     * @param range The range of text to be deleted.\r\n     */\r\n    function del(range) {\r\n        return { range, newText: '' };\r\n    }\r\n    TextEdit.del = del;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && Is.string(candidate.newText)\r\n            && Range.is(candidate.range);\r\n    }\r\n    TextEdit.is = is;\r\n})(TextEdit || (TextEdit = {}));\r\nexport var ChangeAnnotation;\r\n(function (ChangeAnnotation) {\r\n    function create(label, needsConfirmation, description) {\r\n        const result = { label };\r\n        if (needsConfirmation !== undefined) {\r\n            result.needsConfirmation = needsConfirmation;\r\n        }\r\n        if (description !== undefined) {\r\n            result.description = description;\r\n        }\r\n        return result;\r\n    }\r\n    ChangeAnnotation.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&\r\n            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&\r\n            (Is.string(candidate.description) || candidate.description === undefined);\r\n    }\r\n    ChangeAnnotation.is = is;\r\n})(ChangeAnnotation || (ChangeAnnotation = {}));\r\nexport var ChangeAnnotationIdentifier;\r\n(function (ChangeAnnotationIdentifier) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.string(candidate);\r\n    }\r\n    ChangeAnnotationIdentifier.is = is;\r\n})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));\r\nexport var AnnotatedTextEdit;\r\n(function (AnnotatedTextEdit) {\r\n    /**\r\n     * Creates an annotated replace text edit.\r\n     *\r\n     * @param range The range of text to be replaced.\r\n     * @param newText The new text.\r\n     * @param annotation The annotation.\r\n     */\r\n    function replace(range, newText, annotation) {\r\n        return { range, newText, annotationId: annotation };\r\n    }\r\n    AnnotatedTextEdit.replace = replace;\r\n    /**\r\n     * Creates an annotated insert text edit.\r\n     *\r\n     * @param position The position to insert the text at.\r\n     * @param newText The text to be inserted.\r\n     * @param annotation The annotation.\r\n     */\r\n    function insert(position, newText, annotation) {\r\n        return { range: { start: position, end: position }, newText, annotationId: annotation };\r\n    }\r\n    AnnotatedTextEdit.insert = insert;\r\n    /**\r\n     * Creates an annotated delete text edit.\r\n     *\r\n     * @param range The range of text to be deleted.\r\n     * @param annotation The annotation.\r\n     */\r\n    function del(range, annotation) {\r\n        return { range, newText: '', annotationId: annotation };\r\n    }\r\n    AnnotatedTextEdit.del = del;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n    }\r\n    AnnotatedTextEdit.is = is;\r\n})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));\r\n/**\r\n * The TextDocumentEdit namespace provides helper function to create\r\n * an edit that manipulates a text document.\r\n */\r\nexport var TextDocumentEdit;\r\n(function (TextDocumentEdit) {\r\n    /**\r\n     * Creates a new `TextDocumentEdit`\r\n     */\r\n    function create(textDocument, edits) {\r\n        return { textDocument, edits };\r\n    }\r\n    TextDocumentEdit.create = create;\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate)\r\n            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)\r\n            && Array.isArray(candidate.edits);\r\n    }\r\n    TextDocumentEdit.is = is;\r\n})(TextDocumentEdit || (TextDocumentEdit = {}));\r\nexport var CreateFile;\r\n(function (CreateFile) {\r\n    function create(uri, options, annotation) {\r\n        let result = {\r\n            kind: 'create',\r\n            uri\r\n        };\r\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\r\n            result.options = options;\r\n        }\r\n        if (annotation !== undefined) {\r\n            result.annotationId = annotation;\r\n        }\r\n        return result;\r\n    }\r\n    CreateFile.create = create;\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||\r\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n    }\r\n    CreateFile.is = is;\r\n})(CreateFile || (CreateFile = {}));\r\nexport var RenameFile;\r\n(function (RenameFile) {\r\n    function create(oldUri, newUri, options, annotation) {\r\n        let result = {\r\n            kind: 'rename',\r\n            oldUri,\r\n            newUri\r\n        };\r\n        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {\r\n            result.options = options;\r\n        }\r\n        if (annotation !== undefined) {\r\n            result.annotationId = annotation;\r\n        }\r\n        return result;\r\n    }\r\n    RenameFile.create = create;\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||\r\n            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n    }\r\n    RenameFile.is = is;\r\n})(RenameFile || (RenameFile = {}));\r\nexport var DeleteFile;\r\n(function (DeleteFile) {\r\n    function create(uri, options, annotation) {\r\n        let result = {\r\n            kind: 'delete',\r\n            uri\r\n        };\r\n        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {\r\n            result.options = options;\r\n        }\r\n        if (annotation !== undefined) {\r\n            result.annotationId = annotation;\r\n        }\r\n        return result;\r\n    }\r\n    DeleteFile.create = create;\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||\r\n            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));\r\n    }\r\n    DeleteFile.is = is;\r\n})(DeleteFile || (DeleteFile = {}));\r\nexport var WorkspaceEdit;\r\n(function (WorkspaceEdit) {\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate &&\r\n            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&\r\n            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {\r\n                if (Is.string(change.kind)) {\r\n                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);\r\n                }\r\n                else {\r\n                    return TextDocumentEdit.is(change);\r\n                }\r\n            }));\r\n    }\r\n    WorkspaceEdit.is = is;\r\n})(WorkspaceEdit || (WorkspaceEdit = {}));\r\nclass TextEditChangeImpl {\r\n    constructor(edits, changeAnnotations) {\r\n        this.edits = edits;\r\n        this.changeAnnotations = changeAnnotations;\r\n    }\r\n    insert(position, newText, annotation) {\r\n        let edit;\r\n        let id;\r\n        if (annotation === undefined) {\r\n            edit = TextEdit.insert(position, newText);\r\n        }\r\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\r\n            id = annotation;\r\n            edit = AnnotatedTextEdit.insert(position, newText, annotation);\r\n        }\r\n        else {\r\n            this.assertChangeAnnotations(this.changeAnnotations);\r\n            id = this.changeAnnotations.manage(annotation);\r\n            edit = AnnotatedTextEdit.insert(position, newText, id);\r\n        }\r\n        this.edits.push(edit);\r\n        if (id !== undefined) {\r\n            return id;\r\n        }\r\n    }\r\n    replace(range, newText, annotation) {\r\n        let edit;\r\n        let id;\r\n        if (annotation === undefined) {\r\n            edit = TextEdit.replace(range, newText);\r\n        }\r\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\r\n            id = annotation;\r\n            edit = AnnotatedTextEdit.replace(range, newText, annotation);\r\n        }\r\n        else {\r\n            this.assertChangeAnnotations(this.changeAnnotations);\r\n            id = this.changeAnnotations.manage(annotation);\r\n            edit = AnnotatedTextEdit.replace(range, newText, id);\r\n        }\r\n        this.edits.push(edit);\r\n        if (id !== undefined) {\r\n            return id;\r\n        }\r\n    }\r\n    delete(range, annotation) {\r\n        let edit;\r\n        let id;\r\n        if (annotation === undefined) {\r\n            edit = TextEdit.del(range);\r\n        }\r\n        else if (ChangeAnnotationIdentifier.is(annotation)) {\r\n            id = annotation;\r\n            edit = AnnotatedTextEdit.del(range, annotation);\r\n        }\r\n        else {\r\n            this.assertChangeAnnotations(this.changeAnnotations);\r\n            id = this.changeAnnotations.manage(annotation);\r\n            edit = AnnotatedTextEdit.del(range, id);\r\n        }\r\n        this.edits.push(edit);\r\n        if (id !== undefined) {\r\n            return id;\r\n        }\r\n    }\r\n    add(edit) {\r\n        this.edits.push(edit);\r\n    }\r\n    all() {\r\n        return this.edits;\r\n    }\r\n    clear() {\r\n        this.edits.splice(0, this.edits.length);\r\n    }\r\n    assertChangeAnnotations(value) {\r\n        if (value === undefined) {\r\n            throw new Error(`Text edit change is not configured to manage change annotations.`);\r\n        }\r\n    }\r\n}\r\n/**\r\n * A helper class\r\n */\r\nclass ChangeAnnotations {\r\n    constructor(annotations) {\r\n        this._annotations = annotations === undefined ? Object.create(null) : annotations;\r\n        this._counter = 0;\r\n        this._size = 0;\r\n    }\r\n    all() {\r\n        return this._annotations;\r\n    }\r\n    get size() {\r\n        return this._size;\r\n    }\r\n    manage(idOrAnnotation, annotation) {\r\n        let id;\r\n        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {\r\n            id = idOrAnnotation;\r\n        }\r\n        else {\r\n            id = this.nextId();\r\n            annotation = idOrAnnotation;\r\n        }\r\n        if (this._annotations[id] !== undefined) {\r\n            throw new Error(`Id ${id} is already in use.`);\r\n        }\r\n        if (annotation === undefined) {\r\n            throw new Error(`No annotation provided for id ${id}`);\r\n        }\r\n        this._annotations[id] = annotation;\r\n        this._size++;\r\n        return id;\r\n    }\r\n    nextId() {\r\n        this._counter++;\r\n        return this._counter.toString();\r\n    }\r\n}\r\n/**\r\n * A workspace change helps constructing changes to a workspace.\r\n */\r\nexport class WorkspaceChange {\r\n    constructor(workspaceEdit) {\r\n        this._textEditChanges = Object.create(null);\r\n        if (workspaceEdit !== undefined) {\r\n            this._workspaceEdit = workspaceEdit;\r\n            if (workspaceEdit.documentChanges) {\r\n                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);\r\n                workspaceEdit.changeAnnotations = this._changeAnnotations.all();\r\n                workspaceEdit.documentChanges.forEach((change) => {\r\n                    if (TextDocumentEdit.is(change)) {\r\n                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);\r\n                        this._textEditChanges[change.textDocument.uri] = textEditChange;\r\n                    }\r\n                });\r\n            }\r\n            else if (workspaceEdit.changes) {\r\n                Object.keys(workspaceEdit.changes).forEach((key) => {\r\n                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);\r\n                    this._textEditChanges[key] = textEditChange;\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            this._workspaceEdit = {};\r\n        }\r\n    }\r\n    /**\r\n     * Returns the underlying {@link WorkspaceEdit} literal\r\n     * use to be returned from a workspace edit operation like rename.\r\n     */\r\n    get edit() {\r\n        this.initDocumentChanges();\r\n        if (this._changeAnnotations !== undefined) {\r\n            if (this._changeAnnotations.size === 0) {\r\n                this._workspaceEdit.changeAnnotations = undefined;\r\n            }\r\n            else {\r\n                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\r\n            }\r\n        }\r\n        return this._workspaceEdit;\r\n    }\r\n    getTextEditChange(key) {\r\n        if (OptionalVersionedTextDocumentIdentifier.is(key)) {\r\n            this.initDocumentChanges();\r\n            if (this._workspaceEdit.documentChanges === undefined) {\r\n                throw new Error('Workspace edit is not configured for document changes.');\r\n            }\r\n            const textDocument = { uri: key.uri, version: key.version };\r\n            let result = this._textEditChanges[textDocument.uri];\r\n            if (!result) {\r\n                const edits = [];\r\n                const textDocumentEdit = {\r\n                    textDocument,\r\n                    edits\r\n                };\r\n                this._workspaceEdit.documentChanges.push(textDocumentEdit);\r\n                result = new TextEditChangeImpl(edits, this._changeAnnotations);\r\n                this._textEditChanges[textDocument.uri] = result;\r\n            }\r\n            return result;\r\n        }\r\n        else {\r\n            this.initChanges();\r\n            if (this._workspaceEdit.changes === undefined) {\r\n                throw new Error('Workspace edit is not configured for normal text edit changes.');\r\n            }\r\n            let result = this._textEditChanges[key];\r\n            if (!result) {\r\n                let edits = [];\r\n                this._workspaceEdit.changes[key] = edits;\r\n                result = new TextEditChangeImpl(edits);\r\n                this._textEditChanges[key] = result;\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    initDocumentChanges() {\r\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\r\n            this._changeAnnotations = new ChangeAnnotations();\r\n            this._workspaceEdit.documentChanges = [];\r\n            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();\r\n        }\r\n    }\r\n    initChanges() {\r\n        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {\r\n            this._workspaceEdit.changes = Object.create(null);\r\n        }\r\n    }\r\n    createFile(uri, optionsOrAnnotation, options) {\r\n        this.initDocumentChanges();\r\n        if (this._workspaceEdit.documentChanges === undefined) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n        let annotation;\r\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\r\n            annotation = optionsOrAnnotation;\r\n        }\r\n        else {\r\n            options = optionsOrAnnotation;\r\n        }\r\n        let operation;\r\n        let id;\r\n        if (annotation === undefined) {\r\n            operation = CreateFile.create(uri, options);\r\n        }\r\n        else {\r\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\r\n            operation = CreateFile.create(uri, options, id);\r\n        }\r\n        this._workspaceEdit.documentChanges.push(operation);\r\n        if (id !== undefined) {\r\n            return id;\r\n        }\r\n    }\r\n    renameFile(oldUri, newUri, optionsOrAnnotation, options) {\r\n        this.initDocumentChanges();\r\n        if (this._workspaceEdit.documentChanges === undefined) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n        let annotation;\r\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\r\n            annotation = optionsOrAnnotation;\r\n        }\r\n        else {\r\n            options = optionsOrAnnotation;\r\n        }\r\n        let operation;\r\n        let id;\r\n        if (annotation === undefined) {\r\n            operation = RenameFile.create(oldUri, newUri, options);\r\n        }\r\n        else {\r\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\r\n            operation = RenameFile.create(oldUri, newUri, options, id);\r\n        }\r\n        this._workspaceEdit.documentChanges.push(operation);\r\n        if (id !== undefined) {\r\n            return id;\r\n        }\r\n    }\r\n    deleteFile(uri, optionsOrAnnotation, options) {\r\n        this.initDocumentChanges();\r\n        if (this._workspaceEdit.documentChanges === undefined) {\r\n            throw new Error('Workspace edit is not configured for document changes.');\r\n        }\r\n        let annotation;\r\n        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {\r\n            annotation = optionsOrAnnotation;\r\n        }\r\n        else {\r\n            options = optionsOrAnnotation;\r\n        }\r\n        let operation;\r\n        let id;\r\n        if (annotation === undefined) {\r\n            operation = DeleteFile.create(uri, options);\r\n        }\r\n        else {\r\n            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);\r\n            operation = DeleteFile.create(uri, options, id);\r\n        }\r\n        this._workspaceEdit.documentChanges.push(operation);\r\n        if (id !== undefined) {\r\n            return id;\r\n        }\r\n    }\r\n}\r\n/**\r\n * The TextDocumentIdentifier namespace provides helper functions to work with\r\n * {@link TextDocumentIdentifier} literals.\r\n */\r\nexport var TextDocumentIdentifier;\r\n(function (TextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new TextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     */\r\n    function create(uri) {\r\n        return { uri };\r\n    }\r\n    TextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri);\r\n    }\r\n    TextDocumentIdentifier.is = is;\r\n})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));\r\n/**\r\n * The VersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * {@link VersionedTextDocumentIdentifier} literals.\r\n */\r\nexport var VersionedTextDocumentIdentifier;\r\n(function (VersionedTextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new VersionedTextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     * @param version The document's version.\r\n     */\r\n    function create(uri, version) {\r\n        return { uri, version };\r\n    }\r\n    VersionedTextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);\r\n    }\r\n    VersionedTextDocumentIdentifier.is = is;\r\n})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));\r\n/**\r\n * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with\r\n * {@link OptionalVersionedTextDocumentIdentifier} literals.\r\n */\r\nexport var OptionalVersionedTextDocumentIdentifier;\r\n(function (OptionalVersionedTextDocumentIdentifier) {\r\n    /**\r\n     * Creates a new OptionalVersionedTextDocumentIdentifier literal.\r\n     * @param uri The document's uri.\r\n     * @param version The document's version.\r\n     */\r\n    function create(uri, version) {\r\n        return { uri, version };\r\n    }\r\n    OptionalVersionedTextDocumentIdentifier.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));\r\n    }\r\n    OptionalVersionedTextDocumentIdentifier.is = is;\r\n})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));\r\n/**\r\n * The TextDocumentItem namespace provides helper functions to work with\r\n * {@link TextDocumentItem} literals.\r\n */\r\nexport var TextDocumentItem;\r\n(function (TextDocumentItem) {\r\n    /**\r\n     * Creates a new TextDocumentItem literal.\r\n     * @param uri The document's uri.\r\n     * @param languageId The document's language identifier.\r\n     * @param version The document's version number.\r\n     * @param text The document's text.\r\n     */\r\n    function create(uri, languageId, version, text) {\r\n        return { uri, languageId, version, text };\r\n    }\r\n    TextDocumentItem.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);\r\n    }\r\n    TextDocumentItem.is = is;\r\n})(TextDocumentItem || (TextDocumentItem = {}));\r\n/**\r\n * Describes the content type that a client supports in various\r\n * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.\r\n *\r\n * Please note that `MarkupKinds` must not start with a `$`. This kinds\r\n * are reserved for internal usage.\r\n */\r\nexport var MarkupKind;\r\n(function (MarkupKind) {\r\n    /**\r\n     * Plain text is supported as a content format\r\n     */\r\n    MarkupKind.PlainText = 'plaintext';\r\n    /**\r\n     * Markdown is supported as a content format\r\n     */\r\n    MarkupKind.Markdown = 'markdown';\r\n    /**\r\n     * Checks whether the given value is a value of the {@link MarkupKind} type.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;\r\n    }\r\n    MarkupKind.is = is;\r\n})(MarkupKind || (MarkupKind = {}));\r\nexport var MarkupContent;\r\n(function (MarkupContent) {\r\n    /**\r\n     * Checks whether the given value conforms to the {@link MarkupContent} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);\r\n    }\r\n    MarkupContent.is = is;\r\n})(MarkupContent || (MarkupContent = {}));\r\n/**\r\n * The kind of a completion entry.\r\n */\r\nexport var CompletionItemKind;\r\n(function (CompletionItemKind) {\r\n    CompletionItemKind.Text = 1;\r\n    CompletionItemKind.Method = 2;\r\n    CompletionItemKind.Function = 3;\r\n    CompletionItemKind.Constructor = 4;\r\n    CompletionItemKind.Field = 5;\r\n    CompletionItemKind.Variable = 6;\r\n    CompletionItemKind.Class = 7;\r\n    CompletionItemKind.Interface = 8;\r\n    CompletionItemKind.Module = 9;\r\n    CompletionItemKind.Property = 10;\r\n    CompletionItemKind.Unit = 11;\r\n    CompletionItemKind.Value = 12;\r\n    CompletionItemKind.Enum = 13;\r\n    CompletionItemKind.Keyword = 14;\r\n    CompletionItemKind.Snippet = 15;\r\n    CompletionItemKind.Color = 16;\r\n    CompletionItemKind.File = 17;\r\n    CompletionItemKind.Reference = 18;\r\n    CompletionItemKind.Folder = 19;\r\n    CompletionItemKind.EnumMember = 20;\r\n    CompletionItemKind.Constant = 21;\r\n    CompletionItemKind.Struct = 22;\r\n    CompletionItemKind.Event = 23;\r\n    CompletionItemKind.Operator = 24;\r\n    CompletionItemKind.TypeParameter = 25;\r\n})(CompletionItemKind || (CompletionItemKind = {}));\r\n/**\r\n * Defines whether the insert text in a completion item should be interpreted as\r\n * plain text or a snippet.\r\n */\r\nexport var InsertTextFormat;\r\n(function (InsertTextFormat) {\r\n    /**\r\n     * The primary text to be inserted is treated as a plain string.\r\n     */\r\n    InsertTextFormat.PlainText = 1;\r\n    /**\r\n     * The primary text to be inserted is treated as a snippet.\r\n     *\r\n     * A snippet can define tab stops and placeholders with `$1`, `$2`\r\n     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to\r\n     * the end of the snippet. Placeholders with equal identifiers are linked,\r\n     * that is typing in one will update others too.\r\n     *\r\n     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax\r\n     */\r\n    InsertTextFormat.Snippet = 2;\r\n})(InsertTextFormat || (InsertTextFormat = {}));\r\n/**\r\n * Completion item tags are extra annotations that tweak the rendering of a completion\r\n * item.\r\n *\r\n * @since 3.15.0\r\n */\r\nexport var CompletionItemTag;\r\n(function (CompletionItemTag) {\r\n    /**\r\n     * Render a completion as obsolete, usually using a strike-out.\r\n     */\r\n    CompletionItemTag.Deprecated = 1;\r\n})(CompletionItemTag || (CompletionItemTag = {}));\r\n/**\r\n * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.\r\n *\r\n * @since 3.16.0\r\n */\r\nexport var InsertReplaceEdit;\r\n(function (InsertReplaceEdit) {\r\n    /**\r\n     * Creates a new insert / replace edit\r\n     */\r\n    function create(newText, insert, replace) {\r\n        return { newText, insert, replace };\r\n    }\r\n    InsertReplaceEdit.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);\r\n    }\r\n    InsertReplaceEdit.is = is;\r\n})(InsertReplaceEdit || (InsertReplaceEdit = {}));\r\n/**\r\n * How whitespace and indentation is handled during completion\r\n * item insertion.\r\n *\r\n * @since 3.16.0\r\n */\r\nexport var InsertTextMode;\r\n(function (InsertTextMode) {\r\n    /**\r\n     * The insertion or replace strings is taken as it is. If the\r\n     * value is multi line the lines below the cursor will be\r\n     * inserted using the indentation defined in the string value.\r\n     * The client will not apply any kind of adjustments to the\r\n     * string.\r\n     */\r\n    InsertTextMode.asIs = 1;\r\n    /**\r\n     * The editor adjusts leading whitespace of new lines so that\r\n     * they match the indentation up to the cursor of the line for\r\n     * which the item is accepted.\r\n     *\r\n     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a\r\n     * multi line completion item is indented using 2 tabs and all\r\n     * following lines inserted will be indented using 2 tabs as well.\r\n     */\r\n    InsertTextMode.adjustIndentation = 2;\r\n})(InsertTextMode || (InsertTextMode = {}));\r\nexport var CompletionItemLabelDetails;\r\n(function (CompletionItemLabelDetails) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&\r\n            (Is.string(candidate.description) || candidate.description === undefined);\r\n    }\r\n    CompletionItemLabelDetails.is = is;\r\n})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));\r\n/**\r\n * The CompletionItem namespace provides functions to deal with\r\n * completion items.\r\n */\r\nexport var CompletionItem;\r\n(function (CompletionItem) {\r\n    /**\r\n     * Create a completion item and seed it with a label.\r\n     * @param label The completion item's label\r\n     */\r\n    function create(label) {\r\n        return { label };\r\n    }\r\n    CompletionItem.create = create;\r\n})(CompletionItem || (CompletionItem = {}));\r\n/**\r\n * The CompletionList namespace provides functions to deal with\r\n * completion lists.\r\n */\r\nexport var CompletionList;\r\n(function (CompletionList) {\r\n    /**\r\n     * Creates a new completion list.\r\n     *\r\n     * @param items The completion items.\r\n     * @param isIncomplete The list is not complete.\r\n     */\r\n    function create(items, isIncomplete) {\r\n        return { items: items ? items : [], isIncomplete: !!isIncomplete };\r\n    }\r\n    CompletionList.create = create;\r\n})(CompletionList || (CompletionList = {}));\r\nexport var MarkedString;\r\n(function (MarkedString) {\r\n    /**\r\n     * Creates a marked string from plain text.\r\n     *\r\n     * @param plainText The plain text.\r\n     */\r\n    function fromPlainText(plainText) {\r\n        return plainText.replace(/[\\\\`*_{}[\\]()#+\\-.!]/g, '\\\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash\r\n    }\r\n    MarkedString.fromPlainText = fromPlainText;\r\n    /**\r\n     * Checks whether the given value conforms to the {@link MarkedString} type.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));\r\n    }\r\n    MarkedString.is = is;\r\n})(MarkedString || (MarkedString = {}));\r\nexport var Hover;\r\n(function (Hover) {\r\n    /**\r\n     * Checks whether the given value conforms to the {@link Hover} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||\r\n            MarkedString.is(candidate.contents) ||\r\n            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));\r\n    }\r\n    Hover.is = is;\r\n})(Hover || (Hover = {}));\r\n/**\r\n * The ParameterInformation namespace provides helper functions to work with\r\n * {@link ParameterInformation} literals.\r\n */\r\nexport var ParameterInformation;\r\n(function (ParameterInformation) {\r\n    /**\r\n     * Creates a new parameter information literal.\r\n     *\r\n     * @param label A label string.\r\n     * @param documentation A doc string.\r\n     */\r\n    function create(label, documentation) {\r\n        return documentation ? { label, documentation } : { label };\r\n    }\r\n    ParameterInformation.create = create;\r\n})(ParameterInformation || (ParameterInformation = {}));\r\n/**\r\n * The SignatureInformation namespace provides helper functions to work with\r\n * {@link SignatureInformation} literals.\r\n */\r\nexport var SignatureInformation;\r\n(function (SignatureInformation) {\r\n    function create(label, documentation, ...parameters) {\r\n        let result = { label };\r\n        if (Is.defined(documentation)) {\r\n            result.documentation = documentation;\r\n        }\r\n        if (Is.defined(parameters)) {\r\n            result.parameters = parameters;\r\n        }\r\n        else {\r\n            result.parameters = [];\r\n        }\r\n        return result;\r\n    }\r\n    SignatureInformation.create = create;\r\n})(SignatureInformation || (SignatureInformation = {}));\r\n/**\r\n * A document highlight kind.\r\n */\r\nexport var DocumentHighlightKind;\r\n(function (DocumentHighlightKind) {\r\n    /**\r\n     * A textual occurrence.\r\n     */\r\n    DocumentHighlightKind.Text = 1;\r\n    /**\r\n     * Read-access of a symbol, like reading a variable.\r\n     */\r\n    DocumentHighlightKind.Read = 2;\r\n    /**\r\n     * Write-access of a symbol, like writing to a variable.\r\n     */\r\n    DocumentHighlightKind.Write = 3;\r\n})(DocumentHighlightKind || (DocumentHighlightKind = {}));\r\n/**\r\n * DocumentHighlight namespace to provide helper functions to work with\r\n * {@link DocumentHighlight} literals.\r\n */\r\nexport var DocumentHighlight;\r\n(function (DocumentHighlight) {\r\n    /**\r\n     * Create a DocumentHighlight object.\r\n     * @param range The range the highlight applies to.\r\n     * @param kind The highlight kind\r\n     */\r\n    function create(range, kind) {\r\n        let result = { range };\r\n        if (Is.number(kind)) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentHighlight.create = create;\r\n})(DocumentHighlight || (DocumentHighlight = {}));\r\n/**\r\n * A symbol kind.\r\n */\r\nexport var SymbolKind;\r\n(function (SymbolKind) {\r\n    SymbolKind.File = 1;\r\n    SymbolKind.Module = 2;\r\n    SymbolKind.Namespace = 3;\r\n    SymbolKind.Package = 4;\r\n    SymbolKind.Class = 5;\r\n    SymbolKind.Method = 6;\r\n    SymbolKind.Property = 7;\r\n    SymbolKind.Field = 8;\r\n    SymbolKind.Constructor = 9;\r\n    SymbolKind.Enum = 10;\r\n    SymbolKind.Interface = 11;\r\n    SymbolKind.Function = 12;\r\n    SymbolKind.Variable = 13;\r\n    SymbolKind.Constant = 14;\r\n    SymbolKind.String = 15;\r\n    SymbolKind.Number = 16;\r\n    SymbolKind.Boolean = 17;\r\n    SymbolKind.Array = 18;\r\n    SymbolKind.Object = 19;\r\n    SymbolKind.Key = 20;\r\n    SymbolKind.Null = 21;\r\n    SymbolKind.EnumMember = 22;\r\n    SymbolKind.Struct = 23;\r\n    SymbolKind.Event = 24;\r\n    SymbolKind.Operator = 25;\r\n    SymbolKind.TypeParameter = 26;\r\n})(SymbolKind || (SymbolKind = {}));\r\n/**\r\n * Symbol tags are extra annotations that tweak the rendering of a symbol.\r\n *\r\n * @since 3.16\r\n */\r\nexport var SymbolTag;\r\n(function (SymbolTag) {\r\n    /**\r\n     * Render a symbol as obsolete, usually using a strike-out.\r\n     */\r\n    SymbolTag.Deprecated = 1;\r\n})(SymbolTag || (SymbolTag = {}));\r\nexport var SymbolInformation;\r\n(function (SymbolInformation) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the location of the symbol.\r\n     * @param uri The resource of the location of symbol.\r\n     * @param containerName The name of the symbol containing the symbol.\r\n     */\r\n    function create(name, kind, range, uri, containerName) {\r\n        let result = {\r\n            name,\r\n            kind,\r\n            location: { uri, range }\r\n        };\r\n        if (containerName) {\r\n            result.containerName = containerName;\r\n        }\r\n        return result;\r\n    }\r\n    SymbolInformation.create = create;\r\n})(SymbolInformation || (SymbolInformation = {}));\r\nexport var WorkspaceSymbol;\r\n(function (WorkspaceSymbol) {\r\n    /**\r\n     * Create a new workspace symbol.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param uri The resource of the location of the symbol.\r\n     * @param range An options range of the location.\r\n     * @returns A WorkspaceSymbol.\r\n     */\r\n    function create(name, kind, uri, range) {\r\n        return range !== undefined\r\n            ? { name, kind, location: { uri, range } }\r\n            : { name, kind, location: { uri } };\r\n    }\r\n    WorkspaceSymbol.create = create;\r\n})(WorkspaceSymbol || (WorkspaceSymbol = {}));\r\nexport var DocumentSymbol;\r\n(function (DocumentSymbol) {\r\n    /**\r\n     * Creates a new symbol information literal.\r\n     *\r\n     * @param name The name of the symbol.\r\n     * @param detail The detail of the symbol.\r\n     * @param kind The kind of the symbol.\r\n     * @param range The range of the symbol.\r\n     * @param selectionRange The selectionRange of the symbol.\r\n     * @param children Children of the symbol.\r\n     */\r\n    function create(name, detail, kind, range, selectionRange, children) {\r\n        let result = {\r\n            name,\r\n            detail,\r\n            kind,\r\n            range,\r\n            selectionRange\r\n        };\r\n        if (children !== undefined) {\r\n            result.children = children;\r\n        }\r\n        return result;\r\n    }\r\n    DocumentSymbol.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate &&\r\n            Is.string(candidate.name) && Is.number(candidate.kind) &&\r\n            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&\r\n            (candidate.detail === undefined || Is.string(candidate.detail)) &&\r\n            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&\r\n            (candidate.children === undefined || Array.isArray(candidate.children)) &&\r\n            (candidate.tags === undefined || Array.isArray(candidate.tags));\r\n    }\r\n    DocumentSymbol.is = is;\r\n})(DocumentSymbol || (DocumentSymbol = {}));\r\n/**\r\n * A set of predefined code action kinds\r\n */\r\nexport var CodeActionKind;\r\n(function (CodeActionKind) {\r\n    /**\r\n     * Empty kind.\r\n     */\r\n    CodeActionKind.Empty = '';\r\n    /**\r\n     * Base kind for quickfix actions: 'quickfix'\r\n     */\r\n    CodeActionKind.QuickFix = 'quickfix';\r\n    /**\r\n     * Base kind for refactoring actions: 'refactor'\r\n     */\r\n    CodeActionKind.Refactor = 'refactor';\r\n    /**\r\n     * Base kind for refactoring extraction actions: 'refactor.extract'\r\n     *\r\n     * Example extract actions:\r\n     *\r\n     * - Extract method\r\n     * - Extract function\r\n     * - Extract variable\r\n     * - Extract interface from class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorExtract = 'refactor.extract';\r\n    /**\r\n     * Base kind for refactoring inline actions: 'refactor.inline'\r\n     *\r\n     * Example inline actions:\r\n     *\r\n     * - Inline function\r\n     * - Inline variable\r\n     * - Inline constant\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorInline = 'refactor.inline';\r\n    /**\r\n     * Base kind for refactoring rewrite actions: 'refactor.rewrite'\r\n     *\r\n     * Example rewrite actions:\r\n     *\r\n     * - Convert JavaScript function to class\r\n     * - Add or remove parameter\r\n     * - Encapsulate field\r\n     * - Make method static\r\n     * - Move method to base class\r\n     * - ...\r\n     */\r\n    CodeActionKind.RefactorRewrite = 'refactor.rewrite';\r\n    /**\r\n     * Base kind for source actions: `source`\r\n     *\r\n     * Source code actions apply to the entire file.\r\n     */\r\n    CodeActionKind.Source = 'source';\r\n    /**\r\n     * Base kind for an organize imports source action: `source.organizeImports`\r\n     */\r\n    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';\r\n    /**\r\n     * Base kind for auto-fix source actions: `source.fixAll`.\r\n     *\r\n     * Fix all actions automatically fix errors that have a clear fix that do not require user input.\r\n     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.\r\n     *\r\n     * @since 3.15.0\r\n     */\r\n    CodeActionKind.SourceFixAll = 'source.fixAll';\r\n})(CodeActionKind || (CodeActionKind = {}));\r\n/**\r\n * The reason why code actions were requested.\r\n *\r\n * @since 3.17.0\r\n */\r\nexport var CodeActionTriggerKind;\r\n(function (CodeActionTriggerKind) {\r\n    /**\r\n     * Code actions were explicitly requested by the user or by an extension.\r\n     */\r\n    CodeActionTriggerKind.Invoked = 1;\r\n    /**\r\n     * Code actions were requested automatically.\r\n     *\r\n     * This typically happens when current selection in a file changes, but can\r\n     * also be triggered when file content changes.\r\n     */\r\n    CodeActionTriggerKind.Automatic = 2;\r\n})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));\r\n/**\r\n * The CodeActionContext namespace provides helper functions to work with\r\n * {@link CodeActionContext} literals.\r\n */\r\nexport var CodeActionContext;\r\n(function (CodeActionContext) {\r\n    /**\r\n     * Creates a new CodeActionContext literal.\r\n     */\r\n    function create(diagnostics, only, triggerKind) {\r\n        let result = { diagnostics };\r\n        if (only !== undefined && only !== null) {\r\n            result.only = only;\r\n        }\r\n        if (triggerKind !== undefined && triggerKind !== null) {\r\n            result.triggerKind = triggerKind;\r\n        }\r\n        return result;\r\n    }\r\n    CodeActionContext.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)\r\n            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))\r\n            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);\r\n    }\r\n    CodeActionContext.is = is;\r\n})(CodeActionContext || (CodeActionContext = {}));\r\nexport var CodeAction;\r\n(function (CodeAction) {\r\n    function create(title, kindOrCommandOrEdit, kind) {\r\n        let result = { title };\r\n        let checkKind = true;\r\n        if (typeof kindOrCommandOrEdit === 'string') {\r\n            checkKind = false;\r\n            result.kind = kindOrCommandOrEdit;\r\n        }\r\n        else if (Command.is(kindOrCommandOrEdit)) {\r\n            result.command = kindOrCommandOrEdit;\r\n        }\r\n        else {\r\n            result.edit = kindOrCommandOrEdit;\r\n        }\r\n        if (checkKind && kind !== undefined) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    CodeAction.create = create;\r\n    function is(value) {\r\n        let candidate = value;\r\n        return candidate && Is.string(candidate.title) &&\r\n            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&\r\n            (candidate.kind === undefined || Is.string(candidate.kind)) &&\r\n            (candidate.edit !== undefined || candidate.command !== undefined) &&\r\n            (candidate.command === undefined || Command.is(candidate.command)) &&\r\n            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&\r\n            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));\r\n    }\r\n    CodeAction.is = is;\r\n})(CodeAction || (CodeAction = {}));\r\n/**\r\n * The CodeLens namespace provides helper functions to work with\r\n * {@link CodeLens} literals.\r\n */\r\nexport var CodeLens;\r\n(function (CodeLens) {\r\n    /**\r\n     * Creates a new CodeLens literal.\r\n     */\r\n    function create(range, data) {\r\n        let result = { range };\r\n        if (Is.defined(data)) {\r\n            result.data = data;\r\n        }\r\n        return result;\r\n    }\r\n    CodeLens.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link CodeLens} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));\r\n    }\r\n    CodeLens.is = is;\r\n})(CodeLens || (CodeLens = {}));\r\n/**\r\n * The FormattingOptions namespace provides helper functions to work with\r\n * {@link FormattingOptions} literals.\r\n */\r\nexport var FormattingOptions;\r\n(function (FormattingOptions) {\r\n    /**\r\n     * Creates a new FormattingOptions literal.\r\n     */\r\n    function create(tabSize, insertSpaces) {\r\n        return { tabSize, insertSpaces };\r\n    }\r\n    FormattingOptions.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);\r\n    }\r\n    FormattingOptions.is = is;\r\n})(FormattingOptions || (FormattingOptions = {}));\r\n/**\r\n * The DocumentLink namespace provides helper functions to work with\r\n * {@link DocumentLink} literals.\r\n */\r\nexport var DocumentLink;\r\n(function (DocumentLink) {\r\n    /**\r\n     * Creates a new DocumentLink literal.\r\n     */\r\n    function create(range, target, data) {\r\n        return { range, target, data };\r\n    }\r\n    DocumentLink.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link DocumentLink} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));\r\n    }\r\n    DocumentLink.is = is;\r\n})(DocumentLink || (DocumentLink = {}));\r\n/**\r\n * The SelectionRange namespace provides helper function to work with\r\n * SelectionRange literals.\r\n */\r\nexport var SelectionRange;\r\n(function (SelectionRange) {\r\n    /**\r\n     * Creates a new SelectionRange\r\n     * @param range the range.\r\n     * @param parent an optional parent.\r\n     */\r\n    function create(range, parent) {\r\n        return { range, parent };\r\n    }\r\n    SelectionRange.create = create;\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));\r\n    }\r\n    SelectionRange.is = is;\r\n})(SelectionRange || (SelectionRange = {}));\r\n/**\r\n * A set of predefined token types. This set is not fixed\r\n * an clients can specify additional token types via the\r\n * corresponding client capabilities.\r\n *\r\n * @since 3.16.0\r\n */\r\nexport var SemanticTokenTypes;\r\n(function (SemanticTokenTypes) {\r\n    SemanticTokenTypes[\"namespace\"] = \"namespace\";\r\n    /**\r\n     * Represents a generic type. Acts as a fallback for types which can't be mapped to\r\n     * a specific type like class or enum.\r\n     */\r\n    SemanticTokenTypes[\"type\"] = \"type\";\r\n    SemanticTokenTypes[\"class\"] = \"class\";\r\n    SemanticTokenTypes[\"enum\"] = \"enum\";\r\n    SemanticTokenTypes[\"interface\"] = \"interface\";\r\n    SemanticTokenTypes[\"struct\"] = \"struct\";\r\n    SemanticTokenTypes[\"typeParameter\"] = \"typeParameter\";\r\n    SemanticTokenTypes[\"parameter\"] = \"parameter\";\r\n    SemanticTokenTypes[\"variable\"] = \"variable\";\r\n    SemanticTokenTypes[\"property\"] = \"property\";\r\n    SemanticTokenTypes[\"enumMember\"] = \"enumMember\";\r\n    SemanticTokenTypes[\"event\"] = \"event\";\r\n    SemanticTokenTypes[\"function\"] = \"function\";\r\n    SemanticTokenTypes[\"method\"] = \"method\";\r\n    SemanticTokenTypes[\"macro\"] = \"macro\";\r\n    SemanticTokenTypes[\"keyword\"] = \"keyword\";\r\n    SemanticTokenTypes[\"modifier\"] = \"modifier\";\r\n    SemanticTokenTypes[\"comment\"] = \"comment\";\r\n    SemanticTokenTypes[\"string\"] = \"string\";\r\n    SemanticTokenTypes[\"number\"] = \"number\";\r\n    SemanticTokenTypes[\"regexp\"] = \"regexp\";\r\n    SemanticTokenTypes[\"operator\"] = \"operator\";\r\n    /**\r\n     * @since 3.17.0\r\n     */\r\n    SemanticTokenTypes[\"decorator\"] = \"decorator\";\r\n})(SemanticTokenTypes || (SemanticTokenTypes = {}));\r\n/**\r\n * A set of predefined token modifiers. This set is not fixed\r\n * an clients can specify additional token types via the\r\n * corresponding client capabilities.\r\n *\r\n * @since 3.16.0\r\n */\r\nexport var SemanticTokenModifiers;\r\n(function (SemanticTokenModifiers) {\r\n    SemanticTokenModifiers[\"declaration\"] = \"declaration\";\r\n    SemanticTokenModifiers[\"definition\"] = \"definition\";\r\n    SemanticTokenModifiers[\"readonly\"] = \"readonly\";\r\n    SemanticTokenModifiers[\"static\"] = \"static\";\r\n    SemanticTokenModifiers[\"deprecated\"] = \"deprecated\";\r\n    SemanticTokenModifiers[\"abstract\"] = \"abstract\";\r\n    SemanticTokenModifiers[\"async\"] = \"async\";\r\n    SemanticTokenModifiers[\"modification\"] = \"modification\";\r\n    SemanticTokenModifiers[\"documentation\"] = \"documentation\";\r\n    SemanticTokenModifiers[\"defaultLibrary\"] = \"defaultLibrary\";\r\n})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));\r\n/**\r\n * @since 3.16.0\r\n */\r\nexport var SemanticTokens;\r\n(function (SemanticTokens) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&\r\n            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');\r\n    }\r\n    SemanticTokens.is = is;\r\n})(SemanticTokens || (SemanticTokens = {}));\r\n/**\r\n * The InlineValueText namespace provides functions to deal with InlineValueTexts.\r\n *\r\n * @since 3.17.0\r\n */\r\nexport var InlineValueText;\r\n(function (InlineValueText) {\r\n    /**\r\n     * Creates a new InlineValueText literal.\r\n     */\r\n    function create(range, text) {\r\n        return { range, text };\r\n    }\r\n    InlineValueText.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);\r\n    }\r\n    InlineValueText.is = is;\r\n})(InlineValueText || (InlineValueText = {}));\r\n/**\r\n * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.\r\n *\r\n * @since 3.17.0\r\n */\r\nexport var InlineValueVariableLookup;\r\n(function (InlineValueVariableLookup) {\r\n    /**\r\n     * Creates a new InlineValueText literal.\r\n     */\r\n    function create(range, variableName, caseSensitiveLookup) {\r\n        return { range, variableName, caseSensitiveLookup };\r\n    }\r\n    InlineValueVariableLookup.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)\r\n            && (Is.string(candidate.variableName) || candidate.variableName === undefined);\r\n    }\r\n    InlineValueVariableLookup.is = is;\r\n})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));\r\n/**\r\n * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.\r\n *\r\n * @since 3.17.0\r\n */\r\nexport var InlineValueEvaluatableExpression;\r\n(function (InlineValueEvaluatableExpression) {\r\n    /**\r\n     * Creates a new InlineValueEvaluatableExpression literal.\r\n     */\r\n    function create(range, expression) {\r\n        return { range, expression };\r\n    }\r\n    InlineValueEvaluatableExpression.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return candidate !== undefined && candidate !== null && Range.is(candidate.range)\r\n            && (Is.string(candidate.expression) || candidate.expression === undefined);\r\n    }\r\n    InlineValueEvaluatableExpression.is = is;\r\n})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));\r\n/**\r\n * The InlineValueContext namespace provides helper functions to work with\r\n * {@link InlineValueContext} literals.\r\n *\r\n * @since 3.17.0\r\n */\r\nexport var InlineValueContext;\r\n(function (InlineValueContext) {\r\n    /**\r\n     * Creates a new InlineValueContext literal.\r\n     */\r\n    function create(frameId, stoppedLocation) {\r\n        return { frameId, stoppedLocation };\r\n    }\r\n    InlineValueContext.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.\r\n     */\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.defined(candidate) && Range.is(value.stoppedLocation);\r\n    }\r\n    InlineValueContext.is = is;\r\n})(InlineValueContext || (InlineValueContext = {}));\r\n/**\r\n * Inlay hint kinds.\r\n *\r\n * @since 3.17.0\r\n */\r\nexport var InlayHintKind;\r\n(function (InlayHintKind) {\r\n    /**\r\n     * An inlay hint that for a type annotation.\r\n     */\r\n    InlayHintKind.Type = 1;\r\n    /**\r\n     * An inlay hint that is for a parameter.\r\n     */\r\n    InlayHintKind.Parameter = 2;\r\n    function is(value) {\r\n        return value === 1 || value === 2;\r\n    }\r\n    InlayHintKind.is = is;\r\n})(InlayHintKind || (InlayHintKind = {}));\r\nexport var InlayHintLabelPart;\r\n(function (InlayHintLabelPart) {\r\n    function create(value) {\r\n        return { value };\r\n    }\r\n    InlayHintLabelPart.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate)\r\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\r\n            && (candidate.location === undefined || Location.is(candidate.location))\r\n            && (candidate.command === undefined || Command.is(candidate.command));\r\n    }\r\n    InlayHintLabelPart.is = is;\r\n})(InlayHintLabelPart || (InlayHintLabelPart = {}));\r\nexport var InlayHint;\r\n(function (InlayHint) {\r\n    function create(position, label, kind) {\r\n        const result = { position, label };\r\n        if (kind !== undefined) {\r\n            result.kind = kind;\r\n        }\r\n        return result;\r\n    }\r\n    InlayHint.create = create;\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && Position.is(candidate.position)\r\n            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))\r\n            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))\r\n            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)\r\n            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))\r\n            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))\r\n            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));\r\n    }\r\n    InlayHint.is = is;\r\n})(InlayHint || (InlayHint = {}));\r\nexport var StringValue;\r\n(function (StringValue) {\r\n    function createSnippet(value) {\r\n        return { kind: 'snippet', value };\r\n    }\r\n    StringValue.createSnippet = createSnippet;\r\n})(StringValue || (StringValue = {}));\r\nexport var InlineCompletionItem;\r\n(function (InlineCompletionItem) {\r\n    function create(insertText, filterText, range, command) {\r\n        return { insertText, filterText, range, command };\r\n    }\r\n    InlineCompletionItem.create = create;\r\n})(InlineCompletionItem || (InlineCompletionItem = {}));\r\nexport var InlineCompletionList;\r\n(function (InlineCompletionList) {\r\n    function create(items) {\r\n        return { items };\r\n    }\r\n    InlineCompletionList.create = create;\r\n})(InlineCompletionList || (InlineCompletionList = {}));\r\n/**\r\n * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.\r\n *\r\n * @since 3.18.0\r\n * @proposed\r\n */\r\nexport var InlineCompletionTriggerKind;\r\n(function (InlineCompletionTriggerKind) {\r\n    /**\r\n     * Completion was triggered explicitly by a user gesture.\r\n     */\r\n    InlineCompletionTriggerKind.Invoked = 0;\r\n    /**\r\n     * Completion was triggered automatically while editing.\r\n     */\r\n    InlineCompletionTriggerKind.Automatic = 1;\r\n})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));\r\nexport var SelectedCompletionInfo;\r\n(function (SelectedCompletionInfo) {\r\n    function create(range, text) {\r\n        return { range, text };\r\n    }\r\n    SelectedCompletionInfo.create = create;\r\n})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));\r\nexport var InlineCompletionContext;\r\n(function (InlineCompletionContext) {\r\n    function create(triggerKind, selectedCompletionInfo) {\r\n        return { triggerKind, selectedCompletionInfo };\r\n    }\r\n    InlineCompletionContext.create = create;\r\n})(InlineCompletionContext || (InlineCompletionContext = {}));\r\nexport var WorkspaceFolder;\r\n(function (WorkspaceFolder) {\r\n    function is(value) {\r\n        const candidate = value;\r\n        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);\r\n    }\r\n    WorkspaceFolder.is = is;\r\n})(WorkspaceFolder || (WorkspaceFolder = {}));\r\nexport const EOL = ['\\n', '\\r\\n', '\\r'];\r\n/**\r\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\r\n */\r\nexport var TextDocument;\r\n(function (TextDocument) {\r\n    /**\r\n     * Creates a new ITextDocument literal from the given uri and content.\r\n     * @param uri The document's uri.\r\n     * @param languageId The document's language Id.\r\n     * @param version The document's version.\r\n     * @param content The document's content.\r\n     */\r\n    function create(uri, languageId, version, content) {\r\n        return new FullTextDocument(uri, languageId, version, content);\r\n    }\r\n    TextDocument.create = create;\r\n    /**\r\n     * Checks whether the given literal conforms to the {@link ITextDocument} interface.\r\n     */\r\n    function is(value) {\r\n        let candidate = value;\r\n        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)\r\n            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;\r\n    }\r\n    TextDocument.is = is;\r\n    function applyEdits(document, edits) {\r\n        let text = document.getText();\r\n        let sortedEdits = mergeSort(edits, (a, b) => {\r\n            let diff = a.range.start.line - b.range.start.line;\r\n            if (diff === 0) {\r\n                return a.range.start.character - b.range.start.character;\r\n            }\r\n            return diff;\r\n        });\r\n        let lastModifiedOffset = text.length;\r\n        for (let i = sortedEdits.length - 1; i >= 0; i--) {\r\n            let e = sortedEdits[i];\r\n            let startOffset = document.offsetAt(e.range.start);\r\n            let endOffset = document.offsetAt(e.range.end);\r\n            if (endOffset <= lastModifiedOffset) {\r\n                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);\r\n            }\r\n            else {\r\n                throw new Error('Overlapping edit');\r\n            }\r\n            lastModifiedOffset = startOffset;\r\n        }\r\n        return text;\r\n    }\r\n    TextDocument.applyEdits = applyEdits;\r\n    function mergeSort(data, compare) {\r\n        if (data.length <= 1) {\r\n            // sorted\r\n            return data;\r\n        }\r\n        const p = (data.length / 2) | 0;\r\n        const left = data.slice(0, p);\r\n        const right = data.slice(p);\r\n        mergeSort(left, compare);\r\n        mergeSort(right, compare);\r\n        let leftIdx = 0;\r\n        let rightIdx = 0;\r\n        let i = 0;\r\n        while (leftIdx < left.length && rightIdx < right.length) {\r\n            let ret = compare(left[leftIdx], right[rightIdx]);\r\n            if (ret <= 0) {\r\n                // smaller_equal -> take left to preserve order\r\n                data[i++] = left[leftIdx++];\r\n            }\r\n            else {\r\n                // greater -> take right\r\n                data[i++] = right[rightIdx++];\r\n            }\r\n        }\r\n        while (leftIdx < left.length) {\r\n            data[i++] = left[leftIdx++];\r\n        }\r\n        while (rightIdx < right.length) {\r\n            data[i++] = right[rightIdx++];\r\n        }\r\n        return data;\r\n    }\r\n})(TextDocument || (TextDocument = {}));\r\n/**\r\n * @deprecated Use the text document from the new vscode-languageserver-textdocument package.\r\n */\r\nclass FullTextDocument {\r\n    constructor(uri, languageId, version, content) {\r\n        this._uri = uri;\r\n        this._languageId = languageId;\r\n        this._version = version;\r\n        this._content = content;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    get uri() {\r\n        return this._uri;\r\n    }\r\n    get languageId() {\r\n        return this._languageId;\r\n    }\r\n    get version() {\r\n        return this._version;\r\n    }\r\n    getText(range) {\r\n        if (range) {\r\n            let start = this.offsetAt(range.start);\r\n            let end = this.offsetAt(range.end);\r\n            return this._content.substring(start, end);\r\n        }\r\n        return this._content;\r\n    }\r\n    update(event, version) {\r\n        this._content = event.text;\r\n        this._version = version;\r\n        this._lineOffsets = undefined;\r\n    }\r\n    getLineOffsets() {\r\n        if (this._lineOffsets === undefined) {\r\n            let lineOffsets = [];\r\n            let text = this._content;\r\n            let isLineStart = true;\r\n            for (let i = 0; i < text.length; i++) {\r\n                if (isLineStart) {\r\n                    lineOffsets.push(i);\r\n                    isLineStart = false;\r\n                }\r\n                let ch = text.charAt(i);\r\n                isLineStart = (ch === '\\r' || ch === '\\n');\r\n                if (ch === '\\r' && i + 1 < text.length && text.charAt(i + 1) === '\\n') {\r\n                    i++;\r\n                }\r\n            }\r\n            if (isLineStart && text.length > 0) {\r\n                lineOffsets.push(text.length);\r\n            }\r\n            this._lineOffsets = lineOffsets;\r\n        }\r\n        return this._lineOffsets;\r\n    }\r\n    positionAt(offset) {\r\n        offset = Math.max(Math.min(offset, this._content.length), 0);\r\n        let lineOffsets = this.getLineOffsets();\r\n        let low = 0, high = lineOffsets.length;\r\n        if (high === 0) {\r\n            return Position.create(0, offset);\r\n        }\r\n        while (low < high) {\r\n            let mid = Math.floor((low + high) / 2);\r\n            if (lineOffsets[mid] > offset) {\r\n                high = mid;\r\n            }\r\n            else {\r\n                low = mid + 1;\r\n            }\r\n        }\r\n        // low is the least x for which the line offset is larger than the current offset\r\n        // or array.length if no line offset is larger than the current offset\r\n        let line = low - 1;\r\n        return Position.create(line, offset - lineOffsets[line]);\r\n    }\r\n    offsetAt(position) {\r\n        let lineOffsets = this.getLineOffsets();\r\n        if (position.line >= lineOffsets.length) {\r\n            return this._content.length;\r\n        }\r\n        else if (position.line < 0) {\r\n            return 0;\r\n        }\r\n        let lineOffset = lineOffsets[position.line];\r\n        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;\r\n        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);\r\n    }\r\n    get lineCount() {\r\n        return this.getLineOffsets().length;\r\n    }\r\n}\r\nvar Is;\r\n(function (Is) {\r\n    const toString = Object.prototype.toString;\r\n    function defined(value) {\r\n        return typeof value !== 'undefined';\r\n    }\r\n    Is.defined = defined;\r\n    function undefined(value) {\r\n        return typeof value === 'undefined';\r\n    }\r\n    Is.undefined = undefined;\r\n    function boolean(value) {\r\n        return value === true || value === false;\r\n    }\r\n    Is.boolean = boolean;\r\n    function string(value) {\r\n        return toString.call(value) === '[object String]';\r\n    }\r\n    Is.string = string;\r\n    function number(value) {\r\n        return toString.call(value) === '[object Number]';\r\n    }\r\n    Is.number = number;\r\n    function numberRange(value, min, max) {\r\n        return toString.call(value) === '[object Number]' && min <= value && value <= max;\r\n    }\r\n    Is.numberRange = numberRange;\r\n    function integer(value) {\r\n        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;\r\n    }\r\n    Is.integer = integer;\r\n    function uinteger(value) {\r\n        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;\r\n    }\r\n    Is.uinteger = uinteger;\r\n    function func(value) {\r\n        return toString.call(value) === '[object Function]';\r\n    }\r\n    Is.func = func;\r\n    function objectLiteral(value) {\r\n        // Strictly speaking class instances pass this check as well. Since the LSP\r\n        // doesn't use classes we ignore this for now. If we do we need to add something\r\n        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`\r\n        return value !== null && typeof value === 'object';\r\n    }\r\n    Is.objectLiteral = objectLiteral;\r\n    function typedArray(value, check) {\r\n        return Array.isArray(value) && value.every(check);\r\n    }\r\n    Is.typedArray = typedArray;\r\n})(Is || (Is = {}));\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AbstractCancellationTokenSource } from 'vscode-jsonrpc';\r\nimport { CancellationToken, CancellationTokenSource } from 'vscode-jsonrpc';\r\n\r\nexport type MaybePromise<T> = T | Promise<T>\r\n\r\n/**\r\n * Delays the execution of the current code to the next tick of the event loop.\r\n * Don't call this method directly in a tight loop to prevent too many promises from being created.\r\n */\r\nexport function delayNextTick(): Promise<void> {\r\n    return new Promise(resolve => {\r\n        // In case we are running in a non-node environment, `setImmediate` isn't available.\r\n        // Using `setTimeout` of the browser API accomplishes the same result.\r\n        if (typeof setImmediate === 'undefined') {\r\n            setTimeout(resolve, 0);\r\n        } else {\r\n            setImmediate(resolve);\r\n        }\r\n    });\r\n}\r\n\r\nlet lastTick = 0;\r\nlet globalInterruptionPeriod = 10;\r\n\r\n/**\r\n * Reset the global interruption period and create a cancellation token source.\r\n */\r\nexport function startCancelableOperation(): AbstractCancellationTokenSource {\r\n    lastTick = Date.now();\r\n    return new CancellationTokenSource();\r\n}\r\n\r\n/**\r\n * Change the period duration for `interruptAndCheck` to the given number of milliseconds.\r\n * The default value is 10ms.\r\n */\r\nexport function setInterruptionPeriod(period: number): void {\r\n    globalInterruptionPeriod = period;\r\n}\r\n\r\n/**\r\n * This symbol may be thrown in an asynchronous context by any Langium service that receives\r\n * a `CancellationToken`. This means that the promise returned by such a service is rejected with\r\n * this symbol as rejection reason.\r\n */\r\nexport const OperationCancelled = Symbol('OperationCancelled');\r\n\r\n/**\r\n * Use this in a `catch` block to check whether the thrown object indicates that the operation\r\n * has been cancelled.\r\n */\r\nexport function isOperationCancelled(err: unknown): err is typeof OperationCancelled {\r\n    return err === OperationCancelled;\r\n}\r\n\r\n/**\r\n * This function does two things:\r\n *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined\r\n *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.\r\n *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation\r\n *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.\r\n *\r\n * All services in Langium that receive a `CancellationToken` may potentially call this function, so the\r\n * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to\r\n * the promise) to avoid that event being exposed as an error.\r\n */\r\nexport async function interruptAndCheck(token: CancellationToken): Promise<void> {\r\n    if (token === CancellationToken.None) {\r\n        // Early exit in case cancellation was disabled by the caller\r\n        return;\r\n    }\r\n    const current = Date.now();\r\n    if (current - lastTick >= globalInterruptionPeriod) {\r\n        lastTick = current;\r\n        await delayNextTick();\r\n    }\r\n    if (token.isCancellationRequested) {\r\n        throw OperationCancelled;\r\n    }\r\n}\r\n\r\n/**\r\n * Utility class to execute mutually exclusive actions.\r\n */\r\nexport class MutexLock {\r\n\r\n    private previousAction = Promise.resolve();\r\n    private previousTokenSource = new CancellationTokenSource();\r\n\r\n    /**\r\n     * Performs a single async action, like initializing the workspace or processing document changes.\r\n     * Only one action will be executed at a time.\r\n     *\r\n     * When another action is queued up, the token provided for the action will be cancelled.\r\n     * Assuming the action makes use of this token, the next action only has to wait for the current action to finish cancellation.\r\n     */\r\n    lock(action: (token: CancellationToken) => Promise<void>): Promise<void> {\r\n        this.cancel();\r\n        const tokenSource = new CancellationTokenSource();\r\n        this.previousTokenSource = tokenSource;\r\n        // Append the new action to the previous action. We usually don't have to wait for long, as the previous action\r\n        // 1. has either completed\r\n        // 2. has been cancelled\r\n        return this.previousAction = this.previousAction.then(\r\n            () => action(tokenSource.token).catch(err => {\r\n                if (!isOperationCancelled(err)) {\r\n                    console.error('Error: ', err);\r\n                }\r\n            })\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Cancels the currently executed action\r\n     */\r\n    cancel(): void {\r\n        this.previousTokenSource.cancel();\r\n    }\r\n}\r\n\r\n/**\r\n * Simple implementation of the deferred pattern.\r\n * An object that exposes a promise and functions to resolve and reject it.\r\n */\r\nexport class Deferred<T = void> {\r\n    resolve: (value: T) => this;\r\n    reject: (err?: unknown) => this;\r\n\r\n    promise = new Promise<T>((resolve, reject) => {\r\n        this.resolve = (arg) => (resolve(arg), this);\r\n        this.reject = (err) => (reject(err), this);\r\n    });\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, CodeDescription, DiagnosticRelatedInformation, DiagnosticTag, integer, Range } from 'vscode-languageserver';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstReflection, Properties } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\nimport { MultiMap } from '../utils/collections.js';\r\nimport { isOperationCancelled } from '../utils/promise-util.js';\r\nimport { stream } from '../utils/stream.js';\r\n\r\nexport type DiagnosticInfo<N extends AstNode, P extends string = Properties<N>> = {\r\n    /** The AST node to which the diagnostic is attached. */\r\n    node: N;\r\n    /** If a property name is given, the diagnostic is restricted to the corresponding text region. */\r\n    property?: P;\r\n    /** If the value of a keyword is given, the diagnostic will appear at its corresponding text region */\r\n    keyword?: string;\r\n    /** In case of a multi-value property (array), an index can be given to select a specific element. */\r\n    index?: number;\r\n    /** If you want to create a diagnostic independent to any property, use the range property. */\r\n    range?: Range;\r\n    /** The diagnostic's code, which usually appear in the user interface. */\r\n    code?: integer | string;\r\n    /** An optional property to describe the error code. */\r\n    codeDescription?: CodeDescription;\r\n    /** Additional metadata about the diagnostic. */\r\n    tags?: DiagnosticTag[];\r\n    /** An array of related diagnostic information, e.g. when symbol-names within a scope collide all definitions can be marked via this property. */\r\n    relatedInformation?: DiagnosticRelatedInformation[];\r\n    /** A data entry field that is preserved between a `textDocument/publishDiagnostics` notification and `textDocument/codeAction` request. */\r\n    data?: unknown;\r\n}\r\n\r\n/**\r\n * Shape of information commonly used in the `data` field of diagnostics.\r\n */\r\nexport interface DiagnosticData {\r\n    /** Diagnostic code for identifying which code action to apply. This code is _not_ shown in the user interface. */\r\n    code: string\r\n    /** Specifies where to apply the code action in the form of a `DocumentSegment`. */\r\n    actionSegment?: DocumentSegment\r\n    /** Specifies where to apply the code action in the form of a `Range`. */\r\n    actionRange?: Range\r\n}\r\n\r\nexport function diagnosticData(code: string): DiagnosticData {\r\n    return { code };\r\n}\r\n\r\nexport type ValidationAcceptor = <N extends AstNode>(severity: 'error' | 'warning' | 'info' | 'hint', message: string, info: DiagnosticInfo<N>) => void\r\n\r\nexport type ValidationCheck<T extends AstNode = AstNode> = (node: T, accept: ValidationAcceptor, cancelToken: CancellationToken) => MaybePromise<void>;\r\n\r\n/**\r\n * A utility type for associating non-primitive AST types to corresponding validation checks. For example:\r\n *\r\n * ```ts\r\n *   const checks: ValidationChecks<StatemachineAstType> = {\r\n *       State: validator.checkStateNameStartsWithCapital\r\n *    };\r\n * ```\r\n *\r\n * If an AST type does not extend AstNode, e.g. if it describes a union of string literals, that type's name must not occur as a key in objects of type `ValidationCheck<...>`.\r\n *\r\n * @param T a type definition mapping language specific type names (keys) to the corresponding types (values)\r\n */\r\nexport type ValidationChecks<T> = {\r\n    [K in keyof T]?: T[K] extends AstNode ? ValidationCheck<T[K]> | Array<ValidationCheck<T[K]>> : never\r\n} & {\r\n    AstNode?: ValidationCheck<AstNode>;\r\n}\r\n\r\n/**\r\n * `fast` checks can be executed after every document change (i.e. as the user is typing). If a check\r\n * is too slow it can delay the response to document changes, yielding bad user experience. By marking\r\n * it as `slow`, it will be skipped for normal as-you-type validation. Then it's up to you when to\r\n * schedule these long-running checks: after the fast checks are done, or after saving a document,\r\n * or with an explicit command, etc.\r\n *\r\n * `built-in` checks are errors produced by the lexer, the parser, or the linker. They cannot be used\r\n * for custom validation checks.\r\n */\r\nexport type ValidationCategory = 'fast' | 'slow' | 'built-in'\r\n\r\nexport namespace ValidationCategory {\r\n    export const all: readonly ValidationCategory[] = ['fast', 'slow', 'built-in'];\r\n}\r\n\r\ntype ValidationCheckEntry = {\r\n    check: ValidationCheck\r\n    category: ValidationCategory\r\n}\r\n\r\n/**\r\n * Manages a set of `ValidationCheck`s to be applied when documents are validated.\r\n */\r\nexport class ValidationRegistry {\r\n    private readonly entries = new MultiMap<string, ValidationCheckEntry>();\r\n    private readonly reflection: AstReflection;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n    }\r\n\r\n    /**\r\n     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)\r\n     * or an array of validation checks.\r\n     *\r\n     * @param checksRecord Set of validation checks to register.\r\n     * @param category Optional category for the validation checks (defaults to `'fast'`).\r\n     * @param thisObj Optional object to be used as `this` when calling the validation check functions.\r\n     */\r\n    register<T>(checksRecord: ValidationChecks<T>, thisObj: ThisParameterType<unknown> = this, category: ValidationCategory = 'fast'): void {\r\n        if (category === 'built-in') {\r\n            throw new Error(\"The 'built-in' category is reserved for lexer, parser, and linker errors.\");\r\n        }\r\n        for (const [type, ch] of Object.entries(checksRecord)) {\r\n            const callbacks = ch as ValidationCheck | ValidationCheck[];\r\n            if (Array.isArray(callbacks)) {\r\n                for (const check of callbacks) {\r\n                    const entry: ValidationCheckEntry = {\r\n                        check: this.wrapValidationException(check, thisObj),\r\n                        category\r\n                    };\r\n                    this.addEntry(type, entry);\r\n                }\r\n            } else if (typeof callbacks === 'function') {\r\n                const entry: ValidationCheckEntry = {\r\n                    check: this.wrapValidationException(callbacks, thisObj),\r\n                    category\r\n                };\r\n                this.addEntry(type, entry);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected wrapValidationException(check: ValidationCheck, thisObj: unknown): ValidationCheck {\r\n        return async (node, accept, cancelToken) => {\r\n            try {\r\n                await check.call(thisObj, node, accept, cancelToken);\r\n            } catch (err) {\r\n                if (isOperationCancelled(err)) {\r\n                    throw err;\r\n                }\r\n                console.error('An error occurred during validation:', err);\r\n                const message = err instanceof Error ? err.message : String(err);\r\n                if (err instanceof Error && err.stack) {\r\n                    console.error(err.stack);\r\n                }\r\n                accept('error', 'An error occurred during validation: ' + message, { node });\r\n            }\r\n        };\r\n    }\r\n\r\n    protected addEntry(type: string, entry: ValidationCheckEntry): void {\r\n        if (type === 'AstNode') {\r\n            this.entries.add('AstNode', entry);\r\n            return;\r\n        }\r\n        for (const subtype of this.reflection.getAllSubTypes(type)) {\r\n            this.entries.add(subtype, entry);\r\n        }\r\n    }\r\n\r\n    getChecks(type: string, categories?: ValidationCategory[]): Stream<ValidationCheck> {\r\n        let checks = stream(this.entries.get(type))\r\n            .concat(this.entries.get('AstNode'));\r\n        if (categories) {\r\n            checks = checks.filter(entry => categories.includes(entry.category));\r\n        }\r\n        return checks.map(entry => entry.check);\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Interface, Type, TypeDefinition } from '../../generated/ast.js';\r\nimport type { PlainAstTypes, PlainInterface, PlainProperty, PlainPropertyType, PlainUnion } from './plain-types.js';\r\nimport { isArrayType, isReferenceType, isUnionType, isSimpleType } from '../../generated/ast.js';\r\nimport { getTypeName, getTypeNameWithoutError, isPrimitiveType } from '../../internal-grammar-util.js';\r\n\r\nexport function collectDeclaredTypes(interfaces: Interface[], unions: Type[]): PlainAstTypes {\r\n    const declaredTypes: PlainAstTypes = { unions: [], interfaces: [] };\r\n\r\n    // add interfaces\r\n    for (const type of interfaces) {\r\n        const properties: PlainProperty[] = [];\r\n        for (const attribute of type.attributes) {\r\n            properties.push({\r\n                name: attribute.name,\r\n                optional: attribute.isOptional,\r\n                astNodes: new Set([attribute]),\r\n                type: typeDefinitionToPropertyType(attribute.type)\r\n            });\r\n        }\r\n        const superTypes = new Set<string>();\r\n        for (const superType of type.superTypes) {\r\n            if (superType.ref) {\r\n                superTypes.add(getTypeName(superType.ref));\r\n            }\r\n        }\r\n        const interfaceType: PlainInterface = {\r\n            name: type.name,\r\n            declared: true,\r\n            abstract: false,\r\n            properties: properties,\r\n            superTypes: superTypes,\r\n            subTypes: new Set()\r\n        };\r\n        declaredTypes.interfaces.push(interfaceType);\r\n    }\r\n\r\n    // add types\r\n    for (const union of unions) {\r\n        const unionType: PlainUnion = {\r\n            name: union.name,\r\n            declared: true,\r\n            type: typeDefinitionToPropertyType(union.type),\r\n            superTypes: new Set(),\r\n            subTypes: new Set()\r\n        };\r\n        declaredTypes.unions.push(unionType);\r\n    }\r\n\r\n    return declaredTypes;\r\n}\r\n\r\nexport function typeDefinitionToPropertyType(type: TypeDefinition): PlainPropertyType {\r\n    if (isArrayType(type)) {\r\n        return {\r\n            elementType: typeDefinitionToPropertyType(type.elementType)\r\n        };\r\n    } else if (isReferenceType(type)) {\r\n        return {\r\n            referenceType: typeDefinitionToPropertyType(type.referenceType)\r\n        };\r\n    } else if (isUnionType(type)) {\r\n        return {\r\n            types: type.types.map(typeDefinitionToPropertyType)\r\n        };\r\n    } else if (isSimpleType(type)) {\r\n        let value: string | undefined;\r\n        if (type.primitiveType) {\r\n            value = type.primitiveType;\r\n            return {\r\n                primitive: value\r\n            };\r\n        } else if (type.stringType) {\r\n            value = type.stringType;\r\n            return {\r\n                string: value\r\n            };\r\n        } else if (type.typeRef) {\r\n            const ref = type.typeRef.ref;\r\n            const value = getTypeNameWithoutError(ref);\r\n            if (value) {\r\n                if (isPrimitiveType(value)) {\r\n                    return {\r\n                        primitive: value\r\n                    };\r\n                } else {\r\n                    return {\r\n                        value\r\n                    };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return {\r\n        primitive: 'unknown'\r\n    };\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Action, Assignment, TypeAttribute } from '../../generated/ast.js';\r\nimport type { AstTypes, Property, PropertyType } from './types.js';\r\nimport { InterfaceType, UnionType } from './types.js';\r\n\r\nexport interface PlainAstTypes {\r\n    interfaces: PlainInterface[];\r\n    unions: PlainUnion[];\r\n}\r\n\r\nexport type PlainType = PlainInterface | PlainUnion;\r\n\r\nexport interface PlainInterface {\r\n    name: string;\r\n    superTypes: Set<string>;\r\n    subTypes: Set<string>;\r\n    properties: PlainProperty[];\r\n    declared: boolean;\r\n    abstract: boolean;\r\n}\r\n\r\nexport function isPlainInterface(type: PlainType): type is PlainInterface {\r\n    return !isPlainUnion(type);\r\n}\r\n\r\nexport interface PlainUnion {\r\n    name: string;\r\n    superTypes: Set<string>;\r\n    subTypes: Set<string>;\r\n    type: PlainPropertyType;\r\n    declared: boolean;\r\n    dataType?: string;\r\n}\r\n\r\nexport function isPlainUnion(type: PlainType): type is PlainUnion {\r\n    return 'type' in type;\r\n}\r\n\r\nexport interface PlainProperty {\r\n    name: string;\r\n    optional: boolean;\r\n    astNodes: Set<Assignment | Action | TypeAttribute>;\r\n    type: PlainPropertyType;\r\n}\r\n\r\nexport type PlainPropertyType =\r\n    | PlainReferenceType\r\n    | PlainArrayType\r\n    | PlainPropertyUnion\r\n    | PlainValueType\r\n    | PlainPrimitiveType\r\n    | PlainStringType;\r\n\r\nexport interface PlainReferenceType {\r\n    referenceType: PlainPropertyType;\r\n}\r\n\r\nexport function isPlainReferenceType(propertyType: PlainPropertyType): propertyType is PlainReferenceType {\r\n    return 'referenceType' in propertyType;\r\n}\r\n\r\nexport interface PlainArrayType {\r\n    elementType: PlainPropertyType;\r\n}\r\n\r\nexport function isPlainArrayType(propertyType: PlainPropertyType): propertyType is PlainArrayType {\r\n    return 'elementType' in propertyType;\r\n}\r\n\r\nexport interface PlainPropertyUnion {\r\n    types: PlainPropertyType[];\r\n}\r\n\r\nexport function isPlainPropertyUnion(propertyType: PlainPropertyType): propertyType is PlainPropertyUnion {\r\n    return 'types' in propertyType;\r\n}\r\n\r\nexport interface PlainValueType {\r\n    value: string;\r\n}\r\n\r\nexport function isPlainValueType(propertyType: PlainPropertyType): propertyType is PlainValueType {\r\n    return 'value' in propertyType;\r\n}\r\n\r\nexport interface PlainPrimitiveType {\r\n    primitive: string;\r\n    regex?: string;\r\n}\r\n\r\nexport function isPlainPrimitiveType(propertyType: PlainPropertyType): propertyType is PlainPrimitiveType {\r\n    return 'primitive' in propertyType;\r\n}\r\n\r\nexport interface PlainStringType {\r\n    string: string;\r\n}\r\n\r\nexport function isPlainStringType(propertyType: PlainPropertyType): propertyType is PlainStringType {\r\n    return 'string' in propertyType;\r\n}\r\n\r\nexport function plainToTypes(plain: PlainAstTypes): AstTypes {\r\n    const interfaceTypes = new Map<string, InterfaceType>();\r\n    const unionTypes = new Map<string, UnionType>();\r\n    for (const interfaceValue of plain.interfaces) {\r\n        const type = new InterfaceType(interfaceValue.name, interfaceValue.declared, interfaceValue.abstract);\r\n        interfaceTypes.set(interfaceValue.name, type);\r\n    }\r\n    for (const unionValue of plain.unions) {\r\n        const type = new UnionType(unionValue.name, {\r\n            declared: unionValue.declared,\r\n            dataType: unionValue.dataType\r\n        });\r\n        unionTypes.set(unionValue.name, type);\r\n    }\r\n    for (const interfaceValue of plain.interfaces) {\r\n        const type = interfaceTypes.get(interfaceValue.name)!;\r\n        for (const superTypeName of interfaceValue.superTypes) {\r\n            const superType = interfaceTypes.get(superTypeName) || unionTypes.get(superTypeName);\r\n            if (superType) {\r\n                type.superTypes.add(superType);\r\n            }\r\n        }\r\n        for (const subTypeName of interfaceValue.subTypes) {\r\n            const subType = interfaceTypes.get(subTypeName) || unionTypes.get(subTypeName);\r\n            if (subType) {\r\n                type.subTypes.add(subType);\r\n            }\r\n        }\r\n        for (const property of interfaceValue.properties) {\r\n            const prop = plainToProperty(property, interfaceTypes, unionTypes);\r\n            type.properties.push(prop);\r\n        }\r\n    }\r\n    for (const unionValue of plain.unions) {\r\n        const type = unionTypes.get(unionValue.name)!;\r\n        type.type = plainToPropertyType(unionValue.type, type, interfaceTypes, unionTypes);\r\n    }\r\n    return {\r\n        interfaces: Array.from(interfaceTypes.values()),\r\n        unions: Array.from(unionTypes.values())\r\n    };\r\n}\r\n\r\nfunction plainToProperty(property: PlainProperty, interfaces: Map<string, InterfaceType>, unions: Map<string, UnionType>): Property {\r\n    return {\r\n        name: property.name,\r\n        optional: property.optional,\r\n        astNodes: property.astNodes,\r\n        type: plainToPropertyType(property.type, undefined, interfaces, unions)\r\n    };\r\n}\r\n\r\nfunction plainToPropertyType(type: PlainPropertyType, union: UnionType | undefined, interfaces: Map<string, InterfaceType>, unions: Map<string, UnionType>): PropertyType {\r\n    if (isPlainArrayType(type)) {\r\n        return {\r\n            elementType: plainToPropertyType(type.elementType, union, interfaces, unions)\r\n        };\r\n    } else if (isPlainReferenceType(type)) {\r\n        return {\r\n            referenceType: plainToPropertyType(type.referenceType, undefined, interfaces, unions)\r\n        };\r\n    } else if (isPlainPropertyUnion(type)) {\r\n        return {\r\n            types: type.types.map(e => plainToPropertyType(e, union, interfaces, unions))\r\n        };\r\n    } else if (isPlainStringType(type)) {\r\n        return {\r\n            string: type.string\r\n        };\r\n    } else if (isPlainPrimitiveType(type)) {\r\n        return {\r\n            primitive: type.primitive,\r\n            regex: type.regex\r\n        };\r\n    } else if (isPlainValueType(type)) {\r\n        const value = interfaces.get(type.value) || unions.get(type.value);\r\n        if (!value) {\r\n            return {\r\n                primitive: 'unknown'\r\n            };\r\n        }\r\n        if (union) {\r\n            union.subTypes.add(value);\r\n        }\r\n        return {\r\n            value\r\n        };\r\n    } else {\r\n        throw new Error('Invalid property type');\r\n    }\r\n}\r\n\r\nexport function mergePropertyTypes(first: PlainPropertyType, second: PlainPropertyType): PlainPropertyType {\r\n    const flattenedFirst = flattenPlainType(first);\r\n    const flattenedSecond = flattenPlainType(second);\r\n    for (const second of flattenedSecond) {\r\n        if (!includesType(flattenedFirst, second)) {\r\n            flattenedFirst.push(second);\r\n        }\r\n    }\r\n    if (flattenedFirst.length === 1) {\r\n        return flattenedFirst[0];\r\n    } else {\r\n        return {\r\n            types: flattenedFirst\r\n        };\r\n    }\r\n}\r\n\r\nfunction includesType(list: PlainPropertyType[], value: PlainPropertyType): boolean {\r\n    return list.some(e => typeEquals(e, value));\r\n}\r\n\r\nfunction typeEquals(first: PlainPropertyType, second: PlainPropertyType): boolean {\r\n    if (isPlainArrayType(first) && isPlainArrayType(second)) {\r\n        return typeEquals(first.elementType, second.elementType);\r\n    } else if (isPlainReferenceType(first) && isPlainReferenceType(second)) {\r\n        return typeEquals(first.referenceType, second.referenceType);\r\n    } else if (isPlainValueType(first) && isPlainValueType(second)) {\r\n        return first.value === second.value;\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function flattenPlainType(type: PlainPropertyType): PlainPropertyType[] {\r\n    if (isPlainPropertyUnion(type)) {\r\n        return type.types.flatMap(e => flattenPlainType(e));\r\n    } else {\r\n        return [type];\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { NamedAstNode } from '../../references/name-provider.js';\r\nimport type { References } from '../../references/references.js';\r\nimport type { AstNode, Properties, Reference } from '../../syntax-tree.js';\r\nimport type { Stream } from '../../utils/stream.js';\r\nimport type { DiagnosticData, ValidationAcceptor, ValidationChecks } from '../../validation/validation-registry.js';\r\nimport type { LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { LangiumGrammarServices } from '../langium-grammar-module.js';\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport { DiagnosticTag } from 'vscode-languageserver-types';\r\nimport { getContainerOfType, streamAllContents } from '../../utils/ast-util.js';\r\nimport { MultiMap } from '../../utils/collections.js';\r\nimport { toDocumentSegment } from '../../utils/cst-util.js';\r\nimport { findNameAssignment, findNodeForKeyword, findNodeForProperty, getAllReachableRules } from '../../utils/grammar-util.js';\r\nimport { stream } from '../../utils/stream.js';\r\nimport { diagnosticData } from '../../validation/validation-registry.js';\r\nimport * as ast from '../generated/ast.js';\r\nimport { isParserRule, isRuleCall } from '../generated/ast.js';\r\nimport { getTypeNameWithoutError, hasDataTypeReturn, isDataTypeRule, isOptionalCardinality, isPrimitiveType, isStringType, resolveImport, resolveTransitiveImports, terminalRegex } from '../internal-grammar-util.js';\r\nimport { typeDefinitionToPropertyType } from '../type-system/type-collector/declared-types.js';\r\nimport { flattenPlainType, isPlainReferenceType } from '../type-system/type-collector/plain-types.js';\r\n\r\nexport function registerValidationChecks(services: LangiumGrammarServices): void {\r\n    const registry = services.validation.ValidationRegistry;\r\n    const validator = services.validation.LangiumGrammarValidator;\r\n    const checks: ValidationChecks<ast.LangiumGrammarAstType> = {\r\n        Action: [\r\n            validator.checkAssignmentReservedName,\r\n        ],\r\n        AbstractRule: validator.checkRuleName,\r\n        Assignment: [\r\n            validator.checkAssignmentWithFeatureName,\r\n            validator.checkAssignmentToFragmentRule,\r\n            validator.checkAssignmentTypes,\r\n            validator.checkAssignmentReservedName\r\n        ],\r\n        ParserRule: [\r\n            validator.checkParserRuleDataType,\r\n            validator.checkRuleParametersUsed,\r\n            validator.checkParserRuleReservedName,\r\n        ],\r\n        TerminalRule: [\r\n            validator.checkTerminalRuleReturnType,\r\n            validator.checkHiddenTerminalRule,\r\n            validator.checkEmptyTerminalRule\r\n        ],\r\n        InferredType: validator.checkTypeReservedName,\r\n        Keyword: validator.checkKeyword,\r\n        UnorderedGroup: validator.checkUnorderedGroup,\r\n        Grammar: [\r\n            validator.checkGrammarName,\r\n            validator.checkEntryGrammarRule,\r\n            validator.checkUniqueRuleName,\r\n            validator.checkUniqueTypeName,\r\n            validator.checkUniqueImportedRules,\r\n            validator.checkDuplicateImportedGrammar,\r\n            validator.checkGrammarHiddenTokens,\r\n            validator.checkGrammarForUnusedRules,\r\n            validator.checkGrammarTypeInfer,\r\n            validator.checkClashingTerminalNames,\r\n        ],\r\n        GrammarImport: validator.checkPackageImport,\r\n        CharacterRange: validator.checkInvalidCharacterRange,\r\n        Interface: [\r\n            validator.checkTypeReservedName,\r\n            validator.checkInterfacePropertyTypes,\r\n        ],\r\n        Type: [\r\n            validator.checkTypeReservedName,\r\n        ],\r\n        TypeAttribute: validator.checkTypeReservedName,\r\n        RuleCall: [\r\n            validator.checkUsedHiddenTerminalRule,\r\n            validator.checkUsedFragmentTerminalRule,\r\n            validator.checkRuleCallParameters,\r\n        ],\r\n        TerminalRuleCall: validator.checkUsedHiddenTerminalRule,\r\n        CrossReference: [\r\n            validator.checkCrossReferenceSyntax,\r\n            validator.checkCrossRefNameAssignment,\r\n            validator.checkCrossRefTerminalType,\r\n            validator.checkCrossRefType,\r\n            validator.checkCrossReferenceToTypeUnion\r\n        ],\r\n        SimpleType: validator.checkFragmentsInTypes,\r\n        ReferenceType: validator.checkReferenceTypeUnion,\r\n        RegexToken: [\r\n            validator.checkInvalidRegexFlags,\r\n            validator.checkDirectlyUsedRegexFlags\r\n        ]\r\n    };\r\n    registry.register(checks, validator);\r\n}\r\n\r\nexport namespace IssueCodes {\r\n    export const GrammarNameUppercase = 'grammar-name-uppercase';\r\n    export const RuleNameUppercase = 'rule-name-uppercase';\r\n    export const HiddenGrammarTokens = 'hidden-grammar-tokens';\r\n    export const UseRegexTokens = 'use-regex-tokens';\r\n    export const EntryRuleTokenSyntax = 'entry-rule-token-syntax';\r\n    export const CrossRefTokenSyntax = 'cross-ref-token-syntax';\r\n    export const UnnecessaryFileExtension = 'unnecessary-file-extension';\r\n    export const InvalidReturns = 'invalid-returns';\r\n    export const InvalidInfers = 'invalid-infers';\r\n    export const MissingInfer = 'missing-infer';\r\n    export const MissingReturns = 'missing-returns';\r\n    export const SuperfluousInfer = 'superfluous-infer';\r\n    export const OptionalUnorderedGroup = 'optional-unordered-group';\r\n}\r\n\r\nexport class LangiumGrammarValidator {\r\n\r\n    protected readonly references: References;\r\n    protected readonly documents: LangiumDocuments;\r\n\r\n    constructor(services: LangiumGrammarServices) {\r\n        this.references = services.references.References;\r\n        this.documents = services.shared.workspace.LangiumDocuments;\r\n    }\r\n\r\n    checkGrammarName(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        if (grammar.name) {\r\n            const firstChar = grammar.name.substring(0, 1);\r\n            if (firstChar.toUpperCase() !== firstChar) {\r\n                accept('warning', 'Grammar name should start with an upper case letter.', {\r\n                    node: grammar,\r\n                    property: 'name',\r\n                    data: diagnosticData(IssueCodes.GrammarNameUppercase)\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkEntryGrammarRule(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        if (grammar.isDeclared && !grammar.name) {\r\n            // Incomplete syntax: grammar without a name.\r\n            return;\r\n        }\r\n        const entryRules = grammar.rules.filter(e => ast.isParserRule(e) && e.entry) as ast.ParserRule[];\r\n        if (grammar.isDeclared && entryRules.length === 0) {\r\n            const possibleEntryRule = grammar.rules.find(e => ast.isParserRule(e) && !isDataTypeRule(e));\r\n            if (possibleEntryRule) {\r\n                accept('error', 'The grammar is missing an entry parser rule. This rule can be an entry one.', {\r\n                    node: possibleEntryRule,\r\n                    property: 'name',\r\n                    data: diagnosticData(IssueCodes.EntryRuleTokenSyntax)\r\n                });\r\n            } else {\r\n                accept('error', 'This grammar is missing an entry parser rule.', { node: grammar, property: 'name' });\r\n            }\r\n        } else if (!grammar.isDeclared && entryRules.length >= 1) {\r\n            entryRules.forEach(rule => accept('error', 'Cannot declare entry rules for unnamed grammars.', { node: rule, property: 'name' }));\r\n        } else if (entryRules.length > 1) {\r\n            entryRules.forEach(rule => accept('error', 'The entry rule has to be unique.', { node: rule, property: 'name' }));\r\n        } else if (entryRules.length === 1 && isDataTypeRule(entryRules[0])) {\r\n            accept('error', 'The entry rule cannot be a data type rule.', { node: entryRules[0], property: 'name' });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check whether any rule defined in this grammar is a duplicate of an already defined rule or an imported rule\r\n     */\r\n    checkUniqueRuleName(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const extractor = (grammar: ast.Grammar) => stream(grammar.rules).filter(rule => !isEmptyRule(rule));\r\n        this.checkUniqueName(grammar, accept, extractor, 'rule');\r\n    }\r\n\r\n    /**\r\n     * Check whether any type defined in this grammar is a duplicate of an already defined type or an imported type\r\n     */\r\n    checkUniqueTypeName(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const extractor = (grammar: ast.Grammar) => stream(grammar.types).concat(grammar.interfaces);\r\n        this.checkUniqueName(grammar, accept, extractor, 'type');\r\n    }\r\n\r\n    private checkUniqueName(grammar: ast.Grammar, accept: ValidationAcceptor, extractor: (grammar: ast.Grammar) => Stream<NamedAstNode>, uniqueObjName: string): void {\r\n        const map = new MultiMap<string, { name: string } & AstNode>();\r\n        extractor(grammar).forEach(e => map.add(e.name, e));\r\n\r\n        for (const [, types] of map.entriesGroupedByKey()) {\r\n            if (types.length > 1) {\r\n                types.forEach(e => {\r\n                    accept('error', `A ${uniqueObjName}'s name has to be unique.`, { node: e, property: 'name' });\r\n                });\r\n            }\r\n        }\r\n        const imported = new Set<string>();\r\n        const resolvedGrammars = resolveTransitiveImports(this.documents, grammar);\r\n        for (const resolvedGrammar of resolvedGrammars) {\r\n            extractor(resolvedGrammar).forEach(e => imported.add(e.name));\r\n        }\r\n        for (const name of map.keys()) {\r\n            if (imported.has(name)) {\r\n                const types = map.get(name);\r\n                types.forEach(e => {\r\n                    accept('error', `A ${uniqueObjName} with the name '${e.name}' already exists in an imported grammar.`, { node: e, property: 'name' });\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkDuplicateImportedGrammar(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const importMap = new MultiMap<ast.Grammar, ast.GrammarImport>();\r\n        for (const imp of grammar.imports) {\r\n            const resolvedGrammar = resolveImport(this.documents, imp);\r\n            if (resolvedGrammar) {\r\n                importMap.add(resolvedGrammar, imp);\r\n            }\r\n        }\r\n        for (const [, imports] of importMap.entriesGroupedByKey()) {\r\n            if (imports.length > 1) {\r\n                imports.forEach((imp, i) => {\r\n                    if (i > 0) {\r\n                        accept('warning', 'The grammar is already being directly imported.', { node: imp, tags: [DiagnosticTag.Unnecessary] });\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compared to the validation above, this validation only checks whether two imported grammars export the same grammar rule.\r\n     */\r\n    checkUniqueImportedRules(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const imports = new Map<ast.GrammarImport, ast.Grammar[]>();\r\n        for (const imp of grammar.imports) {\r\n            const importedGrammars = resolveTransitiveImports(this.documents, imp);\r\n            imports.set(imp, importedGrammars);\r\n        }\r\n        const allDuplicates = new MultiMap<ast.GrammarImport, string>();\r\n        for (const outerImport of grammar.imports) {\r\n            const outerGrammars = imports.get(outerImport)!;\r\n            for (const innerImport of grammar.imports) {\r\n                if (outerImport === innerImport) {\r\n                    continue;\r\n                }\r\n                const innerGrammars = imports.get(innerImport)!;\r\n                const duplicates = this.getDuplicateExportedRules(outerGrammars, innerGrammars);\r\n                for (const duplicate of duplicates) {\r\n                    allDuplicates.add(outerImport, duplicate);\r\n                }\r\n            }\r\n        }\r\n        for (const imp of grammar.imports) {\r\n            const duplicates = allDuplicates.get(imp);\r\n            if (duplicates.length > 0) {\r\n                accept('error', 'Some rules exported by this grammar are also included in other imports: ' + stream(duplicates).distinct().join(', '), { node: imp, property: 'path' });\r\n            }\r\n        }\r\n    }\r\n\r\n    private getDuplicateExportedRules(outer: ast.Grammar[], inner: ast.Grammar[]): Set<string> {\r\n        const exclusiveOuter = outer.filter(g => !inner.includes(g));\r\n        const outerRules = exclusiveOuter.flatMap(e => e.rules);\r\n        const innerRules = inner.flatMap(e => e.rules);\r\n        const duplicates = new Set<string>();\r\n        for (const outerRule of outerRules) {\r\n            const outerName = outerRule.name;\r\n            for (const innerRule of innerRules) {\r\n                const innerName = innerRule.name;\r\n                if (outerName === innerName) {\r\n                    duplicates.add(innerRule.name);\r\n                }\r\n            }\r\n        }\r\n        return duplicates;\r\n    }\r\n\r\n    checkGrammarTypeInfer(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const types = new Set<string>();\r\n        for (const type of grammar.types) {\r\n            types.add(type.name);\r\n        }\r\n        for (const interfaceType of grammar.interfaces) {\r\n            types.add(interfaceType.name);\r\n        }\r\n        // Collect type/interface definitions from imported grammars\r\n        for (const importedGrammar of resolveTransitiveImports(this.documents, grammar)) {\r\n            importedGrammar.types.forEach(type => types.add(type.name));\r\n            importedGrammar.interfaces.forEach(iface => types.add(iface.name));\r\n        }\r\n\r\n        for (const rule of grammar.rules.filter(ast.isParserRule)) {\r\n            if (isEmptyRule(rule)) {\r\n                continue;\r\n            }\r\n\r\n            const isDataType = isDataTypeRule(rule);\r\n            const isInfers = !rule.returnType && !rule.dataType;\r\n            const ruleTypeName = getTypeNameWithoutError(rule);\r\n            if (!isDataType && ruleTypeName && types.has(ruleTypeName) === isInfers) {\r\n                if ((isInfers || rule.returnType?.ref !== undefined) && rule.inferredType === undefined) {\r\n                    // report missing returns (a type of the same name is declared)\r\n                    accept('error', getMessage(ruleTypeName, isInfers), {\r\n                        node: rule,\r\n                        property: 'name',\r\n                        data: diagnosticData(IssueCodes.MissingReturns)\r\n                    });\r\n                } else if (isInfers || rule.returnType?.ref !== undefined) {\r\n                    // report bad infers (should be corrected to 'returns' to match existing type)\r\n                    const infersNode = findNodeForKeyword(rule.inferredType!.$cstNode, 'infers');\r\n                    accept('error', getMessage(ruleTypeName, isInfers), {\r\n                        node: rule.inferredType!,\r\n                        property: 'name',\r\n                        data: {\r\n                            code: IssueCodes.InvalidInfers,\r\n                            actionSegment: toDocumentSegment(infersNode)\r\n                        } satisfies DiagnosticData\r\n                    });\r\n                }\r\n            } else if (isDataType && isInfers) {\r\n                const inferNode = findNodeForKeyword(rule.$cstNode, 'infer');\r\n                accept('error', 'Data type rules cannot infer a type.', {\r\n                    node: rule,\r\n                    property: 'inferredType',\r\n                    data: {\r\n                        code: IssueCodes.InvalidInfers,\r\n                        actionSegment: toDocumentSegment(inferNode)\r\n                    } satisfies DiagnosticData\r\n                });\r\n            }\r\n        }\r\n        for (const action of streamAllContents(grammar).filter(ast.isAction)) {\r\n            const actionType = this.getActionType(action);\r\n            if (actionType) {\r\n                const isInfers = Boolean(action.inferredType);\r\n                const typeName = getTypeNameWithoutError(action);\r\n                if (action.type && typeName && types.has(typeName) === isInfers) {\r\n                    const keywordNode = isInfers ? findNodeForKeyword(action.$cstNode, 'infer') : findNodeForKeyword(action.$cstNode, '{');\r\n                    accept('error', getMessage(typeName, isInfers), {\r\n                        node: action,\r\n                        property: 'type',\r\n                        data: {\r\n                            code: isInfers ? IssueCodes.SuperfluousInfer : IssueCodes.MissingInfer,\r\n                            actionSegment: toDocumentSegment(keywordNode)\r\n                        } satisfies DiagnosticData\r\n                    });\r\n                } else if (actionType && typeName && types.has(typeName) && isInfers) {\r\n                    // error: action infers type that is already defined\r\n                    if (action.$cstNode) {\r\n                        const inferredTypeNode = findNodeForProperty(action.inferredType?.$cstNode, 'name');\r\n                        const keywordNode = findNodeForKeyword(action.$cstNode, '{');\r\n                        if (inferredTypeNode && keywordNode) {\r\n                            // remove everything from the opening { up to the type name\r\n                            // we may lose comments in-between, but this can be undone as needed\r\n                            accept('error', `${typeName} is a declared type and cannot be redefined.`, {\r\n                                node: action,\r\n                                property: 'type',\r\n                                data: {\r\n                                    code: IssueCodes.SuperfluousInfer,\r\n                                    actionRange: {\r\n                                        start: keywordNode.range.end,\r\n                                        end: inferredTypeNode.range.start\r\n                                    }\r\n                                } satisfies DiagnosticData\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        function getMessage(name: string, infer: boolean) {\r\n            if (infer) {\r\n                return `The type '${name}' is already explicitly declared and cannot be inferred.`;\r\n            } else {\r\n                return `The type '${name}' is not explicitly declared and must be inferred.`;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getActionType(rule: ast.Action): ast.AbstractType | ast.InferredType | undefined {\r\n        if (rule.type) {\r\n            return rule.type?.ref;\r\n        } else if (rule.inferredType) {\r\n            return rule.inferredType;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    checkGrammarHiddenTokens(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        if (grammar.definesHiddenTokens) {\r\n            accept('error', 'Hidden terminals are declared at the terminal definition.', {\r\n                node: grammar,\r\n                property: 'definesHiddenTokens',\r\n                data: diagnosticData(IssueCodes.HiddenGrammarTokens)\r\n            });\r\n        }\r\n    }\r\n\r\n    checkHiddenTerminalRule(terminalRule: ast.TerminalRule, accept: ValidationAcceptor): void {\r\n        if (terminalRule.hidden && terminalRule.fragment) {\r\n            accept('error', 'Cannot use terminal fragments as hidden tokens.', { node: terminalRule, property: 'hidden' });\r\n        }\r\n    }\r\n\r\n    checkEmptyTerminalRule(terminalRule: ast.TerminalRule, accept: ValidationAcceptor): void {\r\n        try {\r\n            const regex = terminalRegex(terminalRule);\r\n            if (new RegExp(regex).test('')) {\r\n                accept('error', 'This terminal could match an empty string.', { node: terminalRule, property: 'name' });\r\n            }\r\n        } catch {\r\n            // In case the terminal can't be transformed into a regex, we throw an error\r\n            // As this indicates unresolved cross references or parser errors, we can ignore this here\r\n        }\r\n    }\r\n\r\n    checkInvalidRegexFlags(token: ast.RegexToken, accept: ValidationAcceptor): void {\r\n        const regex = token.regex;\r\n        if (regex) {\r\n            const slashIndex = regex.lastIndexOf('/');\r\n            const flags = regex.substring(slashIndex + 1);\r\n            // global/multiline/sticky are valid, but not supported\r\n            const unsupportedFlags = 'gmy';\r\n            // only case-insensitive/dotall/unicode are really supported\r\n            const supportedFlags = 'isu';\r\n            const allFlags = unsupportedFlags + supportedFlags;\r\n            const errorFlags = new Set<string>();\r\n            const warningFlags = new Set<string>();\r\n            for (let i = 0; i < flags.length; i++) {\r\n                const flag = flags.charAt(i);\r\n                if (!allFlags.includes(flag)) {\r\n                    errorFlags.add(flag);\r\n                } else if (unsupportedFlags.includes(flag)) {\r\n                    warningFlags.add(flag);\r\n                }\r\n            }\r\n            const range = this.getFlagRange(token);\r\n            if (range) {\r\n                if (errorFlags.size > 0) {\r\n                    accept('error', `'${Array.from(errorFlags).join('')}' ${errorFlags.size > 1 ? 'are' : 'is'} not valid regular expression flag${errorFlags.size > 1 ? 's' : ''}.`, {\r\n                        node: token,\r\n                        range\r\n                    });\r\n                } else if (warningFlags.size > 0) {\r\n                    accept('warning', `'${Array.from(warningFlags).join('')}' regular expression flag${warningFlags.size > 1 ? 's' : ''} will be ignored by Langium.`, {\r\n                        node: token,\r\n                        range\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    checkDirectlyUsedRegexFlags(token: ast.RegexToken, accept: ValidationAcceptor): void {\r\n        if (!ast.isTerminalRule(token.$container)) {\r\n            const range = this.getFlagRange(token);\r\n            if (range) {\r\n                accept('warning', 'Regular expression flags are only applied if the terminal is not a composition', {\r\n                    node: token,\r\n                    range\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    private getFlagRange(token: ast.RegexToken): Range | undefined {\r\n        const regexCstNode = findNodeForProperty(token.$cstNode, 'regex');\r\n        if (!regexCstNode || !token.regex) {\r\n            return undefined;\r\n        }\r\n        const regex = token.regex;\r\n        const slashIndex = regex.lastIndexOf('/') + 1;\r\n        const range: Range = {\r\n            start: {\r\n                line: regexCstNode.range.end.line,\r\n                character: regexCstNode.range.end.character - regex.length + slashIndex\r\n            },\r\n            end: regexCstNode.range.end\r\n        };\r\n        return range;\r\n    }\r\n\r\n    checkUsedHiddenTerminalRule(ruleCall: ast.RuleCall | ast.TerminalRuleCall, accept: ValidationAcceptor): void {\r\n        const parentRule = getContainerOfType(ruleCall, (n): n is ast.TerminalRule | ast.ParserRule => ast.isTerminalRule(n) || ast.isParserRule(n));\r\n        if (parentRule) {\r\n            if ('hidden' in parentRule && parentRule.hidden) {\r\n                return;\r\n            }\r\n            const ref = ruleCall.rule.ref;\r\n            if (ast.isTerminalRule(ref) && ref.hidden) {\r\n                accept('error', 'Cannot use hidden terminal in non-hidden rule', { node: ruleCall, property: 'rule' });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkUsedFragmentTerminalRule(ruleCall: ast.RuleCall, accept: ValidationAcceptor): void {\r\n        const terminal = ruleCall.rule.ref;\r\n        if (ast.isTerminalRule(terminal) && terminal.fragment) {\r\n            const parentRule = getContainerOfType(ruleCall, ast.isParserRule);\r\n            if (parentRule) {\r\n                accept('error', 'Cannot use terminal fragments as part of parser rules.', { node: ruleCall, property: 'rule' });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkCrossReferenceSyntax(crossRef: ast.CrossReference, accept: ValidationAcceptor): void {\r\n        if (crossRef.deprecatedSyntax) {\r\n            accept('error', \"'|' is deprecated. Please, use ':' instead.\", {\r\n                node: crossRef,\r\n                property: 'deprecatedSyntax',\r\n                data: diagnosticData(IssueCodes.CrossRefTokenSyntax)\r\n            });\r\n        }\r\n    }\r\n\r\n    checkPackageImport(imp: ast.GrammarImport, accept: ValidationAcceptor): void {\r\n        const resolvedGrammar = resolveImport(this.documents, imp);\r\n        if (resolvedGrammar === undefined) {\r\n            accept('error', 'Import cannot be resolved.', { node: imp, property: 'path' });\r\n        } else if (imp.path.endsWith('.langium')) {\r\n            accept('warning', 'Imports do not need file extensions.', {\r\n                node: imp,\r\n                property: 'path',\r\n                data: diagnosticData(IssueCodes.UnnecessaryFileExtension)\r\n            });\r\n        }\r\n    }\r\n\r\n    checkInvalidCharacterRange(range: ast.CharacterRange, accept: ValidationAcceptor): void {\r\n        if (range.right) {\r\n            const message = 'Character ranges cannot use more than one character';\r\n            let invalid = false;\r\n            if (range.left.value.length > 1) {\r\n                invalid = true;\r\n                accept('error', message, { node: range.left, property: 'value' });\r\n            }\r\n            if (range.right.value.length > 1) {\r\n                invalid = true;\r\n                accept('error', message, { node: range.right, property: 'value' });\r\n            }\r\n            if (!invalid) {\r\n                accept('hint', 'Consider using regex instead of character ranges', {\r\n                    node: range,\r\n                    data: diagnosticData(IssueCodes.UseRegexTokens)\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkGrammarForUnusedRules(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const reachableRules = getAllReachableRules(grammar, true);\r\n\r\n        for (const rule of grammar.rules) {\r\n            if (ast.isTerminalRule(rule) && rule.hidden || isEmptyRule(rule)) {\r\n                continue;\r\n            }\r\n            if (!reachableRules.has(rule)) {\r\n                accept('hint', 'This rule is declared but never referenced.', {\r\n                    node: rule,\r\n                    property: 'name',\r\n                    tags: [DiagnosticTag.Unnecessary]\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkClashingTerminalNames(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const localTerminals = new MultiMap<string, ast.TerminalRule>();\r\n        const localKeywords = new Set<string>();\r\n\r\n        // Collect locally defined terminals/keywords\r\n        for (const rule of grammar.rules) {\r\n            if (ast.isTerminalRule(rule) && rule.name) {\r\n                localTerminals.add(rule.name, rule);\r\n            }\r\n            if (ast.isParserRule(rule)) {\r\n                const keywords = streamAllContents(rule).filter(ast.isKeyword);\r\n                keywords.forEach(e => localKeywords.add(e.value));\r\n            }\r\n        }\r\n\r\n        // Collect imported terminals/keywords and their respectives imports\r\n        const importedTerminals = new MultiMap<string, ast.GrammarImport>();\r\n        const importedKeywords = new MultiMap<string, ast.GrammarImport>();\r\n\r\n        for (const importNode of grammar.imports) {\r\n            const importedGrammars = resolveTransitiveImports(this.documents, importNode);\r\n            for (const importedGrammar of importedGrammars) {\r\n                for (const rule of importedGrammar.rules) {\r\n                    if (ast.isTerminalRule(rule) && rule.name) {\r\n                        importedTerminals.add(rule.name, importNode);\r\n                    } else if (ast.isParserRule(rule) && rule.name) {\r\n                        const keywords = streamAllContents(rule).filter(ast.isKeyword);\r\n                        keywords.forEach(e => importedKeywords.add(e.value, importNode));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const localTerminal of localTerminals.values()) {\r\n            if (localKeywords.has(localTerminal.name)) {\r\n                // 1st case: Local terminal with local keyword (error on terminal)\r\n                accept('error', 'Terminal name clashes with existing keyword.', {\r\n                    node: localTerminal,\r\n                    property: 'name'\r\n                });\r\n            } else if (importedKeywords.has(localTerminal.name)) {\r\n                const importNode = importedKeywords.get(localTerminal.name)!;\r\n                // 2nd case: Local terminal with imported keyword (error on terminal)\r\n                accept('error', `Terminal name clashes with imported keyword from \"${importNode[0].path}\".`, {\r\n                    node: localTerminal,\r\n                    property: 'name'\r\n                });\r\n            }\r\n        }\r\n\r\n        // Collect all imported terminals that share a name with a local keyword\r\n        const importTerminalMap = new MultiMap<ast.GrammarImport, string>();\r\n        for (const localKeyword of localKeywords) {\r\n            for (const importNode of importedTerminals.get(localKeyword)) {\r\n                importTerminalMap.add(importNode, localKeyword);\r\n            }\r\n        }\r\n\r\n        for (const [importNode, keywords] of importTerminalMap.entriesGroupedByKey()) {\r\n            if (keywords.length > 0) {\r\n                // 3rd case: Imported terminal with local keyword (error on import)\r\n                accept('error', `Imported terminals (${keywords.join(', ')}) clash with locally defined keywords.`, {\r\n                    node: importNode,\r\n                    property: 'path'\r\n                });\r\n            }\r\n        }\r\n\r\n        // Collect all imported terminals that share a name with imported keywords\r\n        const importKeywordMap = new MultiMap<ast.GrammarImport, string>();\r\n        for (const [name, imports] of importedTerminals.entriesGroupedByKey()) {\r\n            const keywordImports = importedKeywords.get(name);\r\n            if (keywordImports.length > 0) {\r\n                imports\r\n                    // Exclude transitive keyword/terminal clashing\r\n                    // These errors are already shown in another file\r\n                    // So no need to validate these again here\r\n                    .filter(e => !keywordImports.includes(e))\r\n                    .forEach(e => importKeywordMap.add(e, name));\r\n            }\r\n        }\r\n\r\n        for (const [importNode, keywords] of importKeywordMap.entriesGroupedByKey()) {\r\n            if (keywords.length > 0) {\r\n                // 4th case: Imported terminal with imported keyword (error on import)\r\n                accept('error', `Imported terminals (${keywords.join(', ')}) clash with imported keywords.`, {\r\n                    node: importNode,\r\n                    property: 'path'\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkRuleName(rule: ast.AbstractRule, accept: ValidationAcceptor): void {\r\n        if (rule.name && !isEmptyRule(rule)) {\r\n            const firstChar = rule.name.substring(0, 1);\r\n            if (firstChar.toUpperCase() !== firstChar) {\r\n                accept('warning', 'Rule name should start with an upper case letter.', {\r\n                    node: rule,\r\n                    property: 'name',\r\n                    data: diagnosticData(IssueCodes.RuleNameUppercase)\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkTypeReservedName(type: ast.Interface | ast.TypeAttribute | ast.Type | ast.InferredType, accept: ValidationAcceptor): void {\r\n        this.checkReservedName(type, 'name', accept);\r\n    }\r\n\r\n    checkAssignmentReservedName(assignment: ast.Assignment | ast.Action, accept: ValidationAcceptor): void {\r\n        this.checkReservedName(assignment, 'feature', accept);\r\n    }\r\n\r\n    checkParserRuleReservedName(rule: ast.ParserRule, accept: ValidationAcceptor): void {\r\n        if (!rule.inferredType) {\r\n            this.checkReservedName(rule, 'name', accept);\r\n        }\r\n    }\r\n\r\n    private checkReservedName<N extends AstNode>(node: N, property: Properties<N>, accept: ValidationAcceptor): void {\r\n        const name = node[property as keyof N];\r\n        if (typeof name === 'string' && reservedNames.has(name)) {\r\n            accept('error', `'${name}' is a reserved name of the JavaScript runtime.`, {\r\n                node,\r\n                property\r\n            });\r\n        }\r\n    }\r\n\r\n    checkKeyword(keyword: ast.Keyword, accept: ValidationAcceptor): void {\r\n        if (getContainerOfType(keyword, isParserRule)) {\r\n            if (keyword.value.length === 0) {\r\n                accept('error', 'Keywords cannot be empty.', { node: keyword });\r\n            } else if (keyword.value.trim().length === 0) {\r\n                accept('error', 'Keywords cannot only consist of whitespace characters.', { node: keyword });\r\n            } else if (/\\s/g.test(keyword.value)) {\r\n                accept('warning', 'Keywords should not contain whitespace characters.', { node: keyword });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkUnorderedGroup(unorderedGroup: ast.UnorderedGroup, accept: ValidationAcceptor): void {\r\n        unorderedGroup.elements.forEach((ele) => {\r\n            if (isOptionalCardinality(ele.cardinality)) {\r\n                accept('error', 'Optional elements in Unordered groups are currently not supported', {\r\n                    node: ele,\r\n                    data: diagnosticData(IssueCodes.OptionalUnorderedGroup)\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    checkRuleParametersUsed(rule: ast.ParserRule, accept: ValidationAcceptor): void {\r\n        const parameters = rule.parameters;\r\n        if (parameters.length > 0) {\r\n            const allReferences = streamAllContents(rule).filter(ast.isParameterReference);\r\n            for (const parameter of parameters) {\r\n                if (!allReferences.some(e => e.parameter.ref === parameter)) {\r\n                    accept('hint', `Parameter '${parameter.name}' is unused.`, {\r\n                        node: parameter,\r\n                        tags: [DiagnosticTag.Unnecessary]\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    checkParserRuleDataType(rule: ast.ParserRule, accept: ValidationAcceptor): void {\r\n        if (isEmptyRule(rule)) {\r\n            return;\r\n        }\r\n        const hasDatatypeReturnType = hasDataTypeReturn(rule);\r\n        const dataTypeRule = isDataTypeRule(rule);\r\n        if (!hasDatatypeReturnType && dataTypeRule) {\r\n            accept('error', 'This parser rule does not create an object. Add a primitive return type or an action to the start of the rule to force object instantiation.', { node: rule, property: 'name' });\r\n        } else if (hasDatatypeReturnType && !dataTypeRule) {\r\n            accept('error', 'Normal parser rules are not allowed to return a primitive value. Use a datatype rule for that.', { node: rule, property: rule.dataType ? 'dataType' : 'returnType' });\r\n        }\r\n    }\r\n\r\n    checkAssignmentToFragmentRule(assignment: ast.Assignment, accept: ValidationAcceptor): void {\r\n        if (!assignment.terminal) {\r\n            return;\r\n        }\r\n        if (isRuleCall(assignment.terminal) && isParserRule(assignment.terminal.rule.ref) && assignment.terminal.rule.ref.fragment) {\r\n            accept('error', `Cannot use fragment rule '${assignment.terminal.rule.ref.name}' for assignment of property '${assignment.feature}'.`, { node: assignment, property: 'terminal' });\r\n        }\r\n    }\r\n\r\n    checkAssignmentTypes(assignment: ast.Assignment, accept: ValidationAcceptor): void {\r\n        if (!assignment.terminal) {\r\n            return;\r\n        }\r\n        let firstType: 'ref' | 'other';\r\n        const foundMixed = streamAllContents(assignment.terminal)\r\n            .map(node => ast.isCrossReference(node) ? 'ref' : 'other')\r\n            .find(type => {\r\n                if (!firstType) {\r\n                    firstType = type;\r\n                    return false;\r\n                }\r\n                return type !== firstType;\r\n            });\r\n        if (foundMixed) {\r\n            accept(\r\n                'error',\r\n                this.createMixedTypeError(assignment.feature),\r\n                {\r\n                    node: assignment,\r\n                    property: 'terminal'\r\n                }\r\n            );\r\n        }\r\n    }\r\n\r\n    checkInterfacePropertyTypes(interfaceDecl: ast.Interface, accept: ValidationAcceptor): void {\r\n        for (const attribute of interfaceDecl.attributes) {\r\n            if (attribute.type) {\r\n                const plainType = typeDefinitionToPropertyType(attribute.type);\r\n                const flattened = flattenPlainType(plainType);\r\n                let hasRef = false;\r\n                let hasNonRef = false;\r\n                for (const flat of flattened) {\r\n                    if (isPlainReferenceType(flat)) {\r\n                        hasRef = true;\r\n                    } else if (!isPlainReferenceType(flat)) {\r\n                        hasNonRef = true;\r\n                    }\r\n                }\r\n                if (hasRef && hasNonRef) {\r\n                    accept(\r\n                        'error',\r\n                        this.createMixedTypeError(attribute.name),\r\n                        {\r\n                            node: attribute,\r\n                            property: 'type'\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected createMixedTypeError(propName: string) {\r\n        return `Mixing a cross-reference with other types is not supported. Consider splitting property \"${propName}\" into two or more different properties.`;\r\n    }\r\n\r\n    checkTerminalRuleReturnType(rule: ast.TerminalRule, accept: ValidationAcceptor): void {\r\n        if (rule.type?.name && !isPrimitiveType(rule.type.name)) {\r\n            accept('error', \"Terminal rules can only return primitive types like 'string', 'boolean', 'number', 'Date' or 'bigint'.\", { node: rule.type, property: 'name' });\r\n        }\r\n    }\r\n\r\n    checkRuleCallParameters(ruleCall: ast.RuleCall, accept: ValidationAcceptor): void {\r\n        const rule = ruleCall.rule.ref;\r\n        if (ast.isParserRule(rule)) {\r\n            const expected = rule.parameters.length;\r\n            const given = ruleCall.arguments.length;\r\n            if (expected !== given) {\r\n                accept('error', `Rule '${rule.name}' expects ${expected} arguments, but got ${given}.`, { node: ruleCall });\r\n            }\r\n        } else if (ast.isTerminalRule(rule) && ruleCall.arguments.length > 0) {\r\n            accept('error', 'Terminal rules do not accept any arguments', { node: ruleCall });\r\n        }\r\n    }\r\n\r\n    checkCrossRefNameAssignment(reference: ast.CrossReference, accept: ValidationAcceptor): void {\r\n        if (!reference.terminal && reference.type.ref && !findNameAssignment(reference.type.ref)) {\r\n            accept('error', 'Cannot infer terminal or data type rule for cross-reference.', { node: reference, property: 'type' });\r\n        }\r\n    }\r\n\r\n    checkCrossRefTerminalType(reference: ast.CrossReference, accept: ValidationAcceptor): void {\r\n        const refTerminal = reference.terminal;\r\n        if (ast.isRuleCall(refTerminal)) {\r\n            const rule = refTerminal.rule.ref;\r\n            if (ast.isParserRule(rule) && !isDataTypeRule(rule)) {\r\n                accept('error', 'Parser rules cannot be used for cross-references.', { node: refTerminal, property: 'rule' });\r\n            } else if (ast.isParserRule(rule) && !isStringType(rule)) {\r\n                accept('error', 'Data type rules for cross-references must be of type string.', { node: refTerminal, property: 'rule' });\r\n            } else if (ast.isTerminalRule(rule) && rule.type?.name && rule.type.name !== 'string') {\r\n                accept('error', 'Terminal rules for cross-references must be of type string.', { node: refTerminal, property: 'rule' });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkCrossRefType(reference: ast.CrossReference, accept: ValidationAcceptor): void {\r\n        const issue = this.checkReferenceToRuleButNotType(reference?.type);\r\n        if (issue) {\r\n            accept('error', issue, { node: reference, property: 'type' });\r\n        }\r\n    }\r\n\r\n    checkCrossReferenceToTypeUnion(reference: ast.CrossReference, accept: ValidationAcceptor): void {\r\n        if (ast.isType(reference.type.ref) && ast.isUnionType(reference.type.ref.type)) {\r\n            const errors = checkTypeUnionContainsOnlyParseRules(reference.type.ref.type);\r\n            if (errors.length > 0) {\r\n                accept('error', `Cross-reference on type union is only valid if all alternatives are AST nodes. ${errors.join(', ')} ${errors.length > 1 ? 'are' : 'is'} not ${errors.length > 1 ? '' : 'an '}AST node${errors.length > 1 ? 's':''}.`, { node: reference, property: 'type' });\r\n            }\r\n        }\r\n    }\r\n\r\n    checkFragmentsInTypes(type: ast.SimpleType, accept: ValidationAcceptor): void {\r\n        if (ast.isParserRule(type.typeRef?.ref) && type.typeRef?.ref.fragment) {\r\n            accept('error', 'Cannot use rule fragments in types.', { node: type, property: 'typeRef' });\r\n        }\r\n    }\r\n\r\n    checkReferenceTypeUnion(type: ast.ReferenceType, accept: ValidationAcceptor): void {\r\n        if (!ast.isSimpleType(type.referenceType)) {\r\n            accept('error', 'Only direct rule references are allowed in reference types.', { node: type, property: 'referenceType' });\r\n        }\r\n    }\r\n\r\n    protected checkReferenceToRuleButNotType(type: Reference<ast.AbstractType>): string | undefined {\r\n        if (type && ast.isParserRule(type.ref) && !isDataTypeRule(type.ref) && (type.ref.returnType || type.ref.inferredType)) {\r\n            const typeName = getTypeNameWithoutError(type.ref);\r\n            if (typeName) {\r\n                return `Use the rule type '${typeName}' instead of the typed rule name '${type.ref.name}' for cross-references.`;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    checkAssignmentWithFeatureName(assignment: ast.Assignment, accept: ValidationAcceptor): void {\r\n        if (assignment.feature === 'name' && ast.isCrossReference(assignment.terminal)) {\r\n            accept('warning', 'The \"name\" property is not recommended for cross-references.', { node: assignment, property: 'feature' });\r\n        }\r\n    }\r\n}\r\n\r\nfunction isEmptyRule(rule: ast.AbstractRule): boolean {\r\n    return !rule.definition || !rule.definition.$cstNode || rule.definition.$cstNode.length === 0;\r\n}\r\n\r\nconst reservedNames = new Set([\r\n    // Built-in objects, properties and methods\r\n    // Collections\r\n    'Array',\r\n    'Int8Array',\r\n    'Uint8Array',\r\n    'Uint8ClampedArray',\r\n    'Int16Array',\r\n    'Uint16Array',\r\n    'Int32Array',\r\n    'Uint32Array',\r\n    'Float32Array',\r\n    'Float64Array',\r\n    'BigInt64Array',\r\n    'BigUint64Array',\r\n    // Keyed collections\r\n    'Map',\r\n    'Set',\r\n    'WeakMap',\r\n    'WeakSet',\r\n    // Errors\r\n    'Error',\r\n    'AggregateError',\r\n    'EvalError',\r\n    'InternalError',\r\n    'RangeError',\r\n    'ReferenceError',\r\n    'SyntaxError',\r\n    'TypeError',\r\n    'URIError',\r\n    // Primitives\r\n    'BigInt',\r\n    'RegExp',\r\n    'Number',\r\n    'Object',\r\n    'Function',\r\n    'Symbol',\r\n    'String',\r\n    // Math\r\n    'Math',\r\n    'NaN',\r\n    'Infinity',\r\n    'isFinite',\r\n    'isNaN',\r\n    // Structured data\r\n    'Buffer',\r\n    'ArrayBuffer',\r\n    'SharedArrayBuffer',\r\n    'Atomics',\r\n    'DataView',\r\n    'JSON',\r\n    'globalThis',\r\n    'decodeURIComponent',\r\n    'decodeURI',\r\n    'encodeURIComponent',\r\n    'encodeURI',\r\n    'parseInt',\r\n    'parseFloat',\r\n    // Control abstraction\r\n    'Promise',\r\n    'Generator',\r\n    'GeneratorFunction',\r\n    'AsyncFunction',\r\n    'AsyncGenerator',\r\n    'AsyncGeneratorFunction',\r\n    // Reflection\r\n    'Reflect',\r\n    'Proxy',\r\n    // Others\r\n    'Date',\r\n    'Intl',\r\n    'eval',\r\n    'undefined'\r\n]);\r\n\r\nfunction checkTypeUnionContainsOnlyParseRules(type: ast.UnionType): string[] {\r\n    const errors: string[] = [];\r\n    type.types.forEach(type => {\r\n        if (ast.isSimpleType(type)) {\r\n            if (type.typeRef?.ref) {\r\n                if(ast.isType(type.typeRef.ref)) {\r\n                    if (ast.isUnionType(type.typeRef.ref.type)) {\r\n                        errors.push(...checkTypeUnionContainsOnlyParseRules(type.typeRef.ref.type));\r\n                    } else {\r\n                        errors.push(type.typeRef.ref.name);\r\n                    }\r\n                }\r\n            } else if (type.stringType) {\r\n                errors.push(`\"${type.stringType}\"`);\r\n            } else if (type.primitiveType) {\r\n                errors.push(type.primitiveType);\r\n            }\r\n        }\r\n    });\r\n    return Array.from(new Set(errors));\r\n}\r\n\r\n", "/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-util.js';\r\nimport type { LangiumDocuments } from '../workspace/documents.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport * as ast from '../grammar/generated/ast.js';\r\nimport { getDocument, streamAllContents } from '../utils/ast-util.js';\r\nimport { TypeResolutionError } from './type-system/type-collector/types.js';\r\nimport { escapeRegExp } from '../utils/regex-util.js';\r\nimport { UriUtils } from '../utils/uri-util.js';\r\n\r\nexport * from './generated/grammar.js';\r\nexport * from './validation/validator.js';\r\n\r\nexport type Cardinality = '?' | '*' | '+' | undefined;\r\nexport type Operator = '=' | '+=' | '?=' | undefined;\r\n\r\nexport function isOptionalCardinality(cardinality?: Cardinality, element?: ast.AbstractElement): boolean {\r\n    return cardinality === '?' || cardinality === '*' || (ast.isGroup(element) && Boolean(element.guardCondition));\r\n}\r\n\r\nexport function isArrayCardinality(cardinality?: Cardinality): boolean {\r\n    return cardinality === '*' || cardinality === '+';\r\n}\r\n\r\nexport function isArrayOperator(operator?: Operator): boolean {\r\n    return operator === '+=';\r\n}\r\n\r\n/**\r\n * Determines whether the given parser rule is a _data type rule_, meaning that it has a\r\n * primitive return type like `number`, `boolean`, etc.\r\n */\r\nexport function isDataTypeRule(rule: ast.ParserRule): boolean {\r\n    return isDataTypeRuleInternal(rule, new Set());\r\n}\r\n\r\nfunction isDataTypeRuleInternal(rule: ast.ParserRule, visited: Set<ast.ParserRule>): boolean {\r\n    if (visited.has(rule)) {\r\n        return true;\r\n    } else {\r\n        visited.add(rule);\r\n    }\r\n    for (const node of streamAllContents(rule)) {\r\n        if (ast.isRuleCall(node)) {\r\n            if (!node.rule.ref) {\r\n                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.\r\n                return false;\r\n            }\r\n            if (ast.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {\r\n                return false;\r\n            }\r\n        } else if (ast.isAssignment(node)) {\r\n            return false;\r\n        } else if (ast.isAction(node)) {\r\n            return false;\r\n        }\r\n    }\r\n    return Boolean(rule.definition);\r\n}\r\n\r\nexport function hasDataTypeReturn(rule: ast.ParserRule): boolean {\r\n    const returnType = rule.returnType?.ref;\r\n    return rule.dataType !== undefined || (ast.isType(returnType) && isDataType(returnType));\r\n}\r\n\r\nexport function isDataType(type: ast.Type): boolean {\r\n    return isDataTypeInternal(type.type, new Set());\r\n}\r\n\r\nfunction isDataTypeInternal(type: ast.TypeDefinition, visited: Set<ast.TypeDefinition>): boolean {\r\n    if (visited.has(type)) {\r\n        return true;\r\n    } else {\r\n        visited.add(type);\r\n    }\r\n    if (ast.isArrayType(type)) {\r\n        return false;\r\n    } else if (ast.isReferenceType(type)) {\r\n        return false;\r\n    } else if (ast.isUnionType(type)) {\r\n        return type.types.every(e => isDataTypeInternal(e, visited));\r\n    } else if (ast.isSimpleType(type)) {\r\n        if (type.primitiveType !== undefined) {\r\n            return true;\r\n        } else if (type.stringType !== undefined) {\r\n            return true;\r\n        } else if (type.typeRef !== undefined) {\r\n            const ref = type.typeRef.ref;\r\n            if (ast.isType(ref)) {\r\n                return isDataTypeInternal(ref.type, visited);\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n\r\nexport function isStringType(type: ast.AbstractType | ast.TypeDefinition): boolean {\r\n    return isStringTypeInternal(type, new Set());\r\n}\r\n\r\nfunction isStringTypeInternal(type: ast.AbstractType | ast.TypeDefinition, visited: Set<AstNode>): boolean {\r\n    if (visited.has(type)) {\r\n        return true;\r\n    } else {\r\n        visited.add(type);\r\n    }\r\n    if (ast.isParserRule(type)) {\r\n        if (type.dataType) {\r\n            return type.dataType === 'string';\r\n        }\r\n        if (type.returnType?.ref) {\r\n            return isStringTypeInternal(type.returnType.ref, visited);\r\n        }\r\n    } else if (ast.isType(type)) {\r\n        return isStringTypeInternal(type.type, visited);\r\n    } else if (ast.isArrayType(type)) {\r\n        return false;\r\n    } else if (ast.isReferenceType(type)) {\r\n        return false;\r\n    } else if (ast.isUnionType(type)) {\r\n        return type.types.every(e => isStringTypeInternal(e, visited));\r\n    } else if (ast.isSimpleType(type)) {\r\n        if (type.primitiveType === 'string') {\r\n            return true;\r\n        } else if (type.stringType) {\r\n            return true;\r\n        } else if (type.typeRef?.ref) {\r\n            return isStringTypeInternal(type.typeRef.ref, visited);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function getActionAtElement(element: ast.AbstractElement): ast.Action | undefined {\r\n    const parent = element.$container;\r\n    if (ast.isGroup(parent)) {\r\n        const elements = parent.elements;\r\n        const index = elements.indexOf(element);\r\n        for (let i = index - 1; i >= 0; i--) {\r\n            const item = elements[i];\r\n            if (ast.isAction(item)) {\r\n                return item;\r\n            } else {\r\n                const action = streamAllContents(elements[i]).find(ast.isAction);\r\n                if (action) {\r\n                    return action;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (ast.isAbstractElement(parent)) {\r\n        return getActionAtElement(parent);\r\n    } else {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport function getTypeName(type: ast.AbstractType | ast.InferredType): string {\r\n    if (ast.isParserRule(type)) {\r\n        return isDataTypeRule(type) ? type.name : getExplicitRuleType(type) ?? type.name;\r\n    } else if (ast.isInterface(type) || ast.isType(type) || ast.isReturnType(type)) {\r\n        return type.name;\r\n    } else if (ast.isAction(type)) {\r\n        const actionType = getActionType(type);\r\n        if (actionType) {\r\n            return actionType;\r\n        }\r\n    } else if (ast.isInferredType(type)) {\r\n        return type.name;\r\n    }\r\n    throw new TypeResolutionError('Cannot get name of Unknown Type', type.$cstNode);\r\n}\r\n\r\nexport function getTypeNameWithoutError(type?: ast.AbstractType | ast.InferredType): string | undefined {\r\n    if (!type) {\r\n        return undefined;\r\n    }\r\n    try {\r\n        return getTypeName(type);\r\n    } catch {\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport function getExplicitRuleType(rule: ast.ParserRule): string | undefined {\r\n    if (rule.inferredType) {\r\n        return rule.inferredType.name;\r\n    } else if (rule.dataType) {\r\n        return rule.dataType;\r\n    } else if (rule.returnType) {\r\n        const refType = rule.returnType.ref;\r\n        if(refType) {\r\n            // check if we need to check Action as return type\r\n            if (ast.isParserRule(refType)) {\r\n                return refType.name;\r\n            }  else if(ast.isInterface(refType) || ast.isType(refType)) {\r\n                return refType.name;\r\n            }\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function getActionType(action: ast.Action): string | undefined {\r\n    if(action.inferredType) {\r\n        return action.inferredType.name;\r\n    } else if (action.type?.ref) {\r\n        return getTypeName(action.type.ref);\r\n    }\r\n    return undefined; // not inferring and not referencing a valid type\r\n}\r\n\r\nexport function getRuleType(rule: ast.AbstractRule): string {\r\n    if (ast.isTerminalRule(rule)) {\r\n        return rule.type?.name ?? 'string';\r\n    } else {\r\n        return isDataTypeRule(rule) ? rule.name : getExplicitRuleType(rule) ?? rule.name;\r\n    }\r\n}\r\n\r\nexport function terminalRegex(terminalRule: ast.TerminalRule): RegExp {\r\n    const flags: Flags = {\r\n        s: false,\r\n        i: false,\r\n        u: false\r\n    };\r\n    const source = abstractElementToRegex(terminalRule.definition, flags);\r\n    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');\r\n    return new RegExp(source, flagText);\r\n}\r\n\r\n// Using [\\s\\S]* allows to match everything, compared to . which doesn't match line terminators\r\nconst WILDCARD = /[\\s\\S]/.source;\r\n\r\ntype Flags = {\r\n    s: boolean;\r\n    i: boolean;\r\n    u: boolean;\r\n}\r\n\r\nfunction abstractElementToRegex(element: ast.AbstractElement, flags?: Flags): string {\r\n    if (ast.isTerminalAlternatives(element)) {\r\n        return terminalAlternativesToRegex(element);\r\n    } else if (ast.isTerminalGroup(element)) {\r\n        return terminalGroupToRegex(element);\r\n    } else if (ast.isCharacterRange(element)) {\r\n        return characterRangeToRegex(element);\r\n    } else if (ast.isTerminalRuleCall(element)) {\r\n        const rule = element.rule.ref;\r\n        if (!rule) {\r\n            throw new Error('Missing rule reference.');\r\n        }\r\n        return withCardinality(abstractElementToRegex(rule.definition), {\r\n            cardinality: element.cardinality,\r\n            lookahead: element.lookahead\r\n        });\r\n    } else if (ast.isNegatedToken(element)) {\r\n        return negateTokenToRegex(element);\r\n    } else if (ast.isUntilToken(element)) {\r\n        return untilTokenToRegex(element);\r\n    } else if (ast.isRegexToken(element)) {\r\n        const lastSlash = element.regex.lastIndexOf('/');\r\n        const source = element.regex.substring(1, lastSlash);\r\n        const regexFlags = element.regex.substring(lastSlash + 1);\r\n        if (flags) {\r\n            flags.i = regexFlags.includes('i');\r\n            flags.s = regexFlags.includes('s');\r\n            flags.u = regexFlags.includes('u');\r\n        }\r\n        return withCardinality(source, {\r\n            cardinality: element.cardinality,\r\n            lookahead: element.lookahead,\r\n            wrap: false\r\n        });\r\n    } else if (ast.isWildcard(element)) {\r\n        return withCardinality(WILDCARD, {\r\n            cardinality: element.cardinality,\r\n            lookahead: element.lookahead\r\n        });\r\n    } else {\r\n        throw new Error(`Invalid terminal element: ${element?.$type}`);\r\n    }\r\n}\r\n\r\nfunction terminalAlternativesToRegex(alternatives: ast.TerminalAlternatives): string {\r\n    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {\r\n        cardinality: alternatives.cardinality,\r\n        lookahead: alternatives.lookahead\r\n    });\r\n}\r\n\r\nfunction terminalGroupToRegex(group: ast.TerminalGroup): string {\r\n    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {\r\n        cardinality: group.cardinality,\r\n        lookahead: group.lookahead\r\n    });\r\n}\r\n\r\nfunction untilTokenToRegex(until: ast.UntilToken): string {\r\n    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {\r\n        cardinality: until.cardinality,\r\n        lookahead: until.lookahead\r\n    });\r\n}\r\n\r\nfunction negateTokenToRegex(negate: ast.NegatedToken): string {\r\n    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {\r\n        cardinality: negate.cardinality,\r\n        lookahead: negate.lookahead\r\n    });\r\n}\r\n\r\nfunction characterRangeToRegex(range: ast.CharacterRange): string {\r\n    if (range.right) {\r\n        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {\r\n            cardinality: range.cardinality,\r\n            lookahead: range.lookahead,\r\n            wrap: false\r\n        });\r\n    }\r\n    return withCardinality(keywordToRegex(range.left), {\r\n        cardinality: range.cardinality,\r\n        lookahead: range.lookahead,\r\n        wrap: false\r\n    });\r\n}\r\n\r\nfunction keywordToRegex(keyword: ast.Keyword): string {\r\n    return escapeRegExp(keyword.value);\r\n}\r\n\r\nfunction withCardinality(regex: string, options: {\r\n    cardinality?: string\r\n    wrap?: boolean\r\n    lookahead?: string\r\n}): string {\r\n    if (options.wrap !== false || options.lookahead) {\r\n        regex = `(${options.lookahead ?? ''}${regex})`;\r\n    }\r\n    if (options.cardinality) {\r\n        return `${regex}${options.cardinality}`;\r\n    }\r\n    return regex;\r\n}\r\n\r\nexport function resolveImportUri(imp: ast.GrammarImport): URI | undefined {\r\n    if (imp.path === undefined || imp.path.length === 0) {\r\n        return undefined;\r\n    }\r\n    const dirUri = UriUtils.dirname(getDocument(imp).uri);\r\n    let grammarPath = imp.path;\r\n    if (!grammarPath.endsWith('.langium')) {\r\n        grammarPath += '.langium';\r\n    }\r\n    return UriUtils.resolvePath(dirUri, grammarPath);\r\n}\r\n\r\nexport function resolveImport(documents: LangiumDocuments, imp: ast.GrammarImport): ast.Grammar | undefined {\r\n    const resolvedUri = resolveImportUri(imp);\r\n    try {\r\n        if (resolvedUri) {\r\n            const resolvedDocument = documents.getOrCreateDocument(resolvedUri);\r\n            const node = resolvedDocument.parseResult.value;\r\n            if (ast.isGrammar(node)) {\r\n                return node;\r\n            }\r\n        }\r\n    } catch {\r\n        // NOOP\r\n    }\r\n    return undefined;\r\n}\r\n\r\nexport function resolveTransitiveImports(documents: LangiumDocuments, grammar: ast.Grammar): ast.Grammar[]\r\nexport function resolveTransitiveImports(documents: LangiumDocuments, importNode: ast.GrammarImport): ast.Grammar[]\r\nexport function resolveTransitiveImports(documents: LangiumDocuments, grammarOrImport: ast.Grammar | ast.GrammarImport): ast.Grammar[] {\r\n    if (ast.isGrammarImport(grammarOrImport)) {\r\n        const resolvedGrammar = resolveImport(documents, grammarOrImport);\r\n        if (resolvedGrammar) {\r\n            const transitiveGrammars = resolveTransitiveImportsInternal(documents, resolvedGrammar);\r\n            transitiveGrammars.push(resolvedGrammar);\r\n            return transitiveGrammars;\r\n        }\r\n        return [];\r\n    } else {\r\n        return resolveTransitiveImportsInternal(documents, grammarOrImport);\r\n    }\r\n}\r\n\r\nfunction resolveTransitiveImportsInternal(documents: LangiumDocuments, grammar: ast.Grammar, initialGrammar = grammar, visited: Set<URI> = new Set(), grammars: Set<ast.Grammar> = new Set()): ast.Grammar[] {\r\n    const doc = getDocument(grammar);\r\n    if (initialGrammar !== grammar) {\r\n        grammars.add(grammar);\r\n    }\r\n    if (!visited.has(doc.uri)) {\r\n        visited.add(doc.uri);\r\n        for (const imp of grammar.imports) {\r\n            const importedGrammar = resolveImport(documents, imp);\r\n            if (importedGrammar) {\r\n                resolveTransitiveImportsInternal(documents, importedGrammar, initialGrammar, visited, grammars);\r\n            }\r\n        }\r\n    }\r\n    return Array.from(grammars);\r\n}\r\n\r\nexport function extractAssignments(element: ast.AbstractElement): ast.Assignment[] {\r\n    if (ast.isAssignment(element)) {\r\n        return [element];\r\n    } else if (ast.isAlternatives(element) || ast.isGroup(element) || ast.isUnorderedGroup(element)) {\r\n        return element.elements.flatMap(e => extractAssignments(e));\r\n    } else if (ast.isRuleCall(element) && element.rule.ref) {\r\n        return extractAssignments(element.rule.ref.definition);\r\n    }\r\n    return [];\r\n}\r\n\r\nconst primitiveTypes = ['string', 'number', 'boolean', 'Date', 'bigint'];\r\n\r\nexport function isPrimitiveType(type: string): boolean {\r\n    return primitiveTypes.includes(type);\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ParserRule, Action, AbstractElement, Assignment, RuleCall } from '../../generated/ast.js';\r\nimport type { PlainAstTypes, PlainInterface, PlainProperty, PlainPropertyType, PlainUnion } from './plain-types.js';\r\nimport { isNamed } from '../../../references/name-provider.js';\r\nimport { MultiMap } from '../../../utils/collections.js';\r\nimport { isAlternatives, isKeyword, isParserRule, isAction, isGroup, isUnorderedGroup, isAssignment, isRuleCall, isCrossReference, isTerminalRule } from '../../generated/ast.js';\r\nimport { getTypeNameWithoutError, isOptionalCardinality, getRuleType, isPrimitiveType, terminalRegex } from '../../internal-grammar-util.js';\r\nimport { mergePropertyTypes } from './plain-types.js';\r\n\r\ninterface TypePart {\r\n    name?: string\r\n    properties: PlainProperty[]\r\n    ruleCalls: string[]\r\n    parents: TypePart[]\r\n    children: TypePart[]\r\n    actionWithAssignment: boolean\r\n}\r\n\r\ntype TypeAlternative = {\r\n    name: string\r\n    super: string[]\r\n    properties: PlainProperty[]\r\n    ruleCalls: string[]\r\n}\r\n\r\ntype TypeCollection = {\r\n    types: Set<string>\r\n    reference: boolean\r\n}\r\n\r\ninterface TypeCollectionContext {\r\n    fragments: Map<ParserRule, PlainProperty[]>\r\n}\r\n\r\ninterface TypePath {\r\n    alt: TypeAlternative\r\n    next: TypePart[]\r\n}\r\n\r\nclass TypeGraph {\r\n    context: TypeCollectionContext;\r\n    root: TypePart;\r\n\r\n    constructor(context: TypeCollectionContext, root: TypePart) {\r\n        this.context = context;\r\n        this.root = root;\r\n    }\r\n\r\n    getTypes(): TypePath[] {\r\n        const rootType: TypeAlternative = {\r\n            name: this.root.name!,\r\n            properties: this.root.properties,\r\n            ruleCalls: this.root.ruleCalls,\r\n            super: []\r\n        };\r\n        if (this.root.children.length === 0) {\r\n            return [{ alt: rootType, next: [] }];\r\n        } else {\r\n            return this.applyNext(this.root, {\r\n                alt: rootType,\r\n                next: this.root.children\r\n            });\r\n        }\r\n    }\r\n\r\n    private applyNext(root: TypePart, nextPath: TypePath): TypePath[] {\r\n        const splits = this.splitType(nextPath.alt, nextPath.next.length);\r\n        const paths: TypePath[] = [];\r\n        for (let i = 0; i < nextPath.next.length; i++) {\r\n            const split = splits[i];\r\n            const part = nextPath.next[i];\r\n            if (part.actionWithAssignment) {\r\n                // If the path enters an action with an assignment which changes the current name\r\n                // We already add a new path, since the next part of the part refers to a new inferred type\r\n                paths.push({\r\n                    alt: copyTypeAlternative(split),\r\n                    next: []\r\n                });\r\n            }\r\n            if (part.name !== undefined && part.name !== split.name) {\r\n                if (part.actionWithAssignment) {\r\n                    // We reset all properties, super types and ruleCalls since we are now in a new inferred type\r\n                    split.properties = [];\r\n                    split.ruleCalls = [];\r\n                    split.super = [root.name!];\r\n                    split.name = part.name;\r\n                } else {\r\n                    split.super = [split.name, ...split.ruleCalls];\r\n                    split.properties = [];\r\n                    split.ruleCalls = [];\r\n                    split.name = part.name;\r\n                }\r\n            }\r\n            split.properties.push(...part.properties);\r\n            split.ruleCalls.push(...part.ruleCalls);\r\n            const path: TypePath = {\r\n                alt: split,\r\n                next: part.children\r\n            };\r\n            if (path.next.length === 0) {\r\n                path.alt.super = path.alt.super.filter(e => e !== path.alt.name);\r\n                paths.push(path);\r\n            } else {\r\n                paths.push(...this.applyNext(root, path));\r\n            }\r\n        }\r\n        return flattenTypes(paths);\r\n    }\r\n\r\n    private splitType(type: TypeAlternative, count: number): TypeAlternative[] {\r\n        const alternatives: TypeAlternative[] = [];\r\n        for (let i = 0; i < count; i++) {\r\n            alternatives.push(copyTypeAlternative(type));\r\n        }\r\n        return alternatives;\r\n    }\r\n\r\n    getSuperTypes(node: TypePart): string[] {\r\n        const set = new Set<string>();\r\n        this.collectSuperTypes(node, node, set);\r\n        return Array.from(set);\r\n    }\r\n\r\n    private collectSuperTypes(original: TypePart, part: TypePart, set: Set<string>): void {\r\n        if (part.ruleCalls.length > 0) {\r\n            // Each unassigned rule call corresponds to a super type\r\n            for (const ruleCall of part.ruleCalls) {\r\n                set.add(ruleCall);\r\n            }\r\n            return;\r\n        }\r\n        for (const parent of part.parents) {\r\n            if (original.name === undefined) {\r\n                this.collectSuperTypes(parent, parent, set);\r\n            } else if (parent.name !== undefined && parent.name !== original.name) {\r\n                set.add(parent.name);\r\n            } else {\r\n                this.collectSuperTypes(original, parent, set);\r\n            }\r\n        }\r\n        if (part.parents.length === 0 && part.name) {\r\n            set.add(part.name);\r\n        }\r\n    }\r\n\r\n    connect(parent: TypePart, children: TypePart): TypePart {\r\n        children.parents.push(parent);\r\n        parent.children.push(children);\r\n        return children;\r\n    }\r\n\r\n    merge(...parts: TypePart[]): TypePart {\r\n        if (parts.length === 1) {\r\n            return parts[0];\r\n        } else if (parts.length === 0) {\r\n            throw new Error('No parts to merge');\r\n        }\r\n        const node = newTypePart();\r\n        node.parents = parts;\r\n        for (const parent of parts) {\r\n            parent.children.push(node);\r\n        }\r\n        return node;\r\n    }\r\n\r\n    hasLeafNode(part: TypePart): boolean {\r\n        return this.partHasLeafNode(part);\r\n    }\r\n\r\n    private partHasLeafNode(part: TypePart, ignore?: TypePart): boolean {\r\n        if (part.children.some(e => e !== ignore)) {\r\n            return true;\r\n        } else if (part.name) {\r\n            return false;\r\n        } else {\r\n            return part.parents.some(e => this.partHasLeafNode(e, part));\r\n        }\r\n    }\r\n}\r\n\r\nfunction copyTypePart(value: TypePart): TypePart {\r\n    return {\r\n        name: value.name,\r\n        children: [],\r\n        parents: [],\r\n        actionWithAssignment: value.actionWithAssignment,\r\n        ruleCalls: [...value.ruleCalls],\r\n        properties: value.properties.map(copyProperty),\r\n    };\r\n}\r\n\r\nfunction copyTypeAlternative(value: TypeAlternative): TypeAlternative {\r\n    return {\r\n        name: value.name,\r\n        super: value.super,\r\n        ruleCalls: value.ruleCalls,\r\n        properties: value.properties.map(e => copyProperty(e))\r\n    };\r\n}\r\n\r\nfunction copyProperty(value: PlainProperty): PlainProperty {\r\n    return {\r\n        name: value.name,\r\n        optional: value.optional,\r\n        type: value.type,\r\n        astNodes: value.astNodes,\r\n    };\r\n}\r\n\r\nexport function collectInferredTypes(parserRules: ParserRule[], datatypeRules: ParserRule[], declared: PlainAstTypes): PlainAstTypes {\r\n    // extract interfaces and types from parser rules\r\n    const allTypes: TypePath[] = [];\r\n    const context: TypeCollectionContext = {\r\n        fragments: new Map()\r\n    };\r\n    for (const rule of parserRules) {\r\n        allTypes.push(...getRuleTypes(context, rule));\r\n    }\r\n    const interfaces = calculateInterfaces(allTypes);\r\n    const unions = buildSuperUnions(interfaces);\r\n    const astTypes = extractUnions(interfaces, unions, declared);\r\n\r\n    // extract types from datatype rules\r\n    for (const rule of datatypeRules) {\r\n        const type = getDataRuleType(rule);\r\n        astTypes.unions.push({\r\n            name: rule.name,\r\n            declared: false,\r\n            type,\r\n            subTypes: new Set(),\r\n            superTypes: new Set(),\r\n            dataType: rule.dataType,\r\n        });\r\n    }\r\n    return astTypes;\r\n}\r\n\r\nfunction getDataRuleType(rule: ParserRule): PlainPropertyType {\r\n    if (rule.dataType && rule.dataType !== 'string') {\r\n        return {\r\n            primitive: rule.dataType\r\n        };\r\n    }\r\n    let cancelled = false;\r\n    const cancel = (): PlainPropertyType => {\r\n        cancelled = true;\r\n        return {\r\n            primitive: 'unknown'\r\n        };\r\n    };\r\n    const type = buildDataRuleType(rule.definition, cancel);\r\n    if (cancelled) {\r\n        return {\r\n            primitive: 'string'\r\n        };\r\n    } else {\r\n        return type;\r\n    }\r\n}\r\n\r\nfunction buildDataRuleType(element: AbstractElement, cancel: () => PlainPropertyType): PlainPropertyType {\r\n    if (element.cardinality) {\r\n        // Multiplicity/optionality is not supported for types\r\n        return cancel();\r\n    }\r\n    if (isAlternatives(element)) {\r\n        return {\r\n            types: element.elements.map(e => buildDataRuleType(e, cancel))\r\n        };\r\n    } else if (isGroup(element) || isUnorderedGroup(element)) {\r\n        if (element.elements.length !== 1) {\r\n            return cancel();\r\n        } else {\r\n            return buildDataRuleType(element.elements[0], cancel);\r\n        }\r\n    } else if (isRuleCall(element)) {\r\n        const ref = element.rule?.ref;\r\n        if (ref) {\r\n            if (isTerminalRule(ref)) {\r\n                return {\r\n                    primitive: ref.type?.name ?? 'string',\r\n                    regex: terminalRegex(ref).toString()\r\n                };\r\n            } else {\r\n                return {\r\n                    value: ref.name\r\n                };\r\n            }\r\n        } else {\r\n            return cancel();\r\n        }\r\n    } else if (isKeyword(element)) {\r\n        return {\r\n            string: element.value\r\n        };\r\n    }\r\n    return cancel();\r\n}\r\n\r\nfunction getRuleTypes(context: TypeCollectionContext, rule: ParserRule): TypePath[] {\r\n    const type = newTypePart(rule);\r\n    const graph = new TypeGraph(context, type);\r\n    if (rule.definition) {\r\n        collectElement(graph, graph.root, rule.definition);\r\n    }\r\n    return graph.getTypes();\r\n}\r\n\r\nfunction newTypePart(element?: ParserRule | Action | string): TypePart {\r\n    return {\r\n        name: isParserRule(element) || isAction(element) ? getTypeNameWithoutError(element) : element,\r\n        properties: [],\r\n        ruleCalls: [],\r\n        children: [],\r\n        parents: [],\r\n        actionWithAssignment: false\r\n    };\r\n}\r\n\r\n/**\r\n * Collects all possible type branches of a given element.\r\n * @param state State to walk over element's graph.\r\n * @param type Element that collects a current type branch for the given element.\r\n * @param element The given AST element, from which it's necessary to extract the type.\r\n */\r\nfunction collectElement(graph: TypeGraph, current: TypePart, element: AbstractElement): TypePart {\r\n    const optional = isOptionalCardinality(element.cardinality, element);\r\n    if (isAlternatives(element)) {\r\n        const children: TypePart[] = [];\r\n        if (optional) {\r\n            // Create a new empty node\r\n            children.push(graph.connect(current, newTypePart()));\r\n        }\r\n        for (const alt of element.elements) {\r\n            const altType = graph.connect(current, newTypePart());\r\n            children.push(collectElement(graph, altType, alt));\r\n        }\r\n        return graph.merge(...children);\r\n    } else if (isGroup(element) || isUnorderedGroup(element)) {\r\n        let groupNode = graph.connect(current, newTypePart());\r\n        let skipNode: TypePart | undefined;\r\n        if (optional) {\r\n            skipNode = graph.connect(current, newTypePart());\r\n        }\r\n        for (const item of element.elements) {\r\n            groupNode = collectElement(graph, groupNode, item);\r\n        }\r\n        if (skipNode) {\r\n            return graph.merge(skipNode, groupNode);\r\n        } else {\r\n            return groupNode;\r\n        }\r\n    } else if (isAction(element)) {\r\n        return addAction(graph, current, element);\r\n    } else if (isAssignment(element)) {\r\n        addAssignment(current, element);\r\n    } else if (isRuleCall(element)) {\r\n        addRuleCall(graph, current, element);\r\n    }\r\n    return current;\r\n}\r\n\r\nfunction addAction(graph: TypeGraph, parent: TypePart, action: Action): TypePart {\r\n\r\n    // We create a copy of the current type part\r\n    // This is essentially a leaf node of the current type\r\n    // Otherwise we might lose information, such as properties\r\n    // We do this if there's no leaf node for the current type yet\r\n    if (!graph.hasLeafNode(parent)) {\r\n        const copy = copyTypePart(parent);\r\n        graph.connect(parent, copy);\r\n    }\r\n\r\n    const typeNode = graph.connect(parent, newTypePart(action));\r\n\r\n    if (action.type) {\r\n        const type = action.type?.ref;\r\n        if (type && isNamed(type))\r\n            // cs: if the (named) type could be resolved properly also set the name on 'typeNode'\r\n            //  for the sake of completeness and better comprehensibility during debugging,\r\n            //  it's not supposed to have a effect on the flow of control!\r\n            typeNode.name = type.name;\r\n    }\r\n\r\n    if (action.feature && action.operator) {\r\n        typeNode.actionWithAssignment = true;\r\n        typeNode.properties.push({\r\n            name: action.feature,\r\n            optional: false,\r\n            type: toPropertyType(\r\n                action.operator === '+=',\r\n                false,\r\n                graph.root.ruleCalls.length !== 0 ? graph.root.ruleCalls : graph.getSuperTypes(typeNode)),\r\n            astNodes: new Set([action])\r\n        });\r\n    }\r\n    return typeNode;\r\n}\r\n\r\nfunction addAssignment(current: TypePart, assignment: Assignment): void {\r\n    const typeItems: TypeCollection = { types: new Set(), reference: false };\r\n    findTypes(assignment.terminal, typeItems);\r\n\r\n    const type: PlainPropertyType = toPropertyType(\r\n        assignment.operator === '+=',\r\n        typeItems.reference,\r\n        assignment.operator === '?=' ? ['boolean'] : Array.from(typeItems.types)\r\n    );\r\n\r\n    current.properties.push({\r\n        name: assignment.feature,\r\n        optional: isOptionalCardinality(assignment.cardinality),\r\n        type,\r\n        astNodes: new Set([assignment])\r\n    });\r\n}\r\n\r\nfunction findTypes(terminal: AbstractElement, types: TypeCollection): void {\r\n    if (isAlternatives(terminal) || isUnorderedGroup(terminal) || isGroup(terminal)) {\r\n        for (const element of terminal.elements) {\r\n            findTypes(element, types);\r\n        }\r\n    } else if (isKeyword(terminal)) {\r\n        types.types.add(`'${terminal.value}'`);\r\n    } else if (isRuleCall(terminal) && terminal.rule.ref) {\r\n        types.types.add(getRuleType(terminal.rule.ref));\r\n    } else if (isCrossReference(terminal) && terminal.type.ref) {\r\n        const refTypeName = getTypeNameWithoutError(terminal.type.ref);\r\n        if (refTypeName) {\r\n            types.types.add(refTypeName);\r\n        }\r\n        types.reference = true;\r\n    }\r\n}\r\n\r\nfunction addRuleCall(graph: TypeGraph, current: TypePart, ruleCall: RuleCall): void {\r\n    const rule = ruleCall.rule.ref;\r\n    // Add all properties of fragments to the current type\r\n    if (isParserRule(rule) && rule.fragment) {\r\n        const properties = getFragmentProperties(rule, graph.context);\r\n        if (isOptionalCardinality(ruleCall.cardinality)) {\r\n            current.properties.push(...properties.map(e => ({\r\n                ...e,\r\n                optional: true\r\n            })));\r\n        } else {\r\n            current.properties.push(...properties);\r\n        }\r\n    } else if (isParserRule(rule)) {\r\n        current.ruleCalls.push(getRuleType(rule));\r\n    }\r\n}\r\n\r\nfunction getFragmentProperties(fragment: ParserRule, context: TypeCollectionContext): PlainProperty[] {\r\n    const existing = context.fragments.get(fragment);\r\n    if (existing) {\r\n        return existing;\r\n    }\r\n    const properties: PlainProperty[] = [];\r\n    context.fragments.set(fragment, properties);\r\n    const fragmentName = getTypeNameWithoutError(fragment);\r\n    const typeAlternatives = getRuleTypes(context, fragment).filter(e => e.alt.name === fragmentName);\r\n    properties.push(...typeAlternatives.flatMap(e => e.alt.properties));\r\n    return properties;\r\n}\r\n\r\n/**\r\n * Calculate interfaces from all possible type branches.\r\n * [some of these interfaces will become types in the generated AST]\r\n * @param alternatives The type branches that will be squashed in interfaces.\r\n * @returns Interfaces.\r\n */\r\nfunction calculateInterfaces(alternatives: TypePath[]): PlainInterface[] {\r\n    const interfaces = new Map<string, PlainInterface>();\r\n    const ruleCallAlternatives: TypeAlternative[] = [];\r\n    const flattened = flattenTypes(alternatives).map(e => e.alt);\r\n\r\n    for (const flat of flattened) {\r\n        const interfaceType: PlainInterface = {\r\n            name: flat.name,\r\n            properties: flat.properties,\r\n            superTypes: new Set(flat.super),\r\n            subTypes: new Set(),\r\n            declared: false,\r\n            abstract: false\r\n        };\r\n        interfaces.set(interfaceType.name, interfaceType);\r\n        if (flat.ruleCalls.length > 0) {\r\n            ruleCallAlternatives.push(flat);\r\n            flat.ruleCalls.forEach(e => {\r\n                if (e !== interfaceType.name) { // An interface cannot subtype itself\r\n                    interfaceType.subTypes.add(e);\r\n                }\r\n            });\r\n        }\r\n        // all other cases assume we have a data type rule\r\n        // we do not generate an AST type for data type rules\r\n    }\r\n\r\n    for (const ruleCallType of ruleCallAlternatives) {\r\n        for (const ruleCall of ruleCallType.ruleCalls) {\r\n            const calledInterface = interfaces.get(ruleCall);\r\n            if (calledInterface) {\r\n                if (calledInterface.name !== ruleCallType.name) {\r\n                    calledInterface.superTypes.add(ruleCallType.name);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return Array.from(interfaces.values());\r\n}\r\n\r\nfunction flattenTypes(alternatives: TypePath[]): TypePath[] {\r\n    const nameToAlternatives = alternatives.reduce((acc, e) => acc.add(e.alt.name, e), new MultiMap<string, TypePath>());\r\n    const types: TypePath[] = [];\r\n\r\n    for (const [name, namedAlternatives] of nameToAlternatives.entriesGroupedByKey()) {\r\n        const properties: PlainProperty[] = [];\r\n        const ruleCalls = new Set<string>();\r\n        const type: TypePath = { alt: { name, properties, ruleCalls: [], super: [] }, next: [] };\r\n        for (const path of namedAlternatives) {\r\n            const alt = path.alt;\r\n            type.alt.super.push(...alt.super);\r\n            type.next.push(...path.next);\r\n            const altProperties = alt.properties;\r\n            for (const altProperty of altProperties) {\r\n                const existingProperty = properties.find(e => e.name === altProperty.name);\r\n                if (existingProperty) {\r\n                    existingProperty.type = mergePropertyTypes(existingProperty.type, altProperty.type);\r\n                    altProperty.astNodes.forEach(e => existingProperty.astNodes.add(e));\r\n                } else {\r\n                    properties.push({ ...altProperty });\r\n                }\r\n            }\r\n            alt.ruleCalls.forEach(ruleCall => ruleCalls.add(ruleCall));\r\n        }\r\n        for (const path of namedAlternatives) {\r\n            const alt = path.alt;\r\n            // A type with rule calls is not a real member of the type\r\n            // Any missing properties are therefore not associated with the current type\r\n            if (alt.ruleCalls.length === 0) {\r\n                for (const property of properties) {\r\n                    if (!alt.properties.find(e => e.name === property.name)) {\r\n                        property.optional = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        type.alt.ruleCalls = Array.from(ruleCalls);\r\n        types.push(type);\r\n    }\r\n\r\n    return types;\r\n}\r\n\r\nfunction buildSuperUnions(interfaces: PlainInterface[]): PlainUnion[] {\r\n    const interfaceMap = new Map(interfaces.map(e => [e.name, e]));\r\n    const unions: PlainUnion[] = [];\r\n    const allSupertypes = new MultiMap<string, string>();\r\n    for (const interfaceType of interfaces) {\r\n        for (const superType of interfaceType.superTypes) {\r\n            allSupertypes.add(superType, interfaceType.name);\r\n        }\r\n    }\r\n    for (const [superType, types] of allSupertypes.entriesGroupedByKey()) {\r\n        if (!interfaceMap.has(superType)) {\r\n            const union: PlainUnion = {\r\n                declared: false,\r\n                name: superType,\r\n                subTypes: new Set(),\r\n                superTypes: new Set(),\r\n                type: toPropertyType(false, false, types)\r\n            };\r\n            unions.push(union);\r\n        }\r\n    }\r\n\r\n    return unions;\r\n}\r\n\r\n/**\r\n * Filters interfaces, transforming some of them in unions.\r\n * The transformation criterion: no properties, but have subtypes.\r\n * @param interfaces The interfaces that have to be transformed on demand.\r\n * @returns Types and not transformed interfaces.\r\n */\r\nfunction extractUnions(interfaces: PlainInterface[], unions: PlainUnion[], declared: PlainAstTypes): {\r\n    interfaces: PlainInterface[],\r\n    unions: PlainUnion[]\r\n} {\r\n    const subTypes = new MultiMap<string, string>();\r\n    for (const interfaceType of interfaces) {\r\n        for (const superTypeName of interfaceType.superTypes) {\r\n            subTypes.add(superTypeName, interfaceType.name);\r\n        }\r\n    }\r\n    const declaredInterfaces = new Set(declared.interfaces.map(e => e.name));\r\n    const astTypes = { interfaces: [] as PlainInterface[], unions };\r\n    const unionTypes = new Map<string, PlainUnion>(unions.map(e => [e.name, e]));\r\n    for (const interfaceType of interfaces) {\r\n        const interfaceSubTypes = new Set(subTypes.get(interfaceType.name));\r\n        // Convert an interface into a union type if it has subtypes and no properties on its own\r\n        if (interfaceType.properties.length === 0 && interfaceSubTypes.size > 0) {\r\n            // In case we have an explicitly declared interface\r\n            // Mark the interface as `abstract` and do not create a union type\r\n            if (declaredInterfaces.has(interfaceType.name)) {\r\n                interfaceType.abstract = true;\r\n                astTypes.interfaces.push(interfaceType);\r\n            } else {\r\n                const interfaceTypeValue = toPropertyType(false, false, Array.from(interfaceSubTypes));\r\n                const existingUnion = unionTypes.get(interfaceType.name);\r\n                if (existingUnion) {\r\n                    existingUnion.type = mergePropertyTypes(existingUnion.type, interfaceTypeValue);\r\n                } else {\r\n                    const unionType: PlainUnion = {\r\n                        name: interfaceType.name,\r\n                        declared: false,\r\n                        subTypes: interfaceSubTypes,\r\n                        superTypes: interfaceType.superTypes,\r\n                        type: interfaceTypeValue\r\n                    };\r\n                    astTypes.unions.push(unionType);\r\n                    unionTypes.set(interfaceType.name, unionType);\r\n                }\r\n            }\r\n        } else {\r\n            astTypes.interfaces.push(interfaceType);\r\n        }\r\n    }\r\n    // After converting some interfaces into union types, these interfaces are no longer valid super types\r\n    for (const interfaceType of astTypes.interfaces) {\r\n        interfaceType.superTypes = new Set([...interfaceType.superTypes].filter(superType => !unionTypes.has(superType)));\r\n    }\r\n    return astTypes;\r\n}\r\n\r\nfunction toPropertyType(array: boolean, reference: boolean, types: string[]): PlainPropertyType {\r\n    if (array) {\r\n        return {\r\n            elementType: toPropertyType(false, reference, types)\r\n        };\r\n    } else if (reference) {\r\n        return {\r\n            referenceType: toPropertyType(false, false, types)\r\n        };\r\n    } else if (types.length === 1) {\r\n        const type = types[0];\r\n        if (type.startsWith(\"'\")) {\r\n            return {\r\n                string: type.substring(1, type.length - 1)\r\n            };\r\n        }\r\n        if (isPrimitiveType(type)) {\r\n            return {\r\n                primitive: type\r\n            };\r\n        } else {\r\n            return {\r\n                value: type\r\n            };\r\n        }\r\n    } else {\r\n        return {\r\n            types: types.map(e => toPropertyType(false, false, [e]))\r\n        };\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ParserRule, Interface, Type, Grammar } from '../../generated/ast.js';\r\nimport type { URI } from '../../../utils/uri-util.js';\r\nimport type { LangiumDocuments } from '../../../workspace/documents.js';\r\nimport type { PlainAstTypes } from './plain-types.js';\r\nimport type { AstTypes } from './types.js';\r\nimport { collectInferredTypes } from './inferred-types.js';\r\nimport { collectDeclaredTypes } from './declared-types.js';\r\nimport { getDocument } from '../../../utils/ast-util.js';\r\nimport { isParserRule } from '../../generated/ast.js';\r\nimport { isDataTypeRule, resolveImport } from '../../internal-grammar-util.js';\r\n\r\nexport type AstResources = {\r\n    parserRules: ParserRule[],\r\n    datatypeRules: ParserRule[],\r\n    interfaces: Interface[],\r\n    types: Type[],\r\n}\r\n\r\nexport type TypeResources = {\r\n    inferred: PlainAstTypes,\r\n    declared: PlainAstTypes,\r\n    astResources: AstResources,\r\n}\r\n\r\nexport interface ValidationAstTypes {\r\n    inferred: AstTypes\r\n    declared: AstTypes\r\n    astResources: AstResources\r\n}\r\n\r\nexport function collectTypeResources(grammars: Grammar | Grammar[], documents?: LangiumDocuments): TypeResources {\r\n    const astResources = collectAllAstResources(grammars, documents);\r\n    const declared = collectDeclaredTypes(astResources.interfaces, astResources.types);\r\n    const inferred = collectInferredTypes(astResources.parserRules, astResources.datatypeRules, declared);\r\n\r\n    return {\r\n        astResources,\r\n        inferred,\r\n        declared\r\n    };\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nexport function collectAllAstResources(grammars: Grammar | Grammar[], documents?: LangiumDocuments, visited: Set<URI> = new Set(),\r\n    astResources: AstResources = { parserRules: [], datatypeRules: [], interfaces: [], types: [] }): AstResources {\r\n\r\n    if (!Array.isArray(grammars)) grammars = [grammars];\r\n    for (const grammar of grammars) {\r\n        const doc = getDocument(grammar);\r\n        if (visited.has(doc.uri)) {\r\n            continue;\r\n        }\r\n        visited.add(doc.uri);\r\n        for (const rule of grammar.rules) {\r\n            if (isParserRule(rule) && !rule.fragment) {\r\n                if (isDataTypeRule(rule)) {\r\n                    astResources.datatypeRules.push(rule);\r\n                } else {\r\n                    astResources.parserRules.push(rule);\r\n                }\r\n            }\r\n        }\r\n        grammar.interfaces.forEach(e => astResources.interfaces.push(e));\r\n        grammar.types.forEach(e => astResources.types.push(e));\r\n\r\n        if (documents) {\r\n            const importedGrammars = grammar.imports.map(e => resolveImport(documents, e)).filter((e): e is Grammar => e !== undefined);\r\n            collectAllAstResources(importedGrammars, documents, visited, astResources);\r\n        }\r\n    }\r\n    return astResources;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Grammar } from '../generated/ast.js';\r\nimport type { LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { AstTypes, InterfaceType, PropertyType, TypeOption, UnionType } from './type-collector/types.js';\r\nimport type { ValidationAstTypes } from './type-collector/all-types.js';\r\nimport type { PlainAstTypes, PlainInterface, PlainUnion } from './type-collector/plain-types.js';\r\nimport { findAstTypes, sortInterfacesTopologically } from './types-util.js';\r\nimport { isInterfaceType, isPrimitiveType, isPropertyUnion, isStringType, isUnionType, isValueType } from './type-collector/types.js';\r\nimport { collectTypeResources } from './type-collector/all-types.js';\r\nimport { plainToTypes } from './type-collector/plain-types.js';\r\n\r\n/**\r\n * Collects all types for the generated AST. The types collector entry point.\r\n *\r\n * @param grammars All grammars involved in the type generation process\r\n * @param documents Additional documents so that imports can be resolved as necessary\r\n */\r\nexport function collectAst(grammars: Grammar | Grammar[], documents?: LangiumDocuments): AstTypes {\r\n    const { inferred, declared } = collectTypeResources(grammars, documents);\r\n    return createAstTypes(inferred, declared);\r\n}\r\n\r\n/**\r\n * Collects all types used during the validation process.\r\n * The validation process requires us to compare our inferred types with our declared types.\r\n *\r\n * @param grammars All grammars involved in the validation process\r\n * @param documents Additional documents so that imports can be resolved as necessary\r\n */\r\nexport function collectValidationAst(grammars: Grammar | Grammar[], documents?: LangiumDocuments): ValidationAstTypes {\r\n    const { inferred, declared, astResources } = collectTypeResources(grammars, documents);\r\n\r\n    return {\r\n        astResources,\r\n        inferred: createAstTypes(declared, inferred),\r\n        declared: createAstTypes(inferred, declared)\r\n    };\r\n}\r\n\r\nexport function createAstTypes(first: PlainAstTypes, second?: PlainAstTypes): AstTypes {\r\n    const astTypes: PlainAstTypes = {\r\n        interfaces: sortInterfacesTopologically(mergeAndRemoveDuplicates<PlainInterface>(...first.interfaces, ...second?.interfaces ?? [])),\r\n        unions: mergeAndRemoveDuplicates<PlainUnion>(...first.unions, ...second?.unions ?? []),\r\n    };\r\n\r\n    const finalTypes = plainToTypes(astTypes);\r\n    specifyAstNodeProperties(finalTypes);\r\n    return finalTypes;\r\n}\r\n\r\n/**\r\n * Merges the lists of given elements into a single list and removes duplicates. Elements later in the lists get precedence over earlier elements.\r\n *\r\n * The distinction is performed over the `name` property of the element. The result is a name-sorted list of elements.\r\n */\r\nfunction mergeAndRemoveDuplicates<T extends { name: string }>(...elements: T[]): T[] {\r\n    return Array.from(elements\r\n        .reduce((acc, type) => { acc.set(type.name, type); return acc; }, new Map<string, T>())\r\n        .values()).sort((a, b) => a.name.localeCompare(b.name));\r\n}\r\n\r\nexport function specifyAstNodeProperties(astTypes: AstTypes) {\r\n    const nameToType = filterInterfaceLikeTypes(astTypes);\r\n    const array = Array.from(nameToType.values());\r\n    addSubTypes(array);\r\n    buildContainerTypes(astTypes.interfaces);\r\n    buildTypeNames(array);\r\n}\r\n\r\nfunction buildTypeNames(types: TypeOption[]) {\r\n    // Recursively collect all subtype names\r\n    const visited = new Set<TypeOption>();\r\n    const collect = (type: TypeOption): void => {\r\n        if (visited.has(type)) return;\r\n        visited.add(type);\r\n        type.typeNames.add(type.name);\r\n        for (const subtype of type.subTypes) {\r\n            collect(subtype);\r\n            subtype.typeNames.forEach(n => type.typeNames.add(n));\r\n        }\r\n    };\r\n    types.forEach(collect);\r\n}\r\n\r\n/**\r\n * Removes union types that reference only to primitive types or\r\n * types that reference only to primitive types.\r\n */\r\nfunction filterInterfaceLikeTypes({ interfaces, unions }: AstTypes): Map<string, TypeOption> {\r\n    const nameToType = (interfaces as TypeOption[]).concat(unions)\r\n        .reduce((acc, e) => { acc.set(e.name, e); return acc; }, new Map<string, TypeOption>());\r\n\r\n    const cache = new Map<UnionType, boolean>();\r\n\r\n    for (const union of unions) {\r\n        cache.set(union, isDataType(union.type, new Set()));\r\n    }\r\n    for (const [union, isDataType] of cache) {\r\n        if (isDataType) {\r\n            nameToType.delete(union.name);\r\n        }\r\n    }\r\n    return nameToType;\r\n}\r\n\r\nfunction isDataType(property: PropertyType, visited: Set<PropertyType>): boolean {\r\n    if (visited.has(property)) {\r\n        return true;\r\n    }\r\n    visited.add(property);\r\n    if (isPropertyUnion(property)) {\r\n        return property.types.every(e => isDataType(e, visited));\r\n    } else if (isValueType(property)) {\r\n        const value = property.value;\r\n        if (isUnionType(value)) {\r\n            return isDataType(value.type, visited);\r\n        } else {\r\n            return false;\r\n        }\r\n    } else {\r\n        return isPrimitiveType(property) || isStringType(property);\r\n    }\r\n}\r\n\r\nfunction addSubTypes(types: TypeOption[]) {\r\n    for (const interfaceType of types) {\r\n        for (const superTypeName of interfaceType.superTypes) {\r\n            superTypeName.subTypes.add(interfaceType);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Builds types of `$container` property.\r\n * @param interfaces Interfaces for which container types are calculated.\r\n */\r\nfunction buildContainerTypes(interfaces: InterfaceType[]) {\r\n    const nameToInterface = interfaces\r\n        .reduce((acc, type) => { acc.set(type.name, type);  return acc; },\r\n            new Map<string, InterfaceType>()\r\n        );\r\n\r\n    // 1st stage: collect container types\r\n\r\n    for (const containerType of interfaces) {\r\n        const types = containerType.properties.flatMap(property => findAstTypes(property.type));\r\n        for (const type of types) {\r\n            nameToInterface.get(type)?.containerTypes.add(containerType);\r\n        }\r\n    }\r\n\r\n    // 2nd stage: lift the container types of containers to parents\r\n\r\n    // if one of the children has no container types, the parent also loses container types\r\n    // contains type names that have children and at least one of them has no container types\r\n    const emptyContainerTypes: Set<string> = new Set();\r\n\r\n    const queue: InterfaceType[] = interfaces.filter(interf => interf.subTypes.size === 0);\r\n    const visited: Set<InterfaceType> = new Set(queue);\r\n\r\n    while (queue.length > 0) {\r\n        const interf = queue.shift();\r\n        if (interf) {\r\n            for (const superType of interf.superTypes) {\r\n                if (isInterfaceType(superType)) {\r\n                    if (interf.containerTypes.size === 0) {\r\n                        emptyContainerTypes.add(superType.name);\r\n                        superType.containerTypes.clear();\r\n                    } else if (!emptyContainerTypes.has(superType.name)) {\r\n                        interf.containerTypes.forEach(e => superType.containerTypes.add(e));\r\n                    }\r\n\r\n                    if (!visited.has(superType)) {\r\n                        visited.add(superType);\r\n                        queue.push(superType);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * This file was generated by langium-cli 2.1.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\nimport type { LanguageMetaData } from '../language-meta-data.js';\r\nimport type { Module } from '../../dependency-injection.js';\r\nimport type { LangiumGeneratedServices, LangiumGeneratedSharedServices, LangiumSharedServices, LangiumServices } from '../../services.js';\r\nimport type { IParserConfig } from '../../parser/parser-config.js';\r\nimport { LangiumGrammarAstReflection } from './ast.js';\r\nimport { LangiumGrammarGrammar } from './grammar.js';\r\n\r\nexport const LangiumGrammarLanguageMetaData = {\r\n    languageId: 'langium',\r\n    fileExtensions: ['.langium'],\r\n    caseInsensitive: false\r\n} as const satisfies LanguageMetaData;\r\n\r\nexport const LangiumGrammarParserConfig: IParserConfig = {\r\n    maxLookahead: 3,\r\n};\r\n\r\nexport const LangiumGrammarGeneratedSharedModule: Module<LangiumSharedServices, LangiumGeneratedSharedServices> = {\r\n    AstReflection: () => new LangiumGrammarAstReflection()\r\n};\r\n\r\nexport const LangiumGrammarGeneratedModule: Module<LangiumServices, LangiumGeneratedServices> = {\r\n    Grammar: () => LangiumGrammarGrammar(),\r\n    LanguageMetaData: () => LangiumGrammarLanguageMetaData,\r\n    parser: {\r\n        ParserConfig: () => LangiumGrammarParserConfig\r\n    }\r\n};\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNodeDescription } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { EMPTY_STREAM, stream } from '../utils/stream.js';\r\n\r\n/**\r\n * A scope describes what target elements are visible from a specific cross-reference context.\r\n */\r\nexport interface Scope {\r\n\r\n    /**\r\n     * Find a target element matching the given name. If no element is found, `undefined` is returned.\r\n     * If multiple matching elements are present, the selection of the returned element should be done\r\n     * according to the semantics of your language. Usually it is the element that is most closely defined.\r\n     *\r\n     * @param name Name of the cross-reference target as it appears in the source text.\r\n     */\r\n    getElement(name: string): AstNodeDescription | undefined;\r\n\r\n    /**\r\n     * Create a stream of all elements in the scope. This is used to compute completion proposals to be\r\n     * shown in the editor.\r\n     */\r\n    getAllElements(): Stream<AstNodeDescription>;\r\n\r\n}\r\n\r\nexport interface ScopeOptions {\r\n    caseInsensitive?: boolean;\r\n}\r\n\r\n/**\r\n * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing\r\n * the next level of elements, which are queried when a target element is not found in the stream provided\r\n * to this scope.\r\n */\r\nexport class StreamScope implements Scope {\r\n    readonly elements: Stream<AstNodeDescription>;\r\n    readonly outerScope?: Scope;\r\n    readonly caseInsensitive: boolean;\r\n\r\n    constructor(elements: Stream<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions) {\r\n        this.elements = elements;\r\n        this.outerScope = outerScope;\r\n        this.caseInsensitive = options?.caseInsensitive ?? false;\r\n    }\r\n\r\n    getAllElements(): Stream<AstNodeDescription> {\r\n        if (this.outerScope) {\r\n            return this.elements.concat(this.outerScope.getAllElements());\r\n        } else {\r\n            return this.elements;\r\n        }\r\n    }\r\n\r\n    getElement(name: string): AstNodeDescription | undefined {\r\n        const local = this.caseInsensitive\r\n            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())\r\n            : this.elements.find(e => e.name === name);\r\n        if (local) {\r\n            return local;\r\n        }\r\n        if (this.outerScope) {\r\n            return this.outerScope.getElement(name);\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n\r\nexport class MapScope implements Scope {\r\n    readonly elements: Map<string, AstNodeDescription>;\r\n    readonly outerScope?: Scope;\r\n    readonly caseInsensitive: boolean;\r\n\r\n    constructor(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions) {\r\n        this.elements = new Map();\r\n        this.caseInsensitive = options?.caseInsensitive ?? false;\r\n        for (const element of elements) {\r\n            const name = this.caseInsensitive\r\n                ? element.name.toLowerCase()\r\n                : element.name;\r\n            this.elements.set(name, element);\r\n        }\r\n        this.outerScope = outerScope;\r\n    }\r\n\r\n    getElement(name: string): AstNodeDescription | undefined {\r\n        const localName = this.caseInsensitive ? name.toLowerCase() : name;\r\n        const local = this.elements.get(localName);\r\n        if (local) {\r\n            return local;\r\n        }\r\n        if (this.outerScope) {\r\n            return this.outerScope.getElement(name);\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    getAllElements(): Stream<AstNodeDescription> {\r\n        let elementStream = stream(this.elements.values());\r\n        if (this.outerScope) {\r\n            elementStream = elementStream.concat(this.outerScope.getAllElements());\r\n        }\r\n        return elementStream;\r\n    }\r\n\r\n}\r\n\r\nexport const EMPTY_SCOPE: Scope = {\r\n    getElement(): undefined {\r\n        return undefined;\r\n    },\r\n    getAllElements(): Stream<AstNodeDescription> {\r\n        return EMPTY_STREAM;\r\n    }\r\n};\r\n", "/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\r\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\r\nimport type { LangiumDocument, PrecomputedScopes } from '../workspace/documents.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport { CancellationToken } from 'vscode-jsonrpc';\r\nimport { streamAllContents, streamContents } from '../utils/ast-util.js';\r\nimport { MultiMap } from '../utils/collections.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\n\r\n/**\r\n * Language-specific service for precomputing global and local scopes. The service methods are executed\r\n * as the first and second phase in the `DocumentBuilder`.\r\n */\r\nexport interface ScopeComputation {\r\n\r\n    /**\r\n     * Creates descriptions of all AST nodes that shall be exported into the _global_ scope from the given\r\n     * document. These descriptions are gathered by the `IndexManager` and stored in the global index so\r\n     * they can be referenced from other documents.\r\n     *\r\n     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference resolution\r\n     * depends on the scope computation phase to be completed (`computeScope` method), which runs after the\r\n     * initial indexing where this method is used.\r\n     *\r\n     * @param document The document from which to gather exported AST nodes.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    computeExports(document: LangiumDocument, cancelToken?: CancellationToken): Promise<AstNodeDescription[]>;\r\n\r\n    /**\r\n     * Precomputes the _local_ scopes for a document, which are necessary for the default way of\r\n     * resolving references to symbols in the same document. The result is a multimap assigning a\r\n     * set of AST node descriptions to every level of the AST. These data are used by the `ScopeProvider`\r\n     * service to determine which target nodes are visible in the context of a specific cross-reference.\r\n     *\r\n     * _Note:_ You should not resolve any cross-references in this service method. Cross-reference\r\n     * resolution depends on the scope computation phase to be completed.\r\n     *\r\n     * @param document The document in which to compute scopes.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    computeLocalScopes(document: LangiumDocument, cancelToken?: CancellationToken): Promise<PrecomputedScopes>;\r\n\r\n}\r\n\r\n/**\r\n * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the\r\n * _global_ scope from the given document. By default those are the document's root AST node and its directly\r\n * contained child nodes.\r\n *\r\n * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them\r\n * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,\r\n * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)\r\n * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)\r\n * are _invisible_ by default, but that can be changed by customizing this service.\r\n */\r\nexport class DefaultScopeComputation implements ScopeComputation {\r\n\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly descriptions: AstNodeDescriptionProvider;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\r\n    }\r\n\r\n    async computeExports(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<AstNodeDescription[]> {\r\n        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);\r\n    }\r\n\r\n    /**\r\n     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.\r\n     * The list of children to be considered is determined by the function parameter {@link children}.\r\n     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.\r\n     *\r\n     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.\r\n     * @param document The document containing the AST node to be exported.\r\n     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution.\r\n     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.\r\n     */\r\n    async computeExportsForNode(parentNode: AstNode, document: LangiumDocument<AstNode>, children: (root: AstNode) => Iterable<AstNode> = streamContents, cancelToken: CancellationToken = CancellationToken.None): Promise<AstNodeDescription[]> {\r\n        const exports: AstNodeDescription[] = [];\r\n\r\n        this.exportNode(parentNode, exports, document);\r\n        for (const node of children(parentNode)) {\r\n            await interruptAndCheck(cancelToken);\r\n            this.exportNode(node, exports, document);\r\n        }\r\n        return exports;\r\n    }\r\n\r\n    /**\r\n     * Add a single node to the list of exports if it has a name. Override this method to change how\r\n     * symbols are exported, e.g. by modifying their exported name.\r\n     */\r\n    protected exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void {\r\n        const name = this.nameProvider.getName(node);\r\n        if (name) {\r\n            exports.push(this.descriptions.createDescription(node, name, document));\r\n        }\r\n    }\r\n\r\n    async computeLocalScopes(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<PrecomputedScopes> {\r\n        const rootNode = document.parseResult.value;\r\n        const scopes = new MultiMap<AstNode, AstNodeDescription>();\r\n        // Here we navigate the full AST - local scopes shall be available in the whole document\r\n        for (const node of streamAllContents(rootNode)) {\r\n            await interruptAndCheck(cancelToken);\r\n            this.processNode(node, document, scopes);\r\n        }\r\n        return scopes;\r\n    }\r\n\r\n    /**\r\n     * Process a single node during scopes computation. The default implementation makes the node visible\r\n     * in the subtree of its container (if the node has a name). Override this method to change this,\r\n     * e.g. by increasing the visibility to a higher level in the AST.\r\n     */\r\n    protected processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void {\r\n        const container = node.$container;\r\n        if (container) {\r\n            const name = this.nameProvider.getName(node);\r\n            if (name) {\r\n                scopes.add(container, this.descriptions.createDescription(node, name, document));\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Disposable } from './disposable.js';\r\nimport type { URI } from './uri-util.js';\r\nimport type { LangiumSharedServices } from '../services.js';\r\n\r\nexport abstract class DisposableCache implements Disposable {\r\n\r\n    protected toDispose: Disposable[] = [];\r\n    protected isDisposed = false;\r\n\r\n    onDispose(disposable: Disposable): void {\r\n        this.toDispose.push(disposable);\r\n    }\r\n\r\n    dispose(): void {\r\n        this.throwIfDisposed();\r\n        this.clear();\r\n        this.isDisposed = true;\r\n        this.toDispose.forEach(disposable => disposable.dispose());\r\n    }\r\n\r\n    protected throwIfDisposed(): void {\r\n        if (this.isDisposed) {\r\n            throw new Error('This cache has already been disposed');\r\n        }\r\n    }\r\n\r\n    abstract clear(): void;\r\n}\r\n\r\nexport class SimpleCache<K, V> extends DisposableCache {\r\n    protected readonly cache = new Map<K, V>();\r\n\r\n    has(key: K): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cache.has(key);\r\n    }\r\n\r\n    set(key: K, value: V): void {\r\n        this.throwIfDisposed();\r\n        this.cache.set(key, value);\r\n    }\r\n\r\n    get(key: K): V | undefined;\r\n    get(key: K, provider: () => V): V;\r\n    get(key: K, provider?: () => V): V | undefined {\r\n        this.throwIfDisposed();\r\n        if (this.cache.has(key)) {\r\n            return this.cache.get(key);\r\n        } else if (provider) {\r\n            const value = provider();\r\n            this.cache.set(key, value);\r\n            return value;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    delete(key: K): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cache.delete(key);\r\n    }\r\n\r\n    clear(): void {\r\n        this.throwIfDisposed();\r\n        this.cache.clear();\r\n    }\r\n}\r\n\r\nexport class ContextCache<Context, Key, Value, ContextKey = Context> extends DisposableCache {\r\n\r\n    private readonly cache = new Map<ContextKey | Context, Map<Key, Value>>();\r\n    private readonly converter: (input: Context) => ContextKey | Context;\r\n\r\n    constructor(converter?: (input: Context) => ContextKey) {\r\n        super();\r\n        this.converter = converter ?? (value => value);\r\n    }\r\n\r\n    has(contextKey: Context, key: Key): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cacheForContext(contextKey).has(key);\r\n    }\r\n\r\n    set(contextKey: Context, key: Key, value: Value): void {\r\n        this.throwIfDisposed();\r\n        this.cacheForContext(contextKey).set(key, value);\r\n    }\r\n\r\n    get(contextKey: Context, key: Key): Value | undefined;\r\n    get(contextKey: Context, key: Key, provider: () => Value): Value;\r\n    get(contextKey: Context, key: Key, provider?: () => Value): Value | undefined {\r\n        this.throwIfDisposed();\r\n        const contextCache = this.cacheForContext(contextKey);\r\n        if (contextCache.has(key)) {\r\n            return contextCache.get(key);\r\n        } else if (provider) {\r\n            const value = provider();\r\n            contextCache.set(key, value);\r\n            return value;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    delete(contextKey: Context, key: Key): boolean {\r\n        this.throwIfDisposed();\r\n        return this.cacheForContext(contextKey).delete(key);\r\n    }\r\n\r\n    clear(): void;\r\n    clear(contextKey: Context): void;\r\n    clear(contextKey?: Context): void {\r\n        this.throwIfDisposed();\r\n        if (contextKey) {\r\n            const mapKey = this.converter(contextKey);\r\n            this.cache.delete(mapKey);\r\n        } else {\r\n            this.cache.clear();\r\n        }\r\n    }\r\n\r\n    protected cacheForContext(contextKey: Context): Map<Key, Value> {\r\n        const mapKey = this.converter(contextKey);\r\n        let documentCache = this.cache.get(mapKey);\r\n        if (!documentCache) {\r\n            documentCache = new Map();\r\n            this.cache.set(mapKey, documentCache);\r\n        }\r\n        return documentCache;\r\n    }\r\n}\r\n\r\n/**\r\n * Every key/value pair in this cache is scoped to a document.\r\n * If this document is changed or deleted, all associated key/value pairs are deleted.\r\n */\r\nexport class DocumentCache<K, V> extends ContextCache<URI | string, K, V, string> {\r\n    constructor(sharedServices: LangiumSharedServices) {\r\n        super(uri => uri.toString());\r\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {\r\n            const allUris = changed.concat(deleted);\r\n            for (const uri of allUris) {\r\n                this.clear(uri);\r\n            }\r\n        }));\r\n    }\r\n}\r\n\r\n/**\r\n * Every key/value pair in this cache is scoped to the whole workspace.\r\n * If any document in the workspace changes, the whole cache is evicted.\r\n */\r\nexport class WorkspaceCache<K, V> extends SimpleCache<K, V> {\r\n    constructor(sharedServices: LangiumSharedServices) {\r\n        super();\r\n        this.onDispose(sharedServices.workspace.DocumentBuilder.onUpdate(() => {\r\n            this.clear();\r\n        }));\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { AstNodeDescriptionProvider } from '../workspace/ast-descriptions.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport type { Scope, ScopeOptions} from './scope.js';\r\nimport { MapScope, StreamScope } from './scope.js';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { WorkspaceCache } from '../utils/caching.js';\r\n\r\n/**\r\n * Language-specific service for determining the scope of target elements visible in a specific cross-reference context.\r\n */\r\nexport interface ScopeProvider {\r\n\r\n    /**\r\n     * Return a scope describing what elements are visible for the given AST node and cross-reference\r\n     * identifier.\r\n     *\r\n     * @param context Information about the reference for which a scope is requested.\r\n     */\r\n    getScope(context: ReferenceInfo): Scope;\r\n\r\n}\r\n\r\nexport class DefaultScopeProvider implements ScopeProvider {\r\n\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly descriptions: AstNodeDescriptionProvider;\r\n    protected readonly indexManager: IndexManager;\r\n\r\n    protected readonly globalScopeCache: WorkspaceCache<string, Scope>;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.descriptions = services.workspace.AstNodeDescriptionProvider;\r\n        this.indexManager = services.shared.workspace.IndexManager;\r\n        this.globalScopeCache = new WorkspaceCache<string, Scope>(services.shared);\r\n    }\r\n\r\n    getScope(context: ReferenceInfo): Scope {\r\n        const scopes: Array<Stream<AstNodeDescription>> = [];\r\n        const referenceType = this.reflection.getReferenceType(context);\r\n\r\n        const precomputed = getDocument(context.container).precomputedScopes;\r\n        if (precomputed) {\r\n            let currentNode: AstNode | undefined = context.container;\r\n            do {\r\n                const allDescriptions = precomputed.get(currentNode);\r\n                if (allDescriptions.length > 0) {\r\n                    scopes.push(stream(allDescriptions).filter(\r\n                        desc => this.reflection.isSubtype(desc.type, referenceType)));\r\n                }\r\n                currentNode = currentNode.$container;\r\n            } while (currentNode);\r\n        }\r\n\r\n        let result: Scope = this.getGlobalScope(referenceType, context);\r\n        for (let i = scopes.length - 1; i >= 0; i--) {\r\n            result = this.createScope(scopes[i], result);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Create a scope for the given collection of AST node descriptions.\r\n     */\r\n    protected createScope(elements: Iterable<AstNodeDescription>, outerScope?: Scope, options?: ScopeOptions): Scope {\r\n        return new StreamScope(stream(elements), outerScope, options);\r\n    }\r\n\r\n    /**\r\n     * Create a scope for the given collection of AST nodes, which need to be transformed into respective\r\n     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.\r\n     */\r\n    protected createScopeForNodes(elements: Iterable<AstNode>, outerScope?: Scope, options?: ScopeOptions): Scope {\r\n        const s = stream(elements).map(e => {\r\n            const name = this.nameProvider.getName(e);\r\n            if (name) {\r\n                return this.descriptions.createDescription(e, name);\r\n            }\r\n            return undefined;\r\n        }).nonNullable();\r\n        return new StreamScope(s, outerScope, options);\r\n    }\r\n\r\n    /**\r\n     * Create a global scope filtered for the given reference type.\r\n     */\r\n    protected getGlobalScope(referenceType: string, _context: ReferenceInfo): Scope {\r\n        return this.globalScopeCache.get(referenceType, () => new MapScope(this.indexManager.allElements(referenceType)));\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Scope } from '../../references/scope.js';\r\nimport type { LangiumServices } from '../../services.js';\r\nimport type { AstNode, AstNodeDescription, ReferenceInfo } from '../../syntax-tree.js';\r\nimport type { Stream } from '../../utils/stream.js';\r\nimport type { AstNodeLocator } from '../../workspace/ast-node-locator.js';\r\nimport type { DocumentSegment, LangiumDocument, LangiumDocuments, PrecomputedScopes } from '../../workspace/documents.js';\r\nimport type { Grammar } from '../generated/ast.js';\r\nimport { EMPTY_SCOPE, MapScope } from '../../references/scope.js';\r\nimport { DefaultScopeComputation } from '../../references/scope-computation.js';\r\nimport { DefaultScopeProvider } from '../../references/scope-provider.js';\r\nimport { findRootNode, getContainerOfType, getDocument, streamAllContents } from '../../utils/ast-util.js';\r\nimport { toDocumentSegment } from '../../utils/cst-util.js';\r\nimport { stream } from '../../utils/stream.js';\r\nimport { AbstractType, Interface, isAction, isGrammar, isParserRule, isReturnType, Type } from '../generated/ast.js';\r\nimport { getActionType, resolveImportUri } from '../internal-grammar-util.js';\r\n\r\nexport class LangiumGrammarScopeProvider extends DefaultScopeProvider {\r\n\r\n    protected readonly langiumDocuments: LangiumDocuments;\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.langiumDocuments = services.shared.workspace.LangiumDocuments;\r\n    }\r\n\r\n    override getScope(context: ReferenceInfo): Scope {\r\n        const referenceType = this.reflection.getReferenceType(context);\r\n        if (referenceType === AbstractType) {\r\n            return this.getTypeScope(referenceType, context);\r\n        } else {\r\n            return super.getScope(context);\r\n        }\r\n    }\r\n\r\n    private getTypeScope(referenceType: string, context: ReferenceInfo): Scope {\r\n        let localScope: Stream<AstNodeDescription> | undefined;\r\n        const precomputed = getDocument(context.container).precomputedScopes;\r\n        const rootNode = findRootNode(context.container);\r\n        if (precomputed && rootNode) {\r\n            const allDescriptions = precomputed.get(rootNode);\r\n            if (allDescriptions.length > 0) {\r\n                localScope = stream(allDescriptions).filter(des => des.type === Interface || des.type === Type);\r\n            }\r\n        }\r\n\r\n        const globalScope = this.getGlobalScope(referenceType, context);\r\n        if (localScope) {\r\n            return this.createScope(localScope, globalScope);\r\n        } else {\r\n            return globalScope;\r\n        }\r\n    }\r\n\r\n    protected override getGlobalScope(referenceType: string, context: ReferenceInfo): Scope {\r\n        const grammar = getContainerOfType(context.container, isGrammar);\r\n        if (!grammar) {\r\n            return EMPTY_SCOPE;\r\n        }\r\n        const importedUris = new Set<string>();\r\n        this.gatherImports(grammar, importedUris);\r\n        let importedElements = this.indexManager.allElements(referenceType, importedUris);\r\n        if (referenceType === AbstractType) {\r\n            importedElements = importedElements.filter(des => des.type === Interface || des.type === Type);\r\n        }\r\n        return new MapScope(importedElements);\r\n    }\r\n\r\n    private gatherImports(grammar: Grammar, importedUris: Set<string>): void {\r\n        for (const imp0rt of grammar.imports) {\r\n            const uri = resolveImportUri(imp0rt);\r\n            if (uri && !importedUris.has(uri.toString())) {\r\n                importedUris.add(uri.toString());\r\n                if (this.langiumDocuments.hasDocument(uri)) {\r\n                    const importedDocument = this.langiumDocuments.getOrCreateDocument(uri);\r\n                    const rootNode = importedDocument.parseResult.value;\r\n                    if (isGrammar(rootNode)) {\r\n                        this.gatherImports(rootNode, importedUris);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\nexport class LangiumGrammarScopeComputation extends DefaultScopeComputation {\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    protected override exportNode(node: AstNode, exports: AstNodeDescription[], document: LangiumDocument): void {\r\n        super.exportNode(node, exports, document);\r\n        if (isParserRule(node)) {\r\n            if (!node.returnType && !node.dataType) {\r\n                // Export inferred rule type as interface\r\n                const typeNode = node.inferredType ?? node;\r\n                exports.push(this.createInterfaceDescription(typeNode, typeNode.name, document));\r\n            }\r\n            streamAllContents(node).forEach(childNode => {\r\n                if (isAction(childNode) && childNode.inferredType) {\r\n                    const typeName = getActionType(childNode);\r\n                    if (typeName) {\r\n                        // Export inferred action type as interface\r\n                        exports.push(this.createInterfaceDescription(childNode, typeName, document));\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n\r\n    protected override processNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void {\r\n        if (isReturnType(node)) return;\r\n        this.processTypeNode(node, document, scopes);\r\n        this.processActionNode(node, document, scopes);\r\n        super.processNode(node, document, scopes);\r\n    }\r\n\r\n    /**\r\n     * Add synthetic Interface in case of explicitly or implicitly inferred type:<br>\r\n     * cases: `ParserRule: ...;` or `ParserRule infers Type: ...;`\r\n     */\r\n    protected processTypeNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void {\r\n        const container = node.$container;\r\n        if (container && isParserRule(node) && !node.returnType && !node.dataType) {\r\n            const typeNode = node.inferredType ?? node;\r\n            scopes.add(container, this.createInterfaceDescription(typeNode, typeNode.name, document));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Add synthetic Interface in case of explicitly inferred type:\r\n     *\r\n     * case: `{infer Action}`\r\n     */\r\n    protected processActionNode(node: AstNode, document: LangiumDocument, scopes: PrecomputedScopes): void {\r\n        const container = findRootNode(node);\r\n        if (container && isAction(node) && node.inferredType) {\r\n            const typeName = getActionType(node);\r\n            if (typeName) {\r\n                scopes.add(container, this.createInterfaceDescription(node, typeName, document));\r\n            }\r\n        }\r\n    }\r\n\r\n    protected createInterfaceDescription(node: AstNode, name: string, document: LangiumDocument = getDocument(node)): AstNodeDescription {\r\n        let nameNodeSegment: DocumentSegment | undefined;\r\n        const nameSegmentGetter = () => nameNodeSegment ??= toDocumentSegment(this.nameProvider.getNameNode(node) ?? node.$cstNode);\r\n        return {\r\n            node,\r\n            name,\r\n            get nameSegment() {\r\n                return nameSegmentGetter();\r\n            },\r\n            selectionSegment: toDocumentSegment(node.$cstNode),\r\n            type: 'Interface',\r\n            documentUri: document.uri,\r\n            path: this.astNodeLocator.getAstNodePath(node)\r\n        };\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Diagnostic } from 'vscode-languageserver';\r\nimport type { CodeActionParams } from 'vscode-languageserver-protocol';\r\nimport type { CodeAction, Command, Position, TextEdit } from 'vscode-languageserver-types';\r\nimport type { URI } from '../../utils/uri-util.js';\r\nimport type { CodeActionProvider } from '../../lsp/code-action.js';\r\nimport type { LangiumServices } from '../../services.js';\r\nimport type { AstReflection, Reference, ReferenceInfo } from '../../syntax-tree.js';\r\nimport type { MaybePromise } from '../../utils/promise-util.js';\r\nimport type { LinkingErrorData } from '../../validation/document-validator.js';\r\nimport type { DiagnosticData } from '../../validation/validation-registry.js';\r\nimport type { LangiumDocument } from '../../workspace/documents.js';\r\nimport type { IndexManager } from '../../workspace/index-manager.js';\r\nimport { CodeActionKind } from 'vscode-languageserver';\r\nimport { getContainerOfType } from '../../utils/ast-util.js';\r\nimport { findLeafNodeAtOffset } from '../../utils/cst-util.js';\r\nimport { findNodeForProperty } from '../../utils/grammar-util.js';\r\nimport { escapeRegExp } from '../../utils/regex-util.js';\r\nimport { UriUtils } from '../../utils/uri-util.js';\r\nimport { DocumentValidator } from '../../validation/document-validator.js';\r\nimport * as ast from '../generated/ast.js';\r\nimport { IssueCodes } from '../validation/validator.js';\r\n\r\nexport class LangiumGrammarCodeActionProvider implements CodeActionProvider {\r\n\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly indexManager: IndexManager;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.indexManager = services.shared.workspace.IndexManager;\r\n    }\r\n\r\n    getCodeActions(document: LangiumDocument, params: CodeActionParams): MaybePromise<Array<Command | CodeAction>> {\r\n        const result: CodeAction[] = [];\r\n        const acceptor = (ca: CodeAction | undefined) => ca && result.push(ca);\r\n        for (const diagnostic of params.context.diagnostics) {\r\n            this.createCodeActions(diagnostic, document, acceptor);\r\n        }\r\n        return result;\r\n    }\r\n\r\n    private createCodeActions(diagnostic: Diagnostic, document: LangiumDocument, accept: (ca: CodeAction | undefined) => void): void {\r\n        switch ((diagnostic.data as DiagnosticData)?.code) {\r\n            case IssueCodes.GrammarNameUppercase:\r\n            case IssueCodes.RuleNameUppercase:\r\n                accept(this.makeUpperCase(diagnostic, document));\r\n                break;\r\n            case IssueCodes.HiddenGrammarTokens:\r\n                accept(this.fixHiddenTerminals(diagnostic, document));\r\n                break;\r\n            case IssueCodes.UseRegexTokens:\r\n                accept(this.fixRegexTokens(diagnostic, document));\r\n                break;\r\n            case IssueCodes.EntryRuleTokenSyntax:\r\n                accept(this.addEntryKeyword(diagnostic, document));\r\n                break;\r\n            case IssueCodes.CrossRefTokenSyntax:\r\n                accept(this.fixCrossRefSyntax(diagnostic, document));\r\n                break;\r\n            case IssueCodes.UnnecessaryFileExtension:\r\n                accept(this.fixUnnecessaryFileExtension(diagnostic, document));\r\n                break;\r\n            case IssueCodes.MissingReturns:\r\n                accept(this.fixMissingReturns(diagnostic, document));\r\n                break;\r\n            case IssueCodes.InvalidInfers:\r\n            case IssueCodes.InvalidReturns:\r\n                accept(this.fixInvalidReturnsInfers(diagnostic, document));\r\n                break;\r\n            case IssueCodes.MissingInfer:\r\n                accept(this.fixMissingInfer(diagnostic, document));\r\n                break;\r\n            case IssueCodes.SuperfluousInfer:\r\n                accept(this.fixSuperfluousInfer(diagnostic, document));\r\n                break;\r\n            case DocumentValidator.LinkingError: {\r\n                const data = diagnostic.data as LinkingErrorData;\r\n                if (data && data.containerType === 'RuleCall' && data.property === 'rule') {\r\n                    accept(this.addNewRule(diagnostic, data, document));\r\n                }\r\n                if (data) {\r\n                    this.lookInGlobalScope(diagnostic, data, document).forEach(accept);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Adds missing returns for parser rule\r\n     */\r\n    private fixMissingReturns(diagnostic: Diagnostic, document: LangiumDocument): CodeAction | undefined {\r\n        const text = document.textDocument.getText(diagnostic.range);\r\n        if (text) {\r\n            return {\r\n                title: `Add explicit return type for parser rule ${text}`,\r\n                kind: CodeActionKind.QuickFix,\r\n                diagnostics: [diagnostic],\r\n                edit: {\r\n                    changes: {\r\n                        [document.textDocument.uri]: [{\r\n                            range: diagnostic.range,\r\n                            newText: `${text} returns ${text}` // suggestion adds missing 'return'\r\n                        }]\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private fixInvalidReturnsInfers(diagnostic: Diagnostic, document: LangiumDocument): CodeAction | undefined {\r\n        const data = diagnostic.data as DiagnosticData;\r\n        if (data && data.actionSegment) {\r\n            const text = document.textDocument.getText(data.actionSegment.range);\r\n            return {\r\n                title: `Correct ${text} usage`,\r\n                kind: CodeActionKind.QuickFix,\r\n                diagnostics: [diagnostic],\r\n                edit: {\r\n                    changes: {\r\n                        [document.textDocument.uri]: [{\r\n                            range: data.actionSegment.range,\r\n                            newText: text === 'infers' ? 'returns' : 'infers'\r\n                        }]\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private fixMissingInfer(diagnostic: Diagnostic, document: LangiumDocument): CodeAction | undefined {\r\n        const data = diagnostic.data as DiagnosticData;\r\n        if (data && data.actionSegment) {\r\n            return {\r\n                title: \"Correct 'infer' usage\",\r\n                kind: CodeActionKind.QuickFix,\r\n                diagnostics: [diagnostic],\r\n                edit: {\r\n                    changes: {\r\n                        [document.textDocument.uri]: [{\r\n                            range: {\r\n                                start: data.actionSegment.range.end,\r\n                                end: data.actionSegment.range.end\r\n                            },\r\n                            newText: 'infer '\r\n                        }]\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private fixSuperfluousInfer(diagnostic: Diagnostic, document: LangiumDocument): CodeAction | undefined {\r\n        const data = diagnostic.data as DiagnosticData;\r\n        if (data && data.actionRange) {\r\n            return {\r\n                title: \"Remove the 'infer' keyword\",\r\n                kind: CodeActionKind.QuickFix,\r\n                diagnostics: [diagnostic],\r\n                edit: {\r\n                    changes: {\r\n                        [document.textDocument.uri]: [{\r\n                            range: data.actionRange,\r\n                            newText: ''\r\n                        }]\r\n                    }\r\n                }\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private fixUnnecessaryFileExtension(diagnostic: Diagnostic, document: LangiumDocument): CodeAction {\r\n        const end = {...diagnostic.range.end};\r\n        end.character -= 1;\r\n        const start = {...end};\r\n        start.character -= '.langium'.length;\r\n        return {\r\n            title: 'Remove file extension',\r\n            kind: CodeActionKind.QuickFix,\r\n            diagnostics: [diagnostic],\r\n            isPreferred: true,\r\n            edit: {\r\n                changes: {\r\n                    [document.textDocument.uri]: [{\r\n                        range: {\r\n                            start,\r\n                            end\r\n                        },\r\n                        newText: ''\r\n                    }]\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private makeUpperCase(diagnostic: Diagnostic, document: LangiumDocument): CodeAction {\r\n        const range = {\r\n            start: diagnostic.range.start,\r\n            end: {\r\n                line: diagnostic.range.start.line,\r\n                character: diagnostic.range.start.character + 1\r\n            }\r\n        };\r\n        return {\r\n            title: 'First letter to upper case',\r\n            kind: CodeActionKind.QuickFix,\r\n            diagnostics: [diagnostic],\r\n            isPreferred: true,\r\n            edit: {\r\n                changes: {\r\n                    [document.textDocument.uri]: [{\r\n                        range,\r\n                        newText: document.textDocument.getText(range).toUpperCase()\r\n                    }]\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private addEntryKeyword(diagnostic: Diagnostic, document: LangiumDocument): CodeAction | undefined {\r\n        return {\r\n            title: 'Add entry keyword',\r\n            kind: CodeActionKind.QuickFix,\r\n            diagnostics: [diagnostic],\r\n            isPreferred: true,\r\n            edit: {\r\n                changes: {\r\n                    [document.textDocument.uri]: [{\r\n                        range: {start: diagnostic.range.start, end: diagnostic.range.start},\r\n                        newText: 'entry '\r\n                    }]\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private fixRegexTokens(diagnostic: Diagnostic, document: LangiumDocument): CodeAction | undefined {\r\n        const offset = document.textDocument.offsetAt(diagnostic.range.start);\r\n        const rootCst = document.parseResult.value.$cstNode;\r\n        if (rootCst) {\r\n            const cstNode = findLeafNodeAtOffset(rootCst, offset);\r\n            const container = getContainerOfType(cstNode?.astNode, ast.isCharacterRange);\r\n            if (container && container.right && container.$cstNode) {\r\n                const left = container.left.value;\r\n                const right = container.right.value;\r\n                return {\r\n                    title: 'Refactor into regular expression',\r\n                    kind: CodeActionKind.QuickFix,\r\n                    diagnostics: [diagnostic],\r\n                    isPreferred: true,\r\n                    edit: {\r\n                        changes: {\r\n                            [document.textDocument.uri]: [{\r\n                                range: container.$cstNode.range,\r\n                                newText: `/[${escapeRegExp(left)}-${escapeRegExp(right)}]/`\r\n                            }]\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private fixCrossRefSyntax(diagnostic: Diagnostic, document: LangiumDocument): CodeAction {\r\n        return {\r\n            title: \"Replace '|' with ':'\",\r\n            kind: CodeActionKind.QuickFix,\r\n            diagnostics: [diagnostic],\r\n            isPreferred: true,\r\n            edit: {\r\n                changes: {\r\n                    [document.textDocument.uri]: [{\r\n                        range: diagnostic.range,\r\n                        newText: ':'\r\n                    }]\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private fixHiddenTerminals(diagnostic: Diagnostic, document: LangiumDocument): CodeAction {\r\n        const grammar = document.parseResult.value as ast.Grammar;\r\n        const hiddenTokens = grammar.hiddenTokens;\r\n        const changes: TextEdit[] = [];\r\n        const hiddenNode = findNodeForProperty(grammar.$cstNode, 'definesHiddenTokens');\r\n        if (hiddenNode) {\r\n            const start = hiddenNode.range.start;\r\n            const offset = hiddenNode.offset;\r\n            const end = grammar.$cstNode!.text.indexOf(')', offset) + 1;\r\n            changes.push({\r\n                newText: '',\r\n                range: {\r\n                    start,\r\n                    end: document.textDocument.positionAt(end)\r\n                }\r\n            });\r\n        }\r\n        for (const terminal of hiddenTokens) {\r\n            const ref = terminal.ref;\r\n            if (ref && ast.isTerminalRule(ref) && !ref.hidden && ref.$cstNode) {\r\n                const start = ref.$cstNode.range.start;\r\n                changes.push({\r\n                    newText: 'hidden ',\r\n                    range: {\r\n                        start,\r\n                        end: start\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        return {\r\n            title: 'Fix hidden terminals',\r\n            kind: CodeActionKind.QuickFix,\r\n            diagnostics: [diagnostic],\r\n            isPreferred: true,\r\n            edit: {\r\n                changes: {\r\n                    [document.textDocument.uri]: changes\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n    private addNewRule(diagnostic: Diagnostic, data: LinkingErrorData, document: LangiumDocument): CodeAction | undefined {\r\n        const offset = document.textDocument.offsetAt(diagnostic.range.start);\r\n        const rootCst = document.parseResult.value.$cstNode;\r\n        if (rootCst) {\r\n            const cstNode = findLeafNodeAtOffset(rootCst, offset);\r\n            const container = getContainerOfType(cstNode?.astNode, ast.isParserRule);\r\n            if (container && container.$cstNode) {\r\n                return {\r\n                    title: `Add new rule '${data.refText}'`,\r\n                    kind: CodeActionKind.QuickFix,\r\n                    diagnostics: [diagnostic],\r\n                    isPreferred: false,\r\n                    edit: {\r\n                        changes: {\r\n                            [document.textDocument.uri]: [{\r\n                                range: {\r\n                                    start: container.$cstNode.range.end,\r\n                                    end: container.$cstNode.range.end\r\n                                },\r\n                                newText: '\\n\\n' + data.refText + ':\\n    /* TODO implement rule */ {infer ' + data.refText + '};'\r\n                            }]\r\n                        }\r\n                    }\r\n                };\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    private lookInGlobalScope(diagnostic: Diagnostic, data: LinkingErrorData, document: LangiumDocument): CodeAction[] {\r\n        const refInfo: ReferenceInfo = {\r\n            container: {\r\n                $type: data.containerType\r\n            },\r\n            property: data.property,\r\n            reference: {\r\n                $refText: data.refText\r\n            } as Reference\r\n        };\r\n        const referenceType = this.reflection.getReferenceType(refInfo);\r\n        const candidates = this.indexManager.allElements(referenceType).filter(e => e.name === data.refText);\r\n\r\n        const result: CodeAction[] = [];\r\n        let shortestPathIndex = -1;\r\n        let shortestPathLength = -1;\r\n        for (const candidate of candidates) {\r\n            if (UriUtils.equals(candidate.documentUri, document.uri)) {\r\n                continue;\r\n            }\r\n            // Find an import path and a position to insert the import\r\n            const importPath = getRelativeImport(document.uri, candidate.documentUri);\r\n            let position: Position | undefined;\r\n            let suffix = '';\r\n            const grammar = document.parseResult.value as ast.Grammar;\r\n            const nextImport = grammar.imports.find(imp => imp.path && importPath < imp.path);\r\n            if (nextImport) {\r\n                // Insert the new import alphabetically\r\n                position = nextImport.$cstNode?.range.start;\r\n            } else if (grammar.imports.length > 0) {\r\n                // Put the new import after the last import\r\n                const rangeEnd = grammar.imports[grammar.imports.length - 1].$cstNode!.range.end;\r\n                if (rangeEnd) {\r\n                    position = { line: rangeEnd.line + 1, character: 0 };\r\n                }\r\n            } else if (grammar.rules.length > 0) {\r\n                // Put the new import before the first rule\r\n                position = grammar.rules[0].$cstNode?.range.start;\r\n                suffix = '\\n';\r\n            }\r\n\r\n            if (position) {\r\n                if (shortestPathIndex < 0 || importPath.length < shortestPathLength) {\r\n                    shortestPathIndex = result.length;\r\n                    shortestPathLength = importPath.length;\r\n                }\r\n                // Add an import declaration for the candidate in the global scope\r\n                result.push({\r\n                    title: `Add import to '${importPath}'`,\r\n                    kind: CodeActionKind.QuickFix,\r\n                    diagnostics: [diagnostic],\r\n                    isPreferred: false,\r\n                    edit: {\r\n                        changes: {\r\n                            [document.textDocument.uri]: [{\r\n                                range: {\r\n                                    start: position,\r\n                                    end: position\r\n                                },\r\n                                newText: `import '${importPath}'\\n${suffix}`\r\n                            }]\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        // Mark the code action with the shortest import path as preferred\r\n        if (shortestPathIndex >= 0) {\r\n            result[shortestPathIndex].isPreferred = true;\r\n        }\r\n        return result;\r\n    }\r\n\r\n}\r\n\r\nfunction getRelativeImport(source: URI, target: URI): string {\r\n    const sourceDir = UriUtils.dirname(source);\r\n    let relativePath = UriUtils.relative(sourceDir, target);\r\n    if (!relativePath.startsWith('./') && !relativePath.startsWith('../')) {\r\n        relativePath = './' + relativePath;\r\n    }\r\n    if (relativePath.endsWith('.langium')) {\r\n        relativePath = relativePath.substring(0, relativePath.length - '.langium'.length);\r\n    }\r\n    return relativePath;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { MismatchedTokenException } from 'chevrotain';\r\nimport type { Diagnostic } from 'vscode-languageserver';\r\nimport type { LanguageMetaData } from '../grammar/language-meta-data.js';\r\nimport type { ParseResult } from '../parser/langium-parser.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport type { DiagnosticData, DiagnosticInfo, ValidationAcceptor, ValidationCategory, ValidationRegistry } from './validation-registry.js';\r\nimport { CancellationToken, DiagnosticSeverity, Position, Range } from 'vscode-languageserver';\r\nimport { findNodeForKeyword, findNodeForProperty } from '../utils/grammar-util.js';\r\nimport { streamAst } from '../utils/ast-util.js';\r\nimport { tokenToRange } from '../utils/cst-util.js';\r\nimport { interruptAndCheck, isOperationCancelled } from '../utils/promise-util.js';\r\nimport { diagnosticData } from './validation-registry.js';\r\n\r\nexport interface ValidationOptions {\r\n    /**\r\n     * If this is set, only the checks associated with these categories are executed; otherwise\r\n     * all checks are executed. The default category if not specified to the registry is `'fast'`.\r\n     */\r\n    categories?: ValidationCategory[];\r\n    /** If true, no further diagnostics are reported if there are lexing errors. */\r\n    stopAfterLexingErrors?: boolean\r\n    /** If true, no further diagnostics are reported if there are parsing errors. */\r\n    stopAfterParsingErrors?: boolean\r\n    /** If true, no further diagnostics are reported if there are linking errors. */\r\n    stopAfterLinkingErrors?: boolean\r\n}\r\n\r\n/**\r\n * Language-specific service for validating `LangiumDocument`s.\r\n */\r\nexport interface DocumentValidator {\r\n    /**\r\n     * Validates the whole specified document.\r\n     *\r\n     * @param document specified document to validate\r\n     * @param options options to control the validation process\r\n     * @param cancelToken allows to cancel the current operation\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    validateDocument(document: LangiumDocument, options?: ValidationOptions, cancelToken?: CancellationToken): Promise<Diagnostic[]>;\r\n}\r\n\r\nexport class DefaultDocumentValidator implements DocumentValidator {\r\n\r\n    protected readonly validationRegistry: ValidationRegistry;\r\n    protected readonly metadata: LanguageMetaData;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.validationRegistry = services.validation.ValidationRegistry;\r\n        this.metadata = services.LanguageMetaData;\r\n    }\r\n\r\n    async validateDocument(document: LangiumDocument, options: ValidationOptions = {}, cancelToken = CancellationToken.None): Promise<Diagnostic[]> {\r\n        const parseResult = document.parseResult;\r\n        const diagnostics: Diagnostic[] = [];\r\n\r\n        await interruptAndCheck(cancelToken);\r\n\r\n        if (!options.categories || options.categories.includes('built-in')) {\r\n            this.processLexingErrors(parseResult, diagnostics, options);\r\n            if (options.stopAfterLexingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.LexingError)) {\r\n                return diagnostics;\r\n            }\r\n\r\n            this.processParsingErrors(parseResult, diagnostics, options);\r\n            if (options.stopAfterParsingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.ParsingError)) {\r\n                return diagnostics;\r\n            }\r\n\r\n            this.processLinkingErrors(document, diagnostics, options);\r\n            if (options.stopAfterLinkingErrors && diagnostics.some(d => d.data?.code === DocumentValidator.LinkingError)) {\r\n                return diagnostics;\r\n            }\r\n        }\r\n\r\n        // Process custom validations\r\n        try {\r\n            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));\r\n        } catch (err) {\r\n            if (isOperationCancelled(err)) {\r\n                throw err;\r\n            }\r\n            console.error('An error occurred during validation:', err);\r\n        }\r\n\r\n        await interruptAndCheck(cancelToken);\r\n\r\n        return diagnostics;\r\n    }\r\n\r\n    protected processLexingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void {\r\n        for (const lexerError of parseResult.lexerErrors) {\r\n            const diagnostic: Diagnostic = {\r\n                severity: DiagnosticSeverity.Error,\r\n                range: {\r\n                    start: {\r\n                        line: lexerError.line! - 1,\r\n                        character: lexerError.column! - 1\r\n                    },\r\n                    end: {\r\n                        line: lexerError.line! - 1,\r\n                        character: lexerError.column! + lexerError.length - 1\r\n                    }\r\n                },\r\n                message: lexerError.message,\r\n                data: diagnosticData(DocumentValidator.LexingError),\r\n                source: this.getSource()\r\n            };\r\n            diagnostics.push(diagnostic);\r\n        }\r\n    }\r\n\r\n    protected processParsingErrors(parseResult: ParseResult, diagnostics: Diagnostic[], _options: ValidationOptions): void {\r\n        for (const parserError of parseResult.parserErrors) {\r\n            let range: Range | undefined = undefined;\r\n            // We can run into the chevrotain error recovery here\r\n            // The token contained in the parser error might be automatically inserted\r\n            // In this case every position value will be `NaN`\r\n            if (isNaN(parserError.token.startOffset)) {\r\n                // Some special parser error types contain a `previousToken`\r\n                // We can simply append our diagnostic to that token\r\n                if ('previousToken' in parserError) {\r\n                    const token = (parserError as MismatchedTokenException).previousToken;\r\n                    if (!isNaN(token.startOffset)) {\r\n                        const position = Position.create(token.endLine! - 1, token.endColumn!);\r\n                        range = Range.create(position, position);\r\n                    } else {\r\n                        // No valid prev token. Might be empty document or containing only hidden tokens.\r\n                        // Point to document start\r\n                        range = Range.create(0, 0, 0, 0);\r\n                    }\r\n                }\r\n            } else {\r\n                range = tokenToRange(parserError.token);\r\n            }\r\n            if (range) {\r\n                const diagnostic: Diagnostic = {\r\n                    severity: DiagnosticSeverity.Error,\r\n                    range,\r\n                    message: parserError.message,\r\n                    data: diagnosticData(DocumentValidator.ParsingError),\r\n                    source: this.getSource()\r\n                };\r\n                diagnostics.push(diagnostic);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected processLinkingErrors(document: LangiumDocument, diagnostics: Diagnostic[], _options: ValidationOptions): void {\r\n        for (const reference of document.references) {\r\n            const linkingError = reference.error;\r\n            if (linkingError) {\r\n                const info: DiagnosticInfo<AstNode, string> = {\r\n                    node: linkingError.container,\r\n                    property: linkingError.property,\r\n                    index: linkingError.index,\r\n                    data: {\r\n                        code: DocumentValidator.LinkingError,\r\n                        containerType: linkingError.container.$type,\r\n                        property: linkingError.property,\r\n                        refText: linkingError.reference.$refText\r\n                    } satisfies LinkingErrorData\r\n                };\r\n                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async validateAst(rootNode: AstNode, options: ValidationOptions, cancelToken = CancellationToken.None): Promise<Diagnostic[]> {\r\n        const validationItems: Diagnostic[] = [];\r\n        const acceptor: ValidationAcceptor = <N extends AstNode>(severity: 'error' | 'warning' | 'info' | 'hint', message: string, info: DiagnosticInfo<N>) => {\r\n            validationItems.push(this.toDiagnostic(severity, message, info));\r\n        };\r\n\r\n        await Promise.all(streamAst(rootNode).map(async node => {\r\n            await interruptAndCheck(cancelToken);\r\n            const checks = this.validationRegistry.getChecks(node.$type, options.categories);\r\n            for (const check of checks) {\r\n                await check(node, acceptor, cancelToken);\r\n            }\r\n        }));\r\n        return validationItems;\r\n    }\r\n\r\n    protected toDiagnostic<N extends AstNode>(severity: 'error' | 'warning' | 'info' | 'hint', message: string, info: DiagnosticInfo<N, string>): Diagnostic {\r\n        return {\r\n            message,\r\n            range: getDiagnosticRange(info),\r\n            severity: toDiagnosticSeverity(severity),\r\n            code: info.code,\r\n            codeDescription: info.codeDescription,\r\n            tags: info.tags,\r\n            relatedInformation: info.relatedInformation,\r\n            data: info.data,\r\n            source: this.getSource()\r\n        };\r\n    }\r\n\r\n    protected getSource(): string | undefined {\r\n        return this.metadata.languageId;\r\n    }\r\n}\r\n\r\nexport function getDiagnosticRange<N extends AstNode>(info: DiagnosticInfo<N, string>): Range {\r\n    if (Range.is(info.range)) {\r\n        return info.range;\r\n    }\r\n    let cstNode: CstNode | undefined;\r\n    if (typeof info.property === 'string') {\r\n        cstNode = findNodeForProperty(info.node.$cstNode, info.property, info.index);\r\n    } else if (typeof info.keyword === 'string') {\r\n        cstNode = findNodeForKeyword(info.node.$cstNode, info.keyword, info.index);\r\n    }\r\n    cstNode ??= info.node.$cstNode;\r\n    if (!cstNode) {\r\n        return {\r\n            start: { line: 0, character: 0 },\r\n            end: { line: 0, character: 0 }\r\n        };\r\n    }\r\n    return cstNode.range;\r\n}\r\n\r\nexport function toDiagnosticSeverity(severity: 'error' | 'warning' | 'info' | 'hint'): DiagnosticSeverity {\r\n    switch (severity) {\r\n        case 'error':\r\n            return DiagnosticSeverity.Error;\r\n        case 'warning':\r\n            return DiagnosticSeverity.Warning;\r\n        case 'info':\r\n            return DiagnosticSeverity.Information;\r\n        case 'hint':\r\n            return DiagnosticSeverity.Hint;\r\n        default:\r\n            throw new Error('Invalid diagnostic severity: ' + severity);\r\n    }\r\n}\r\n\r\nexport namespace DocumentValidator {\r\n    export const LexingError = 'lexing-error';\r\n    export const ParsingError = 'parsing-error';\r\n    export const LinkingError = 'linking-error';\r\n}\r\n\r\nexport interface LinkingErrorData extends DiagnosticData {\r\n    containerType: string\r\n    property: string\r\n    refText: string\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, CompletionItem, CompletionParams } from 'vscode-languageserver';\r\nimport type { TextDocument, TextEdit } from 'vscode-languageserver-textdocument';\r\nimport type { LangiumCompletionParser } from '../../parser/langium-parser.js';\r\nimport type { NameProvider } from '../../references/name-provider.js';\r\nimport type { ScopeProvider } from '../../references/scope-provider.js';\r\nimport type { LangiumServices } from '../../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, CstNode, ReferenceInfo } from '../../syntax-tree.js';\r\nimport type { MaybePromise } from '../../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../../workspace/documents.js';\r\nimport type { NextFeature } from './follow-element-computation.js';\r\nimport type { NodeKindProvider } from '../node-kind-provider.js';\r\nimport type { FuzzyMatcher } from '../fuzzy-matcher.js';\r\nimport type { GrammarConfig } from '../../grammar/grammar-config.js';\r\nimport type { Lexer } from '../../parser/lexer.js';\r\nimport type { IToken } from 'chevrotain';\r\nimport { CompletionItemKind, CompletionList, Position } from 'vscode-languageserver';\r\nimport * as ast from '../../grammar/generated/ast.js';\r\nimport { getExplicitRuleType } from '../../grammar/internal-grammar-util.js';\r\nimport { assignMandatoryAstProperties, getContainerOfType } from '../../utils/ast-util.js';\r\nimport { findDeclarationNodeAtOffset, findLeafNodeBeforeOffset } from '../../utils/cst-util.js';\r\nimport { getEntryRule } from '../../utils/grammar-util.js';\r\nimport { stream } from '../../utils/stream.js';\r\nimport { findFirstFeatures, findNextFeatures } from './follow-element-computation.js';\r\n\r\nexport type CompletionAcceptor = (context: CompletionContext, value: CompletionValueItem) => void\r\n\r\nexport type CompletionValueItem = ({\r\n    label?: string\r\n} | {\r\n    node: AstNode\r\n} | {\r\n    nodeDescription: AstNodeDescription\r\n}) & Partial<CompletionItem>;\r\n\r\nexport interface CompletionContext {\r\n    node?: AstNode\r\n    document: LangiumDocument\r\n    textDocument: TextDocument\r\n    features: NextFeature[]\r\n    /**\r\n     * Index at the start of the token related to this context.\r\n     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.\r\n     */\r\n    tokenOffset: number\r\n    /**\r\n     * Index at the end of the token related to this context, even if it is behind the cursor position.\r\n     * Points at the first character after the last token.\r\n     * If the context performs completion for a token that doesn't exist yet, it is equal to the `offset`.\r\n     */\r\n    tokenEndOffset: number\r\n    /**\r\n     * Index of the requested completed position.\r\n     */\r\n    offset: number\r\n    position: Position\r\n}\r\n\r\nexport interface CompletionProviderOptions {\r\n    /**\r\n     * Most tools trigger completion request automatically without explicitly requesting\r\n     * it using a keyboard shortcut (e.g. Ctrl+Space). Typically they do so when the user\r\n     * starts to type an identifier. For example if the user types `c` in a JavaScript file\r\n     * code complete will automatically pop up present `console` besides others as a\r\n     * completion item. Characters that make up identifiers don't need to be listed here.\r\n     *\r\n     * If code complete should automatically be trigger on characters not being valid inside\r\n     * an identifier (for example `.` in JavaScript) list them in `triggerCharacters`.\r\n     */\r\n    triggerCharacters?: string[];\r\n    /**\r\n     * The list of all possible characters that commit a completion. This field can be used\r\n     * if clients don't support individual commit characters per completion item.\r\n     *\r\n     * If a server provides both `allCommitCharacters` and commit characters on an individual\r\n     * completion item the ones on the completion item win.\r\n     */\r\n    allCommitCharacters?: string[];\r\n}\r\n\r\nexport interface CompletionBacktrackingInformation {\r\n    previousTokenStart?: number;\r\n    previousTokenEnd?: number;\r\n    nextTokenStart: number;\r\n    nextTokenEnd: number;\r\n}\r\n\r\nexport function mergeCompletionProviderOptions(options: Array<CompletionProviderOptions | undefined>): CompletionProviderOptions {\r\n    const triggerCharacters = Array.from(new Set(options.flatMap(option => option?.triggerCharacters ?? [])));\r\n    const allCommitCharacters = Array.from(new Set(options.flatMap(option => option?.allCommitCharacters ?? [])));\r\n    return {\r\n        triggerCharacters: triggerCharacters.length > 0 ? triggerCharacters : undefined,\r\n        allCommitCharacters: allCommitCharacters.length > 0 ? allCommitCharacters : undefined\r\n    };\r\n}\r\n\r\n/**\r\n * Language-specific service for handling completion requests.\r\n */\r\nexport interface CompletionProvider {\r\n    /**\r\n     * Handle a completion request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getCompletion(document: LangiumDocument, params: CompletionParams, cancelToken?: CancellationToken): MaybePromise<CompletionList | undefined>\r\n    /**\r\n     * Contains the completion options for this completion provider.\r\n     *\r\n     * If multiple languages return different options, they are merged before being sent to the language client.\r\n     */\r\n    readonly completionOptions?: CompletionProviderOptions;\r\n}\r\n\r\nexport class DefaultCompletionProvider implements CompletionProvider {\r\n\r\n    protected readonly completionParser: LangiumCompletionParser;\r\n    protected readonly scopeProvider: ScopeProvider;\r\n    protected readonly grammar: ast.Grammar;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly lexer: Lexer;\r\n    protected readonly nodeKindProvider: NodeKindProvider;\r\n    protected readonly fuzzyMatcher: FuzzyMatcher;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n    protected readonly astReflection: AstReflection;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.scopeProvider = services.references.ScopeProvider;\r\n        this.grammar = services.Grammar;\r\n        this.completionParser = services.parser.CompletionParser;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.lexer = services.parser.Lexer;\r\n        this.nodeKindProvider = services.shared.lsp.NodeKindProvider;\r\n        this.fuzzyMatcher = services.shared.lsp.FuzzyMatcher;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n        this.astReflection = services.shared.AstReflection;\r\n    }\r\n\r\n    async getCompletion(document: LangiumDocument, params: CompletionParams): Promise<CompletionList | undefined> {\r\n        const items: CompletionItem[] = [];\r\n        const contexts = this.buildContexts(document, params.position);\r\n\r\n        const acceptor: CompletionAcceptor = (context, value) => {\r\n            const completionItem = this.fillCompletionItem(context, value);\r\n            if (completionItem) {\r\n                items.push(completionItem);\r\n            }\r\n        };\r\n\r\n        const distinctionFunction = (element: NextFeature) => {\r\n            if (ast.isKeyword(element.feature)) {\r\n                return element.feature.value;\r\n            } else {\r\n                return element.feature;\r\n            }\r\n        };\r\n\r\n        const completedFeatures: NextFeature[] = [];\r\n        for (const context of contexts) {\r\n            await Promise.all(\r\n                stream(context.features)\r\n                    .distinct(distinctionFunction)\r\n                    .exclude(completedFeatures)\r\n                    .map(e => this.completionFor(context, e, acceptor))\r\n            );\r\n            // Do not try to complete the same feature multiple times\r\n            completedFeatures.push(...context.features);\r\n            // We might want to stop computing completion results\r\n            if (!this.continueCompletion(items)) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        return CompletionList.create(this.deduplicateItems(items), true);\r\n    }\r\n\r\n    /**\r\n     * The completion algorithm could yield the same reference/keyword multiple times.\r\n     *\r\n     * This methods deduplicates these items afterwards before returning to the client.\r\n     * Unique items are identified as a combination of `kind`, `label` and `detail`.\r\n     */\r\n    protected deduplicateItems(items: CompletionItem[]): CompletionItem[] {\r\n        return stream(items).distinct(item => `${item.kind}_${item.label}_${item.detail}`).toArray();\r\n    }\r\n\r\n    protected findFeaturesAt(document: TextDocument, offset: number): NextFeature[] {\r\n        const text = document.getText({\r\n            start: Position.create(0, 0),\r\n            end: document.positionAt(offset)\r\n        });\r\n        const parserResult = this.completionParser.parse(text);\r\n        const tokens = parserResult.tokens;\r\n        // If the parser didn't parse any tokens, return the next features of the entry rule\r\n        if (parserResult.tokenIndex === 0) {\r\n            const parserRule = getEntryRule(this.grammar)!;\r\n            const firstFeatures = findFirstFeatures({\r\n                feature: parserRule.definition,\r\n                type: getExplicitRuleType(parserRule)\r\n            });\r\n            if (tokens.length > 0) {\r\n                // We have to skip the first token\r\n                // The interpreter will only look at the next features, which requires every token after the first\r\n                tokens.shift();\r\n                return findNextFeatures(firstFeatures.map(e => [e]), tokens);\r\n            } else {\r\n                return firstFeatures;\r\n            }\r\n        }\r\n        const leftoverTokens = [...tokens].splice(parserResult.tokenIndex);\r\n        const features = findNextFeatures([parserResult.elementStack.map(feature => ({ feature }))], leftoverTokens);\r\n        return features;\r\n    }\r\n\r\n    protected *buildContexts(document: LangiumDocument, position: Position): IterableIterator<CompletionContext> {\r\n        const cst = document.parseResult.value.$cstNode;\r\n        if (!cst) {\r\n            return;\r\n        }\r\n        const textDocument = document.textDocument;\r\n        const text = textDocument.getText();\r\n        const offset = textDocument.offsetAt(position);\r\n        const partialContext = {\r\n            document,\r\n            textDocument,\r\n            offset,\r\n            position\r\n        };\r\n        // Data type rules need special handling, as their tokens are irrelevant for completion purposes.\r\n        // If we encounter a data type rule at the current offset, we jump to the start of the data type rule.\r\n        const dataTypeRuleOffsets = this.findDataTypeRuleStart(cst, offset);\r\n        if (dataTypeRuleOffsets) {\r\n            const [ruleStart, ruleEnd] = dataTypeRuleOffsets;\r\n            const parentNode = findLeafNodeBeforeOffset(cst, ruleStart)?.astNode;\r\n            yield {\r\n                ...partialContext,\r\n                node: parentNode,\r\n                tokenOffset: ruleStart,\r\n                tokenEndOffset: ruleEnd,\r\n                features: this.findFeaturesAt(textDocument, ruleStart),\r\n            };\r\n        }\r\n        // For all other purposes, it's enough to jump to the start of the current/previous token\r\n        const { nextTokenStart, nextTokenEnd, previousTokenStart, previousTokenEnd } = this.backtrackToAnyToken(text, offset);\r\n        let astNodeOffset = nextTokenStart;\r\n        if (offset <= nextTokenStart && previousTokenStart !== undefined) {\r\n            // This check indicates that the cursor is still before the next token, so we should use the previous AST node (if it exists)\r\n            astNodeOffset = previousTokenStart;\r\n        }\r\n        const astNode = findLeafNodeBeforeOffset(cst, astNodeOffset)?.astNode;\r\n        let performNextCompletion = true;\r\n        if (previousTokenStart !== undefined && previousTokenEnd !== undefined && previousTokenEnd === offset) {\r\n            // This context aims to complete the current feature\r\n            yield {\r\n                ...partialContext,\r\n                node: astNode,\r\n                tokenOffset: previousTokenStart,\r\n                tokenEndOffset: previousTokenEnd,\r\n                features: this.findFeaturesAt(textDocument, previousTokenStart),\r\n            };\r\n            // The completion after the current token should be prevented in case we find out that the current token definitely isn't completed yet\r\n            // This is usually the case when the current token ends on a letter.\r\n            performNextCompletion = this.performNextTokenCompletion(\r\n                document,\r\n                text.substring(previousTokenStart, previousTokenEnd),\r\n                previousTokenStart,\r\n                previousTokenEnd\r\n            );\r\n            if (performNextCompletion) {\r\n                // This context aims to complete the immediate next feature (if one exists at the current cursor position)\r\n                // It uses the previous cst start/offset for that.\r\n                yield {\r\n                    ...partialContext,\r\n                    node: astNode,\r\n                    tokenOffset: previousTokenEnd,\r\n                    tokenEndOffset: previousTokenEnd,\r\n                    features: this.findFeaturesAt(textDocument, previousTokenEnd),\r\n                };\r\n            }\r\n        }\r\n\r\n        if (!astNode) {\r\n            const parserRule = getEntryRule(this.grammar);\r\n            if (!parserRule) {\r\n                throw new Error('Missing entry parser rule');\r\n            }\r\n            // This context aims to perform completion for the grammar start (usually when the document is empty)\r\n            yield {\r\n                ...partialContext,\r\n                tokenOffset: nextTokenStart,\r\n                tokenEndOffset: nextTokenEnd,\r\n                features: findFirstFeatures(parserRule.definition)\r\n            };\r\n        } else if (performNextCompletion) {\r\n            // This context aims to complete the next feature, using the next cst start/end\r\n            yield {\r\n                ...partialContext,\r\n                node: astNode,\r\n                tokenOffset: nextTokenStart,\r\n                tokenEndOffset: nextTokenEnd,\r\n                features: this.findFeaturesAt(textDocument, nextTokenStart),\r\n            };\r\n        }\r\n    }\r\n\r\n    protected performNextTokenCompletion(document: LangiumDocument, text: string, _offset: number, _end: number): boolean {\r\n        // This regex returns false if the text ends with a letter.\r\n        // We don't want to complete new text immediately after a keyword, ID etc.\r\n        // We only care about the last character in the text, so we use $ here.\r\n        // The \\P{L} used here is a Unicode category that matches any character that is not a letter\r\n        return /\\P{L}$/u.test(text);\r\n    }\r\n\r\n    protected findDataTypeRuleStart(cst: CstNode, offset: number): [number, number] | undefined {\r\n        let containerNode: CstNode | undefined = findDeclarationNodeAtOffset(cst, offset, this.grammarConfig.nameRegexp);\r\n        // Identify whether the element was parsed as part of a data type rule\r\n        let isDataTypeNode = Boolean(getContainerOfType(containerNode?.grammarSource, ast.isParserRule)?.dataType);\r\n        if (isDataTypeNode) {\r\n            while (isDataTypeNode) {\r\n                // Use the container to find the correct parent element\r\n                containerNode = containerNode?.container;\r\n                isDataTypeNode = Boolean(getContainerOfType(containerNode?.grammarSource, ast.isParserRule)?.dataType);\r\n            }\r\n            if (containerNode) {\r\n                return [containerNode.offset, containerNode.end];\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Indicates whether the completion should continue to process the next completion context.\r\n     *\r\n     * The default implementation continues the completion only if there are currently no proposed completion items.\r\n     */\r\n    protected continueCompletion(items: CompletionItem[]): boolean {\r\n        return items.length === 0;\r\n    }\r\n\r\n    /**\r\n     * This method returns two sets of token offset information.\r\n     *\r\n     * The `nextToken*` offsets are related to the token at the cursor position.\r\n     * If there is none, both offsets are simply set to `offset`.\r\n     *\r\n     * The `previousToken*` offsets are related to the last token before the current token at the cursor position.\r\n     * They are `undefined`, if there is no token before the cursor position.\r\n     */\r\n    protected backtrackToAnyToken(text: string, offset: number): CompletionBacktrackingInformation {\r\n        const tokens = this.lexer.tokenize(text).tokens;\r\n        if (tokens.length === 0) {\r\n            // If we don't have any tokens in our document, just return the offset position\r\n            return {\r\n                nextTokenStart: offset,\r\n                nextTokenEnd: offset\r\n            };\r\n        }\r\n        let previousToken: IToken | undefined;\r\n        for (const token of tokens) {\r\n            if (token.startOffset >= offset) {\r\n                // We are between two tokens\r\n                // Return the current offset as the next token index\r\n                return {\r\n                    nextTokenStart: offset,\r\n                    nextTokenEnd: offset,\r\n                    previousTokenStart: previousToken ? previousToken.startOffset : undefined,\r\n                    previousTokenEnd: previousToken ? previousToken.endOffset! + 1 : undefined\r\n                };\r\n            }\r\n            if (token.endOffset! >= offset) {\r\n                // We are within a token\r\n                // Return the current and previous token offsets as normal\r\n                return {\r\n                    nextTokenStart: token.startOffset,\r\n                    nextTokenEnd: token.endOffset! + 1,\r\n                    previousTokenStart: previousToken ? previousToken.startOffset : undefined,\r\n                    previousTokenEnd: previousToken ? previousToken.endOffset! + 1 : undefined\r\n                };\r\n            }\r\n            previousToken = token;\r\n        }\r\n        // We have run into the end of the file\r\n        // Return the current offset as the next token index\r\n        return {\r\n            nextTokenStart: offset,\r\n            nextTokenEnd: offset,\r\n            previousTokenStart: previousToken ? previousToken.startOffset : undefined,\r\n            previousTokenEnd: previousToken ? previousToken.endOffset! + 1 : undefined\r\n        };\r\n    }\r\n\r\n    protected completionFor(context: CompletionContext, next: NextFeature, acceptor: CompletionAcceptor): MaybePromise<void> {\r\n        if (ast.isKeyword(next.feature)) {\r\n            return this.completionForKeyword(context, next.feature, acceptor);\r\n        } else if (ast.isCrossReference(next.feature) && context.node) {\r\n            return this.completionForCrossReference(context, next as NextFeature<ast.CrossReference>, acceptor);\r\n        }\r\n        // Don't offer any completion for other elements (i.e. terminals, datatype rules)\r\n        // We - from a framework level - cannot reasonably assume their contents.\r\n        // Adopters can just override `completionFor` if they want to do that anyway.\r\n    }\r\n\r\n    protected completionForCrossReference(context: CompletionContext, next: NextFeature<ast.CrossReference>, acceptor: CompletionAcceptor): MaybePromise<void> {\r\n        const assignment = getContainerOfType(next.feature, ast.isAssignment);\r\n        let node = context.node;\r\n        if (assignment && node) {\r\n            if (next.type) {\r\n                // When `type` is set, it indicates that we have just entered a new parser rule.\r\n                // The cross reference that we're trying to complete is on a new element that doesn't exist yet.\r\n                // So we create a new synthetic element with the correct type information.\r\n                node = {\r\n                    $type: next.type,\r\n                    $container: node,\r\n                    $containerProperty: next.property\r\n                };\r\n                assignMandatoryAstProperties(this.astReflection, node);\r\n            }\r\n            const refInfo: ReferenceInfo = {\r\n                reference: {\r\n                    $refText: ''\r\n                },\r\n                container: node,\r\n                property: assignment.feature\r\n            };\r\n            try {\r\n                const scope = this.scopeProvider.getScope(refInfo);\r\n                scope.getAllElements().forEach(e => {\r\n                    if (this.filterCrossReference(context, e)) {\r\n                        acceptor(context, this.createReferenceCompletionItem(e));\r\n                    }\r\n                });\r\n            } catch (err) {\r\n                console.error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Override this method to change how reference completion items are created.\r\n     * To change the `kind` of a completion item, override the `NodeKindProvider` service instead.\r\n     *\r\n     * @param nodeDescription The description of a reference candidate\r\n     * @returns A partial completion item\r\n     */\r\n    protected createReferenceCompletionItem(nodeDescription: AstNodeDescription): CompletionValueItem {\r\n        return {\r\n            nodeDescription,\r\n            kind: this.nodeKindProvider.getCompletionItemKind(nodeDescription),\r\n            detail: nodeDescription.type,\r\n            sortText: '0'\r\n        };\r\n    }\r\n\r\n    protected filterCrossReference(_context: CompletionContext, _nodeDescription: AstNodeDescription): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected completionForKeyword(context: CompletionContext, keyword: ast.Keyword, acceptor: CompletionAcceptor): MaybePromise<void> {\r\n        if (!this.filterKeyword(context, keyword)) {\r\n            return;\r\n        }\r\n        acceptor(context, {\r\n            label: keyword.value,\r\n            kind: CompletionItemKind.Keyword,\r\n            detail: 'Keyword',\r\n            sortText: '1'\r\n        });\r\n    }\r\n\r\n    protected filterKeyword(context: CompletionContext, keyword: ast.Keyword): boolean {\r\n        // Filter out keywords that do not contain any word character\r\n        return /\\p{L}/u.test(keyword.value);\r\n    }\r\n\r\n    protected fillCompletionItem(context: CompletionContext, item: CompletionValueItem): CompletionItem | undefined {\r\n        let label: string;\r\n        if (typeof item.label === 'string') {\r\n            label = item.label;\r\n        } else if ('node' in item) {\r\n            const name = this.nameProvider.getName(item.node);\r\n            if (!name) {\r\n                return undefined;\r\n            }\r\n            label = name;\r\n        } else if ('nodeDescription' in item) {\r\n            label = item.nodeDescription.name;\r\n        } else {\r\n            return undefined;\r\n        }\r\n        let insertText: string;\r\n        if (typeof item.textEdit?.newText === 'string') {\r\n            insertText = item.textEdit.newText;\r\n        } else if (typeof item.insertText === 'string') {\r\n            insertText = item.insertText;\r\n        } else {\r\n            insertText = label;\r\n        }\r\n        const textEdit = item.textEdit ?? this.buildCompletionTextEdit(context, label, insertText);\r\n        if (!textEdit) {\r\n            return undefined;\r\n        }\r\n        // Copy all valid properties of `CompletionItem`\r\n        const completionItem: CompletionItem = {\r\n            additionalTextEdits: item.additionalTextEdits,\r\n            command: item.command,\r\n            commitCharacters: item.commitCharacters,\r\n            data: item.data,\r\n            detail: item.detail,\r\n            documentation: item.documentation,\r\n            filterText: item.filterText,\r\n            insertText: item.insertText,\r\n            insertTextFormat: item.insertTextFormat,\r\n            insertTextMode: item.insertTextMode,\r\n            kind: item.kind,\r\n            labelDetails: item.labelDetails,\r\n            preselect: item.preselect,\r\n            sortText: item.sortText,\r\n            tags: item.tags,\r\n            textEditText: item.textEditText,\r\n            textEdit,\r\n            label\r\n        };\r\n        return completionItem;\r\n    }\r\n\r\n    protected buildCompletionTextEdit(context: CompletionContext, label: string, newText: string): TextEdit | undefined {\r\n        const content = context.textDocument.getText();\r\n        const identifier = content.substring(context.tokenOffset, context.offset);\r\n        if (this.fuzzyMatcher.match(identifier, label)) {\r\n            const start = context.textDocument.positionAt(context.tokenOffset);\r\n            const end = context.position;\r\n            return {\r\n                newText,\r\n                range: {\r\n                    start,\r\n                    end\r\n                }\r\n            };\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken } from 'chevrotain';\r\nimport type { Cardinality } from '../../grammar/internal-grammar-util.js';\r\nimport * as ast from '../../grammar/generated/ast.js';\r\nimport { getExplicitRuleType, getTypeName, isArrayCardinality, isOptionalCardinality, terminalRegex } from '../../grammar/internal-grammar-util.js';\r\nimport { isAstNode } from '../../syntax-tree.js';\r\nimport { getContainerOfType } from '../../utils/ast-util.js';\r\nimport { getCrossReferenceTerminal } from '../../utils/grammar-util.js';\r\n\r\nexport interface NextFeature<T extends ast.AbstractElement = ast.AbstractElement> {\r\n    /**\r\n     * A feature that could appear during completion.\r\n     */\r\n    feature: T\r\n    /**\r\n     * The type that carries this `feature`. Only set if we encounter a new type.\r\n     */\r\n    type?: string\r\n    /**\r\n     * The container property for the new `type`\r\n     */\r\n    property?: string\r\n}\r\n\r\n/**\r\n * Calculates any features that can follow the given feature stack.\r\n * This also includes features following optional features and features from previously called rules that could follow the last feature.\r\n * @param featureStack A stack of features starting at the entry rule and ending at the feature of the current cursor position.\r\n * @param unparsedTokens All tokens which haven't been parsed successfully yet. This is the case when we call this function inside an alternative.\r\n * @returns Any `AbstractElement` that could be following the given feature stack.\r\n */\r\nexport function findNextFeatures(featureStack: NextFeature[][], unparsedTokens: IToken[]): NextFeature[] {\r\n    const context: InterpretationContext = {\r\n        stacks: featureStack,\r\n        tokens: unparsedTokens\r\n    };\r\n    interpretTokens(context);\r\n    // Reset the container property\r\n    context.stacks.flat().forEach(feature => { feature.property = undefined; });\r\n    const nextStacks = findNextFeatureStacks(context.stacks);\r\n    // We only need the last element of each stack\r\n    return nextStacks.map(e => e[e.length - 1]);\r\n}\r\n\r\nfunction findNextFeaturesInternal(options: { next: NextFeature, cardinalities: Map<ast.AbstractElement, Cardinality>, visited: Set<ast.AbstractElement>, plus: Set<ast.AbstractElement> }): NextFeature[] {\r\n    const { next, cardinalities, visited, plus } = options;\r\n    const features: NextFeature[] = [];\r\n    const feature = next.feature;\r\n    if (visited.has(feature)) {\r\n        return [];\r\n    } else {\r\n        visited.add(feature);\r\n    }\r\n    let parent: ast.Group | undefined;\r\n    let item = feature;\r\n    while (item.$container) {\r\n        if (ast.isGroup(item.$container)) {\r\n            parent = item.$container;\r\n            break;\r\n        } else if (ast.isAbstractElement(item.$container)) {\r\n            item = item.$container;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    // First try to iterate the same element again\r\n    if (isArrayCardinality(item.cardinality)) {\r\n        const repeatingFeatures = findFirstFeaturesInternal({\r\n            next: {\r\n                feature: item,\r\n                type: next.type\r\n            },\r\n            cardinalities,\r\n            visited,\r\n            plus\r\n        });\r\n        for (const repeatingFeature of repeatingFeatures) {\r\n            plus.add(repeatingFeature.feature);\r\n        }\r\n        features.push(...repeatingFeatures);\r\n    }\r\n    if (parent) {\r\n        const ownIndex = parent.elements.indexOf(item);\r\n        // Find next elements of the same group\r\n        if (ownIndex !== undefined && ownIndex < parent.elements.length - 1) {\r\n            features.push(...findNextFeaturesInGroup({\r\n                feature: parent,\r\n                type: next.type\r\n            }, ownIndex + 1, cardinalities, visited, plus));\r\n        }\r\n        // Try to find the next elements of the parent\r\n        // Only do this if every following element is either optional or has been parsed as +\r\n        if (features.every(e => isOptionalCardinality(e.feature.cardinality, e.feature) || isOptionalCardinality(cardinalities.get(e.feature)) || plus.has(e.feature))) {\r\n            features.push(...findNextFeaturesInternal({\r\n                next: {\r\n                    feature: parent,\r\n                    type: next.type\r\n                },\r\n                cardinalities,\r\n                visited,\r\n                plus\r\n            }));\r\n        }\r\n    }\r\n    return features;\r\n}\r\n\r\n/**\r\n * Calculates the first child feature of any `AbstractElement`.\r\n * @param next The `AbstractElement` whose first child features should be calculated.\r\n */\r\nexport function findFirstFeatures(next: ast.AbstractElement | NextFeature): NextFeature[] {\r\n    if (isAstNode(next)) {\r\n        next = { feature: next };\r\n    }\r\n    return findFirstFeaturesInternal({ next, cardinalities: new Map(), visited: new Set(), plus: new Set() });\r\n}\r\n\r\nfunction findFirstFeaturesInternal(options: { next: NextFeature, cardinalities: Map<ast.AbstractElement, Cardinality>, visited: Set<ast.AbstractElement>, plus: Set<ast.AbstractElement> }): NextFeature[] {\r\n    const { next, cardinalities, visited, plus } = options;\r\n    if (next === undefined) {\r\n        return [];\r\n    }\r\n    const { feature, type } = next;\r\n    if (ast.isGroup(feature)) {\r\n        if (visited.has(feature)) {\r\n            return [];\r\n        } else {\r\n            visited.add(feature);\r\n        }\r\n    }\r\n    if (ast.isGroup(feature)) {\r\n        return findNextFeaturesInGroup(next as NextFeature<ast.Group>, 0, cardinalities, visited, plus)\r\n            .map(e => modifyCardinality(e, feature.cardinality, cardinalities));\r\n    } else if (ast.isAlternatives(feature) || ast.isUnorderedGroup(feature)) {\r\n        return feature.elements.flatMap(e => findFirstFeaturesInternal({\r\n            next: {\r\n                feature: e,\r\n                type,\r\n                property: next.property\r\n            },\r\n            cardinalities,\r\n            visited,\r\n            plus\r\n        }))\r\n            .map(e => modifyCardinality(e, feature.cardinality, cardinalities));\r\n    } else if (ast.isAssignment(feature)) {\r\n        const assignmentNext = {\r\n            feature: feature.terminal,\r\n            type,\r\n            property: next.property ?? feature.feature\r\n        };\r\n        return findFirstFeaturesInternal({ next: assignmentNext, cardinalities, visited, plus })\r\n            .map(e => modifyCardinality(e, feature.cardinality, cardinalities));\r\n    } else if (ast.isAction(feature)) {\r\n        return findNextFeaturesInternal({\r\n            next: {\r\n                feature,\r\n                type: getTypeName(feature),\r\n                property: next.property ?? feature.feature\r\n            },\r\n            cardinalities,\r\n            visited,\r\n            plus\r\n        });\r\n    } else if (ast.isRuleCall(feature) && ast.isParserRule(feature.rule.ref)) {\r\n        const rule = feature.rule.ref;\r\n        const ruleCallNext = {\r\n            feature: rule.definition,\r\n            type: rule.fragment || rule.dataType ? undefined : (getExplicitRuleType(rule) ?? rule.name),\r\n            property: next.property\r\n        };\r\n        return findFirstFeaturesInternal({ next: ruleCallNext, cardinalities, visited, plus })\r\n            .map(e => modifyCardinality(e, feature.cardinality, cardinalities));\r\n    } else {\r\n        return [next];\r\n    }\r\n}\r\n\r\n/**\r\n * Modifying the cardinality is necessary to identify which features are coming from an optional feature.\r\n * Those features should be optional as well.\r\n * @param next The next feature that could be made optionally.\r\n * @param cardinality The cardinality of the calling (parent) object.\r\n * @returns A new feature that could be now optional (`?` or `*`).\r\n */\r\nfunction modifyCardinality(next: NextFeature, cardinality: Cardinality, cardinalities: Map<ast.AbstractElement, Cardinality>): NextFeature {\r\n    cardinalities.set(next.feature, cardinality);\r\n    return next;\r\n}\r\n\r\nfunction findNextFeaturesInGroup(next: NextFeature<ast.Group>, index: number, cardinalities: Map<ast.AbstractElement, Cardinality>, visited: Set<ast.AbstractElement>, plus: Set<ast.AbstractElement>): NextFeature[] {\r\n    const features: NextFeature[] = [];\r\n    let firstFeature: NextFeature;\r\n    while (index < next.feature.elements.length) {\r\n        const feature = next.feature.elements[index++];\r\n        firstFeature = {\r\n            feature,\r\n            type: next.type\r\n        };\r\n        features.push(...findFirstFeaturesInternal({\r\n            next: firstFeature,\r\n            cardinalities,\r\n            visited,\r\n            plus\r\n        }));\r\n        if (!isOptionalCardinality(firstFeature.feature.cardinality ?? cardinalities.get(firstFeature.feature), firstFeature.feature)) {\r\n            break;\r\n        }\r\n    }\r\n    return features;\r\n}\r\n\r\ninterface InterpretationContext {\r\n    tokens: IToken[]\r\n    stacks: NextFeature[][]\r\n}\r\n\r\nfunction interpretTokens(context: InterpretationContext): void {\r\n    for (const token of context.tokens) {\r\n        const nextFeatureStacks = findNextFeatureStacks(context.stacks, token);\r\n        context.stacks = nextFeatureStacks;\r\n    }\r\n}\r\n\r\nfunction findNextFeatureStacks(stacks: NextFeature[][], token?: IToken): NextFeature[][] {\r\n    const newStacks: NextFeature[][] = [];\r\n    for (const stack of stacks) {\r\n        newStacks.push(...interpretStackToken(stack, token));\r\n    }\r\n    return newStacks;\r\n}\r\n\r\nfunction interpretStackToken(stack: NextFeature[], token?: IToken): NextFeature[][] {\r\n    const cardinalities = new Map<ast.AbstractElement, Cardinality>();\r\n    const plus = new Set<ast.AbstractElement>(stack.map(e => e.feature).filter(isPlusFeature));\r\n    const newStacks: NextFeature[][] = [];\r\n    while (stack.length > 0) {\r\n        const top = stack.pop()!;\r\n        const allNextFeatures = findNextFeaturesInternal({\r\n            next: top,\r\n            cardinalities,\r\n            plus,\r\n            visited: new Set()\r\n        }).filter(next => token ? featureMatches(next.feature, token) : true);\r\n        for (const nextFeature of allNextFeatures) {\r\n            newStacks.push([...stack, nextFeature]);\r\n        }\r\n        if (!allNextFeatures.every(e => isOptionalCardinality(e.feature.cardinality, e.feature) || isOptionalCardinality(cardinalities.get(e.feature)))) {\r\n            break;\r\n        }\r\n    }\r\n    return newStacks;\r\n}\r\n\r\nfunction isPlusFeature(feature: ast.AbstractElement): boolean {\r\n    if (feature.cardinality === '+') {\r\n        return true;\r\n    }\r\n    const assignment = getContainerOfType(feature, ast.isAssignment);\r\n    if (assignment && assignment.cardinality === '+') {\r\n        return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction featureMatches(feature: ast.AbstractElement, token: IToken): boolean {\r\n    if (ast.isKeyword(feature)) {\r\n        const content = feature.value;\r\n        return content === token.image;\r\n    } else if (ast.isRuleCall(feature)) {\r\n        return ruleMatches(feature.rule.ref, token);\r\n    } else if (ast.isCrossReference(feature)) {\r\n        const crossRefTerminal = getCrossReferenceTerminal(feature);\r\n        if (crossRefTerminal) {\r\n            return featureMatches(crossRefTerminal, token);\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction ruleMatches(rule: ast.AbstractRule | undefined, token: IToken): boolean {\r\n    if (ast.isParserRule(rule)) {\r\n        const ruleFeatures = findFirstFeatures(rule.definition);\r\n        return ruleFeatures.some(e => featureMatches(e.feature, token));\r\n    } else if (ast.isTerminalRule(rule)) {\r\n        // We have to take keywords into account\r\n        // e.g. most keywords are valid IDs as well\r\n        // Only return 'true' if this terminal does not match a keyword. TODO\r\n        return terminalRegex(rule).test(token.image);\r\n    } else {\r\n        return false;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport { CompletionItemKind } from 'vscode-languageserver-types';\r\nimport type { NextFeature } from '../../lsp/completion/follow-element-computation.js';\r\nimport type { CompletionAcceptor, CompletionContext } from '../../lsp/completion/completion-provider.js';\r\nimport { DefaultCompletionProvider } from '../../lsp/completion/completion-provider.js';\r\nimport type { LangiumServices } from '../../services.js';\r\nimport type { MaybePromise } from '../../utils/promise-util.js';\r\nimport { getContainerOfType } from '../../utils/ast-util.js';\r\nimport type { LangiumDocument, LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { AbstractElement } from '../generated/ast.js';\r\nimport { isAssignment } from '../generated/ast.js';\r\nimport { UriUtils } from '../../utils/uri-util.js';\r\n\r\nexport class LangiumGrammarCompletionProvider extends DefaultCompletionProvider {\r\n\r\n    private readonly documents: () => LangiumDocuments;\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.documents = () => services.shared.workspace.LangiumDocuments;\r\n    }\r\n\r\n    protected override completionFor(context: CompletionContext, next: NextFeature<AbstractElement>, acceptor: CompletionAcceptor): MaybePromise<void> {\r\n        const assignment = getContainerOfType(next.feature, isAssignment);\r\n        if (assignment?.feature === 'path') {\r\n            this.completeImportPath(context, acceptor);\r\n        } else {\r\n            return super.completionFor(context, next, acceptor);\r\n        }\r\n    }\r\n\r\n    private completeImportPath(context: CompletionContext, acceptor: CompletionAcceptor): void {\r\n        const text = context.textDocument.getText();\r\n        const existingText = text.substring(context.tokenOffset, context.offset);\r\n        let allPaths = this.getAllFiles(context.document);\r\n        let range: Range = {\r\n            start: context.position,\r\n            end: context.position\r\n        };\r\n        if (existingText.length > 0) {\r\n            const existingPath = existingText.substring(1);\r\n            allPaths = allPaths.filter(path => path.startsWith(existingPath));\r\n            // Completely replace the current token\r\n            const start = context.textDocument.positionAt(context.tokenOffset + 1);\r\n            const end = context.textDocument.positionAt(context.tokenEndOffset - 1);\r\n            range = {\r\n                start,\r\n                end\r\n            };\r\n        }\r\n        for (const path of allPaths) {\r\n            // Only insert quotes if there is no `path` token yet.\r\n            const delimiter = existingText.length > 0 ? '' : '\"';\r\n            const completionValue = `${delimiter}${path}${delimiter}`;\r\n            acceptor(context, {\r\n                label: path,\r\n                textEdit: {\r\n                    newText: completionValue,\r\n                    range\r\n                },\r\n                kind: CompletionItemKind.File,\r\n                sortText: '0'\r\n            });\r\n        }\r\n    }\r\n\r\n    private getAllFiles(document: LangiumDocument): string[] {\r\n        const documents = this.documents().all;\r\n        const uri = document.uri.toString();\r\n        const dirname = UriUtils.dirname(document.uri).toString();\r\n        const paths: string[] = [];\r\n        for (const doc of documents) {\r\n            if (!UriUtils.equals(doc.uri, uri)) {\r\n                const docUri = doc.uri.toString();\r\n                const uriWithoutExt = docUri.substring(0, docUri.length - UriUtils.extname(doc.uri).length);\r\n                let relativePath = UriUtils.relative(dirname, uriWithoutExt);\r\n                if (!relativePath.startsWith('.')) {\r\n                    relativePath = `./${relativePath}`;\r\n                }\r\n                paths.push(relativePath);\r\n            }\r\n        }\r\n        return paths;\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, FoldingRangeParams } from 'vscode-languageserver';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { FoldingRange, FoldingRangeKind } from 'vscode-languageserver';\r\nimport { streamAllContents } from '../utils/ast-util.js';\r\nimport { flattenCst } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling folding range requests.\r\n */\r\nexport interface FoldingRangeProvider {\r\n    /**\r\n     * Handle a folding range request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getFoldingRanges(document: LangiumDocument, params: FoldingRangeParams, cancelToken?: CancellationToken): MaybePromise<FoldingRange[]>;\r\n}\r\n\r\nexport type FoldingRangeAcceptor = (foldingRange: FoldingRange) => void;\r\n\r\nexport class DefaultFoldingRangeProvider implements FoldingRangeProvider {\r\n\r\n    protected readonly commentNames: string[];\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.commentNames = services.parser.GrammarConfig.multilineCommentRules;\r\n    }\r\n\r\n    getFoldingRanges(document: LangiumDocument): MaybePromise<FoldingRange[]> {\r\n        const foldings: FoldingRange[] = [];\r\n        const acceptor: FoldingRangeAcceptor = (foldingRange) => foldings.push(foldingRange);\r\n        this.collectFolding(document, acceptor);\r\n        return foldings;\r\n    }\r\n\r\n    protected collectFolding(document: LangiumDocument, acceptor: FoldingRangeAcceptor): void {\r\n        const root = document.parseResult?.value;\r\n        if (root) {\r\n            if (this.shouldProcessContent(root)) {\r\n                const treeIterator = streamAllContents(root).iterator();\r\n                let result: IteratorResult<AstNode>;\r\n                do {\r\n                    result = treeIterator.next();\r\n                    if (!result.done) {\r\n                        const node = result.value;\r\n                        if (this.shouldProcess(node)) {\r\n                            this.collectObjectFolding(document, node, acceptor);\r\n                        }\r\n                        if (!this.shouldProcessContent(node)) {\r\n                            treeIterator.prune();\r\n                        }\r\n                    }\r\n                } while (!result.done);\r\n            }\r\n\r\n            this.collectCommentFolding(document, root, acceptor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Template method to determine whether the specified `AstNode` should be handled by the folding range provider.\r\n     * Returns true by default for all nodes. Returning false only ignores the specified node and not its content.\r\n     * To ignore the content of a node use `shouldProcessContent`.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected shouldProcess(node: AstNode): boolean {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Template method to determine whether the content/children of the specified `AstNode` should be handled by the folding range provider.\r\n     * Returns true by default for all nodes. Returning false ignores _all_ content of this node, even transitive ones.\r\n     * For more precise control over foldings use the `shouldProcess` method.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected shouldProcessContent(node: AstNode): boolean {\r\n        return true;\r\n    }\r\n\r\n    protected collectObjectFolding(document: LangiumDocument, node: AstNode, acceptor: FoldingRangeAcceptor): void {\r\n        const cstNode = node.$cstNode;\r\n        if (cstNode) {\r\n            const foldingRange = this.toFoldingRange(document, cstNode);\r\n            if (foldingRange) {\r\n                acceptor(foldingRange);\r\n            }\r\n        }\r\n    }\r\n\r\n    protected collectCommentFolding(document: LangiumDocument, node: AstNode, acceptor: FoldingRangeAcceptor): void {\r\n        const cstNode = node.$cstNode;\r\n        if (cstNode) {\r\n            for (const node of flattenCst(cstNode)) {\r\n                if (this.commentNames.includes(node.tokenType.name)) {\r\n                    const foldingRange = this.toFoldingRange(document, node, FoldingRangeKind.Comment);\r\n                    if (foldingRange) {\r\n                        acceptor(foldingRange);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    protected toFoldingRange(document: LangiumDocument, node: CstNode, kind?: string): FoldingRange | undefined {\r\n        const range = node.range;\r\n        const start = range.start;\r\n        let end = range.end;\r\n        // Don't generate foldings for nodes that are less than 3 lines\r\n        if (end.line - start.line < 2) {\r\n            return undefined;\r\n        }\r\n        // As we don't want to hide the end token like 'if { ... --> } <--',\r\n        // we simply select the end of the previous line as the end position\r\n        if (!this.includeLastFoldingLine(node, kind)) {\r\n            end = document.textDocument.positionAt(document.textDocument.offsetAt({ line: end.line, character: 0 }) - 1);\r\n        }\r\n        return FoldingRange.create(start.line, end.line, start.character, end.character, kind);\r\n    }\r\n\r\n    /**\r\n     * Template method to determine whether the folding range for this cst node should include its last line.\r\n     * Returns false by default for ast nodes which end in braces and for comments.\r\n     */\r\n    protected includeLastFoldingLine(node: CstNode, kind?: string): boolean {\r\n        if (kind === FoldingRangeKind.Comment) {\r\n            return false;\r\n        }\r\n\r\n        const nodeText = node.text;\r\n        const endChar = nodeText.charAt(nodeText.length - 1);\r\n        if (endChar === '}' || endChar === ')' || endChar === ']') {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode } from '../../syntax-tree.js';\r\nimport { DefaultFoldingRangeProvider } from '../../lsp/folding-range-provider.js';\r\nimport { isParserRule } from '../generated/ast.js';\r\n\r\n/**\r\n * A specialized folding range provider for the grammar language\r\n */\r\nexport class LangiumGrammarFoldingRangeProvider extends DefaultFoldingRangeProvider {\r\n\r\n    override shouldProcessContent(node: AstNode): boolean {\r\n        // Exclude parser rules from folding\r\n        return !isParserRule(node);\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, DocumentFormattingParams, DocumentOnTypeFormattingOptions, DocumentOnTypeFormattingParams, DocumentRangeFormattingParams, FormattingOptions, Range, TextEdit } from 'vscode-languageserver';\r\nimport type { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport type { AstNode, CstNode, Properties } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { findNodeForKeyword, findNodesForKeyword, findNodeForProperty, findNodesForProperty } from '../utils/grammar-util.js';\r\nimport { isCompositeCstNode, isLeafCstNode } from '../syntax-tree.js';\r\nimport { streamAllContents } from '../utils/ast-util.js';\r\nimport { getInteriorNodes, getNextNode } from '../utils/cst-util.js';\r\nimport { DONE_RESULT, EMPTY_STREAM, StreamImpl, TreeStreamImpl } from '../utils/stream.js';\r\n\r\n/**\r\n * Language specific service for handling formatting related LSP requests.\r\n */\r\nexport interface Formatter {\r\n    /**\r\n     * Handles full document formatting.\r\n     */\r\n    formatDocument(document: LangiumDocument, params: DocumentFormattingParams, cancelToken?: CancellationToken): MaybePromise<TextEdit[]>\r\n    /**\r\n     * Handles partial document formatting. Only parts of the document within the `params.range` property are formatted.\r\n     */\r\n    formatDocumentRange(document: LangiumDocument, params: DocumentRangeFormattingParams, cancelToken?: CancellationToken): MaybePromise<TextEdit[]>\r\n    /**\r\n     * Handles document formatting while typing. Only formats the current line.\r\n     */\r\n    formatDocumentOnType(document: LangiumDocument, params: DocumentOnTypeFormattingParams, cancelToken?: CancellationToken): MaybePromise<TextEdit[]>\r\n    /**\r\n     * Options that determine when the `formatDocumentOnType` method should be invoked by the language client.\r\n     * When `undefined` is returned, document format on type will be disabled.\r\n     */\r\n    get formatOnTypeOptions(): DocumentOnTypeFormattingOptions | undefined\r\n}\r\n\r\nexport abstract class AbstractFormatter implements Formatter {\r\n\r\n    protected collector: FormattingCollector = () => { /* Does nothing at first */ };\r\n\r\n    /**\r\n     * Creates a formatter scoped to the supplied AST node.\r\n     * Allows to define fine-grained formatting rules for elements.\r\n     *\r\n     * Example usage:\r\n     *\r\n     * ```ts\r\n     * export class CustomFormatter extends AbstractFormatter {\r\n     *   protected override format(node: AstNode): void {\r\n     *     if (isPerson(node)) {\r\n     *       const formatter = this.getNodeFormatter(node);\r\n     *       formatter.property('name').prepend(Formatting.oneSpace());\r\n     *     }\r\n     *   }\r\n     * }\r\n     * ```\r\n     * @param node The specific node the formatter should be scoped to. Every call to properties or keywords will only select those which belong to the supplied AST node.\r\n     */\r\n    protected getNodeFormatter<T extends AstNode>(node: T): NodeFormatter<T> {\r\n        return new DefaultNodeFormatter(node, this.collector);\r\n    }\r\n\r\n    formatDocument(document: LangiumDocument, params: DocumentFormattingParams): MaybePromise<TextEdit[]> {\r\n        const pr = document.parseResult;\r\n        if (pr.lexerErrors.length === 0 && pr.parserErrors.length === 0) {\r\n            // safe to format\r\n            return this.doDocumentFormat(document, params.options);\r\n        } else {\r\n            // don't format a potentially broken document, return no edits\r\n            return [];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns whether a range for a given document is error free, i.e. safe to format\r\n     *\r\n     * @param document Document to inspect for lexer & parser errors that may produce an unsafe range\r\n     * @param range Formatting range to check for safety\r\n     * @returns Whether the given formatting range does not overlap with or follow any regions with an error\r\n     */\r\n    protected isFormatRangeErrorFree(document: LangiumDocument, range: Range): boolean {\r\n        const pr = document.parseResult;\r\n        if (pr.lexerErrors.length || pr.parserErrors.length) {\r\n            // collect the earliest error line from either\r\n            const earliestErrLine = Math.min(\r\n                ...pr.lexerErrors.map(e => e.line ?? Number.MAX_VALUE),\r\n                ...pr.parserErrors.map(e => e.token.startLine ?? Number.MAX_VALUE)\r\n            );\r\n            // if the earliest error line occurs before or at the end line of the range, then don't format\r\n            return earliestErrLine > range.end.line;\r\n        } else {\r\n            // no errors, ok to format\r\n            return true;\r\n        }\r\n    }\r\n\r\n    formatDocumentRange(document: LangiumDocument, params: DocumentRangeFormattingParams): MaybePromise<TextEdit[]> {\r\n        if (this.isFormatRangeErrorFree(document, params.range)) {\r\n            return this.doDocumentFormat(document, params.options, params.range);\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    formatDocumentOnType(document: LangiumDocument, params: DocumentOnTypeFormattingParams): MaybePromise<TextEdit[]> {\r\n        // Format the current line after typing something\r\n        const range = {\r\n            start: {\r\n                character: 0,\r\n                line: params.position.line\r\n            },\r\n            end: params.position\r\n        };\r\n\r\n        if (this.isFormatRangeErrorFree(document, range)) {\r\n            return this.doDocumentFormat(document, params.options, range);\r\n        } else {\r\n            return [];\r\n        }\r\n    }\r\n\r\n    get formatOnTypeOptions(): DocumentOnTypeFormattingOptions | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    protected doDocumentFormat(document: LangiumDocument, options: FormattingOptions, range?: Range): TextEdit[] {\r\n        const map = new Map<string, FormattingAction>();\r\n        const collector: FormattingCollector = (node, mode, formatting) => {\r\n            const key = this.nodeModeToKey(node, mode);\r\n            const existing = map.get(key);\r\n            const priority = formatting.options.priority ?? 0;\r\n            const existingPriority = existing?.options.priority ?? 0;\r\n            if (!existing || existingPriority <= priority) {\r\n                map.set(key, formatting);\r\n            }\r\n        };\r\n        this.collector = collector;\r\n\r\n        this.iterateAstFormatting(document, range);\r\n        const edits = this.iterateCstFormatting(document, map, options, range);\r\n\r\n        return this.avoidOverlappingEdits(document.textDocument, edits);\r\n    }\r\n\r\n    protected avoidOverlappingEdits(textDocument: TextDocument, textEdits: TextEdit[]): TextEdit[] {\r\n        const edits: TextEdit[] = [];\r\n        for (const edit of textEdits) {\r\n            const last = edits[edits.length - 1];\r\n            if (last) {\r\n                const currentStart = textDocument.offsetAt(edit.range.start);\r\n                const lastEnd = textDocument.offsetAt(last.range.end);\r\n                if (currentStart < lastEnd) {\r\n                    edits.pop();\r\n                }\r\n            }\r\n            edits.push(edit);\r\n        }\r\n        return edits;\r\n    }\r\n\r\n    protected iterateAstFormatting(document: LangiumDocument, range?: Range): void {\r\n        const root = document.parseResult.value;\r\n        this.format(root);\r\n        const treeIterator = streamAllContents(root).iterator();\r\n        let result: IteratorResult<AstNode>;\r\n        do {\r\n            result = treeIterator.next();\r\n            if (!result.done) {\r\n                const node = result.value;\r\n                const inside = this.insideRange(node.$cstNode!.range, range);\r\n                if (inside) {\r\n                    this.format(node);\r\n                } else {\r\n                    treeIterator.prune();\r\n                }\r\n            }\r\n        } while (!result.done);\r\n    }\r\n\r\n    protected abstract format(node: AstNode): void;\r\n\r\n    protected nodeModeToKey(node: CstNode, mode: 'prepend' | 'append'): string {\r\n        return `${node.offset}:${node.end}:${mode}`;\r\n    }\r\n\r\n    protected insideRange(inside: Range, total?: Range): boolean {\r\n        if (!total) {\r\n            return true;\r\n        }\r\n        if ((inside.start.line <= total.start.line && inside.end.line >= total.end.line) ||\r\n            (inside.start.line >= total.start.line && inside.end.line <= total.end.line) ||\r\n            (inside.start.line <= total.end.line && inside.end.line >= total.end.line)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected isNecessary(edit: TextEdit, document: TextDocument): boolean {\r\n        const existing = document.getText(edit.range);\r\n        return existing !== edit.newText;\r\n    }\r\n\r\n    protected iterateCstFormatting(document: LangiumDocument, formattings: Map<string, FormattingAction>, options: FormattingOptions, range?: Range): TextEdit[] {\r\n        const context: FormattingContext = {\r\n            indentation: 0,\r\n            options,\r\n            document: document.textDocument\r\n        };\r\n        const edits: TextEdit[] = [];\r\n        const cstTreeStream = this.iterateCstTree(document, context);\r\n        const iterator = cstTreeStream.iterator();\r\n        let lastNode: CstNode | undefined;\r\n        let result: IteratorResult<CstNode>;\r\n        do {\r\n            result = iterator.next();\r\n            if (!result.done) {\r\n                const node = result.value;\r\n                const isLeaf = isLeafCstNode(node);\r\n                const prependKey = this.nodeModeToKey(node, 'prepend');\r\n                const prependFormatting = formattings.get(prependKey);\r\n                formattings.delete(prependKey);\r\n                if (prependFormatting) {\r\n                    const nodeEdits = this.createTextEdit(lastNode, node, prependFormatting, context);\r\n                    for (const edit of nodeEdits) {\r\n                        if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document.textDocument)) {\r\n                            edits.push(edit);\r\n                        }\r\n                    }\r\n                }\r\n                const appendKey = this.nodeModeToKey(node, 'append');\r\n                const appendFormatting = formattings.get(appendKey);\r\n                formattings.delete(appendKey);\r\n                if (appendFormatting) {\r\n                    const nextNode = getNextNode(node);\r\n                    if (nextNode) {\r\n                        const nodeEdits = this.createTextEdit(node, nextNode, appendFormatting, context);\r\n                        for (const edit of nodeEdits) {\r\n                            if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document.textDocument)) {\r\n                                edits.push(edit);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if (!prependFormatting && node.hidden) {\r\n                    const hiddenEdits = this.createHiddenTextEdits(lastNode, node, undefined, context);\r\n                    for (const edit of hiddenEdits) {\r\n                        if (edit && this.insideRange(edit.range, range) && this.isNecessary(edit, document.textDocument)) {\r\n                            edits.push(edit);\r\n                        }\r\n                    }\r\n                }\r\n                if (isLeaf) {\r\n                    lastNode = node;\r\n                }\r\n            }\r\n        } while (!result.done);\r\n\r\n        return edits;\r\n    }\r\n\r\n    protected createHiddenTextEdits(previous: CstNode | undefined, hidden: CstNode, formatting: FormattingAction | undefined, context: FormattingContext): TextEdit[] {\r\n        // Don't format the hidden node if it is on the same line as its previous node\r\n        const startLine = hidden.range.start.line;\r\n        if (previous && previous.range.end.line === startLine) {\r\n            return [];\r\n        }\r\n        const edits: TextEdit[] = [];\r\n\r\n        const startRange: Range = {\r\n            start: {\r\n                character: 0,\r\n                line: startLine\r\n            },\r\n            end: hidden.range.start\r\n        };\r\n        const hiddenStartText = context.document.getText(startRange);\r\n        const move = this.findFittingMove(startRange, formatting?.moves ?? [], context);\r\n        const hiddenStartChar = this.getExistingIndentationCharacterCount(hiddenStartText, context);\r\n        const expectedStartChar = this.getIndentationCharacterCount(context, move);\r\n\r\n        const characterIncrease = expectedStartChar - hiddenStartChar;\r\n\r\n        if (characterIncrease === 0) {\r\n            return [];\r\n        }\r\n\r\n        let newText = '';\r\n        if (characterIncrease > 0) {\r\n            newText = (context.options.insertSpaces ? ' ' : '\\t').repeat(characterIncrease);\r\n        }\r\n\r\n        const lines = hidden.text.split('\\n');\r\n        lines[0] = hiddenStartText + lines[0];\r\n        for (let i = 0; i < lines.length; i++) {\r\n            const currentLine = startLine + i;\r\n            const pos = {\r\n                character: 0,\r\n                line: currentLine\r\n            };\r\n            if (characterIncrease > 0) {\r\n                edits.push({\r\n                    newText,\r\n                    range: {\r\n                        start: pos,\r\n                        end: pos\r\n                    }\r\n                });\r\n            } else {\r\n                const currentText = lines[i];\r\n                let j = 0;\r\n                for (; j < currentText.length; j++) {\r\n                    const char = currentText.charAt(j);\r\n                    if (char !== ' ' && char !== '\\t') {\r\n                        break;\r\n                    }\r\n                }\r\n                edits.push({\r\n                    newText: '',\r\n                    range: {\r\n                        start: pos,\r\n                        end: {\r\n                            line: currentLine,\r\n                            // Remove as much whitespace characters as necessary\r\n                            // In some cases `characterIncrease` is actually larger than the amount of whitespace available\r\n                            // So we simply remove all whitespace characters `j`\r\n                            character: Math.min(j, Math.abs(characterIncrease))\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        return edits;\r\n    }\r\n\r\n    protected getExistingIndentationCharacterCount(text: string, context: FormattingContext): number {\r\n        const tabWhitespace = ' '.repeat(context.options.tabSize);\r\n        const normalized = context.options.insertSpaces ? text.replaceAll('\\t', tabWhitespace) : text.replaceAll(tabWhitespace, '\\t');\r\n        return normalized.length;\r\n    }\r\n\r\n    protected getIndentationCharacterCount(context: FormattingContext, formattingMove?: FormattingMove): number {\r\n        let indentation = context.indentation;\r\n        if (formattingMove && formattingMove.tabs) {\r\n            indentation += formattingMove.tabs;\r\n        }\r\n        return (context.options.insertSpaces ? context.options.tabSize : 1) * indentation;\r\n    }\r\n\r\n    protected createTextEdit(a: CstNode | undefined, b: CstNode, formatting: FormattingAction, context: FormattingContext): TextEdit[] {\r\n        if (b.hidden) {\r\n            return this.createHiddenTextEdits(a, b, formatting, context);\r\n        }\r\n        const betweenRange: Range = {\r\n            start: a?.range.end ?? {\r\n                character: 0,\r\n                line: 0\r\n            },\r\n            end: b.range.start\r\n        };\r\n        const move = this.findFittingMove(betweenRange, formatting.moves, context);\r\n        if (!move) {\r\n            return [];\r\n        }\r\n        const chars = move.characters;\r\n        const lines = move.lines;\r\n        const tabs = move.tabs;\r\n        const existingIndentation = context.indentation;\r\n        context.indentation += (tabs ?? 0);\r\n        const edits: TextEdit[] = [];\r\n        if (chars !== undefined) {\r\n            edits.push(this.createSpaceTextEdit(betweenRange, chars, formatting.options));\r\n        } else if (lines !== undefined) {\r\n            edits.push(this.createLineTextEdit(betweenRange, lines, context, formatting.options));\r\n        } else if (tabs !== undefined) {\r\n            edits.push(this.createTabTextEdit(betweenRange, Boolean(a), context));\r\n        }\r\n        if (isLeafCstNode(b)) {\r\n            context.indentation = existingIndentation;\r\n        }\r\n        return edits;\r\n    }\r\n\r\n    protected createSpaceTextEdit(range: Range, spaces: number, options: FormattingActionOptions): TextEdit {\r\n        if (range.start.line === range.end.line) {\r\n            const existingSpaces = range.end.character - range.start.character;\r\n            spaces = this.fitIntoOptions(spaces, existingSpaces, options);\r\n        }\r\n        const newText = ' '.repeat(spaces);\r\n        return {\r\n            newText,\r\n            range\r\n        };\r\n    }\r\n\r\n    protected createLineTextEdit(range: Range, lines: number, context: FormattingContext, options: FormattingActionOptions): TextEdit {\r\n        const existingLines = range.end.line - range.start.line;\r\n        lines = this.fitIntoOptions(lines, existingLines, options);\r\n        const indent = context.options.insertSpaces ? ' '.repeat(context.options.tabSize) : '\\t';\r\n        const nodeIndent = indent.repeat(context.indentation);\r\n        const newText = `${'\\n'.repeat(lines)}${nodeIndent}`;\r\n        return {\r\n            newText,\r\n            range\r\n        };\r\n    }\r\n\r\n    protected createTabTextEdit(range: Range, hasPrevious: boolean, context: FormattingContext): TextEdit {\r\n        const indent = context.options.insertSpaces ? ' '.repeat(context.options.tabSize) : '\\t';\r\n        const nodeIndent = indent.repeat(context.indentation);\r\n        const minimumLines = hasPrevious ? 1 : 0;\r\n        const lines = Math.max(range.end.line - range.start.line, minimumLines);\r\n        const newText = `${'\\n'.repeat(lines)}${nodeIndent}`;\r\n        return {\r\n            newText,\r\n            range\r\n        };\r\n    }\r\n\r\n    protected fitIntoOptions(value: number, existing: number, options: FormattingActionOptions): number {\r\n        if (options.allowMore) {\r\n            value = Math.max(existing, value);\r\n        } else if (options.allowLess) {\r\n            value = Math.min(existing, value);\r\n        }\r\n        return value;\r\n    }\r\n\r\n    protected findFittingMove(range: Range, moves: FormattingMove[], _context: FormattingContext): FormattingMove | undefined {\r\n        if (moves.length === 0) {\r\n            return undefined;\r\n        } else if (moves.length === 1) {\r\n            return moves[0];\r\n        }\r\n\r\n        const existingLines = range.end.line - range.start.line;\r\n\r\n        for (const move of moves) {\r\n            if (move.lines !== undefined && existingLines <= move.lines) {\r\n                return move;\r\n            } else if (move.lines === undefined && existingLines === 0) {\r\n                return move;\r\n            }\r\n        }\r\n\r\n        // Return the last move\r\n        return moves[moves.length - 1];\r\n    }\r\n\r\n    protected iterateCstTree(document: LangiumDocument, context: FormattingContext): Stream<CstNode> {\r\n        const root = document.parseResult.value;\r\n        const rootCst = root.$cstNode;\r\n        if (!rootCst) {\r\n            return EMPTY_STREAM;\r\n        }\r\n        return new TreeStreamImpl(rootCst, node => this.iterateCst(node, context));\r\n    }\r\n\r\n    protected iterateCst(node: CstNode, context: FormattingContext): Stream<CstNode> {\r\n        if (!isCompositeCstNode(node)) {\r\n            return EMPTY_STREAM;\r\n        }\r\n        const initial = context.indentation;\r\n        return new StreamImpl<{ index: number }, CstNode>(\r\n            () => ({ index: 0 }),\r\n            (state) => {\r\n                if (state.index < node.content.length) {\r\n                    return { done: false, value: node.content[state.index++] };\r\n                } else {\r\n                    // Reset the indentation to the level when we entered the node\r\n                    context.indentation = initial;\r\n                    return DONE_RESULT;\r\n                }\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Represents an object that allows to format certain parts of a specific node, like its keywords or properties.\r\n */\r\nexport interface NodeFormatter<T extends AstNode> {\r\n    /**\r\n     * Creates a new formatting region that contains the specified node.\r\n     */\r\n    node(node: AstNode): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains all of the specified nodes.\r\n     */\r\n    nodes(...nodes: AstNode[]): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains the specified property of the supplied node.\r\n     *\r\n     * @param property The name of the property to format. Scoped to the supplied node.\r\n     * @param index The index of the property, if the property is an array. `0` by default. To retrieve all elements of this array, use the {@link properties} method instead.\r\n     */\r\n    property(property: Properties<T>, index?: number): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains the all of the specified properties of the supplied node.\r\n     *\r\n     * @param properties The names of the properties to format. Scoped to the supplied node.\r\n     */\r\n    properties(...properties: Array<Properties<T>>): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains the specified keyword of the supplied node.\r\n     *\r\n     * @param keyword The keyword to format. Scoped to the supplied node.\r\n     * @param index The index of the keyword, necessary if the keyword appears multiple times. `0` by default. To retrieve all keywords, use the {@link keywords} method instead.\r\n     */\r\n    keyword(keyword: string, index?: number): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains the all of the specified keywords of the supplied node.\r\n     *\r\n     * @param keywords The keywords to format. Scoped to the supplied node.\r\n     */\r\n    keywords(...keywords: string[]): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains the all of the specified CST nodes.\r\n     *\r\n     * @param nodes A list of CST nodes to format\r\n     */\r\n    cst(nodes: CstNode[]): FormattingRegion\r\n    /**\r\n     * Creates a new formatting region that contains all nodes between the given formatting regions.\r\n     *\r\n     * For example, can be used to retrieve a formatting region that contains all nodes between two curly braces:\r\n     *\r\n     * ```ts\r\n     * const formatter = this.getNodeFormatter(node);\r\n     * const bracesOpen = formatter.keyword('{');\r\n     * const bracesClose = formatter.keyword('}');\r\n     * formatter.interior(bracesOpen, bracesClose).prepend(Formatting.indent());\r\n     * ```\r\n     *\r\n     * @param start Determines where the search for interior nodes should start\r\n     * @param end Determines where the search for interior nodes should end\r\n     */\r\n    interior(start: FormattingRegion, end: FormattingRegion): FormattingRegion\r\n}\r\n\r\nexport class DefaultNodeFormatter<T extends AstNode> implements NodeFormatter<T> {\r\n\r\n    protected readonly astNode: T;\r\n    protected readonly collector: FormattingCollector;\r\n\r\n    constructor(astNode: T, collector: FormattingCollector) {\r\n        this.astNode = astNode;\r\n        this.collector = collector;\r\n    }\r\n\r\n    node(node: AstNode): FormattingRegion {\r\n        return new FormattingRegion(node.$cstNode ? [node.$cstNode] : [], this.collector);\r\n    }\r\n\r\n    nodes(...nodes: AstNode[]): FormattingRegion {\r\n        const cstNodes: CstNode[] = [];\r\n        for (const node of nodes) {\r\n            if (node.$cstNode) {\r\n                cstNodes.push(node.$cstNode);\r\n            }\r\n        }\r\n        return new FormattingRegion(cstNodes, this.collector);\r\n    }\r\n\r\n    property(feature: Properties<T>, index?: number): FormattingRegion {\r\n        const cstNode = findNodeForProperty(this.astNode.$cstNode, feature, index);\r\n        return new FormattingRegion(cstNode ? [cstNode] : [], this.collector);\r\n    }\r\n\r\n    properties(...features: Array<Properties<T>>): FormattingRegion {\r\n        const nodes: CstNode[] = [];\r\n        for (const feature of features) {\r\n            const cstNodes = findNodesForProperty(this.astNode.$cstNode, feature);\r\n            nodes.push(...cstNodes);\r\n        }\r\n        return new FormattingRegion(nodes, this.collector);\r\n    }\r\n\r\n    keyword(keyword: string, index?: number): FormattingRegion {\r\n        const cstNode = findNodeForKeyword(this.astNode.$cstNode, keyword, index);\r\n        return new FormattingRegion(cstNode ? [cstNode] : [], this.collector);\r\n    }\r\n\r\n    keywords(...keywords: string[]): FormattingRegion {\r\n        const nodes: CstNode[] = [];\r\n        for (const feature of keywords) {\r\n            const cstNodes = findNodesForKeyword(this.astNode.$cstNode, feature);\r\n            nodes.push(...cstNodes);\r\n        }\r\n        return new FormattingRegion(nodes, this.collector);\r\n    }\r\n\r\n    cst(nodes: CstNode[]): FormattingRegion {\r\n        return new FormattingRegion([...nodes], this.collector);\r\n    }\r\n\r\n    interior(start: FormattingRegion, end: FormattingRegion): FormattingRegion {\r\n        const startNodes = start.nodes;\r\n        const endNodes = end.nodes;\r\n        if (startNodes.length !== 1 || endNodes.length !== 1) {\r\n            return new FormattingRegion([], this.collector);\r\n        }\r\n        let startNode = startNodes[0];\r\n        let endNode = endNodes[0];\r\n\r\n        if (startNode.offset > endNode.offset) {\r\n            const intermediate = startNode;\r\n            startNode = endNode;\r\n            endNode = intermediate;\r\n        }\r\n\r\n        return new FormattingRegion(getInteriorNodes(startNode, endNode), this.collector);\r\n    }\r\n}\r\n\r\nexport interface FormattingContext {\r\n    document: TextDocument\r\n    options: FormattingOptions\r\n    indentation: number // Level of indentation, not the amount of spaces/tabs\r\n}\r\n\r\nexport class FormattingRegion {\r\n\r\n    readonly nodes: CstNode[];\r\n    protected readonly collector: FormattingCollector;\r\n\r\n    constructor(nodes: CstNode[], collector: FormattingCollector) {\r\n        this.nodes = nodes;\r\n        this.collector = collector;\r\n    }\r\n\r\n    /**\r\n     * Prepends the specified formatting to all nodes of this region.\r\n     */\r\n    prepend(formatting: FormattingAction): FormattingRegion {\r\n        for (const node of this.nodes) {\r\n            this.collector(node, 'prepend', formatting);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Appends the specified formatting to all nodes of this region.\r\n     */\r\n    append(formatting: FormattingAction): FormattingRegion {\r\n        for (const node of this.nodes) {\r\n            this.collector(node, 'append', formatting);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Sorrounds all nodes of this region with the specified formatting.\r\n     * Functionally the same as invoking `prepend` and `append` with the same formatting.\r\n     */\r\n    surround(formatting: FormattingAction): FormattingRegion {\r\n        for (const node of this.nodes) {\r\n            this.collector(node, 'prepend', formatting);\r\n            this.collector(node, 'append', formatting);\r\n        }\r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * Creates a copy of this region with a slice of the selected nodes.\r\n     * For both start and end, a negative index can be used to indicate an offset from the end of the array.\r\n     * For example, -2 refers to the second to last element of the array.\r\n     * @param start The beginning index of the specified portion of the region. If start is undefined, then the slice begins at index 0.\r\n     * @param end The end index of the specified portion of the region. This is exclusive of the element at the index 'end'. If end is undefined, then the slice extends to the end of the region.\r\n     */\r\n    slice(start?: number, end?: number): FormattingRegion {\r\n        return new FormattingRegion(this.nodes.slice(start, end), this.collector);\r\n    }\r\n}\r\n\r\nexport interface FormattingAction {\r\n    options: FormattingActionOptions\r\n    moves: FormattingMove[]\r\n}\r\n\r\nexport interface FormattingActionOptions {\r\n    /**\r\n     * The priority of this formatting. Formattings with a higher priority override those with lower priority.\r\n     * `0` by default.\r\n     */\r\n    priority?: number\r\n    /**\r\n     * Determines whether this formatting allows more spaces/lines than expected. For example, if {@link Formatting.newLine} is used, but 2 empty lines already exist between the elements, no formatting is applied.\r\n     */\r\n    allowMore?: boolean\r\n    /**\r\n     * Determines whether this formatting allows less spaces/lines than expected. For example, if {@link Formatting.oneSpace} is used, but no spaces exist between the elements, no formatting is applied.\r\n     */\r\n    allowLess?: boolean\r\n}\r\n\r\nexport interface FormattingMove {\r\n    characters?: number\r\n    tabs?: number\r\n    lines?: number\r\n}\r\n\r\n/**\r\n * Contains utilities to easily create formatting actions that can be applied to a {@link FormattingRegion}.\r\n */\r\nexport namespace Formatting {\r\n\r\n    /**\r\n     * Creates a new formatting that tries to fit the existing text into one of the specified formattings.\r\n     * @param formattings All possible formattings.\r\n     */\r\n    export function fit(...formattings: FormattingAction[]): FormattingAction {\r\n        return {\r\n            options: {},\r\n            moves: formattings.flatMap(e => e.moves).sort(compareMoves)\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that removes all spaces\r\n     */\r\n    export function noSpace(options?: FormattingActionOptions): FormattingAction {\r\n        return spaces(0, options);\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that creates a single space\r\n     */\r\n    export function oneSpace(options?: FormattingActionOptions): FormattingAction {\r\n        return spaces(1, options);\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that creates the specified amount of spaces\r\n     *\r\n     * @param count The amount of spaces to be inserted\r\n     */\r\n    export function spaces(count: number, options?: FormattingActionOptions): FormattingAction {\r\n        return {\r\n            options: options ?? {},\r\n            moves: [{\r\n                characters: count\r\n            }]\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that moves an element to the next line\r\n     */\r\n    export function newLine(options?: FormattingActionOptions): FormattingAction {\r\n        return newLines(1, options);\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that creates the specified amount of new lines.\r\n     */\r\n    export function newLines(count: number, options?: FormattingActionOptions): FormattingAction {\r\n        return {\r\n            options: options ?? {},\r\n            moves: [{\r\n                lines: count\r\n            }]\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that moves the element to a new line and indents that line.\r\n     */\r\n    export function indent(options?: FormattingActionOptions): FormattingAction {\r\n        return {\r\n            options: options ?? {},\r\n            moves: [{\r\n                tabs: 1,\r\n                lines: 1\r\n            }]\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a new formatting that removes all indentation.\r\n     */\r\n    export function noIndent(options?: FormattingActionOptions): FormattingAction {\r\n        return {\r\n            options: options ?? {},\r\n            moves: [{\r\n                tabs: 0\r\n            }]\r\n        };\r\n    }\r\n\r\n    function compareMoves(a: FormattingMove, b: FormattingMove): number {\r\n        const aLines = a.lines ?? 0;\r\n        const bLines = b.lines ?? 0;\r\n        const aTabs = a.tabs ?? 0;\r\n        const bTabs = b.tabs ?? 0;\r\n        const aSpaces = a.characters ?? 0;\r\n        const bSpaces = b.characters ?? 0;\r\n        if (aLines < bLines) {\r\n            return -1;\r\n        } else if (aLines > bLines) {\r\n            return 1;\r\n        } else if (aTabs < bTabs) {\r\n            return -1;\r\n        } else if (aTabs > bTabs) {\r\n            return 1;\r\n        } else if (aSpaces < bSpaces) {\r\n            return -1;\r\n        } else if (aSpaces > bSpaces) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n}\r\n\r\nexport type FormattingCollector = (node: CstNode, mode: 'prepend' | 'append', formatting: FormattingAction) => void;\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode } from '../../syntax-tree.js';\r\nimport { AbstractFormatter, Formatting } from '../../lsp/formatter.js';\r\nimport * as ast from '../generated/ast.js';\r\n\r\nconst indentOrSpace = Formatting.fit(Formatting.oneSpace(), Formatting.indent());\r\n\r\nexport class LangiumGrammarFormatter extends AbstractFormatter {\r\n\r\n    protected format(node: AstNode): void {\r\n        if (ast.isCrossReference(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.properties('type', 'terminal').surround(Formatting.noSpace());\r\n        } else if (ast.isParserRule(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keywords('entry', 'fragment', 'returns').append(Formatting.oneSpace());\r\n            if ((node.inferredType || node.returnType || node.dataType) && node.parameters.length === 0) {\r\n                formatter.property('name').append(Formatting.oneSpace());\r\n            } else {\r\n                formatter.property('name').append(Formatting.noSpace());\r\n            }\r\n            formatter.properties('parameters').append(Formatting.noSpace());\r\n            formatter.keywords(',').append(Formatting.oneSpace());\r\n            formatter.keywords('<').append(Formatting.noSpace());\r\n            const semicolon = formatter.keyword(';');\r\n            const colon = formatter.keyword(':');\r\n            colon.prepend(Formatting.noSpace());\r\n            formatter.interior(colon, semicolon).prepend(Formatting.indent());\r\n            semicolon.prepend(Formatting.fit(Formatting.noSpace(), Formatting.newLine()));\r\n            formatter.node(node).prepend(Formatting.noIndent());\r\n        } else if (ast.isTerminalRule(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            if (node.type) {\r\n                formatter.property('name').append(Formatting.oneSpace());\r\n                formatter.keyword('returns').append(Formatting.oneSpace());\r\n            }\r\n            formatter.keywords('hidden', 'terminal', 'fragment').append(Formatting.oneSpace());\r\n            formatter.keyword(':').prepend(Formatting.noSpace());\r\n            formatter.keyword(';').prepend(Formatting.fit(Formatting.noSpace(), Formatting.newLine()));\r\n            formatter.node(node).prepend(Formatting.noIndent());\r\n        } else if (ast.isAction(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keyword('{').append(Formatting.noSpace());\r\n            formatter.keywords('.', '+=', '=').surround(Formatting.noSpace());\r\n            formatter.keyword('}').prepend(Formatting.noSpace());\r\n        } else if (ast.isInferredType(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keywords('infer', 'infers').append(Formatting.oneSpace());\r\n        } else if (ast.isAssignment(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keywords('=', '+=', '?=').surround(Formatting.noSpace());\r\n        } else if (ast.isRuleCall(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keyword('<').surround(Formatting.noSpace());\r\n            formatter.keyword(',').append(Formatting.oneSpace());\r\n            formatter.properties('arguments').append(Formatting.noSpace());\r\n        } else if (ast.isInterface(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keyword('interface').append(Formatting.oneSpace());\r\n            formatter.keyword('extends').prepend(Formatting.oneSpace()).append(indentOrSpace);\r\n            formatter.keywords(',').prepend(Formatting.noSpace()).append(indentOrSpace);\r\n            const bracesOpen = formatter.keyword('{');\r\n            bracesOpen.prepend(Formatting.fit(Formatting.oneSpace(), Formatting.newLine()));\r\n            const bracesClose = formatter.keyword('}');\r\n            bracesClose.prepend(Formatting.newLine());\r\n            formatter.interior(bracesOpen, bracesClose).prepend(Formatting.indent());\r\n        } else if (ast.isType(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.keyword('type').append(Formatting.oneSpace());\r\n            formatter.keyword('=').prepend(Formatting.oneSpace()).append(indentOrSpace);\r\n            formatter.keyword(';').prepend(Formatting.noSpace()).append(Formatting.newLine());\r\n        } else if (ast.isGrammar(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            const nodes = formatter.nodes(...node.rules, ...node.interfaces, ...node.types, ...node.imports);\r\n            nodes.prepend(Formatting.noIndent());\r\n            formatter.keyword('grammar').prepend(Formatting.noSpace()).append(Formatting.oneSpace());\r\n        }\r\n\r\n        if (ast.isAbstractElement(node)) {\r\n            const formatter = this.getNodeFormatter(node);\r\n            formatter.property('cardinality').prepend(Formatting.noSpace());\r\n        }\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode } from '../../syntax-tree.js';\r\nimport type { SemanticTokenAcceptor } from '../../lsp/semantic-token-provider.js';\r\nimport { SemanticTokenTypes } from 'vscode-languageserver';\r\nimport { AbstractSemanticTokenProvider } from '../../lsp/semantic-token-provider.js';\r\nimport { isAction, isAssignment, isParameter, isParameterReference, isReturnType, isRuleCall, isSimpleType, isTypeAttribute } from '../generated/ast.js';\r\n\r\nexport class LangiumGrammarSemanticTokenProvider extends AbstractSemanticTokenProvider {\r\n\r\n    protected highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void {\r\n        if (isAssignment(node)) {\r\n            acceptor({\r\n                node,\r\n                property: 'feature',\r\n                type: SemanticTokenTypes.property\r\n            });\r\n        } else if (isAction(node)) {\r\n            if (node.feature) {\r\n                acceptor({\r\n                    node,\r\n                    property: 'feature',\r\n                    type: SemanticTokenTypes.property\r\n                });\r\n            }\r\n        } else if (isReturnType(node)) {\r\n            acceptor({\r\n                node,\r\n                property: 'name',\r\n                type: SemanticTokenTypes.type\r\n            });\r\n        } else if (isSimpleType(node)) {\r\n            if (node.primitiveType || node.typeRef) {\r\n                acceptor({\r\n                    node,\r\n                    property: node.primitiveType ? 'primitiveType' : 'typeRef',\r\n                    type: SemanticTokenTypes.type\r\n                });\r\n            }\r\n        } else if (isParameter(node)) {\r\n            acceptor({\r\n                node,\r\n                property: 'name',\r\n                type: SemanticTokenTypes.parameter\r\n            });\r\n        } else if (isParameterReference(node)) {\r\n            acceptor({\r\n                node,\r\n                property: 'parameter',\r\n                type: SemanticTokenTypes.parameter\r\n            });\r\n        } else if (isRuleCall(node)) {\r\n            if (node.rule.ref?.fragment) {\r\n                acceptor({\r\n                    node,\r\n                    property: 'rule',\r\n                    type: SemanticTokenTypes.type\r\n                });\r\n            }\r\n        } else if (isTypeAttribute(node)) {\r\n            acceptor({\r\n                node,\r\n                property: 'name',\r\n                type: SemanticTokenTypes.property\r\n            });\r\n        }\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable no-bitwise */\r\n\r\nimport type { Range, SemanticTokens, SemanticTokensClientCapabilities, SemanticTokensDelta, SemanticTokensDeltaParams, SemanticTokensOptions, SemanticTokensParams, SemanticTokensRangeParams } from 'vscode-languageserver';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, CstNode, Properties } from '../syntax-tree.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport { CancellationToken, SemanticTokenModifiers, SemanticTokensBuilder as BaseSemanticTokensBuilder, SemanticTokenTypes } from 'vscode-languageserver';\r\nimport { findNodesForKeyword, findNodeForProperty, findNodesForProperty, findNodeForKeyword } from '../utils/grammar-util.js';\r\nimport { streamAst } from '../utils/ast-util.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\nimport { inRange } from '../utils/cst-util.js';\r\n\r\nexport const AllSemanticTokenTypes: Record<string, number> = {\r\n    [SemanticTokenTypes.class]: 0,\r\n    [SemanticTokenTypes.comment]: 1,\r\n    [SemanticTokenTypes.enum]: 2,\r\n    [SemanticTokenTypes.enumMember]: 3,\r\n    [SemanticTokenTypes.event]: 4,\r\n    [SemanticTokenTypes.function]: 5,\r\n    [SemanticTokenTypes.interface]: 6,\r\n    [SemanticTokenTypes.keyword]: 7,\r\n    [SemanticTokenTypes.macro]: 8,\r\n    [SemanticTokenTypes.method]: 9,\r\n    [SemanticTokenTypes.modifier]: 10,\r\n    [SemanticTokenTypes.namespace]: 11,\r\n    [SemanticTokenTypes.number]: 12,\r\n    [SemanticTokenTypes.operator]: 13,\r\n    [SemanticTokenTypes.parameter]: 14,\r\n    [SemanticTokenTypes.property]: 15,\r\n    [SemanticTokenTypes.regexp]: 16,\r\n    [SemanticTokenTypes.string]: 17,\r\n    [SemanticTokenTypes.struct]: 18,\r\n    [SemanticTokenTypes.type]: 19,\r\n    [SemanticTokenTypes.typeParameter]: 20,\r\n    [SemanticTokenTypes.variable]: 21,\r\n    [SemanticTokenTypes.decorator]: 22\r\n};\r\n\r\nexport const AllSemanticTokenModifiers: Record<string, number> = {\r\n    [SemanticTokenModifiers.abstract]: 1 << 0,\r\n    [SemanticTokenModifiers.async]: 1 << 1,\r\n    [SemanticTokenModifiers.declaration]: 1 << 2,\r\n    [SemanticTokenModifiers.defaultLibrary]: 1 << 3,\r\n    [SemanticTokenModifiers.definition]: 1 << 4,\r\n    [SemanticTokenModifiers.deprecated]: 1 << 5,\r\n    [SemanticTokenModifiers.documentation]: 1 << 6,\r\n    [SemanticTokenModifiers.modification]: 1 << 7,\r\n    [SemanticTokenModifiers.readonly]: 1 << 8,\r\n    [SemanticTokenModifiers.static]: 1 << 9\r\n};\r\n\r\nexport const DefaultSemanticTokenOptions: SemanticTokensOptions = {\r\n    legend: {\r\n        tokenTypes: Object.keys(AllSemanticTokenTypes),\r\n        tokenModifiers: Object.keys(AllSemanticTokenModifiers)\r\n    },\r\n    full: {\r\n        delta: true\r\n    },\r\n    range: true\r\n};\r\n\r\nexport interface SemanticTokenProvider {\r\n    semanticHighlight(document: LangiumDocument, params: SemanticTokensParams, cancelToken?: CancellationToken): MaybePromise<SemanticTokens>\r\n    semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken?: CancellationToken): MaybePromise<SemanticTokens>\r\n    semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken?: CancellationToken): MaybePromise<SemanticTokens | SemanticTokensDelta>\r\n}\r\n\r\nexport interface SemanticToken {\r\n    line: number\r\n    char: number\r\n    length: number\r\n    tokenType: number\r\n    tokenModifiers: number\r\n}\r\n\r\nexport type SemanticTokenAcceptorOptions<N extends AstNode = AstNode> = ({\r\n    line: number;\r\n    char: number;\r\n    length: number;\r\n} | {\r\n    node: N;\r\n    property: Properties<N>;\r\n    index?: number;\r\n} | {\r\n    node: N;\r\n    keyword: string;\r\n    index?: number;\r\n} | {\r\n    cst: CstNode;\r\n} | {\r\n    range: Range;\r\n}) & {\r\n    type: string;\r\n    modifier?: string | string[];\r\n}\r\n\r\nexport interface SemanticTokenPropertyOptions<T extends AstNode> {\r\n    node: T;\r\n    property: Properties<T>;\r\n    index?: number;\r\n    type: string;\r\n    modifier?: string | string[];\r\n}\r\n\r\nexport interface SemanticTokenKeywordOptions {\r\n    node: AstNode;\r\n    keyword: string;\r\n    index?: number;\r\n    type: string;\r\n    modifier?: string | string[];\r\n}\r\n\r\nexport interface SemanticTokenNodeOptions {\r\n    node: CstNode;\r\n    type: string;\r\n    modifier?: string | string[];\r\n}\r\n\r\nexport interface SemanticTokenRangeOptions {\r\n    range: Range\r\n    type: string\r\n    modifier?: string | string[]\r\n}\r\n\r\nexport class SemanticTokensBuilder extends BaseSemanticTokensBuilder {\r\n    private _tokens: SemanticToken[] = [];\r\n\r\n    override push(line: number, char: number, length: number, tokenType: number, tokenModifiers: number): void {\r\n        this._tokens.push({\r\n            line,\r\n            char,\r\n            length,\r\n            tokenType,\r\n            tokenModifiers\r\n        });\r\n    }\r\n\r\n    override build(): SemanticTokens {\r\n        this.applyTokens();\r\n        return super.build();\r\n    }\r\n\r\n    override buildEdits(): SemanticTokens | SemanticTokensDelta {\r\n        this.applyTokens();\r\n        return super.buildEdits();\r\n    }\r\n\r\n    /**\r\n     * Flushes the cached delta token values\r\n     */\r\n    flush(): void {\r\n        this.previousResult(this.id);\r\n    }\r\n\r\n    private applyTokens(): void {\r\n        for (const token of this._tokens.sort(this.compareTokens)) {\r\n            super.push(token.line, token.char, token.length, token.tokenType, token.tokenModifiers);\r\n        }\r\n        this._tokens = [];\r\n    }\r\n\r\n    private compareTokens(a: SemanticToken, b: SemanticToken): number {\r\n        if (a.line === b.line) {\r\n            return a.char - b.char;\r\n        }\r\n        return a.line - b.line;\r\n    }\r\n}\r\n\r\nexport type SemanticTokenAcceptor = <N extends AstNode = AstNode>(options: SemanticTokenAcceptorOptions<N>) => void;\r\n\r\n/**\r\n * A basic super class for providing semantic token data.\r\n * Users of Langium should extend this class to create their own `SemanticTokenProvider`.\r\n *\r\n * The entry method for generating semantic tokens based on an `AstNode` is the `highlightElement` method.\r\n */\r\nexport abstract class AbstractSemanticTokenProvider implements SemanticTokenProvider {\r\n\r\n    /**\r\n     * Store a token builder for each open document.\r\n     */\r\n    protected tokensBuilders = new Map<string, SemanticTokensBuilder>();\r\n    protected currentDocument?: LangiumDocument;\r\n    protected currentTokensBuilder?: SemanticTokensBuilder;\r\n    protected currentRange?: Range;\r\n    protected clientCapabilities?: SemanticTokensClientCapabilities;\r\n\r\n    constructor(services: LangiumServices) {\r\n        // Delete the token builder once the text document has been closed\r\n        services.shared.workspace.TextDocuments.onDidClose(e => {\r\n            this.tokensBuilders.delete(e.document.uri);\r\n        });\r\n        services.shared.lsp.LanguageServer.onInitialize(params => {\r\n            this.initialize(params.capabilities.textDocument?.semanticTokens);\r\n        });\r\n    }\r\n\r\n    initialize(clientCapabilities?: SemanticTokensClientCapabilities): void {\r\n        this.clientCapabilities = clientCapabilities;\r\n    }\r\n\r\n    async semanticHighlight(document: LangiumDocument, _params: SemanticTokensParams, cancelToken = CancellationToken.None): Promise<SemanticTokens> {\r\n        this.currentRange = undefined;\r\n        this.currentDocument = document;\r\n        this.currentTokensBuilder = this.getDocumentTokensBuilder(document);\r\n        this.currentTokensBuilder.flush();\r\n        await this.computeHighlighting(document, this.createAcceptor(), cancelToken);\r\n        return this.currentTokensBuilder.build();\r\n    }\r\n\r\n    async semanticHighlightRange(document: LangiumDocument, params: SemanticTokensRangeParams, cancelToken = CancellationToken.None): Promise<SemanticTokens> {\r\n        this.currentRange = params.range;\r\n        this.currentDocument = document;\r\n        this.currentTokensBuilder = this.getDocumentTokensBuilder(document);\r\n        this.currentTokensBuilder.flush();\r\n        await this.computeHighlighting(document, this.createAcceptor(), cancelToken);\r\n        return this.currentTokensBuilder.build();\r\n    }\r\n\r\n    async semanticHighlightDelta(document: LangiumDocument, params: SemanticTokensDeltaParams, cancelToken = CancellationToken.None): Promise<SemanticTokens | SemanticTokensDelta> {\r\n        this.currentRange = undefined;\r\n        this.currentDocument = document;\r\n        this.currentTokensBuilder = this.getDocumentTokensBuilder(document);\r\n        this.currentTokensBuilder.previousResult(params.previousResultId);\r\n        await this.computeHighlighting(document, this.createAcceptor(), cancelToken);\r\n        return this.currentTokensBuilder.buildEdits();\r\n    }\r\n\r\n    protected createAcceptor(): SemanticTokenAcceptor {\r\n        const acceptor: SemanticTokenAcceptor = options => {\r\n            if ('line' in options) {\r\n                this.highlightToken({\r\n                    range: {\r\n                        start: {\r\n                            line: options.line,\r\n                            character: options.char\r\n                        },\r\n                        end: {\r\n                            line: options.line,\r\n                            character: options.char + options.length\r\n                        }\r\n                    },\r\n                    type: options.type,\r\n                    modifier: options.modifier\r\n                });\r\n            } else if ('range' in options) {\r\n                this.highlightToken(options);\r\n            } else if ('keyword' in options) {\r\n                this.highlightKeyword(options);\r\n            } else if ('property' in options) {\r\n                this.highlightProperty(options);\r\n            } else {\r\n                this.highlightNode({\r\n                    node: options.cst,\r\n                    type: options.type,\r\n                    modifier: options.modifier\r\n                });\r\n            }\r\n        };\r\n        return acceptor;\r\n    }\r\n\r\n    protected getDocumentTokensBuilder(document: LangiumDocument): SemanticTokensBuilder {\r\n        const existing = this.tokensBuilders.get(document.uri.toString());\r\n        if (existing) {\r\n            return existing;\r\n        }\r\n        const builder = new SemanticTokensBuilder();\r\n        this.tokensBuilders.set(document.uri.toString(), builder);\r\n        return builder;\r\n    }\r\n\r\n    protected async computeHighlighting(document: LangiumDocument, acceptor: SemanticTokenAcceptor, cancelToken: CancellationToken): Promise<void> {\r\n        const root = document.parseResult.value;\r\n        const treeIterator = streamAst(root, { range: this.currentRange }).iterator();\r\n        let result: IteratorResult<AstNode>;\r\n        do {\r\n            result = treeIterator.next();\r\n            if (!result.done) {\r\n                await interruptAndCheck(cancelToken);\r\n                const node = result.value;\r\n                if (this.highlightElement(node, acceptor) === 'prune') {\r\n                    treeIterator.prune();\r\n                }\r\n            }\r\n        } while (!result.done);\r\n    }\r\n\r\n    /**\r\n     * @return `'prune'` to skip the children of this element, nothing otherwise.\r\n     */\r\n    protected abstract highlightElement(node: AstNode, acceptor: SemanticTokenAcceptor): void | undefined | 'prune';\r\n\r\n    protected highlightToken(options: SemanticTokenRangeOptions): void {\r\n        const { range, type } = options;\r\n        let modifiers = options.modifier;\r\n        if ((this.currentRange && !inRange(range, this.currentRange)) || !this.currentDocument || !this.currentTokensBuilder) {\r\n            return;\r\n        }\r\n        const intType = AllSemanticTokenTypes[type];\r\n        let totalModifier = 0;\r\n        if (modifiers !== undefined) {\r\n            if (typeof modifiers === 'string') {\r\n                modifiers = [modifiers];\r\n            }\r\n            for (const modifier of modifiers) {\r\n                const intModifier = AllSemanticTokenModifiers[modifier];\r\n                totalModifier |= intModifier;\r\n            }\r\n        }\r\n        const startLine = range.start.line;\r\n        const endLine = range.end.line;\r\n        if (startLine === endLine) {\r\n            // Token only spans a single line\r\n            const char = range.start.character;\r\n            const length = range.end.character - char;\r\n            this.currentTokensBuilder.push(startLine, char, length, intType, totalModifier);\r\n        } else if (this.clientCapabilities?.multilineTokenSupport) {\r\n            // Let token span multiple lines\r\n            const startChar = range.start.character;\r\n            const startOffset = this.currentDocument.textDocument.offsetAt(range.start);\r\n            const endOffset = this.currentDocument.textDocument.offsetAt(range.end);\r\n            this.currentTokensBuilder.push(startLine, startChar, endOffset - startOffset, intType, totalModifier);\r\n        } else {\r\n            // Token spans multiple lines, but the client doesn't support it\r\n            // Split the range into multiple semantic tokens\r\n            const firstLineStart = range.start;\r\n            let nextLineOffset = this.currentDocument.textDocument.offsetAt({\r\n                line: startLine + 1,\r\n                character: 0\r\n            });\r\n            // Build first line\r\n            this.currentTokensBuilder.push(\r\n                firstLineStart.line,\r\n                firstLineStart.character,\r\n                nextLineOffset - firstLineStart.character - 1,\r\n                intType,\r\n                totalModifier\r\n            );\r\n            // Build all lines in between first and last\r\n            for (let i = startLine + 1; i < endLine; i++) {\r\n                const currentLineOffset = nextLineOffset;\r\n                nextLineOffset = this.currentDocument.textDocument.offsetAt({\r\n                    line: i + 1,\r\n                    character: 0\r\n                });\r\n                this.currentTokensBuilder.push(\r\n                    i,\r\n                    0,\r\n                    nextLineOffset - currentLineOffset - 1,\r\n                    intType, totalModifier\r\n                );\r\n            }\r\n            // Build last line\r\n            this.currentTokensBuilder.push(\r\n                endLine,\r\n                0,\r\n                range.end.character,\r\n                intType,\r\n                totalModifier\r\n            );\r\n        }\r\n    }\r\n\r\n    protected highlightProperty<N extends AstNode>(options: SemanticTokenPropertyOptions<N>): void {\r\n        const nodes: CstNode[] = [];\r\n        if (typeof options.index === 'number') {\r\n            const node = findNodeForProperty(options.node.$cstNode, options.property, options.index);\r\n            if (node) {\r\n                nodes.push(node);\r\n            }\r\n        } else {\r\n            nodes.push(...findNodesForProperty(options.node.$cstNode, options.property));\r\n        }\r\n        const { type, modifier } = options;\r\n        for (const node of nodes) {\r\n            this.highlightNode({\r\n                node,\r\n                type,\r\n                modifier\r\n            });\r\n        }\r\n    }\r\n\r\n    protected highlightKeyword(options: SemanticTokenKeywordOptions): void {\r\n        const { node, keyword, type, index, modifier } = options;\r\n        const nodes: CstNode[] = [];\r\n        if (typeof index === 'number') {\r\n            const keywordNode = findNodeForKeyword(node.$cstNode, keyword, index);\r\n            if (keywordNode) {\r\n                nodes.push(keywordNode);\r\n            }\r\n        } else {\r\n            nodes.push(...findNodesForKeyword(node.$cstNode, keyword));\r\n        }\r\n        for (const keywordNode of nodes) {\r\n            this.highlightNode({\r\n                node: keywordNode,\r\n                type,\r\n                modifier\r\n            });\r\n        }\r\n    }\r\n\r\n    protected highlightNode(options: SemanticTokenNodeOptions): void {\r\n        const { node, type, modifier } = options;\r\n        const range = node.range;\r\n        this.highlightToken({\r\n            range,\r\n            type,\r\n            modifier\r\n        });\r\n    }\r\n\r\n}\r\n\r\nexport namespace SemanticTokensDecoder {\r\n    export interface DecodedSemanticToken {\r\n        offset: number;\r\n        tokenType: SemanticTokenTypes;\r\n        tokenModifiers: number;\r\n        text: string;\r\n    }\r\n\r\n    export function decode<T extends AstNode = AstNode>(tokens: SemanticTokens, document: LangiumDocument<T>): DecodedSemanticToken[] {\r\n        const typeMap = new Map<number, SemanticTokenTypes>();\r\n        Object.entries(AllSemanticTokenTypes).forEach(([type, index]) => typeMap.set(index, type as SemanticTokenTypes));\r\n        let line = 0;\r\n        let character = 0;\r\n        return sliceIntoChunks(tokens.data, 5).map(t => {\r\n            line += t[0];\r\n            if (t[0] !== 0) {\r\n                character = 0;\r\n            }\r\n            character += t[1];\r\n            const length = t[2];\r\n            const offset = document.textDocument.offsetAt({ line, character });\r\n            return {\r\n                offset,\r\n                tokenType: typeMap.get(t[3])!,\r\n                tokenModifiers: t[4],\r\n                text: document.textDocument.getText({ start: { line, character }, end: { line, character: character + length } })\r\n            } as DecodedSemanticToken;\r\n        });\r\n    }\r\n\r\n    function sliceIntoChunks<T>(arr: T[], chunkSize: number) {\r\n        const res = [];\r\n        for (let i = 0; i < arr.length; i += chunkSize) {\r\n            const chunk = arr.slice(i, i + chunkSize);\r\n            res.push(chunk);\r\n        }\r\n        return res;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n* Copyright 2022 TypeFox GmbH\r\n* This program and the accompanying materials are made available under the\r\n* terms of the MIT License, which is available in the project root.\r\n******************************************************************************/\r\n\r\nimport type { AstNode, CstNode } from '../../syntax-tree.js';\r\nimport { DefaultNameProvider } from '../../references/name-provider.js';\r\nimport { findNodeForProperty } from '../../utils/grammar-util.js';\r\nimport { isAssignment } from '../generated/ast.js';\r\n\r\nexport class LangiumGrammarNameProvider extends DefaultNameProvider {\r\n\r\n    override getName(node: AstNode): string | undefined {\r\n        if (isAssignment(node)) {\r\n            return node.feature;\r\n        } else {\r\n            return super.getName(node);\r\n        }\r\n    }\r\n\r\n    override getNameNode(node: AstNode): CstNode | undefined {\r\n        if (isAssignment(node)) {\r\n            return findNodeForProperty(node.$cstNode, 'feature');\r\n        } else {\r\n            return super.getNameNode(node);\r\n        }\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, CstNode, GenericAstNode } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { ReferenceDescription } from '../workspace/ast-descriptions.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { NameProvider } from './name-provider.js';\r\nimport type { URI } from '../utils/uri-util.js';\r\nimport { findAssignment } from '../utils/grammar-util.js';\r\nimport { isReference } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { isCstChildNode, toDocumentSegment } from '../utils/cst-util.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { UriUtils } from '../utils/uri-util.js';\r\n\r\n/**\r\n * Language-specific service for finding references and declaration of a given `CstNode`.\r\n */\r\nexport interface References {\r\n\r\n    /**\r\n     * If the CstNode is a reference node the target CstNode will be returned.\r\n     * If the CstNode is a significant node of the CstNode this CstNode will be returned.\r\n     *\r\n     * @param sourceCstNode CstNode that points to a AstNode\r\n     */\r\n    findDeclaration(sourceCstNode: CstNode): AstNode | undefined;\r\n\r\n    /**\r\n     * If the CstNode is a reference node the target CstNode will be returned.\r\n     * If the CstNode is a significant node of the CstNode this CstNode will be returned.\r\n     *\r\n     * @param sourceCstNode CstNode that points to a AstNode\r\n     */\r\n    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined;\r\n\r\n    /**\r\n     * Finds all references to the target node as references (local references) or reference descriptions.\r\n     *\r\n     * @param targetNode Specified target node whose references should be returned\r\n     */\r\n    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription>;\r\n}\r\n\r\nexport interface FindReferencesOptions {\r\n    /**\r\n     * @deprecated Since v1.2.0. Please use `documentUri` instead.\r\n     */\r\n    onlyLocal?: boolean;\r\n    /**\r\n     * When set, the `findReferences` method will only return references/declarations from the specified document.\r\n     */\r\n    documentUri?: URI;\r\n    /**\r\n     * Whether the returned list of references should include the declaration.\r\n     */\r\n    includeDeclaration?: boolean;\r\n}\r\n\r\nexport class DefaultReferences implements References {\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly index: IndexManager;\r\n    protected readonly nodeLocator: AstNodeLocator;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.index = services.shared.workspace.IndexManager;\r\n        this.nodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    findDeclaration(sourceCstNode: CstNode): AstNode | undefined {\r\n        if (sourceCstNode) {\r\n            const assignment = findAssignment(sourceCstNode);\r\n            const nodeElem = sourceCstNode.astNode;\r\n            if (assignment && nodeElem) {\r\n                const reference = (nodeElem as GenericAstNode)[assignment.feature];\r\n\r\n                if (isReference(reference)) {\r\n                    return reference.ref;\r\n                } else if (Array.isArray(reference)) {\r\n                    for (const ref of reference) {\r\n                        if (isReference(ref) && ref.$refNode\r\n                            && ref.$refNode.offset <= sourceCstNode.offset\r\n                            && ref.$refNode.end >= sourceCstNode.end) {\r\n                            return ref.ref;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (nodeElem) {\r\n                const nameNode = this.nameProvider.getNameNode(nodeElem);\r\n                // Only return the targeted node in case the targeted cst node is the name node or part of it\r\n                if (nameNode && (nameNode === sourceCstNode || isCstChildNode(sourceCstNode, nameNode))) {\r\n                    return nodeElem;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    findDeclarationNode(sourceCstNode: CstNode): CstNode | undefined {\r\n        const astNode = this.findDeclaration(sourceCstNode);\r\n        if (astNode?.$cstNode) {\r\n            const targetNode = this.nameProvider.getNameNode(astNode);\r\n            return targetNode ?? astNode.$cstNode;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription> {\r\n        const refs: ReferenceDescription[] = [];\r\n        if (options.includeDeclaration) {\r\n            const ref = this.getReferenceToSelf(targetNode);\r\n            if (ref) {\r\n                refs.push(ref);\r\n            }\r\n        }\r\n        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));\r\n        if (options.documentUri) {\r\n            indexReferences = indexReferences.filter(ref => UriUtils.equals(ref.sourceUri, options.documentUri));\r\n        }\r\n        refs.push(...indexReferences);\r\n        return stream(refs);\r\n    }\r\n\r\n    protected getReferenceToSelf(targetNode: AstNode): ReferenceDescription | undefined {\r\n        const nameNode = this.nameProvider.getNameNode(targetNode);\r\n        if (nameNode) {\r\n            const doc = getDocument(targetNode);\r\n            const path = this.nodeLocator.getAstNodePath(targetNode);\r\n            return {\r\n                sourceUri: doc.uri,\r\n                sourcePath: path,\r\n                targetUri: doc.uri,\r\n                targetPath: path,\r\n                segment: toDocumentSegment(nameNode),\r\n                local: true\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n* Copyright 2021 TypeFox GmbH\r\n* This program and the accompanying materials are made available under the\r\n* terms of the MIT License, which is available in the project root.\r\n******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../../services.js';\r\nimport type { AstNode, CstNode } from '../../syntax-tree.js';\r\nimport type { Stream } from '../../utils/stream.js';\r\nimport type { ReferenceDescription } from '../../workspace/ast-descriptions.js';\r\nimport type { LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { Action, Assignment, Interface, ParserRule, Type, TypeAttribute } from '../generated/ast.js';\r\nimport type { FindReferencesOptions } from '../../references/references.js';\r\nimport { DefaultReferences } from '../../references/references.js';\r\nimport { getContainerOfType, getDocument } from '../../utils/ast-util.js';\r\nimport { toDocumentSegment } from '../../utils/cst-util.js';\r\nimport { findAssignment, findNodeForProperty } from '../../utils/grammar-util.js';\r\nimport { stream } from '../../utils/stream.js';\r\nimport { UriUtils } from '../../utils/uri-util.js';\r\nimport { isAction, isAssignment, isInterface, isParserRule, isType, isTypeAttribute } from '../generated/ast.js';\r\nimport { extractAssignments, getActionAtElement } from '../internal-grammar-util.js';\r\nimport { collectChildrenTypes, collectSuperTypes } from '../type-system/types-util.js';\r\n\r\nexport class LangiumGrammarReferences extends DefaultReferences {\r\n    protected readonly documents: LangiumDocuments;\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.documents = services.shared.workspace.LangiumDocuments;\r\n    }\r\n\r\n    override findDeclaration(sourceCstNode: CstNode): AstNode | undefined {\r\n        const nodeElem = sourceCstNode.astNode;\r\n        const assignment = findAssignment(sourceCstNode);\r\n        if (assignment && assignment.feature === 'feature') {\r\n            // Only search for a special declaration if the cst node is the feature property of the action/assignment\r\n            if (isAssignment(nodeElem)) {\r\n                return this.findAssignmentDeclaration(nodeElem);\r\n            } else if (isAction(nodeElem)) {\r\n                return this.findActionDeclaration(nodeElem);\r\n            }\r\n        }\r\n        return super.findDeclaration(sourceCstNode);\r\n    }\r\n\r\n    override findReferences(targetNode: AstNode, options: FindReferencesOptions): Stream<ReferenceDescription> {\r\n        if (isTypeAttribute(targetNode)) {\r\n            return this.findReferencesToTypeAttribute(targetNode, options.includeDeclaration ?? false);\r\n        } else {\r\n            return super.findReferences(targetNode, options);\r\n        }\r\n    }\r\n\r\n    protected findReferencesToTypeAttribute(targetNode: TypeAttribute, includeDeclaration: boolean): Stream<ReferenceDescription> {\r\n        const refs: ReferenceDescription[] = [];\r\n        const interfaceNode = getContainerOfType(targetNode, isInterface);\r\n        if (interfaceNode) {\r\n            if (includeDeclaration) {\r\n                const ref = this.getReferenceToSelf(targetNode);\r\n                if (ref) {\r\n                    refs.push(ref);\r\n                }\r\n            }\r\n            const interfaces = collectChildrenTypes(interfaceNode, this, this.documents, this.nodeLocator);\r\n            const targetRules: Array<ParserRule | Action> = [];\r\n            interfaces.forEach(interf => {\r\n                const rules = this.findRulesWithReturnType(interf);\r\n                targetRules.push(...rules);\r\n            });\r\n            targetRules.forEach(rule => {\r\n                const references = this.createReferencesToAttribute(rule, targetNode);\r\n                refs.push(...references);\r\n            });\r\n        }\r\n        return stream(refs);\r\n    }\r\n\r\n    protected createReferencesToAttribute(ruleOrAction: ParserRule | Action, attribute: TypeAttribute): ReferenceDescription[] {\r\n        const refs: ReferenceDescription[] = [];\r\n        if (isParserRule(ruleOrAction)) {\r\n            const assignment = extractAssignments(ruleOrAction.definition).find(a => a.feature === attribute.name);\r\n            if (assignment?.$cstNode) {\r\n                const leaf = this.nameProvider.getNameNode(assignment);\r\n                if (leaf) {\r\n                    refs.push({\r\n                        sourceUri: getDocument(assignment).uri,\r\n                        sourcePath: this.nodeLocator.getAstNodePath(assignment),\r\n                        targetUri: getDocument(attribute).uri,\r\n                        targetPath: this.nodeLocator.getAstNodePath(attribute),\r\n                        segment: toDocumentSegment(leaf),\r\n                        local: UriUtils.equals(getDocument(assignment).uri, getDocument(attribute).uri)\r\n                    });\r\n                }\r\n            }\r\n        } else {\r\n            // If the action references the attribute directly\r\n            if (ruleOrAction.feature === attribute.name) {\r\n                const leaf = findNodeForProperty(ruleOrAction.$cstNode, 'feature');\r\n                if (leaf) {\r\n                    refs.push({\r\n                        sourceUri: getDocument(ruleOrAction).uri,\r\n                        sourcePath: this.nodeLocator.getAstNodePath(ruleOrAction),\r\n                        targetUri: getDocument(attribute).uri,\r\n                        targetPath: this.nodeLocator.getAstNodePath(attribute),\r\n                        segment: toDocumentSegment(leaf),\r\n                        local: UriUtils.equals(getDocument(ruleOrAction).uri, getDocument(attribute).uri)\r\n                    });\r\n                }\r\n            }\r\n            // Find all references within the parser rule that contains this action\r\n            const parserRule = getContainerOfType(ruleOrAction, isParserRule);\r\n            refs.push(...this.createReferencesToAttribute(parserRule!, attribute));\r\n        }\r\n        return refs;\r\n    }\r\n\r\n    protected findAssignmentDeclaration(assignment: Assignment): AstNode | undefined {\r\n        const parserRule = getContainerOfType(assignment, isParserRule);\r\n        const action = getActionAtElement(assignment);\r\n        if (action) {\r\n            const actionDeclaration = this.findActionDeclaration(action, assignment.feature);\r\n            if (actionDeclaration) {\r\n                return actionDeclaration;\r\n            }\r\n        }\r\n        if (parserRule?.returnType?.ref) {\r\n            if (isInterface(parserRule.returnType.ref) || isType(parserRule.returnType.ref)) {\r\n                const interfaces = collectSuperTypes(parserRule.returnType.ref);\r\n                for (const interf of interfaces) {\r\n                    const typeAttribute = interf.attributes.find(att => att.name === assignment.feature);\r\n                    if (typeAttribute) {\r\n                        return typeAttribute;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return assignment;\r\n    }\r\n\r\n    protected findActionDeclaration(action: Action, featureName?: string): TypeAttribute | undefined {\r\n        if (action.type?.ref) {\r\n            const feature = featureName ?? action.feature;\r\n            const interfaces = collectSuperTypes(action.type.ref);\r\n            for (const interf of interfaces) {\r\n                const typeAttribute = interf.attributes.find(att => att.name === feature);\r\n                if (typeAttribute) {\r\n                    return typeAttribute;\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected findRulesWithReturnType(interf: Interface | Type): Array<ParserRule | Action> {\r\n        const rules: Array<ParserRule | Action> = [];\r\n        const refs = this.index.findAllReferences(interf, this.nodeLocator.getAstNodePath(interf));\r\n        refs.forEach(ref => {\r\n            const doc = this.documents.getOrCreateDocument(ref.sourceUri);\r\n            const astNode = this.nodeLocator.getAstNode(doc.parseResult.value, ref.sourcePath);\r\n            if (isParserRule(astNode) || isAction(astNode)) {\r\n                rules.push(astNode);\r\n            }\r\n        });\r\n        return rules;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { DefinitionParams } from 'vscode-languageserver';\r\nimport type { LangiumServices } from '../../services.js';\r\nimport type { AstNode, LeafCstNode, Properties } from '../../syntax-tree.js';\r\nimport type { MaybePromise } from '../../utils/promise-util.js';\r\nimport type { LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { Grammar, GrammarImport } from '../generated/ast.js';\r\nimport { LocationLink, Range } from 'vscode-languageserver';\r\nimport { DefaultDefinitionProvider } from '../../lsp/index.js';\r\nimport { streamContents } from '../../utils/ast-util.js';\r\nimport { findAssignment } from '../../utils/grammar-util.js';\r\nimport { isGrammarImport } from '../generated/ast.js';\r\nimport { resolveImport } from '../internal-grammar-util.js';\r\n\r\nexport class LangiumGrammarDefinitionProvider extends DefaultDefinitionProvider {\r\n\r\n    protected documents: LangiumDocuments;\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.documents = services.shared.workspace.LangiumDocuments;\r\n    }\r\n\r\n    protected override collectLocationLinks(sourceCstNode: LeafCstNode, _params: DefinitionParams): MaybePromise<LocationLink[] | undefined> {\r\n        const pathFeature: Properties<GrammarImport> = 'path';\r\n        if (isGrammarImport(sourceCstNode.astNode) && findAssignment(sourceCstNode)?.feature === pathFeature) {\r\n            const importedGrammar = resolveImport(this.documents, sourceCstNode.astNode);\r\n            if (importedGrammar?.$document) {\r\n                const targetObject = this.findTargetObject(importedGrammar) ?? importedGrammar;\r\n                const selectionRange = this.nameProvider.getNameNode(targetObject)?.range ?? Range.create(0, 0, 0, 0);\r\n                const previewRange = targetObject.$cstNode?.range ?? Range.create(0, 0, 0, 0);\r\n                return [\r\n                    LocationLink.create(\r\n                        importedGrammar.$document.uri.toString(),\r\n                        previewRange,\r\n                        selectionRange,\r\n                        sourceCstNode.range\r\n                    )\r\n                ];\r\n            }\r\n            return undefined;\r\n        }\r\n        return super.collectLocationLinks(sourceCstNode, _params);\r\n    }\r\n\r\n    protected findTargetObject(importedGrammar: Grammar): AstNode | undefined {\r\n        // Jump to grammar name or the first element\r\n        if (importedGrammar.isDeclared) {\r\n            return importedGrammar;\r\n        }\r\n        return streamContents(importedGrammar).head();\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CallHierarchyIncomingCall, CallHierarchyIncomingCallsParams, CallHierarchyItem, CallHierarchyOutgoingCall, CallHierarchyOutgoingCallsParams, CallHierarchyPrepareParams, CancellationToken } from 'vscode-languageserver';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { ReferenceDescription } from '../workspace/ast-descriptions.js';\r\nimport type { LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\r\nimport { SymbolKind } from 'vscode-languageserver';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\nimport { URI } from '../utils/uri-util.js';\r\n\r\n/**\r\n * Language-specific service for handling call hierarchy requests.\r\n */\r\nexport interface CallHierarchyProvider {\r\n    prepareCallHierarchy(document: LangiumDocument, params: CallHierarchyPrepareParams, cancelToken?: CancellationToken): CallHierarchyItem[] | undefined;\r\n\r\n    incomingCalls(params: CallHierarchyIncomingCallsParams, cancelToken?: CancellationToken): CallHierarchyIncomingCall[] | undefined;\r\n\r\n    outgoingCalls(params: CallHierarchyOutgoingCallsParams, cancelToken?: CancellationToken): CallHierarchyOutgoingCall[] | undefined;\r\n}\r\n\r\nexport abstract class AbstractCallHierarchyProvider implements CallHierarchyProvider {\r\n    protected readonly grammarConfig: GrammarConfig;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly documents: LangiumDocuments;\r\n    protected readonly references: References;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.documents = services.shared.workspace.LangiumDocuments;\r\n        this.references = services.references.References;\r\n    }\r\n\r\n    prepareCallHierarchy(document: LangiumDocument<AstNode>, params: CallHierarchyPrepareParams): CallHierarchyItem[] | undefined {\r\n        const rootNode = document.parseResult.value;\r\n        const targetNode = findDeclarationNodeAtOffset(\r\n            rootNode.$cstNode,\r\n            document.textDocument.offsetAt(params.position),\r\n            this.grammarConfig.nameRegexp\r\n        );\r\n        if (!targetNode) {\r\n            return undefined;\r\n        }\r\n\r\n        const declarationNode = this.references.findDeclarationNode(targetNode);\r\n        if (!declarationNode) {\r\n            return undefined;\r\n        }\r\n\r\n        return this.getCallHierarchyItems(declarationNode.astNode, document);\r\n    }\r\n\r\n    protected getCallHierarchyItems(targetNode: AstNode, document: LangiumDocument<AstNode>): CallHierarchyItem[] | undefined {\r\n        const nameNode = this.nameProvider.getNameNode(targetNode);\r\n        const name = this.nameProvider.getName(targetNode);\r\n        if (!nameNode || !targetNode.$cstNode || name === undefined) {\r\n            return undefined;\r\n        }\r\n\r\n        return [{\r\n            kind: SymbolKind.Method,\r\n            name,\r\n            range: targetNode.$cstNode.range,\r\n            selectionRange: nameNode.range,\r\n            uri: document.uri.toString(),\r\n            ...this.getCallHierarchyItem(targetNode)\r\n        }];\r\n    }\r\n\r\n    protected getCallHierarchyItem(_targetNode: AstNode): Partial<CallHierarchyItem> | undefined {\r\n        return undefined;\r\n    }\r\n\r\n    incomingCalls(params: CallHierarchyIncomingCallsParams): CallHierarchyIncomingCall[] | undefined {\r\n        const document = this.documents.getOrCreateDocument(URI.parse(params.item.uri));\r\n        const rootNode = document.parseResult.value;\r\n        const targetNode = findDeclarationNodeAtOffset(\r\n            rootNode.$cstNode,\r\n            document.textDocument.offsetAt(params.item.range.start),\r\n            this.grammarConfig.nameRegexp\r\n        );\r\n        if (!targetNode) {\r\n            return undefined;\r\n        }\r\n\r\n        const references = this.references.findReferences(\r\n            targetNode.astNode,\r\n            {\r\n                includeDeclaration: false\r\n            }\r\n        );\r\n        return this.getIncomingCalls(targetNode.astNode, references);\r\n    }\r\n\r\n    /**\r\n     * Override this method to collect the incoming calls for your language\r\n     */\r\n    protected abstract getIncomingCalls(node: AstNode, references: Stream<ReferenceDescription>): CallHierarchyIncomingCall[] | undefined;\r\n\r\n    outgoingCalls(params: CallHierarchyOutgoingCallsParams): CallHierarchyOutgoingCall[] | undefined {\r\n        const document = this.documents.getOrCreateDocument(URI.parse(params.item.uri));\r\n        const rootNode = document.parseResult.value;\r\n        const targetNode = findDeclarationNodeAtOffset(\r\n            rootNode.$cstNode,\r\n            document.textDocument.offsetAt(params.item.range.start),\r\n            this.grammarConfig.nameRegexp\r\n        );\r\n        if (!targetNode) {\r\n            return undefined;\r\n        }\r\n        return this.getOutgoingCalls(targetNode.astNode);\r\n    }\r\n\r\n    /**\r\n     * Override this method to collect the outgoing calls for your language\r\n     */\r\n    protected abstract getOutgoingCalls(node: AstNode): CallHierarchyOutgoingCall[] | undefined;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, DefinitionParams } from 'vscode-languageserver';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { CstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { LocationLink } from 'vscode-languageserver';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling go to definition requests.\r\n */\r\nexport interface DefinitionProvider {\r\n    /**\r\n     * Handle a go to definition request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getDefinition(document: LangiumDocument, params: DefinitionParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;\r\n}\r\n\r\nexport interface GoToLink {\r\n    source: CstNode\r\n    target: CstNode\r\n    targetDocument: LangiumDocument\r\n}\r\n\r\nexport class DefaultDefinitionProvider implements DefinitionProvider {\r\n\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly references: References;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.references = services.references.References;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n    }\r\n\r\n    getDefinition(document: LangiumDocument, params: DefinitionParams): MaybePromise<LocationLink[] | undefined> {\r\n        const rootNode = document.parseResult.value;\r\n        if (rootNode.$cstNode) {\r\n            const cst = rootNode.$cstNode;\r\n            const sourceCstNode = findDeclarationNodeAtOffset(cst, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);\r\n            if (sourceCstNode) {\r\n                return this.collectLocationLinks(sourceCstNode, params);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected collectLocationLinks(sourceCstNode: CstNode, _params: DefinitionParams): MaybePromise<LocationLink[] | undefined> {\r\n        const goToLink = this.findLink(sourceCstNode);\r\n        if (goToLink) {\r\n            return [LocationLink.create(\r\n                goToLink.targetDocument.textDocument.uri,\r\n                (goToLink.target.astNode.$cstNode ?? goToLink.target).range,\r\n                goToLink.target.range,\r\n                goToLink.source.range\r\n            )];\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected findLink(source: CstNode): GoToLink | undefined {\r\n        const target = this.references.findDeclarationNode(source);\r\n        if (target?.astNode) {\r\n            const targetDocument = getDocument(target.astNode);\r\n            if (target && targetDocument) {\r\n                return { source, target, targetDocument };\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, DocumentHighlightParams } from 'vscode-languageserver';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { FindReferencesOptions, References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { ReferenceDescription } from '../workspace/ast-descriptions.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { DocumentHighlight } from 'vscode-languageserver';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\nimport { UriUtils } from '../utils/uri-util.js';\r\n\r\n/**\r\n * Language-specific service for handling document highlight requests.\r\n */\r\nexport interface DocumentHighlightProvider {\r\n    /**\r\n     * Handle a document highlight request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams, cancelToken?: CancellationToken): MaybePromise<DocumentHighlight[] | undefined>;\r\n}\r\n\r\nexport class DefaultDocumentHighlightProvider implements DocumentHighlightProvider {\r\n    protected readonly references: References;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.references = services.references.References;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n    }\r\n\r\n    getDocumentHighlight(document: LangiumDocument, params: DocumentHighlightParams): MaybePromise<DocumentHighlight[] | undefined> {\r\n        const rootNode = document.parseResult.value.$cstNode;\r\n        if (!rootNode) {\r\n            return undefined;\r\n        }\r\n        const selectedNode = findDeclarationNodeAtOffset(rootNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);\r\n        if (!selectedNode) {\r\n            return undefined;\r\n        }\r\n        const targetAstNode = this.references.findDeclaration(selectedNode);\r\n        if (targetAstNode) {\r\n            const includeDeclaration = UriUtils.equals(getDocument(targetAstNode).uri, document.uri);\r\n            const options: FindReferencesOptions = { documentUri: document.uri, includeDeclaration };\r\n            const references = this.references.findReferences(targetAstNode, options);\r\n            return references.map(ref => this.createDocumentHighlight(ref)).toArray();\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n    * Override this method to determine the highlight kind of the given reference.\r\n    */\r\n    protected createDocumentHighlight(reference: ReferenceDescription): DocumentHighlight {\r\n        return DocumentHighlight.create(reference.segment.range);\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, DocumentSymbol, DocumentSymbolParams} from 'vscode-languageserver';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport { streamContents } from '../utils/ast-util.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport type { NodeKindProvider } from './node-kind-provider.js';\r\n\r\n/**\r\n * Language-specific service for handling document symbols requests.\r\n */\r\nexport interface DocumentSymbolProvider {\r\n    /**\r\n     * Handle a document symbols request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getSymbols(document: LangiumDocument, params: DocumentSymbolParams, cancelToken?: CancellationToken): MaybePromise<DocumentSymbol[]>;\r\n}\r\n\r\nexport class DefaultDocumentSymbolProvider implements DocumentSymbolProvider {\r\n\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly nodeKindProvider: NodeKindProvider;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.nodeKindProvider = services.shared.lsp.NodeKindProvider;\r\n    }\r\n\r\n    getSymbols(document: LangiumDocument): MaybePromise<DocumentSymbol[]> {\r\n        return this.getSymbol(document, document.parseResult.value);\r\n    }\r\n\r\n    protected getSymbol(document: LangiumDocument, astNode: AstNode): DocumentSymbol[] {\r\n        const node = astNode.$cstNode;\r\n        const nameNode = this.nameProvider.getNameNode(astNode);\r\n        if (nameNode && node) {\r\n            const name = this.nameProvider.getName(astNode);\r\n            return [{\r\n                kind: this.nodeKindProvider.getSymbolKind(astNode),\r\n                name: name ?? nameNode.text,\r\n                range: node.range,\r\n                selectionRange: nameNode.range,\r\n                children: this.getChildSymbols(document, astNode)\r\n            }];\r\n        } else {\r\n            return this.getChildSymbols(document, astNode) || [];\r\n        }\r\n    }\r\n\r\n    protected getChildSymbols(document: LangiumDocument, astNode: AstNode): DocumentSymbol[] | undefined {\r\n        const children: DocumentSymbol[] = [];\r\n\r\n        for (const child of streamContents(astNode)) {\r\n            const result = this.getSymbol(document, child);\r\n            children.push(...result);\r\n        }\r\n        if (children.length > 0) {\r\n            return children;\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\n\r\nexport interface ExecuteCommandHandler {\r\n    get commands(): string[]\r\n    executeCommand(name: string, args: any[], cancelToken?: CancellationToken): Promise<unknown>\r\n}\r\n\r\nexport type ExecuteCommandFunction = (args: any[], cancelToken: CancellationToken) => MaybePromise<unknown>\r\n\r\nexport type ExecuteCommandAcceptor = (name: string, execute: ExecuteCommandFunction) => void;\r\n\r\nexport abstract class AbstractExecuteCommandHandler implements ExecuteCommandHandler {\r\n\r\n    protected registeredCommands = new Map<string, ExecuteCommandFunction>();\r\n\r\n    get commands(): string[] {\r\n        return Array.from(this.registeredCommands.keys());\r\n    }\r\n\r\n    constructor() {\r\n        this.registerCommands(this.createCommandAcceptor());\r\n    }\r\n\r\n    async executeCommand(name: string, args: any[], cancelToken = CancellationToken.None): Promise<unknown> {\r\n        const command = this.registeredCommands.get(name);\r\n        if (command) {\r\n            return command(args, cancelToken);\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    protected createCommandAcceptor(): ExecuteCommandAcceptor {\r\n        return (name, execute) => this.registeredCommands.set(name, execute);\r\n    }\r\n\r\n    abstract registerCommands(acceptor: ExecuteCommandAcceptor): void;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/**\r\n * This service implements a [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching) method.\r\n */\r\nexport interface FuzzyMatcher {\r\n    /**\r\n     * Performs [fuzzy matching](https://en.wikipedia.org/wiki/Approximate_string_matching).\r\n     *\r\n     * Fuzzy matching improves search/completion user experience by allowing to omit characters.\r\n     * For example, a query such as `FuMa` matches the text `FuzzyMatcher`.\r\n     *\r\n     * @param query The user input search query.\r\n     * @param text The text that should be matched against the query.\r\n     * @returns Whether the query matches the text.\r\n     */\r\n    match(query: string, text: string): boolean;\r\n}\r\n\r\nexport class DefaultFuzzyMatcher implements FuzzyMatcher {\r\n\r\n    match(query: string, text: string): boolean {\r\n        if (query.length === 0) {\r\n            return true;\r\n        }\r\n\r\n        text = text.toLowerCase();\r\n        let matchedFirstCharacter = false;\r\n        let previous: number | undefined;\r\n        let character = 0;\r\n        const len = text.length;\r\n        for (let i = 0; i < len; i++) {\r\n            const strChar = text.charCodeAt(i);\r\n            const testChar = query.charCodeAt(character);\r\n            if (strChar === testChar || this.toUpperCharCode(strChar) === this.toUpperCharCode(testChar)) {\r\n                matchedFirstCharacter ||=\r\n                    previous === undefined || // Beginning of word\r\n                    this.isWordTransition(previous, strChar);\r\n                if (matchedFirstCharacter) {\r\n                    character++;\r\n                }\r\n                if (character === query.length) {\r\n                    return true;\r\n                }\r\n            }\r\n            previous = strChar;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    protected isWordTransition(previous: number, current: number): boolean {\r\n        return a <= previous && previous <= z && A <= current && current <= Z || // camelCase transition\r\n            previous === _ && current !== _; // snake_case transition\r\n    }\r\n\r\n    protected toUpperCharCode(charCode: number) {\r\n        if (a <= charCode && charCode <= z) {\r\n            return charCode - 32;\r\n        }\r\n        return charCode;\r\n    }\r\n}\r\n\r\nconst a = 'a'.charCodeAt(0);\r\nconst z = 'z'.charCodeAt(0);\r\nconst A = 'A'.charCodeAt(0);\r\nconst Z = 'Z'.charCodeAt(0);\r\nconst _ = '_'.charCodeAt(0);\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, Hover, HoverParams } from 'vscode-languageserver';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport type { References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport type { DocumentationProvider } from '../documentation/documentation-provider.js';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling hover requests.\r\n */\r\nexport interface HoverProvider {\r\n    /**\r\n     * Handle a hover request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getHoverContent(document: LangiumDocument, params: HoverParams, cancelToken?: CancellationToken): MaybePromise<Hover | undefined>;\r\n}\r\n\r\nexport abstract class AstNodeHoverProvider implements HoverProvider {\r\n\r\n    protected readonly references: References;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.references = services.references.References;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n    }\r\n\r\n    getHoverContent(document: LangiumDocument, params: HoverParams): MaybePromise<Hover | undefined> {\r\n        const rootNode = document.parseResult?.value?.$cstNode;\r\n        if (rootNode) {\r\n            const offset = document.textDocument.offsetAt(params.position);\r\n            const cstNode = findDeclarationNodeAtOffset(rootNode, offset, this.grammarConfig.nameRegexp);\r\n            if (cstNode && cstNode.offset + cstNode.length > offset) {\r\n                const targetNode = this.references.findDeclaration(cstNode);\r\n                if (targetNode) {\r\n                    return this.getAstNodeHoverContent(targetNode);\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected abstract getAstNodeHoverContent(node: AstNode): MaybePromise<Hover | undefined>;\r\n\r\n}\r\n\r\nexport class MultilineCommentHoverProvider extends AstNodeHoverProvider {\r\n\r\n    protected readonly documentationProvider: DocumentationProvider;\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.documentationProvider = services.documentation.DocumentationProvider;\r\n    }\r\n\r\n    protected getAstNodeHoverContent(node: AstNode): MaybePromise<Hover | undefined> {\r\n        const content = this.documentationProvider.getDocumentation(node);\r\n\r\n        if (content) {\r\n            return {\r\n                contents: {\r\n                    kind: 'markdown',\r\n                    value: content\r\n                }\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ImplementationParams, LocationLink } from 'vscode-languageserver';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport type { References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling go to implementation requests.\r\n */\r\nexport interface ImplementationProvider {\r\n    /**\r\n     * Handles a go to implementation request.\r\n     */\r\n    getImplementation(document: LangiumDocument, params: ImplementationParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;\r\n}\r\n\r\nexport abstract class AbstractGoToImplementationProvider implements ImplementationProvider {\r\n    protected readonly references: References;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.references = services.references.References;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n    }\r\n\r\n    getImplementation(document: LangiumDocument<AstNode>, params: ImplementationParams, cancelToken = CancellationToken.None): MaybePromise<LocationLink[] | undefined> {\r\n        const rootNode = document.parseResult.value;\r\n        if (rootNode.$cstNode) {\r\n            const sourceCstNode = findDeclarationNodeAtOffset(rootNode.$cstNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);\r\n            if (sourceCstNode) {\r\n                const nodeDeclaration = this.references.findDeclaration(sourceCstNode);\r\n                if (nodeDeclaration) {\r\n                    return this.collectGoToImplementationLocationLinks(nodeDeclaration, cancelToken);\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    abstract collectGoToImplementationLocationLinks(element: AstNode, cancelToken: CancellationToken): MaybePromise<LocationLink[] | undefined>;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { InlayHint, InlayHintParams } from 'vscode-languageserver';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { streamAst } from '../utils/ast-util.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\n\r\nexport type InlayHintAcceptor = (inlayHint: InlayHint) => void;\r\n\r\n/**\r\n * Provider for the inlay hint LSP type.\r\n */\r\nexport interface InlayHintProvider {\r\n    /**\r\n     * Handle the `textDocument.inlayHint` language server request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getInlayHints(document: LangiumDocument, params: InlayHintParams, cancelToken?: CancellationToken): MaybePromise<InlayHint[] | undefined>;\r\n}\r\n\r\nexport abstract class AbstractInlayHintProvider implements InlayHintProvider {\r\n    async getInlayHints(document: LangiumDocument, params: InlayHintParams, cancelToken = CancellationToken.None): Promise<InlayHint[] | undefined> {\r\n        const root = document.parseResult.value;\r\n        const inlayHints: InlayHint[] = [];\r\n        const acceptor: InlayHintAcceptor = hint => inlayHints.push(hint);\r\n        for (const node of streamAst(root, { range: params.range })) {\r\n            await interruptAndCheck(cancelToken);\r\n            this.computeInlayHint(node, acceptor);\r\n        }\r\n        return inlayHints;\r\n    }\r\n\r\n    abstract computeInlayHint(astNode: AstNode, acceptor: InlayHintAcceptor): void;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type {\r\n    CallHierarchyIncomingCallsParams,\r\n    CallHierarchyOutgoingCallsParams,\r\n    CancellationToken,\r\n    Connection,\r\n    Disposable,\r\n    Event,\r\n    HandlerResult,\r\n    InitializedParams,\r\n    InitializeParams,\r\n    InitializeResult,\r\n    RequestHandler,\r\n    SemanticTokens,\r\n    SemanticTokensDelta,\r\n    SemanticTokensDeltaParams,\r\n    SemanticTokensDeltaPartialResult,\r\n    SemanticTokensParams,\r\n    SemanticTokensPartialResult,\r\n    SemanticTokensRangeParams,\r\n    ServerRequestHandler,\r\n    TextDocumentIdentifier\r\n} from 'vscode-languageserver';\r\nimport type { LangiumServices, LangiumSharedServices } from '../services.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { Emitter, FileChangeType, LSPErrorCodes, ResponseError, TextDocumentSyncKind } from 'vscode-languageserver';\r\nimport { eagerLoad } from '../dependency-injection.js';\r\nimport { isOperationCancelled } from '../utils/promise-util.js';\r\nimport { DocumentState } from '../workspace/documents.js';\r\nimport { mergeCompletionProviderOptions } from './completion/completion-provider.js';\r\nimport { DefaultSemanticTokenOptions } from './semantic-token-provider.js';\r\nimport { mergeSignatureHelpOptions } from './signature-help-provider.js';\r\nimport { URI } from '../utils/uri-util.js';\r\n\r\nexport interface LanguageServer {\r\n    initialize(params: InitializeParams): Promise<InitializeResult>\r\n    initialized(params: InitializedParams): Promise<void>\r\n    onInitialize(callback: (params: InitializeParams) => void): Disposable\r\n    onInitialized(callback: (params: InitializedParams) => void): Disposable\r\n}\r\n\r\nexport class DefaultLanguageServer implements LanguageServer {\r\n\r\n    protected onInitializeEmitter = new Emitter<InitializeParams>();\r\n    protected onInitializedEmitter = new Emitter<InitializedParams>();\r\n\r\n    protected readonly services: LangiumSharedServices;\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.services = services;\r\n    }\r\n\r\n    get onInitialize(): Event<InitializeParams> {\r\n        return this.onInitializeEmitter.event;\r\n    }\r\n\r\n    get onInitialized(): Event<InitializedParams> {\r\n        return this.onInitializedEmitter.event;\r\n    }\r\n\r\n    async initialize(params: InitializeParams): Promise<InitializeResult> {\r\n        this.eagerLoadServices();\r\n        this.onInitializeEmitter.fire(params);\r\n        this.onInitializeEmitter.dispose();\r\n        return this.buildInitializeResult(params);\r\n    }\r\n\r\n    /**\r\n     * Eagerly loads all services before emitting the `onInitialize` event.\r\n     * Ensures that all services are able to catch the event.\r\n     */\r\n    protected eagerLoadServices(): void {\r\n        eagerLoad(this.services);\r\n        this.services.ServiceRegistry.all.forEach(language => eagerLoad(language));\r\n    }\r\n\r\n    protected hasService(callback: (language: LangiumServices) => object | undefined): boolean {\r\n        return this.services.ServiceRegistry.all.some(language => callback(language) !== undefined);\r\n    }\r\n\r\n    protected buildInitializeResult(_params: InitializeParams): InitializeResult {\r\n        const languages = this.services.ServiceRegistry.all;\r\n        const hasFormattingService = this.hasService(e => e.lsp.Formatter);\r\n        const formattingOnTypeOptions = languages.map(e => e.lsp.Formatter?.formatOnTypeOptions).find(e => Boolean(e));\r\n        const hasCodeActionProvider = this.hasService(e => e.lsp.CodeActionProvider);\r\n        const hasSemanticTokensProvider = this.hasService(e => e.lsp.SemanticTokenProvider);\r\n        const commandNames = this.services.lsp.ExecuteCommandHandler?.commands;\r\n        const hasDocumentLinkProvider = this.hasService(e => e.lsp.DocumentLinkProvider);\r\n        const signatureHelpOptions = mergeSignatureHelpOptions(languages.map(e => e.lsp.SignatureHelp?.signatureHelpOptions));\r\n        const hasGoToTypeProvider = this.hasService(e => e.lsp.TypeProvider);\r\n        const hasGoToImplementationProvider = this.hasService(e => e.lsp.ImplementationProvider);\r\n        const hasCompletionProvider = this.hasService(e => e.lsp.CompletionProvider);\r\n        const completionOptions = mergeCompletionProviderOptions(languages.map(e => e.lsp.CompletionProvider?.completionOptions));\r\n        const hasReferencesProvider = this.hasService(e => e.lsp.ReferencesProvider);\r\n        const hasDocumentSymbolProvider = this.hasService(e => e.lsp.DocumentSymbolProvider);\r\n        const hasDefinitionProvider = this.hasService(e => e.lsp.DefinitionProvider);\r\n        const hasDocumentHighlightProvider = this.hasService(e => e.lsp.DocumentHighlightProvider);\r\n        const hasFoldingRangeProvider = this.hasService(e => e.lsp.FoldingRangeProvider);\r\n        const hasHoverProvider = this.hasService(e => e.lsp.HoverProvider);\r\n        const hasRenameProvider = this.hasService(e => e.lsp.RenameProvider);\r\n        const hasCallHierarchyProvider = this.hasService(e => e.lsp.CallHierarchyProvider);\r\n        const hasCodeLensProvider = this.hasService(e => e.lsp.CodeLensProvider);\r\n        const hasDeclarationProvider = this.hasService(e => e.lsp.DeclarationProvider);\r\n        const hasInlayHintProvider = this.hasService(e => e.lsp.InlayHintProvider);\r\n        const workspaceSymbolProvider = this.services.lsp.WorkspaceSymbolProvider;\r\n\r\n        const result: InitializeResult = {\r\n            capabilities: {\r\n                workspace: {\r\n                    workspaceFolders: {\r\n                        supported: true\r\n                    }\r\n                },\r\n                executeCommandProvider: commandNames && {\r\n                    commands: commandNames\r\n                },\r\n                textDocumentSync: TextDocumentSyncKind.Incremental,\r\n                completionProvider: hasCompletionProvider ? completionOptions : undefined,\r\n                referencesProvider: hasReferencesProvider,\r\n                documentSymbolProvider: hasDocumentSymbolProvider,\r\n                definitionProvider: hasDefinitionProvider,\r\n                typeDefinitionProvider: hasGoToTypeProvider,\r\n                documentHighlightProvider: hasDocumentHighlightProvider,\r\n                codeActionProvider: hasCodeActionProvider,\r\n                documentFormattingProvider: hasFormattingService,\r\n                documentRangeFormattingProvider: hasFormattingService,\r\n                documentOnTypeFormattingProvider: formattingOnTypeOptions,\r\n                foldingRangeProvider: hasFoldingRangeProvider,\r\n                hoverProvider: hasHoverProvider,\r\n                renameProvider: hasRenameProvider ? {\r\n                    prepareProvider: true\r\n                } : undefined,\r\n                semanticTokensProvider: hasSemanticTokensProvider\r\n                    ? DefaultSemanticTokenOptions\r\n                    : undefined,\r\n                signatureHelpProvider: signatureHelpOptions,\r\n                implementationProvider: hasGoToImplementationProvider,\r\n                callHierarchyProvider: hasCallHierarchyProvider\r\n                    ? {}\r\n                    : undefined,\r\n                documentLinkProvider: hasDocumentLinkProvider\r\n                    ? { resolveProvider: false }\r\n                    : undefined,\r\n                codeLensProvider: hasCodeLensProvider\r\n                    ? { resolveProvider: false }\r\n                    : undefined,\r\n                declarationProvider: hasDeclarationProvider,\r\n                inlayHintProvider: hasInlayHintProvider\r\n                    ? { resolveProvider: false }\r\n                    : undefined,\r\n                workspaceSymbolProvider: workspaceSymbolProvider\r\n                    ? { resolveProvider: Boolean(workspaceSymbolProvider.resolveSymbol) }\r\n                    : undefined\r\n            }\r\n        };\r\n\r\n        return result;\r\n    }\r\n\r\n    async initialized(params: InitializedParams): Promise<void> {\r\n        this.onInitializedEmitter.fire(params);\r\n        this.onInitializedEmitter.dispose();\r\n    }\r\n}\r\n\r\nexport function startLanguageServer(services: LangiumSharedServices): void {\r\n    const connection = services.lsp.Connection;\r\n    if (!connection) {\r\n        throw new Error('Starting a language server requires the languageServer.Connection service to be set.');\r\n    }\r\n\r\n    addDocumentsHandler(connection, services);\r\n    addDiagnosticsHandler(connection, services);\r\n    addCompletionHandler(connection, services);\r\n    addFindReferencesHandler(connection, services);\r\n    addDocumentSymbolHandler(connection, services);\r\n    addGotoDefinitionHandler(connection, services);\r\n    addGoToTypeDefinitionHandler(connection, services);\r\n    addGoToImplementationHandler(connection, services);\r\n    addDocumentHighlightsHandler(connection, services);\r\n    addFoldingRangeHandler(connection, services);\r\n    addFormattingHandler(connection, services);\r\n    addCodeActionHandler(connection, services);\r\n    addRenameHandler(connection, services);\r\n    addHoverHandler(connection, services);\r\n    addInlayHintHandler(connection, services);\r\n    addSemanticTokenHandler(connection, services);\r\n    addExecuteCommandHandler(connection, services);\r\n    addSignatureHelpHandler(connection, services);\r\n    addCallHierarchyHandler(connection, services);\r\n    addCodeLensHandler(connection, services);\r\n    addDocumentLinkHandler(connection, services);\r\n    addConfigurationChangeHandler(connection, services);\r\n    addGoToDeclarationHandler(connection, services);\r\n    addWorkspaceSymbolHandler(connection, services);\r\n\r\n    connection.onInitialize(params => {\r\n        return services.lsp.LanguageServer.initialize(params);\r\n    });\r\n    connection.onInitialized(params => {\r\n        return services.lsp.LanguageServer.initialized(params);\r\n    });\r\n\r\n    // Make the text document manager listen on the connection for open, change and close text document events.\r\n    const documents = services.workspace.TextDocuments;\r\n    documents.listen(connection);\r\n\r\n    // Start listening for incoming messages from the client.\r\n    connection.listen();\r\n}\r\n\r\nexport function addDocumentsHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    const documentBuilder = services.workspace.DocumentBuilder;\r\n    const mutex = services.workspace.MutexLock;\r\n\r\n    function onDidChange(changed: URI[], deleted: URI[]): void {\r\n        mutex.lock(token => documentBuilder.update(changed, deleted, token));\r\n    }\r\n\r\n    const documents = services.workspace.TextDocuments;\r\n    documents.onDidChangeContent(change => {\r\n        onDidChange([URI.parse(change.document.uri)], []);\r\n    });\r\n    connection.onDidChangeWatchedFiles(params => {\r\n        const changedUris: URI[] = [];\r\n        const deletedUris: URI[] = [];\r\n        for (const change of params.changes) {\r\n            const uri = URI.parse(change.uri);\r\n            if (change.type === FileChangeType.Deleted) {\r\n                deletedUris.push(uri);\r\n            } else {\r\n                changedUris.push(uri);\r\n            }\r\n        }\r\n        onDidChange(changedUris, deletedUris);\r\n    });\r\n}\r\n\r\nexport function addDiagnosticsHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    const documentBuilder = services.workspace.DocumentBuilder;\r\n    documentBuilder.onBuildPhase(DocumentState.Validated, async (documents, cancelToken) => {\r\n        for (const document of documents) {\r\n            if (document.diagnostics) {\r\n                connection.sendDiagnostics({\r\n                    uri: document.uri.toString(),\r\n                    diagnostics: document.diagnostics\r\n                });\r\n            }\r\n            if (cancelToken.isCancellationRequested) {\r\n                return;\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nexport function addCompletionHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onCompletion(createRequestHandler(\r\n        (services, document, params, cancelToken) => {\r\n            return services.lsp.CompletionProvider?.getCompletion(document, params, cancelToken);\r\n        },\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addFindReferencesHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onReferences(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.ReferencesProvider?.findReferences(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addCodeActionHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onCodeAction(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.CodeActionProvider?.getCodeActions(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addDocumentSymbolHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onDocumentSymbol(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.DocumentSymbolProvider?.getSymbols(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addGotoDefinitionHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onDefinition(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.DefinitionProvider?.getDefinition(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addGoToTypeDefinitionHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onTypeDefinition(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.TypeProvider?.getTypeDefinition(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addGoToImplementationHandler(connection: Connection, services: LangiumSharedServices) {\r\n    connection.onImplementation(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.ImplementationProvider?.getImplementation(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addGoToDeclarationHandler(connection: Connection, services: LangiumSharedServices) {\r\n    connection.onDeclaration(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.DeclarationProvider?.getDeclaration(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addDocumentHighlightsHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onDocumentHighlight(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.DocumentHighlightProvider?.getDocumentHighlight(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addHoverHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onHover(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.HoverProvider?.getHoverContent(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addFoldingRangeHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onFoldingRanges(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.FoldingRangeProvider?.getFoldingRanges(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addFormattingHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onDocumentFormatting(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.Formatter?.formatDocument(document, params, cancelToken),\r\n        services\r\n    ));\r\n    connection.onDocumentRangeFormatting(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.Formatter?.formatDocumentRange(document, params, cancelToken),\r\n        services\r\n    ));\r\n    connection.onDocumentOnTypeFormatting(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.Formatter?.formatDocumentOnType(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addRenameHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onRenameRequest(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.RenameProvider?.rename(document, params, cancelToken),\r\n        services\r\n    ));\r\n    connection.onPrepareRename(createRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.RenameProvider?.prepareRename(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addInlayHintHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.languages.inlayHint.on(createServerRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.InlayHintProvider?.getInlayHints(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addSemanticTokenHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    // If no semantic token provider is registered that's fine. Just return an empty result\r\n    const emptyResult: SemanticTokens = { data: [] };\r\n    connection.languages.semanticTokens.on(createServerRequestHandler<SemanticTokensParams, SemanticTokens, SemanticTokensPartialResult, void>(\r\n        (services, document, params, cancelToken) => {\r\n            if (services.lsp.SemanticTokenProvider) {\r\n                return services.lsp.SemanticTokenProvider.semanticHighlight(document, params, cancelToken);\r\n            }\r\n            return emptyResult;\r\n        },\r\n        services\r\n    ));\r\n    connection.languages.semanticTokens.onDelta(createServerRequestHandler<SemanticTokensDeltaParams, SemanticTokens | SemanticTokensDelta, SemanticTokensDeltaPartialResult, void>(\r\n        (services, document, params, cancelToken) => {\r\n            if (services.lsp.SemanticTokenProvider) {\r\n                return services.lsp.SemanticTokenProvider.semanticHighlightDelta(document, params, cancelToken);\r\n            }\r\n            return emptyResult;\r\n        },\r\n        services\r\n    ));\r\n    connection.languages.semanticTokens.onRange(createServerRequestHandler<SemanticTokensRangeParams, SemanticTokens, SemanticTokensPartialResult, void>(\r\n        (services, document, params, cancelToken) => {\r\n            if (services.lsp.SemanticTokenProvider) {\r\n                return services.lsp.SemanticTokenProvider.semanticHighlightRange(document, params, cancelToken);\r\n            }\r\n            return emptyResult;\r\n        },\r\n        services\r\n    ));\r\n}\r\nexport function addConfigurationChangeHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onDidChangeConfiguration(change => {\r\n        if (change.settings) {\r\n            services.workspace.ConfigurationProvider.updateConfiguration(change);\r\n        }\r\n    });\r\n}\r\n\r\nexport function addExecuteCommandHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    const commandHandler = services.lsp.ExecuteCommandHandler;\r\n    if (commandHandler) {\r\n        connection.onExecuteCommand(async (params, token) => {\r\n            try {\r\n                return await commandHandler.executeCommand(params.command, params.arguments ?? [], token);\r\n            } catch (err) {\r\n                return responseError(err);\r\n            }\r\n        });\r\n    }\r\n}\r\n\r\nexport function addDocumentLinkHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onDocumentLinks(createServerRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.DocumentLinkProvider?.getDocumentLinks(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addSignatureHelpHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onSignatureHelp(createServerRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.SignatureHelp?.provideSignatureHelp(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addCodeLensHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.onCodeLens(createServerRequestHandler(\r\n        (services, document, params, cancelToken) => services.lsp.CodeLensProvider?.provideCodeLens(document, params, cancelToken),\r\n        services\r\n    ));\r\n}\r\n\r\nexport function addWorkspaceSymbolHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    const workspaceSymbolProvider = services.lsp.WorkspaceSymbolProvider;\r\n    if (workspaceSymbolProvider) {\r\n        connection.onWorkspaceSymbol(async (params, token) => {\r\n            try {\r\n                return await workspaceSymbolProvider.getSymbols(params, token);\r\n            } catch (err) {\r\n                return responseError(err);\r\n            }\r\n        });\r\n        const resolveWorkspaceSymbol = workspaceSymbolProvider.resolveSymbol?.bind(workspaceSymbolProvider);\r\n        if (resolveWorkspaceSymbol) {\r\n            connection.onWorkspaceSymbolResolve(async (workspaceSymbol, token) => {\r\n                try {\r\n                    return await resolveWorkspaceSymbol(workspaceSymbol, token);\r\n                } catch (err) {\r\n                    return responseError(err);\r\n                }\r\n            });\r\n        }\r\n    }\r\n}\r\n\r\nexport function addCallHierarchyHandler(connection: Connection, services: LangiumSharedServices): void {\r\n    connection.languages.callHierarchy.onPrepare(createServerRequestHandler(\r\n        (services, document, params, cancelToken) => {\r\n            if (services.lsp.CallHierarchyProvider) {\r\n                return services.lsp.CallHierarchyProvider.prepareCallHierarchy(document, params, cancelToken) ?? null;\r\n            }\r\n            return null;\r\n        },\r\n        services\r\n    ));\r\n\r\n    connection.languages.callHierarchy.onIncomingCalls(createCallHierarchyRequestHandler(\r\n        (services, params, cancelToken) => {\r\n            if (services.lsp.CallHierarchyProvider) {\r\n                return services.lsp.CallHierarchyProvider.incomingCalls(params, cancelToken) ?? null;\r\n            }\r\n            return null;\r\n        },\r\n        services\r\n    ));\r\n\r\n    connection.languages.callHierarchy.onOutgoingCalls(createCallHierarchyRequestHandler(\r\n        (services, params, cancelToken) => {\r\n            if (services.lsp.CallHierarchyProvider) {\r\n                return services.lsp.CallHierarchyProvider.outgoingCalls(params, cancelToken) ?? null;\r\n            }\r\n            return null;\r\n        },\r\n        services\r\n    ));\r\n}\r\n\r\nexport function createCallHierarchyRequestHandler<P extends CallHierarchyIncomingCallsParams | CallHierarchyOutgoingCallsParams, R, PR, E = void>(\r\n    serviceCall: (services: LangiumServices, params: P, cancelToken: CancellationToken) => HandlerResult<R, E>,\r\n    sharedServices: LangiumSharedServices\r\n): ServerRequestHandler<P, R, PR, E> {\r\n    const serviceRegistry = sharedServices.ServiceRegistry;\r\n    return async (params: P, cancelToken: CancellationToken) => {\r\n        const uri = URI.parse(params.item.uri);\r\n        const language = serviceRegistry.getServices(uri);\r\n        if (!language) {\r\n            const message = `Could not find service instance for uri: '${uri.toString()}'`;\r\n            console.error(message);\r\n            throw new Error(message);\r\n        }\r\n        try {\r\n            return await serviceCall(language, params, cancelToken);\r\n        } catch (err) {\r\n            return responseError<E>(err);\r\n        }\r\n    };\r\n}\r\n\r\nexport function createServerRequestHandler<P extends { textDocument: TextDocumentIdentifier }, R, PR, E = void>(\r\n    serviceCall: (services: LangiumServices, document: LangiumDocument, params: P, cancelToken: CancellationToken) => HandlerResult<R, E>,\r\n    sharedServices: LangiumSharedServices\r\n): ServerRequestHandler<P, R, PR, E> {\r\n    const documents = sharedServices.workspace.LangiumDocuments;\r\n    const serviceRegistry = sharedServices.ServiceRegistry;\r\n    return async (params: P, cancelToken: CancellationToken) => {\r\n        const uri = URI.parse(params.textDocument.uri);\r\n        const language = serviceRegistry.getServices(uri);\r\n        if (!language) {\r\n            console.error(`Could not find service instance for uri: '${uri.toString()}'`);\r\n            throw new Error();\r\n        }\r\n        const document = documents.getOrCreateDocument(uri);\r\n        if (!document) {\r\n            throw new Error();\r\n        }\r\n        try {\r\n            return await serviceCall(language, document, params, cancelToken);\r\n        } catch (err) {\r\n            return responseError<E>(err);\r\n        }\r\n    };\r\n}\r\n\r\nexport function createRequestHandler<P extends { textDocument: TextDocumentIdentifier }, R, E = void>(\r\n    serviceCall: (services: LangiumServices, document: LangiumDocument, params: P, cancelToken: CancellationToken) => HandlerResult<R, E>,\r\n    sharedServices: LangiumSharedServices\r\n): RequestHandler<P, R | null, E> {\r\n    const documents = sharedServices.workspace.LangiumDocuments;\r\n    const serviceRegistry = sharedServices.ServiceRegistry;\r\n    return async (params: P, cancelToken: CancellationToken) => {\r\n        const uri = URI.parse(params.textDocument.uri);\r\n        const language = serviceRegistry.getServices(uri);\r\n        if (!language) {\r\n            console.error(`Could not find service instance for uri: '${uri.toString()}'`);\r\n            return null;\r\n        }\r\n        const document = documents.getOrCreateDocument(uri);\r\n        if (!document) {\r\n            return null;\r\n        }\r\n        try {\r\n            return await serviceCall(language, document, params, cancelToken);\r\n        } catch (err) {\r\n            return responseError<E>(err);\r\n        }\r\n    };\r\n}\r\n\r\nfunction responseError<E = void>(err: unknown): ResponseError<E> {\r\n    if (isOperationCancelled(err)) {\r\n        return new ResponseError(LSPErrorCodes.RequestCancelled, 'The request has been cancelled.');\r\n    }\r\n    if (err instanceof ResponseError) {\r\n        return err;\r\n    }\r\n    throw err;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Range } from 'vscode-languageserver-textdocument';\r\nimport type { Diagnostic, TextDocuments } from 'vscode-languageserver';\r\nimport type { ParseResult } from '../parser/langium-parser.js';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, Reference } from '../syntax-tree.js';\r\nimport type { Mutable } from '../utils/ast-util.js';\r\nimport type { MultiMap } from '../utils/collections.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { FileSystemProvider } from './file-system-provider.js';\r\nimport { URI } from '../utils/uri-util.js';\r\nimport { TextDocument } from 'vscode-languageserver-textdocument';\r\nimport { stream } from '../utils/stream.js';\r\n\r\n/**\r\n * A Langium document holds the parse result (AST and CST) and any additional state that is derived\r\n * from the AST, e.g. the result of scope precomputation.\r\n */\r\nexport interface LangiumDocument<T extends AstNode = AstNode> {\r\n    /** The Uniform Resource Identifier (URI) of the document */\r\n    readonly uri: URI;\r\n    /** The text document used to convert between offsets and positions */\r\n    readonly textDocument: TextDocument;\r\n    /** The current state of the document */\r\n    state: DocumentState;\r\n    /** The parse result holds the Abstract Syntax Tree (AST) and potentially also parser / lexer errors */\r\n    parseResult: ParseResult<T>;\r\n    /** Result of the scope precomputation phase */\r\n    precomputedScopes?: PrecomputedScopes;\r\n    /** An array of all cross-references found in the AST while linking */\r\n    references: Reference[];\r\n    /** Result of the validation phase */\r\n    diagnostics?: Diagnostic[]\r\n}\r\n\r\n/**\r\n * A document is subject to several phases that are run in predefined order. Any state value implies that\r\n * smaller state values are finished as well.\r\n */\r\nexport enum DocumentState {\r\n    /**\r\n     * The text content has changed and needs to be parsed again. The AST held by this outdated\r\n     * document instance is no longer valid.\r\n     */\r\n    Changed = 0,\r\n    /**\r\n     * An AST has been created from the text content. The document structure can be traversed,\r\n     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated\r\n     * at this stage as a preprocessing step.\r\n     */\r\n    Parsed = 1,\r\n    /**\r\n     * The `IndexManager` service has processed AST nodes of this document. This means the\r\n     * exported symbols are available in the global scope and can be resolved from other documents.\r\n     */\r\n    IndexedContent = 2,\r\n    /**\r\n     * The `ScopeComputation` service has processed this document. This means the local symbols\r\n     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.\r\n     * Once a document has reached this state, you may follow every reference - it will lazily\r\n     * resolve its `ref` property and yield either the target AST node or `undefined` in case\r\n     * the target is not in scope.\r\n     */\r\n    ComputedScopes = 3,\r\n    /**\r\n     * The `Linker` service has processed this document. All outgoing references have been\r\n     * resolved or marked as erroneous.\r\n     */\r\n    Linked = 4,\r\n    /**\r\n     * The `IndexManager` service has processed AST node references of this document. This is\r\n     * necessary to determine which documents are affected by a change in one of the workspace\r\n     * documents.\r\n     */\r\n    IndexedReferences = 5,\r\n    /**\r\n     * The `DocumentValidator` service has processed this document. The language server listens\r\n     * to the results of this phase and sends diagnostics to the client.\r\n     */\r\n    Validated = 6\r\n}\r\n\r\n/**\r\n * Result of the scope precomputation phase (`ScopeComputation` service).\r\n * It maps every AST node to the set of symbols that are visible in the subtree of that node.\r\n */\r\nexport type PrecomputedScopes = MultiMap<AstNode, AstNodeDescription>\r\n\r\nexport interface DocumentSegment {\r\n    readonly range: Range\r\n    readonly offset: number\r\n    readonly length: number\r\n    readonly end: number\r\n}\r\n\r\n/**\r\n * Shared service for creating `LangiumDocument` instances.\r\n *\r\n * Register a custom implementation if special (additional) behavior is required for your language(s).\r\n * Note: If you specialize {@link fromString} or {@link fromTextDocument} you probably might want to\r\n * specialize {@link update}, too!\r\n */\r\nexport interface LangiumDocumentFactory {\r\n    /**\r\n     * Create a Langium document from a `TextDocument` (usually associated with a file).\r\n     */\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI): LangiumDocument<T>;\r\n\r\n    /**\r\n     * Create an Langium document from an in-memory string.\r\n     */\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI): LangiumDocument<T>;\r\n\r\n    /**\r\n     * Create an Langium document from a model that has been constructed in memory.\r\n     */\r\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T>;\r\n\r\n    /**\r\n     * Create a Langium document for the given URI. The document shall be fetched from the {@link TextDocuments}\r\n     * service if present, and loaded via the configured {@link FileSystemProvider} otherwise.\r\n     */\r\n    create<T extends AstNode = AstNode>(uri: URI): LangiumDocument<T>\r\n\r\n    /**\r\n     * Update the given document after changes in the corresponding textual representation.\r\n     * Method is called by the document builder after it has been requested to build an exisiting\r\n     * document and the document's state is {@link DocumentState.Changed}.\r\n     * The text parsing is expected to be done the same way as in {@link fromTextDocument}\r\n     * and {@link fromString}.\r\n     */\r\n    update<T extends AstNode = AstNode>(document: LangiumDocument<T>): LangiumDocument<T>\r\n}\r\n\r\nexport class DefaultLangiumDocumentFactory implements LangiumDocumentFactory {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly textDocuments: TextDocuments<TextDocument>;\r\n    protected readonly fileSystemProvider: FileSystemProvider;\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.textDocuments = services.workspace.TextDocuments;\r\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\r\n    }\r\n\r\n    fromTextDocument<T extends AstNode = AstNode>(textDocument: TextDocument, uri?: URI): LangiumDocument<T> {\r\n        return this.create<T>(uri ?? URI.parse(textDocument.uri), textDocument);\r\n    }\r\n\r\n    fromString<T extends AstNode = AstNode>(text: string, uri: URI): LangiumDocument<T> {\r\n        return this.create<T>(uri, text);\r\n    }\r\n\r\n    fromModel<T extends AstNode = AstNode>(model: T, uri: URI): LangiumDocument<T> {\r\n        return this.create<T>(uri, { $model: model });\r\n    }\r\n\r\n    create<T extends AstNode = AstNode>(uri: URI, content?: string | TextDocument | { $model: T }): LangiumDocument<T> {\r\n        // if no document is given, check the textDocuments service first, it maintains documents being opened in an editor\r\n        content ??= this.textDocuments.get(uri.toString());\r\n        // if still no document is found try to load it from the file system\r\n        content ??= this.getContentFromFileSystem(uri);\r\n\r\n        if (typeof content === 'string') {\r\n            const parseResult = this.parse<T>(uri, content);\r\n            return this.createLangiumDocument<T>(parseResult, uri, undefined, content);\r\n\r\n        } else if ('$model' in content) {\r\n            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };\r\n            return this.createLangiumDocument<T>(parseResult, uri);\r\n\r\n        } else {\r\n            const parseResult = this.parse<T>(uri, content.getText());\r\n            return this.createLangiumDocument(parseResult, uri, content);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a LangiumDocument from a given parse result.\r\n     *\r\n     * A TextDocument is created on demand if it is not provided as argument here. Usually this\r\n     * should not be necessary because the main purpose of the TextDocument is to convert between\r\n     * text ranges and offsets, which is done solely in LSP request handling.\r\n     *\r\n     * With the introduction of {@link update} below this method is supposed to be mainly called\r\n     * during workspace initialization and on addition/recognition of new files, while changes in\r\n     * existing documents are processed via {@link update}.\r\n     */\r\n    protected createLangiumDocument<T extends AstNode = AstNode>(parseResult: ParseResult<T>, uri: URI, textDocument?: TextDocument, text?: string): LangiumDocument<T> {\r\n        let document: LangiumDocument<T>;\r\n        if (textDocument) {\r\n            document = {\r\n                parseResult,\r\n                uri,\r\n                state: DocumentState.Parsed,\r\n                references: [],\r\n                textDocument\r\n            };\r\n        } else {\r\n            const textDocumentGetter = this.createTextDocumentGetter(uri, text);\r\n            document = {\r\n                parseResult,\r\n                uri,\r\n                state: DocumentState.Parsed,\r\n                references: [],\r\n                get textDocument() {\r\n                    return textDocumentGetter();\r\n                }\r\n            };\r\n        }\r\n        (parseResult.value as Mutable<AstNode>).$document = document;\r\n        return document;\r\n    }\r\n\r\n    update<T extends AstNode = AstNode>(document: Mutable<LangiumDocument<T>>): LangiumDocument<T> {\r\n        const textDocument = this.textDocuments.get(document.uri.toString());\r\n        const text = textDocument ? textDocument.getText() : this.getContentFromFileSystem(document.uri);\r\n\r\n        if (textDocument) {\r\n            Object.defineProperty(\r\n                document, 'textDocument',\r\n                {\r\n                    value: textDocument\r\n                }\r\n            );\r\n        } else {\r\n            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);\r\n            Object.defineProperty(\r\n                document, 'textDocument',\r\n                {\r\n                    get: textDocumentGetter\r\n                }\r\n            );\r\n        }\r\n\r\n        document.parseResult = this.parse(document.uri, text);\r\n        (document.parseResult.value as Mutable<AstNode>).$document = document;\r\n        return document;\r\n    }\r\n\r\n    protected getContentFromFileSystem(uri: URI): string {\r\n        return this.fileSystemProvider.readFileSync(uri);\r\n    }\r\n\r\n    protected parse<T extends AstNode>(uri: URI, text: string): ParseResult<T> {\r\n        const services = this.serviceRegistry.getServices(uri);\r\n        return services.parser.LangiumParser.parse<T>(text);\r\n    }\r\n\r\n    protected createTextDocumentGetter(uri: URI, text?: string): () => TextDocument {\r\n        const serviceRegistry = this.serviceRegistry;\r\n        let textDoc: TextDocument | undefined = undefined;\r\n        return () => {\r\n            return textDoc ??= TextDocument.create(\r\n                uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text ?? ''\r\n            );\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Shared service for managing Langium documents.\r\n */\r\nexport interface LangiumDocuments {\r\n\r\n    /**\r\n     * A stream of all documents managed under this service.\r\n     */\r\n    readonly all: Stream<LangiumDocument>\r\n\r\n    /**\r\n     * Manage a new document under this service.\r\n     * @throws an error if a document with the same URI is already present.\r\n     */\r\n    addDocument(document: LangiumDocument): void;\r\n\r\n    /**\r\n     * Retrieve the document with the given URI, if present. Otherwise create a new document\r\n     * and add it to the managed documents.\r\n     */\r\n    getOrCreateDocument(uri: URI): LangiumDocument;\r\n\r\n    /**\r\n     * Returns `true` if a document with the given URI is managed under this service.\r\n     */\r\n    hasDocument(uri: URI): boolean;\r\n\r\n    /**\r\n     * Flag the document with the given URI as `Changed`, if present, meaning that its content\r\n     * is no longer valid. The content (parseResult) stays untouched, while internal data may\r\n     * be dropped to reduce memory footprint.\r\n     *\r\n     * @returns the affected {@link LangiumDocument} if existing for convenience\r\n     */\r\n    invalidateDocument(uri: URI): LangiumDocument | undefined;\r\n\r\n    /**\r\n     * Remove the document with the given URI, if present, and mark it as `Changed`, meaning\r\n     * that its content is no longer valid. The next call to `getOrCreateDocument` with the same\r\n     * URI will create a new document instance.\r\n     *\r\n     * @returns the affected {@link LangiumDocument} if existing for convenience\r\n     */\r\n    deleteDocument(uri: URI): LangiumDocument | undefined;\r\n}\r\n\r\nexport class DefaultLangiumDocuments implements LangiumDocuments {\r\n\r\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\r\n\r\n    protected readonly documentMap: Map<string, LangiumDocument> = new Map();\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\r\n    }\r\n\r\n    get all(): Stream<LangiumDocument> {\r\n        return stream(this.documentMap.values());\r\n    }\r\n\r\n    addDocument(document: LangiumDocument): void {\r\n        const uriString = document.uri.toString();\r\n        if (this.documentMap.has(uriString)) {\r\n            throw new Error(`A document with the URI '${uriString}' is already present.`);\r\n        }\r\n        this.documentMap.set(uriString, document);\r\n    }\r\n\r\n    getOrCreateDocument(uri: URI): LangiumDocument {\r\n        const uriString = uri.toString();\r\n        let langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            // The document is already present in our map\r\n            return langiumDoc;\r\n        }\r\n        langiumDoc = this.langiumDocumentFactory.create(uri);\r\n        this.documentMap.set(uriString, langiumDoc);\r\n        return langiumDoc;\r\n    }\r\n\r\n    hasDocument(uri: URI): boolean {\r\n        return this.documentMap.has(uri.toString());\r\n    }\r\n\r\n    invalidateDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        const langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            langiumDoc.state = DocumentState.Changed;\r\n            langiumDoc.precomputedScopes = undefined;\r\n            langiumDoc.references = [];\r\n            langiumDoc.diagnostics = undefined;\r\n        }\r\n        return langiumDoc;\r\n    }\r\n\r\n    deleteDocument(uri: URI): LangiumDocument | undefined {\r\n        const uriString = uri.toString();\r\n        const langiumDoc = this.documentMap.get(uriString);\r\n        if (langiumDoc) {\r\n            langiumDoc.state = DocumentState.Changed;\r\n            this.documentMap.delete(uriString);\r\n        }\r\n        return langiumDoc;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { SignatureHelp, SignatureHelpOptions, SignatureHelpParams } from 'vscode-languageserver';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport { findLeafNodeAtOffset } from '../utils/cst-util.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\n\r\n/**\r\n * Language-specific service for handling signature help requests.\r\n */\r\nexport interface SignatureHelpProvider {\r\n    /**\r\n     * Handles a signature help request\r\n     */\r\n    provideSignatureHelp(document: LangiumDocument, params: SignatureHelpParams, cancelToken?: CancellationToken): MaybePromise<SignatureHelp | undefined>;\r\n    /**\r\n     * Options that determine the server capabilities for a signature help request. It contains the list of triggering characters.\r\n     */\r\n    get signatureHelpOptions(): SignatureHelpOptions;\r\n}\r\n\r\nexport abstract class AbstractSignatureHelpProvider implements SignatureHelpProvider {\r\n    provideSignatureHelp(document: LangiumDocument, params: SignatureHelpParams, cancelToken = CancellationToken.None): MaybePromise<SignatureHelp | undefined> {\r\n        const rootNode = document.parseResult.value;\r\n        const cst = rootNode.$cstNode;\r\n        if (cst) {\r\n            const sourceCstNode = findLeafNodeAtOffset(cst, document.textDocument.offsetAt(params.position));\r\n            if (sourceCstNode) {\r\n                return this.getSignatureFromElement(sourceCstNode.astNode, cancelToken);\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Override this method to return the desired SignatureHelp\r\n     */\r\n    protected abstract getSignatureFromElement(element: AstNode, cancelToken: CancellationToken): MaybePromise<SignatureHelp | undefined>;\r\n\r\n    /**\r\n     * Override this getter to return the list of triggering characters for your language. To deactivate the signature help, return an empty object.\r\n     */\r\n    get signatureHelpOptions(): SignatureHelpOptions {\r\n        return {\r\n            triggerCharacters: ['('],\r\n            retriggerCharacters: [',']\r\n        };\r\n    }\r\n}\r\n\r\n/**\r\n * Merges the SignatureHelpOptions of all languages\r\n */\r\nexport function mergeSignatureHelpOptions(options: Array<SignatureHelpOptions | undefined>): SignatureHelpOptions | undefined {\r\n    const triggerCharacters: string[] = [];\r\n    const retriggerCharacters: string[] = [];\r\n\r\n    options.forEach(option => {\r\n        if (option?.triggerCharacters) {\r\n            triggerCharacters.push(...option.triggerCharacters);\r\n        }\r\n        if (option?.retriggerCharacters) {\r\n            retriggerCharacters.push(...option.retriggerCharacters);\r\n        }\r\n    });\r\n\r\n    const mergedOptions: SignatureHelpOptions = {\r\n        triggerCharacters: triggerCharacters.length > 0 ? Array.from(new Set(triggerCharacters)).sort() : undefined,\r\n        retriggerCharacters: retriggerCharacters.length > 0 ? Array.from(new Set(retriggerCharacters)).sort() : undefined\r\n    };\r\n\r\n    return mergedOptions.triggerCharacters ? mergedOptions : undefined;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\r\nimport { CompletionItemKind, SymbolKind } from 'vscode-languageserver';\r\n\r\n/**\r\n * This service consolidates the logic for gathering LSP kind information based on AST nodes or their descriptions.\r\n */\r\nexport interface NodeKindProvider {\r\n    /**\r\n     * Returns a `SymbolKind` as used by `WorkspaceSymbolProvider` or `DocumentSymbolProvider`.\r\n     */\r\n    getSymbolKind(node: AstNode | AstNodeDescription): SymbolKind;\r\n    /**\r\n     * Returns a `CompletionItemKind` as used by the `CompletionProvider`.\r\n     */\r\n    getCompletionItemKind(node: AstNode | AstNodeDescription): CompletionItemKind;\r\n}\r\n\r\nexport class DefaultNodeKindProvider implements NodeKindProvider {\r\n    getSymbolKind(): SymbolKind {\r\n        return SymbolKind.Field;\r\n    }\r\n    getCompletionItemKind(): CompletionItemKind {\r\n        return CompletionItemKind.Reference;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, ReferenceParams } from 'vscode-languageserver';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { References } from '../references/references.js';\r\nimport type { LeafCstNode } from '../syntax-tree.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport { Location } from 'vscode-languageserver';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling find references requests.\r\n */\r\nexport interface ReferencesProvider {\r\n    /**\r\n     * Handle a find references request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    findReferences(document: LangiumDocument, params: ReferenceParams, cancelToken?: CancellationToken): MaybePromise<Location[]>;\r\n}\r\n\r\nexport class DefaultReferencesProvider implements ReferencesProvider {\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly references: References;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.references = services.references.References;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n    }\r\n\r\n    findReferences(document: LangiumDocument, params: ReferenceParams): MaybePromise<Location[]> {\r\n        const rootNode = document.parseResult.value.$cstNode;\r\n        if (!rootNode) {\r\n            return [];\r\n        }\r\n\r\n        const selectedNode = findDeclarationNodeAtOffset(rootNode, document.textDocument.offsetAt(params.position), this.grammarConfig.nameRegexp);\r\n        if (!selectedNode) {\r\n            return [];\r\n        }\r\n\r\n        return this.getReferences(selectedNode, params, document);\r\n    }\r\n\r\n    protected getReferences(selectedNode: LeafCstNode, params: ReferenceParams, _document: LangiumDocument): Location[] {\r\n        const locations: Location[] = [];\r\n        const targetAstNode = this.references.findDeclaration(selectedNode);\r\n        if (targetAstNode) {\r\n            const options = { includeDeclaration: params.context.includeDeclaration };\r\n            this.references.findReferences(targetAstNode, options).forEach(reference => {\r\n                locations.push(Location.create(reference.sourceUri.toString(), reference.segment.range));\r\n            });\r\n        }\r\n        return locations;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CancellationToken, Position, Range, RenameParams, TextDocumentPositionParams, WorkspaceEdit } from 'vscode-languageserver';\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { CstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { TextEdit } from 'vscode-languageserver';\r\nimport { isNamed } from '../references/name-provider.js';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling rename requests and prepare rename requests.\r\n */\r\nexport interface RenameProvider {\r\n    /**\r\n     * Handle a rename request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    rename(document: LangiumDocument, params: RenameParams, cancelToken?: CancellationToken): MaybePromise<WorkspaceEdit | undefined>;\r\n\r\n    /**\r\n     * Handle a prepare rename request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    prepareRename(document: LangiumDocument, params: TextDocumentPositionParams, cancelToken?: CancellationToken): MaybePromise<Range | undefined>;\r\n}\r\n\r\nexport class DefaultRenameProvider implements RenameProvider {\r\n\r\n    protected readonly references: References;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly grammarConfig: GrammarConfig;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.references = services.references.References;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.grammarConfig = services.parser.GrammarConfig;\r\n    }\r\n\r\n    async rename(document: LangiumDocument, params: RenameParams): Promise<WorkspaceEdit | undefined> {\r\n        const changes: Record<string, TextEdit[]> = {};\r\n        const rootNode = document.parseResult.value.$cstNode;\r\n        if (!rootNode) return undefined;\r\n        const offset = document.textDocument.offsetAt(params.position);\r\n        const leafNode = findDeclarationNodeAtOffset(rootNode, offset, this.grammarConfig.nameRegexp);\r\n        if (!leafNode) return undefined;\r\n        const targetNode = this.references.findDeclaration(leafNode);\r\n        if (!targetNode) return undefined;\r\n        const options = { onlyLocal: false, includeDeclaration: true };\r\n        const references = this.references.findReferences(targetNode, options);\r\n        references.forEach(ref => {\r\n            const change = TextEdit.replace(ref.segment.range, params.newName);\r\n            const uri = ref.sourceUri.toString();\r\n            if (changes[uri]) {\r\n                changes[uri].push(change);\r\n            } else {\r\n                changes[uri] = [change];\r\n            }\r\n        });\r\n        return { changes };\r\n    }\r\n\r\n    prepareRename(document: LangiumDocument, params: TextDocumentPositionParams): MaybePromise<Range | undefined> {\r\n        return this.renameNodeRange(document, params.position);\r\n    }\r\n\r\n    protected renameNodeRange(doc: LangiumDocument, position: Position): Range | undefined {\r\n        const rootNode = doc.parseResult.value.$cstNode;\r\n        const offset = doc.textDocument.offsetAt(position);\r\n        if (rootNode && offset) {\r\n            const leafNode = findDeclarationNodeAtOffset(rootNode, offset, this.grammarConfig.nameRegexp);\r\n            if (!leafNode) {\r\n                return undefined;\r\n            }\r\n            const isCrossRef = this.references.findDeclaration(leafNode);\r\n            // return range if selected CstNode is the name node or it is a crosslink which points to a declaration\r\n            if (isCrossRef || this.isNameNode(leafNode)) {\r\n                return leafNode.range;\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected isNameNode(leafNode: CstNode | undefined): boolean | undefined {\r\n        return leafNode?.astNode && isNamed(leafNode.astNode) && leafNode === this.nameProvider.getNameNode(leafNode.astNode);\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LocationLink, TypeDefinitionParams } from 'vscode-languageserver';\r\nimport type { References } from '../references/references.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { LangiumDocument } from '../workspace/documents.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { findDeclarationNodeAtOffset } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Language-specific service for handling go to type requests.\r\n */\r\nexport interface TypeDefinitionProvider {\r\n    /**\r\n     * Handles a go to type definition request.\r\n     */\r\n    getTypeDefinition(document: LangiumDocument, params: TypeDefinitionParams, cancelToken?: CancellationToken): MaybePromise<LocationLink[] | undefined>;\r\n}\r\n\r\nexport abstract class AbstractTypeDefinitionProvider implements TypeDefinitionProvider {\r\n\r\n    protected readonly references: References;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.references = services.references.References;\r\n    }\r\n\r\n    getTypeDefinition(document: LangiumDocument, params: TypeDefinitionParams, cancelToken = CancellationToken.None): MaybePromise<LocationLink[] | undefined> {\r\n        const rootNode = document.parseResult.value;\r\n        if (rootNode.$cstNode) {\r\n            const sourceCstNode = findDeclarationNodeAtOffset(rootNode.$cstNode, document.textDocument.offsetAt(params.position));\r\n            if (sourceCstNode) {\r\n                const nodeDeclaration = this.references.findDeclaration(sourceCstNode);\r\n                if (nodeDeclaration) {\r\n                    return this.collectGoToTypeLocationLinks(nodeDeclaration, cancelToken);\r\n                }\r\n            }\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    /**\r\n     * Override this method to implement the logic to generate the expected LocationLink[] for a go to type request for your language.\r\n     */\r\n    abstract collectGoToTypeLocationLinks(element: AstNode, cancelToken: CancellationToken): MaybePromise<LocationLink[] | undefined>;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { WorkspaceSymbol, WorkspaceSymbolParams } from 'vscode-languageserver';\r\nimport type { LangiumSharedServices } from '../services.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { MaybePromise} from '../utils/promise-util.js';\r\nimport type { AstNodeDescription } from '../syntax-tree.js';\r\nimport type { NodeKindProvider } from './node-kind-provider.js';\r\nimport type { FuzzyMatcher } from './fuzzy-matcher.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\n\r\n/**\r\n * Shared service for handling workspace symbols requests.\r\n */\r\nexport interface WorkspaceSymbolProvider {\r\n    /**\r\n     * Handle a workspace symbols request.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    getSymbols(params: WorkspaceSymbolParams, cancelToken?: CancellationToken): MaybePromise<WorkspaceSymbol[]>;\r\n    /**\r\n     * Handle a resolve request for a workspace symbol.\r\n     *\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     * @throws `ResponseError` if an error is detected that should be sent as response to the client\r\n     */\r\n    resolveSymbol?(symbol: WorkspaceSymbol, cancelToken?: CancellationToken): MaybePromise<WorkspaceSymbol>;\r\n}\r\n\r\nexport class DefaultWorkspaceSymbolProvider implements WorkspaceSymbolProvider {\r\n\r\n    protected readonly indexManager: IndexManager;\r\n    protected readonly nodeKindProvider: NodeKindProvider;\r\n    protected readonly fuzzyMatcher: FuzzyMatcher;\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.indexManager = services.workspace.IndexManager;\r\n        this.nodeKindProvider = services.lsp.NodeKindProvider;\r\n        this.fuzzyMatcher = services.lsp.FuzzyMatcher;\r\n    }\r\n\r\n    async getSymbols(params: WorkspaceSymbolParams, cancelToken = CancellationToken.None): Promise<WorkspaceSymbol[]> {\r\n        const workspaceSymbols: WorkspaceSymbol[] = [];\r\n        const query = params.query.toLowerCase();\r\n        for (const description of this.indexManager.allElements()) {\r\n            await interruptAndCheck(cancelToken);\r\n            if (this.fuzzyMatcher.match(query, description.name)) {\r\n                const symbol = this.getWorkspaceSymbol(description);\r\n                if (symbol) {\r\n                    workspaceSymbols.push(symbol);\r\n                }\r\n            }\r\n        }\r\n        return workspaceSymbols;\r\n    }\r\n\r\n    protected getWorkspaceSymbol(astDescription: AstNodeDescription): WorkspaceSymbol | undefined {\r\n        const nameSegment = astDescription.nameSegment;\r\n        if (nameSegment) {\r\n            return {\r\n                kind: this.nodeKindProvider.getSymbolKind(astDescription),\r\n                name: astDescription.name,\r\n                location: {\r\n                    range: nameSegment.range,\r\n                    uri: astDescription.documentUri.toString()\r\n                }\r\n            };\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CallHierarchyIncomingCall, CallHierarchyOutgoingCall, Range } from 'vscode-languageserver';\r\nimport type { AstNode, CstNode } from '../../syntax-tree.js';\r\nimport type { Stream } from '../../utils/stream.js';\r\nimport type { ReferenceDescription } from '../../workspace/ast-descriptions.js';\r\nimport { SymbolKind } from 'vscode-languageserver';\r\nimport { AbstractCallHierarchyProvider } from '../../lsp/call-hierarchy-provider.js';\r\nimport { getContainerOfType, getDocument, streamAllContents } from '../../utils/ast-util.js';\r\nimport { findLeafNodeAtOffset } from '../../utils/cst-util.js';\r\nimport { isParserRule, isRuleCall } from '../generated/ast.js';\r\n\r\nexport class LangiumGrammarCallHierarchyProvider extends AbstractCallHierarchyProvider {\r\n    protected getIncomingCalls(node: AstNode, references: Stream<ReferenceDescription>): CallHierarchyIncomingCall[] | undefined {\r\n        if (!isParserRule(node)) {\r\n            return undefined;\r\n        }\r\n        // This map is used to group incoming calls to avoid duplicates.\r\n        const uniqueRules = new Map<string, { parserRule: CstNode, nameNode: CstNode, targetNodes: CstNode[], docUri: string }>();\r\n        references.forEach(ref => {\r\n            const doc = this.documents.getOrCreateDocument(ref.sourceUri);\r\n            const rootNode = doc.parseResult.value;\r\n            if (!rootNode.$cstNode) {\r\n                return;\r\n            }\r\n            const targetNode = findLeafNodeAtOffset(rootNode.$cstNode, ref.segment.offset);\r\n            if (!targetNode) {\r\n                return;\r\n            }\r\n            const parserRule = getContainerOfType(targetNode.astNode, isParserRule);\r\n            if (!parserRule || !parserRule.$cstNode) {\r\n                return;\r\n            }\r\n            const nameNode = this.nameProvider.getNameNode(parserRule);\r\n            if (!nameNode) {\r\n                return;\r\n            }\r\n            const refDocUri = ref.sourceUri.toString();\r\n            const ruleId = refDocUri + '@' + nameNode.text;\r\n\r\n            uniqueRules.has(ruleId) ?\r\n                uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [...uniqueRules.get(ruleId)!.targetNodes, targetNode], docUri: refDocUri })\r\n                : uniqueRules.set(ruleId, { parserRule: parserRule.$cstNode, nameNode, targetNodes: [targetNode], docUri: refDocUri });\r\n        });\r\n        if (uniqueRules.size === 0) {\r\n            return undefined;\r\n        }\r\n        return Array.from(uniqueRules.values()).map(rule => ({\r\n            from: {\r\n                kind: SymbolKind.Method,\r\n                name: rule.nameNode.text,\r\n                range: rule.parserRule.range,\r\n                selectionRange: rule.nameNode.range,\r\n                uri: rule.docUri\r\n            },\r\n            fromRanges: rule.targetNodes.map(node => node.range)\r\n        }));\r\n    }\r\n\r\n    protected getOutgoingCalls(node: AstNode): CallHierarchyOutgoingCall[] | undefined {\r\n        if (!isParserRule(node)) {\r\n            return undefined;\r\n        }\r\n        const ruleCalls = streamAllContents(node).filter(isRuleCall).toArray();\r\n        // This map is used to group outgoing calls to avoid duplicates.\r\n        const uniqueRules = new Map<string, { refCstNode: CstNode, to: CstNode, from: Range[], docUri: string }>();\r\n        ruleCalls.forEach(ruleCall => {\r\n            const cstNode = ruleCall.$cstNode;\r\n            if (!cstNode) {\r\n                return;\r\n            }\r\n            const refCstNode = ruleCall.rule.ref?.$cstNode;\r\n            if (!refCstNode) {\r\n                return;\r\n            }\r\n            const refNameNode = this.nameProvider.getNameNode(refCstNode.astNode);\r\n            if (!refNameNode) {\r\n                return;\r\n            }\r\n            const refDocUri = getDocument(refCstNode.astNode).uri.toString();\r\n            const ruleId = refDocUri + '@' + refNameNode.text;\r\n\r\n            uniqueRules.has(ruleId) ?\r\n                uniqueRules.set(ruleId, { refCstNode: refCstNode, to: refNameNode, from: [...uniqueRules.get(ruleId)!.from, cstNode.range], docUri: refDocUri })\r\n                : uniqueRules.set(ruleId, { refCstNode: refCstNode, to: refNameNode, from: [cstNode.range], docUri: refDocUri });\r\n        });\r\n        if (uniqueRules.size === 0) {\r\n            return undefined;\r\n        }\r\n        return Array.from(uniqueRules.values()).map(rule => ({\r\n            to: {\r\n                kind: SymbolKind.Method,\r\n                name: rule.to.text,\r\n                range: rule.refCstNode.range,\r\n                selectionRange: rule.to.range,\r\n                uri: rule.docUri\r\n            },\r\n            fromRanges: rule.from\r\n        }));\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumDocuments } from '../../workspace/documents.js';\r\nimport type { AbstractElement, Action, Grammar, Interface, ParserRule, Type } from '../generated/ast.js';\r\nimport type { AstResources, ValidationAstTypes } from '../type-system/type-collector/all-types.js';\r\nimport type { TypeToValidationInfo, ValidationResources } from '../workspace/documents.js';\r\nimport type { LangiumGrammarServices } from '../langium-grammar-module.js';\r\nimport type { InterfaceType, Property } from '../type-system/type-collector/types.js';\r\nimport { MultiMap } from '../../utils/collections.js';\r\nimport { stream } from '../../utils/stream.js';\r\nimport { isAction, isAlternatives, isGroup, isUnorderedGroup } from '../generated/ast.js';\r\nimport { getActionType, getRuleType } from '../internal-grammar-util.js';\r\nimport { mergeInterfaces, mergeTypesAndInterfaces } from '../type-system/types-util.js';\r\nimport { collectValidationAst } from '../type-system/ast-collector.js';\r\n\r\nexport class LangiumGrammarValidationResourcesCollector {\r\n    private readonly documents: LangiumDocuments;\r\n\r\n    constructor(services: LangiumGrammarServices) {\r\n        this.documents = services.shared.workspace.LangiumDocuments;\r\n    }\r\n\r\n    collectValidationResources(grammar: Grammar): ValidationResources {\r\n        const typeResources = collectValidationAst(grammar, this.documents);\r\n        return {\r\n            typeToValidationInfo: this.collectValidationInfo(typeResources),\r\n            typeToSuperProperties: this.collectSuperProperties(typeResources),\r\n        };\r\n    }\r\n\r\n    private collectValidationInfo({ astResources, inferred, declared }: ValidationAstTypes) {\r\n        const res: TypeToValidationInfo = new Map();\r\n        const typeNameToRulesActions = collectNameToRulesActions(astResources);\r\n\r\n        for (const type of mergeTypesAndInterfaces(inferred)) {\r\n            res.set(\r\n                type.name,\r\n                { inferred: type, inferredNodes: typeNameToRulesActions.get(type.name) }\r\n            );\r\n        }\r\n\r\n        const typeNametoInterfacesUnions = stream(astResources.interfaces)\r\n            .concat(astResources.types)\r\n            .reduce((acc, type) => acc.set(type.name, type),\r\n                new Map<string, Type | Interface>()\r\n            );\r\n        for (const type of mergeTypesAndInterfaces(declared)) {\r\n            const node = typeNametoInterfacesUnions.get(type.name);\r\n            if (node) {\r\n                const inferred = res.get(type.name);\r\n                res.set(\r\n                    type.name,\r\n                    { ...inferred ?? {}, declared: type, declaredNode: node }\r\n                );\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    private collectSuperProperties({ inferred, declared }: ValidationAstTypes): Map<string, Property[]> {\r\n        const typeToSuperProperties: Map<string, Property[]> = new Map();\r\n        const interfaces = mergeInterfaces(inferred, declared);\r\n        const interfaceMap = new Map(interfaces.map(e => [e.name, e]));\r\n        for (const type of mergeInterfaces(inferred, declared)) {\r\n            typeToSuperProperties.set(type.name, this.addSuperProperties(type, interfaceMap, new Set()));\r\n        }\r\n        return typeToSuperProperties;\r\n    }\r\n\r\n    private addSuperProperties(interfaceType: InterfaceType, map: Map<string, InterfaceType>, visited: Set<string>): Property[] {\r\n        if (visited.has(interfaceType.name)) {\r\n            return [];\r\n        }\r\n        visited.add(interfaceType.name);\r\n        const properties: Property[] = [...interfaceType.properties];\r\n        for (const superType of interfaceType.superTypes) {\r\n            const value = map.get(superType.name);\r\n            if (value) {\r\n                properties.push(...this.addSuperProperties(value, map, visited));\r\n            }\r\n        }\r\n        return properties;\r\n    }\r\n}\r\n\r\nfunction collectNameToRulesActions({ parserRules, datatypeRules }: AstResources): MultiMap<string, ParserRule | Action> {\r\n    const acc = new MultiMap<string, ParserRule | Action>();\r\n\r\n    // collect rules\r\n    stream(parserRules)\r\n        .concat(datatypeRules)\r\n        .forEach(rule => acc.add(getRuleType(rule), rule));\r\n\r\n    // collect actions\r\n    function collectActions(element: AbstractElement) {\r\n        if (isAction(element)) {\r\n            const name = getActionType(element);\r\n            if (name) {\r\n                acc.add(name, element);\r\n            }\r\n        } if (isAlternatives(element) || isGroup(element) || isUnorderedGroup(element)) {\r\n            element.elements.forEach(e => collectActions(e));\r\n        }\r\n    }\r\n\r\n    parserRules\r\n        .forEach(rule => collectActions(rule.definition));\r\n\r\n    return acc;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumDocument } from '../../workspace/documents.js';\r\nimport type { Action, Grammar, Interface, ParserRule, Type } from '../generated/ast.js';\r\nimport type { Property, TypeOption } from '../type-system/type-collector/types.js';\r\n\r\n/**\r\n * A Langium document holds the parse result (AST and CST) and any additional state that is derived\r\n * from the AST, e.g. the result of scope precomputation.\r\n */\r\nexport interface LangiumGrammarDocument extends LangiumDocument<Grammar> {\r\n    validationResources?: ValidationResources\r\n}\r\n\r\nexport type ValidationResources = {\r\n    typeToValidationInfo: TypeToValidationInfo,\r\n    typeToSuperProperties: Map<string, Property[]>,\r\n}\r\n\r\nexport type TypeToValidationInfo = Map<string, InferredInfo | DeclaredInfo | InferredInfo & DeclaredInfo>;\r\n\r\nexport type InferredInfo = {\r\n    inferred: TypeOption,\r\n    inferredNodes: ReadonlyArray<ParserRule | Action>\r\n}\r\n\r\nexport type DeclaredInfo = {\r\n    declared: TypeOption,\r\n    declaredNode: Type | Interface,\r\n}\r\n\r\nexport function isDeclared(type: InferredInfo | DeclaredInfo | InferredInfo & DeclaredInfo): type is DeclaredInfo {\r\n    return type && 'declared' in type;\r\n}\r\n\r\nexport function isInferred(type: InferredInfo | DeclaredInfo | InferredInfo & DeclaredInfo): type is InferredInfo {\r\n    return type && 'inferred' in type;\r\n}\r\n\r\nexport function isInferredAndDeclared(type: InferredInfo | DeclaredInfo | InferredInfo & DeclaredInfo): type is InferredInfo & DeclaredInfo {\r\n    return type && 'inferred' in type && 'declared' in type;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode } from '../../syntax-tree.js';\r\nimport type { DiagnosticInfo, ValidationAcceptor, ValidationChecks } from '../../validation/validation-registry.js';\r\nimport type { LangiumGrammarServices } from '../langium-grammar-module.js';\r\nimport type { Property, PropertyType } from '../type-system/type-collector/types.js';\r\nimport type { DeclaredInfo, InferredInfo, LangiumGrammarDocument, ValidationResources } from '../workspace/documents.js';\r\nimport * as ast from '../generated/ast.js';\r\nimport { MultiMap } from '../../utils/collections.js';\r\nimport { extractAssignments } from '../internal-grammar-util.js';\r\nimport { flattenPropertyUnion, InterfaceType, isArrayType, isInterfaceType, isMandatoryPropertyType, isPropertyUnion, isReferenceType, isTypeAssignable, isUnionType, isValueType, propertyTypeToString } from '../type-system/type-collector/types.js';\r\nimport { isDeclared, isInferred, isInferredAndDeclared } from '../workspace/documents.js';\r\n\r\nexport function registerTypeValidationChecks(services: LangiumGrammarServices): void {\r\n    const registry = services.validation.ValidationRegistry;\r\n    const typesValidator = services.validation.LangiumGrammarTypesValidator;\r\n    const checks: ValidationChecks<ast.LangiumGrammarAstType> = {\r\n        Action: [\r\n            typesValidator.checkActionIsNotUnionType,\r\n        ],\r\n        Grammar: [\r\n            typesValidator.checkDeclaredTypesConsistency,\r\n            typesValidator.checkDeclaredAndInferredTypesConsistency,\r\n        ],\r\n        Interface: [\r\n            typesValidator.checkCyclicInterface\r\n        ],\r\n        Type: [\r\n            typesValidator.checkCyclicType\r\n        ]\r\n    };\r\n    registry.register(checks, typesValidator);\r\n}\r\n\r\nexport class LangiumGrammarTypesValidator {\r\n\r\n    checkCyclicType(type: ast.Type, accept: ValidationAcceptor): void {\r\n        if (isCyclicType(type, new Set())) {\r\n            accept('error', `Type alias '${type.name}' circularly references itself.`, { node: type, property: 'name' });\r\n        }\r\n    }\r\n\r\n    checkCyclicInterface(type: ast.Interface, accept: ValidationAcceptor): void {\r\n        if (isCyclicType(type, new Set())) {\r\n            accept('error', `Type '${type.name}' recursively references itself as a base type.`, { node: type, property: 'name' });\r\n        }\r\n    }\r\n\r\n    checkDeclaredTypesConsistency(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const validationResources = (grammar.$document as LangiumGrammarDocument)?.validationResources;\r\n        if (validationResources) {\r\n            for (const typeInfo of validationResources.typeToValidationInfo.values()) {\r\n                if (isDeclared(typeInfo) && isInterfaceType(typeInfo.declared) && ast.isInterface(typeInfo.declaredNode)) {\r\n                    const declInterface = typeInfo as { declared: InterfaceType, declaredNode: ast.Interface };\r\n                    validateInterfaceSuperTypes(declInterface, accept);\r\n                    validateSuperTypesConsistency(declInterface, accept);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    checkDeclaredAndInferredTypesConsistency(grammar: ast.Grammar, accept: ValidationAcceptor): void {\r\n        const validationResources = (grammar.$document as LangiumGrammarDocument)?.validationResources;\r\n        if (validationResources) {\r\n            for (const typeInfo of validationResources.typeToValidationInfo.values()) {\r\n                if (isInferred(typeInfo) && typeInfo.inferred instanceof InterfaceType) {\r\n                    validateInferredInterface(typeInfo.inferred as InterfaceType, accept);\r\n                }\r\n                if (isInferredAndDeclared(typeInfo)) {\r\n                    validateDeclaredAndInferredConsistency(typeInfo, validationResources, accept);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    checkActionIsNotUnionType(action: ast.Action, accept: ValidationAcceptor): void {\r\n        if (ast.isType(action.type)) {\r\n            accept('error', 'Actions cannot create union types.', { node: action, property: 'type' });\r\n        }\r\n    }\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction isCyclicType(type: ast.TypeDefinition | ast.AbstractType, visited: Set<AstNode>): boolean {\r\n    if (visited.has(type)) {\r\n        return true;\r\n    }\r\n    visited.add(type);\r\n    if (ast.isType(type)) {\r\n        return isCyclicType(type.type, visited);\r\n    } else if (ast.isInterface(type)) {\r\n        return type.superTypes.some(t => t.ref && isCyclicType(t.ref, new Set(visited)));\r\n    } else if (ast.isSimpleType(type)) {\r\n        if (type.typeRef?.ref) {\r\n            return isCyclicType(type.typeRef!.ref, visited);\r\n        }\r\n    } else if (ast.isReferenceType(type)) {\r\n        return isCyclicType(type.referenceType, visited);\r\n    } else if (ast.isArrayType(type)) {\r\n        return isCyclicType(type.elementType, visited);\r\n    } else if (ast.isUnionType(type)) {\r\n        return type.types.some(t => isCyclicType(t, new Set(visited)));\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction validateInferredInterface(inferredInterface: InterfaceType, accept: ValidationAcceptor): void {\r\n    inferredInterface.properties.forEach(prop => {\r\n        const flattened = flattenPropertyUnion(prop.type);\r\n        if (flattened.length > 1) {\r\n            const typeKind = (type: PropertyType) => isReferenceType(type) ? 'ref' : 'other';\r\n            const firstKind = typeKind(flattened[0]);\r\n            if (flattened.slice(1).some(type => typeKind(type) !== firstKind)) {\r\n                const targetNode = prop.astNodes.values().next()?.value;\r\n                if (targetNode) {\r\n                    accept(\r\n                        'error',\r\n                        `Mixing a cross-reference with other types is not supported. Consider splitting property \"${prop.name}\" into two or more different properties.`,\r\n                        { node: targetNode }\r\n                    );\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction validateInterfaceSuperTypes(\r\n    { declared, declaredNode }: { declared: InterfaceType, declaredNode: ast.Interface },\r\n    accept: ValidationAcceptor): void {\r\n\r\n    Array.from(declared.superTypes).forEach((superType, i) => {\r\n        if (superType) {\r\n            if (isUnionType(superType)) {\r\n                accept('error', 'Interfaces cannot extend union types.', { node: declaredNode, property: 'superTypes', index: i });\r\n            }\r\n            if (!superType.declared) {\r\n                accept('error', 'Extending an inferred type is discouraged.', { node: declaredNode, property: 'superTypes', index: i });\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction validateSuperTypesConsistency(\r\n    { declared, declaredNode }: { declared: InterfaceType, declaredNode: ast.Interface },\r\n    accept: ValidationAcceptor): void {\r\n\r\n    const nameToProp = declared.properties.reduce((acc, e) => acc.add(e.name, e), new MultiMap<string, Property>());\r\n    for (const [name, props] of nameToProp.entriesGroupedByKey()) {\r\n        if (props.length > 1) {\r\n            for (const prop of props) {\r\n                accept('error', `Cannot have two properties with the same name '${name}'.`, {\r\n                    node: Array.from(prop.astNodes)[0],\r\n                    property: 'name'\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    const allSuperTypes = Array.from(declared.superTypes);\r\n    for (let i = 0; i < allSuperTypes.length; i++) {\r\n        for (let j = i + 1; j < allSuperTypes.length; j++) {\r\n            const outerType = allSuperTypes[i];\r\n            const innerType = allSuperTypes[j];\r\n            const outerProps = isInterfaceType(outerType) ? outerType.superProperties : [];\r\n            const innerProps = isInterfaceType(innerType) ? innerType.superProperties : [];\r\n            const nonIdentical = getNonIdenticalProps(outerProps, innerProps);\r\n            if (nonIdentical.length > 0) {\r\n                accept('error', `Cannot simultaneously inherit from '${outerType}' and '${innerType}'. Their ${nonIdentical.map(e => \"'\" + e + \"'\").join(', ')} properties are not identical.`, {\r\n                    node: declaredNode,\r\n                    property: 'name'\r\n                });\r\n            }\r\n        }\r\n    }\r\n    const allSuperProps = new Set<string>();\r\n    for (const superType of allSuperTypes) {\r\n        const props = isInterfaceType(superType) ? superType.superProperties : [];\r\n        for (const prop of props) {\r\n            allSuperProps.add(prop.name);\r\n        }\r\n    }\r\n    for (const ownProp of declared.properties) {\r\n        if (allSuperProps.has(ownProp.name)) {\r\n            const propNode = declaredNode.attributes.find(e => e.name === ownProp.name);\r\n            if (propNode) {\r\n                accept('error', `Cannot redeclare property '${ownProp.name}'. It is already inherited from another interface.`, {\r\n                    node: propNode,\r\n                    property: 'name'\r\n                });\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getNonIdenticalProps(a: readonly Property[], b: readonly Property[]): string[] {\r\n    const nonIdentical: string[] = [];\r\n    for (const outerProp of a) {\r\n        const innerProp = b.find(e => e.name === outerProp.name);\r\n        if (innerProp && !arePropTypesIdentical(outerProp, innerProp)) {\r\n            nonIdentical.push(outerProp.name);\r\n        }\r\n    }\r\n    return nonIdentical;\r\n}\r\n\r\nfunction arePropTypesIdentical(a: Property, b: Property): boolean {\r\n    return isTypeAssignable(a.type, b.type) && isTypeAssignable(b.type, a.type);\r\n}\r\n\r\n///////////////////////////////////////////////////////////////////////////////\r\n\r\nfunction validateDeclaredAndInferredConsistency(typeInfo: InferredInfo & DeclaredInfo, resources: ValidationResources, accept: ValidationAcceptor) {\r\n    const { inferred, declared, declaredNode, inferredNodes } = typeInfo;\r\n    const typeName = declared.name;\r\n\r\n    const applyErrorToRulesAndActions = (msgPostfix?: string) => (errorMsg: string) =>\r\n        inferredNodes.forEach(node => accept('error', `${errorMsg}${msgPostfix ? ` ${msgPostfix}` : ''}.`,\r\n            (node?.inferredType) ?\r\n                <DiagnosticInfo<ast.InferredType, string>>{ node: node?.inferredType, property: 'name' } :\r\n                <DiagnosticInfo<ast.ParserRule | ast.Action | ast.InferredType, string>>{ node, property: ast.isAction(node) ? 'type' : 'name' }\r\n        ));\r\n\r\n    const applyErrorToProperties = (nodes: Set<ast.Assignment | ast.Action | ast.TypeAttribute>, errorMessage: string) =>\r\n        nodes.forEach(node =>\r\n            accept('error', errorMessage, { node, property: ast.isAssignment(node) || ast.isAction(node) ? 'feature' : 'name' })\r\n        );\r\n\r\n    // todo add actions\r\n    // currently we don't track which assignments belong to which actions and can't apply this error\r\n    const applyMissingPropErrorToRules = (missingProp: string) => {\r\n        inferredNodes.forEach(node => {\r\n            if (ast.isParserRule(node)) {\r\n                const assignments = extractAssignments(node.definition);\r\n                if (assignments.find(e => e.feature === missingProp) === undefined) {\r\n                    accept(\r\n                        'error',\r\n                        `Property '${missingProp}' is missing in a rule '${node.name}', but is required in type '${typeName}'.`,\r\n                        {\r\n                            node,\r\n                            property: 'parameters'\r\n                        }\r\n                    );\r\n                }\r\n            }\r\n        });\r\n    };\r\n\r\n    if (isUnionType(inferred) && isUnionType(declared)) {\r\n        validateAlternativesConsistency(inferred.type, declared.type,\r\n            applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`),\r\n        );\r\n    } else if (isInterfaceType(inferred) && isInterfaceType(declared)) {\r\n        validatePropertiesConsistency(inferred, declared, resources,\r\n            applyErrorToRulesAndActions(`in a rule that returns type '${typeName}'`),\r\n            applyErrorToProperties,\r\n            applyMissingPropErrorToRules\r\n        );\r\n    } else {\r\n        const errorMessage = `Inferred and declared versions of type '${typeName}' both have to be interfaces or unions.`;\r\n        applyErrorToRulesAndActions()(errorMessage);\r\n        accept('error', errorMessage, { node: declaredNode, property: 'name' });\r\n    }\r\n}\r\n\r\nfunction validateAlternativesConsistency(\r\n    inferred: PropertyType,\r\n    declared: PropertyType,\r\n    applyErrorToInferredTypes: (errorMessage: string) => void\r\n) {\r\n    if (!isTypeAssignable(inferred, declared)) {\r\n        applyErrorToInferredTypes(`Cannot assign type '${propertyTypeToString(inferred, 'DeclaredType')}' to '${propertyTypeToString(declared, 'DeclaredType')}'`);\r\n    }\r\n}\r\n\r\nfunction isOptionalProperty(prop: Property): boolean {\r\n    // mandatory properties will always be created so there are no issues if they are missing\r\n    return prop.optional || isMandatoryPropertyType(prop.type);\r\n}\r\n\r\nfunction validatePropertiesConsistency(\r\n    inferred: InterfaceType,\r\n    declared: InterfaceType,\r\n    resources: ValidationResources,\r\n    applyErrorToType: (errorMessage: string) => void,\r\n    applyErrorToProperties: (nodes: Set<ast.Assignment | ast.Action | ast.TypeAttribute>, errorMessage: string) => void,\r\n    applyMissingPropErrorToRules: (missingProp: string) => void\r\n) {\r\n    const ownInferredProps = new Set(inferred.properties.map(e => e.name));\r\n    // This field also contains properties of sub types\r\n    const allInferredProps = new Map(inferred.allProperties.map(e => [e.name, e]));\r\n    // This field only contains properties of itself or super types\r\n    const declaredProps = new Map(declared.superProperties.map(e => [e.name, e]));\r\n\r\n    // The inferred props may not have full hierarchy information so try finding\r\n    // a corresponding declared type\r\n    const matchingProp = (type: PropertyType): PropertyType => {\r\n        if (isPropertyUnion(type)) return { types: type.types.map(t => matchingProp(t)) };\r\n        if (isReferenceType(type)) return { referenceType: matchingProp(type.referenceType) };\r\n        if (isArrayType(type)) return { elementType: matchingProp(type.elementType) };\r\n        if (isValueType(type)) {\r\n            const resource = resources.typeToValidationInfo.get(type.value.name);\r\n            if (!resource) return type;\r\n            return { value: 'declared' in resource ? resource.declared : resource.inferred };\r\n        }\r\n        return type;\r\n    };\r\n\r\n    // detects extra properties & validates matched ones on consistency by the 'optional' property\r\n    for (const [name, foundProp] of allInferredProps.entries()) {\r\n        const expectedProp = declaredProps.get(name);\r\n        if (expectedProp) {\r\n            const foundTypeAsStr = propertyTypeToString(foundProp.type, 'DeclaredType');\r\n            const expectedTypeAsStr = propertyTypeToString(expectedProp.type, 'DeclaredType');\r\n            const typeAlternativesErrors = isTypeAssignable(matchingProp(foundProp.type), expectedProp.type);\r\n            if (!typeAlternativesErrors && expectedTypeAsStr !== 'unknown') {\r\n                const errorMsgPrefix = `The assigned type '${foundTypeAsStr}' is not compatible with the declared property '${name}' of type '${expectedTypeAsStr}'.`;\r\n                applyErrorToProperties(foundProp.astNodes, errorMsgPrefix);\r\n            }\r\n\r\n            if (foundProp.optional && !isOptionalProperty(expectedProp)) {\r\n                applyMissingPropErrorToRules(name);\r\n            }\r\n        } else if (ownInferredProps.has(name)) {\r\n            // Only apply the superfluous property error on properties which are actually declared on the current type\r\n            applyErrorToProperties(foundProp.astNodes, `A property '${name}' is not expected.`);\r\n        }\r\n    }\r\n\r\n    // Detect any missing properties\r\n    const missingProps = new Set<string>();\r\n    for (const [name, expectedProperties] of declaredProps.entries()) {\r\n        const foundProperty = allInferredProps.get(name);\r\n        if (!foundProperty && !isOptionalProperty(expectedProperties)) {\r\n            missingProps.add(name);\r\n        }\r\n    }\r\n\r\n    if (missingProps.size > 0) {\r\n        const prefix = missingProps.size > 1 ? 'Properties' : 'A property';\r\n        const postfix = missingProps.size > 1 ? 'are expected' : 'is expected';\r\n        const props = Array.from(missingProps).map(e => `'${e}'`).sort().join(', ');\r\n        applyErrorToType(`${prefix} ${props} ${postfix}.`);\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { DefaultSharedModuleContext } from '../default-module.js';\r\nimport type { Module } from '../dependency-injection.js';\r\nimport type { LangiumServices, LangiumSharedServices, PartialLangiumServices, PartialLangiumSharedServices } from '../services.js';\r\nimport type { LangiumGrammarDocument } from './workspace/documents.js';\r\nimport type { Grammar } from './generated/ast.js';\r\nimport { createDefaultModule, createDefaultSharedModule } from '../default-module.js';\r\nimport { inject } from '../dependency-injection.js';\r\nimport { LangiumGrammarGeneratedModule, LangiumGrammarGeneratedSharedModule } from './generated/module.js';\r\nimport { LangiumGrammarScopeComputation, LangiumGrammarScopeProvider } from './references/grammar-scope.js';\r\nimport { LangiumGrammarValidator, registerValidationChecks } from './validation/validator.js';\r\nimport { LangiumGrammarCodeActionProvider } from './lsp/grammar-code-actions.js';\r\nimport { LangiumGrammarCompletionProvider } from './lsp/grammar-completion-provider.js';\r\nimport { LangiumGrammarFoldingRangeProvider } from './lsp/grammar-folding-ranges.js';\r\nimport { LangiumGrammarFormatter } from './lsp/grammar-formatter.js';\r\nimport { LangiumGrammarSemanticTokenProvider } from './lsp/grammar-semantic-tokens.js';\r\nimport { LangiumGrammarNameProvider } from './references/grammar-naming.js';\r\nimport { LangiumGrammarReferences } from './references/grammar-references.js';\r\nimport { LangiumGrammarDefinitionProvider } from './lsp/grammar-definition.js';\r\nimport { LangiumGrammarCallHierarchyProvider } from './lsp/grammar-call-hierarchy.js';\r\nimport { LangiumGrammarValidationResourcesCollector } from './validation/validation-resources-collector.js';\r\nimport { LangiumGrammarTypesValidator, registerTypeValidationChecks } from './validation/types-validator.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\nimport { DocumentState } from '../workspace/documents.js';\r\n\r\nexport type LangiumGrammarAddedServices = {\r\n    validation: {\r\n        LangiumGrammarValidator: LangiumGrammarValidator,\r\n        ValidationResourcesCollector: LangiumGrammarValidationResourcesCollector,\r\n        LangiumGrammarTypesValidator: LangiumGrammarTypesValidator,\r\n    }\r\n}\r\n\r\nexport type LangiumGrammarServices = LangiumServices & LangiumGrammarAddedServices;\r\n\r\nexport const LangiumGrammarModule: Module<LangiumGrammarServices, PartialLangiumServices & LangiumGrammarAddedServices> = {\r\n    validation: {\r\n        LangiumGrammarValidator: (services) => new LangiumGrammarValidator(services),\r\n        ValidationResourcesCollector: (services) => new LangiumGrammarValidationResourcesCollector(services),\r\n        LangiumGrammarTypesValidator: () => new LangiumGrammarTypesValidator(),\r\n    },\r\n    lsp: {\r\n        FoldingRangeProvider: (services) => new LangiumGrammarFoldingRangeProvider(services),\r\n        CodeActionProvider: (services) => new LangiumGrammarCodeActionProvider(services),\r\n        SemanticTokenProvider: (services) => new LangiumGrammarSemanticTokenProvider(services),\r\n        Formatter: () => new LangiumGrammarFormatter(),\r\n        DefinitionProvider: (services) => new LangiumGrammarDefinitionProvider(services),\r\n        CallHierarchyProvider: (services) => new LangiumGrammarCallHierarchyProvider(services),\r\n        CompletionProvider: (services) => new LangiumGrammarCompletionProvider(services)\r\n    },\r\n    references: {\r\n        ScopeComputation: (services) => new LangiumGrammarScopeComputation(services),\r\n        ScopeProvider: (services) => new LangiumGrammarScopeProvider(services),\r\n        References: (services) => new LangiumGrammarReferences(services),\r\n        NameProvider: () => new LangiumGrammarNameProvider()\r\n    }\r\n};\r\n\r\nexport function createLangiumGrammarServices(context: DefaultSharedModuleContext,\r\n    sharedModule?: Module<LangiumSharedServices, PartialLangiumSharedServices>): {\r\n        shared: LangiumSharedServices,\r\n        grammar: LangiumGrammarServices\r\n    } {\r\n    const shared = inject(\r\n        createDefaultSharedModule(context),\r\n        LangiumGrammarGeneratedSharedModule,\r\n        sharedModule\r\n    );\r\n    const grammar = inject(\r\n        createDefaultModule({ shared }),\r\n        LangiumGrammarGeneratedModule,\r\n        LangiumGrammarModule\r\n    );\r\n    addTypeCollectionPhase(shared, grammar);\r\n    shared.ServiceRegistry.register(grammar);\r\n\r\n    registerValidationChecks(grammar);\r\n    registerTypeValidationChecks(grammar);\r\n\r\n    return { shared, grammar };\r\n}\r\n\r\nfunction addTypeCollectionPhase(sharedServices: LangiumSharedServices, grammarServices: LangiumGrammarServices) {\r\n    const documentBuilder = sharedServices.workspace.DocumentBuilder;\r\n    documentBuilder.onBuildPhase(DocumentState.IndexedReferences, async (documents, cancelToken) => {\r\n        for (const document of documents) {\r\n            await interruptAndCheck(cancelToken);\r\n            const typeCollector = grammarServices.validation.ValidationResourcesCollector;\r\n            const grammar = document.parseResult.value as Grammar;\r\n            (document as LangiumGrammarDocument).validationResources = typeCollector.collectValidationResources(grammar);\r\n        }\r\n    });\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-util.js';\r\n\r\nexport interface FileSystemNode {\r\n    readonly isFile: boolean;\r\n    readonly isDirectory: boolean;\r\n    readonly uri: URI;\r\n}\r\n\r\nexport type FileSystemFilter = (node: FileSystemNode) => boolean;\r\n\r\n/**\r\n * Provides methods to interact with an abstract file system. The default implementation is based on the node.js `fs` API.\r\n */\r\nexport interface FileSystemProvider {\r\n    /**\r\n     * Reads a document asynchronously from a given URI.\r\n     * @returns The string content of the file with the specified URI.\r\n     */\r\n    readFile(uri: URI): Promise<string>;\r\n    /**\r\n     * Reads a document synchronously from a given URI.\r\n     * @returns The string content of the file with the specified URI.\r\n     */\r\n    readFileSync(uri: URI): string;\r\n    /**\r\n     * Reads the directory information for the given URI.\r\n     * @returns The list of file system entries that are contained within the specified directory.\r\n     */\r\n    readDirectory(uri: URI): Promise<FileSystemNode[]>;\r\n}\r\n\r\nexport class EmptyFileSystemProvider implements FileSystemProvider {\r\n\r\n    readFile(): Promise<string> {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n\r\n    readFileSync(): string {\r\n        throw new Error('Method not implemented.');\r\n    }\r\n\r\n    async readDirectory(): Promise<FileSystemNode[]> {\r\n        return [];\r\n    }\r\n\r\n}\r\n\r\nexport const EmptyFileSystem = {\r\n    fileSystemProvider: () => new EmptyFileSystemProvider()\r\n};\r\n", "/******************************************************************************\r\n * Copyright 2021-2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Module } from '../dependency-injection.js';\r\nimport type { LangiumGrammarServices } from '../grammar/langium-grammar-module.js';\r\nimport type { LanguageMetaData } from '../grammar/language-meta-data.js';\r\nimport type { IParserConfig } from '../parser/parser-config.js';\r\nimport type { LangiumGeneratedServices, LangiumGeneratedSharedServices, LangiumServices, LangiumSharedServices, PartialLangiumServices, PartialLangiumSharedServices } from '../services.js';\r\nimport type { AstNode, CstNode } from '../syntax-tree.js';\r\nimport type { Mutable } from '../utils/ast-util.js';\r\nimport { createDefaultModule, createDefaultSharedModule } from '../default-module.js';\r\nimport { inject } from '../dependency-injection.js';\r\nimport { interpretAstReflection } from '../grammar/ast-reflection-interpreter.js';\r\nimport * as ast from '../grammar/generated/ast.js';\r\nimport { terminalRegex } from '../grammar/internal-grammar-util.js';\r\nimport { createLangiumGrammarServices } from '../grammar/langium-grammar-module.js';\r\nimport { isCompositeCstNode } from '../syntax-tree.js';\r\nimport { getContainerOfType, getDocument, streamAllContents } from '../utils/ast-util.js';\r\nimport { streamCst } from '../utils/cst-util.js';\r\nimport { EmptyFileSystem } from '../workspace/file-system-provider.js';\r\nimport { URI } from './uri-util.js';\r\n\r\n/**\r\n * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,\r\n * the result is `undefined`.\r\n */\r\nexport function getEntryRule(grammar: ast.Grammar): ast.ParserRule | undefined {\r\n    return grammar.rules.find(e => ast.isParserRule(e) && e.entry) as ast.ParserRule;\r\n}\r\n\r\n/**\r\n * Returns all hidden terminal rules of the given grammar, if any.\r\n */\r\nexport function getHiddenRules(grammar: ast.Grammar) {\r\n    return grammar.rules.filter((e): e is ast.TerminalRule => ast.isTerminalRule(e) && e.hidden);\r\n}\r\n\r\n/**\r\n * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).\r\n *\r\n * @param grammar The grammar that contains all rules\r\n * @param allTerminals Whether or not to include terminals that are referenced only by other terminals\r\n * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,\r\n *      this function returns all rules of the specified grammar.\r\n */\r\nexport function getAllReachableRules(grammar: ast.Grammar, allTerminals: boolean): Set<ast.AbstractRule> {\r\n    const ruleNames = new Set<string>();\r\n    const entryRule = getEntryRule(grammar);\r\n    if (!entryRule) {\r\n        return new Set(grammar.rules);\r\n    }\r\n\r\n    const topMostRules = [entryRule as ast.AbstractRule].concat(getHiddenRules(grammar));\r\n    for (const rule of topMostRules) {\r\n        ruleDfs(rule, ruleNames, allTerminals);\r\n    }\r\n\r\n    const rules = new Set<ast.AbstractRule>();\r\n    for (const rule of grammar.rules) {\r\n        if (ruleNames.has(rule.name) || (ast.isTerminalRule(rule) && rule.hidden)) {\r\n            rules.add(rule);\r\n        }\r\n    }\r\n    return rules;\r\n}\r\n\r\nfunction ruleDfs(rule: ast.AbstractRule, visitedSet: Set<string>, allTerminals: boolean): void {\r\n    visitedSet.add(rule.name);\r\n    streamAllContents(rule).forEach(node => {\r\n        if (ast.isRuleCall(node) || (allTerminals && ast.isTerminalRuleCall(node))) {\r\n            const refRule = node.rule.ref;\r\n            if (refRule && !visitedSet.has(refRule.name)) {\r\n                ruleDfs(refRule, visitedSet, allTerminals);\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\n/**\r\n * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).\r\n * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`\r\n * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).\r\n *\r\n * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared\r\n * and cannot be inferred.\r\n */\r\nexport function getCrossReferenceTerminal(crossRef: ast.CrossReference): ast.AbstractElement | undefined {\r\n    if (crossRef.terminal) {\r\n        return crossRef.terminal;\r\n    } else if (crossRef.type.ref) {\r\n        const nameAssigment = findNameAssignment(crossRef.type.ref);\r\n        return nameAssigment?.terminal;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Determines whether the given terminal rule represents a comment. This is true if the rule is marked\r\n * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)\r\n * that contains visible characters is considered a comment.\r\n */\r\nexport function isCommentTerminal(terminalRule: ast.TerminalRule): boolean {\r\n    return terminalRule.hidden && !terminalRegex(terminalRule).test(' ');\r\n}\r\n\r\n/**\r\n * Find all CST nodes within the given node that contribute to the specified property.\r\n *\r\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.\r\n * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.\r\n */\r\nexport function findNodesForProperty(node: CstNode | undefined, property: string | undefined): CstNode[] {\r\n    if (!node || !property) {\r\n        return [];\r\n    }\r\n    return findNodesForPropertyInternal(node, property, node.astNode, true);\r\n}\r\n\r\n/**\r\n * Find a single CST node within the given node that contributes to the specified property.\r\n *\r\n * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.\r\n * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.\r\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\r\n *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,\r\n *        the node with the specified index is returned.\r\n */\r\nexport function findNodeForProperty(node: CstNode | undefined, property: string | undefined, index?: number): CstNode | undefined {\r\n    if (!node || !property) {\r\n        return undefined;\r\n    }\r\n    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);\r\n    if (nodes.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (index !== undefined) {\r\n        index = Math.max(0, Math.min(index, nodes.length - 1));\r\n    } else {\r\n        index = 0;\r\n    }\r\n    return nodes[index];\r\n}\r\n\r\nfunction findNodesForPropertyInternal(node: CstNode, property: string, element: AstNode | undefined, first: boolean): CstNode[] {\r\n    if (!first) {\r\n        const nodeFeature = getContainerOfType(node.grammarSource, ast.isAssignment);\r\n        if (nodeFeature && nodeFeature.feature === property) {\r\n            return [node];\r\n        }\r\n    }\r\n    if (isCompositeCstNode(node) && node.astNode === element) {\r\n        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));\r\n    }\r\n    return [];\r\n}\r\n\r\n/**\r\n * Find all CST nodes within the given node that correspond to the specified keyword.\r\n *\r\n * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.\r\n * @param keyword A keyword as specified in the grammar.\r\n */\r\nexport function findNodesForKeyword(node: CstNode | undefined, keyword: string): CstNode[] {\r\n    if (!node) {\r\n        return [];\r\n    }\r\n    return findNodesForKeywordInternal(node, keyword, node?.astNode);\r\n}\r\n\r\n/**\r\n * Find a single CST node within the given node that corresponds to the specified keyword.\r\n *\r\n * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.\r\n * @param keyword A keyword as specified in the grammar.\r\n * @param index If no index is specified or the index is less than zero, the first found node is returned. If the\r\n *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,\r\n *        the node with the specified index is returned.\r\n */\r\nexport function findNodeForKeyword(node: CstNode | undefined, keyword: string, index?: number): CstNode | undefined {\r\n    if (!node) {\r\n        return undefined;\r\n    }\r\n    const nodes = findNodesForKeywordInternal(node, keyword, node?.astNode);\r\n    if (nodes.length === 0) {\r\n        return undefined;\r\n    }\r\n    if (index !== undefined) {\r\n        index = Math.max(0, Math.min(index, nodes.length - 1));\r\n    } else {\r\n        index = 0;\r\n    }\r\n    return nodes[index];\r\n}\r\n\r\nexport function findNodesForKeywordInternal(node: CstNode, keyword: string, element: AstNode | undefined): CstNode[] {\r\n    if (node.astNode !== element) {\r\n        return [];\r\n    }\r\n    if (ast.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {\r\n        return [node];\r\n    }\r\n    const treeIterator = streamCst(node).iterator();\r\n    let result: IteratorResult<CstNode>;\r\n    const keywordNodes: CstNode[] = [];\r\n    do {\r\n        result = treeIterator.next();\r\n        if (!result.done) {\r\n            const childNode = result.value;\r\n            if (childNode.astNode === element) {\r\n                if (ast.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {\r\n                    keywordNodes.push(childNode);\r\n                }\r\n            } else {\r\n                treeIterator.prune();\r\n            }\r\n        }\r\n    } while (!result.done);\r\n    return keywordNodes;\r\n}\r\n\r\n/**\r\n * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar\r\n * node is returned. If no assignment is found, the result is `undefined`.\r\n *\r\n * @param cstNode A CST node for which to find a property assignment.\r\n */\r\nexport function findAssignment(cstNode: CstNode): ast.Assignment | undefined {\r\n    const astNode = cstNode.astNode;\r\n    // Only search until the ast node of the parent cst node is no longer the original ast node\r\n    // This would make us jump to a preceding rule call, which contains only unrelated assignments\r\n    while (astNode === cstNode.container?.astNode) {\r\n        const assignment = getContainerOfType(cstNode.grammarSource, ast.isAssignment);\r\n        if (assignment) {\r\n            return assignment;\r\n        }\r\n        cstNode = cstNode.container;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred\r\n * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,\r\n * this function returns `undefined`.\r\n */\r\nexport function findNameAssignment(type: ast.AbstractType | ast.InferredType): ast.Assignment | undefined {\r\n    if (ast.isInferredType(type)) {\r\n        // inferred type is unexpected, extract AbstractType first\r\n        type = type.$container;\r\n    }\r\n    return findNameAssignmentInternal(type, new Map());\r\n}\r\n\r\nfunction findNameAssignmentInternal(type: ast.AbstractType, cache: Map<ast.AbstractType, ast.Assignment | undefined>): ast.Assignment | undefined {\r\n    function go(node: AstNode, refType: ast.AbstractType): ast.Assignment | undefined {\r\n        let childAssignment: ast.Assignment | undefined = undefined;\r\n        const parentAssignment = getContainerOfType(node, ast.isAssignment);\r\n        // No parent assignment implies unassigned rule call\r\n        if (!parentAssignment) {\r\n            childAssignment = findNameAssignmentInternal(refType, cache);\r\n        }\r\n        cache.set(type, childAssignment);\r\n        return childAssignment;\r\n    }\r\n\r\n    if (cache.has(type)) return cache.get(type);\r\n    cache.set(type, undefined);\r\n    for (const node of streamAllContents(type)) {\r\n        if (ast.isAssignment(node) && node.feature.toLowerCase() === 'name') {\r\n            cache.set(type, node);\r\n            return node;\r\n        } else if (ast.isRuleCall(node) && ast.isParserRule(node.rule.ref)) {\r\n            return go(node, node.rule.ref);\r\n        } else if (ast.isSimpleType(node) && node.typeRef?.ref) {\r\n            return go(node, node.typeRef.ref);\r\n        }\r\n    }\r\n    return undefined;\r\n}\r\n\r\n/**\r\n * Load a Langium grammar for your language from a JSON string. This is used by several services,\r\n * most notably the parser builder which interprets the grammar to create a parser.\r\n */\r\nexport function loadGrammarFromJson(json: string): ast.Grammar {\r\n    const services = createLangiumGrammarServices(EmptyFileSystem).grammar;\r\n    const astNode = services.serializer.JsonSerializer.deserialize(json) as Mutable<ast.Grammar>;\r\n    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, URI.parse(`memory://${astNode.name ?? 'grammar'}.langium`));\r\n    return astNode;\r\n}\r\n\r\n/**\r\n * Create an instance of the language services for the given grammar. This function is very\r\n * useful when the grammar is defined on-the-fly, for example in tests of the Langium framework.\r\n */\r\nexport async function createServicesForGrammar(config: {\r\n    grammar: string | ast.Grammar,\r\n    grammarServices?: LangiumGrammarServices,\r\n    parserConfig?: IParserConfig,\r\n    languageMetaData?: LanguageMetaData,\r\n    module?: Module<LangiumServices, PartialLangiumServices>\r\n    sharedModule?: Module<LangiumSharedServices, PartialLangiumSharedServices>\r\n}): Promise<LangiumServices> {\r\n    const grammarServices = config.grammarServices ?? createLangiumGrammarServices(EmptyFileSystem).grammar;\r\n    const uri = URI.parse('memory:///grammar.langium');\r\n    const factory = grammarServices.shared.workspace.LangiumDocumentFactory;\r\n    const grammarDocument = typeof config.grammar === 'string'\r\n        ? factory.fromString(config.grammar, uri)\r\n        : getDocument(config.grammar);\r\n    const grammarNode = grammarDocument.parseResult.value as ast.Grammar;\r\n    const documentBuilder = grammarServices.shared.workspace.DocumentBuilder;\r\n    await documentBuilder.build([grammarDocument], { validation: false });\r\n\r\n    const parserConfig = config.parserConfig ?? {\r\n        skipValidations: false\r\n    };\r\n    const languageMetaData = config.languageMetaData ?? {\r\n        caseInsensitive: false,\r\n        fileExtensions: [`.${grammarNode.name?.toLowerCase() ?? 'unknown'}`],\r\n        languageId: grammarNode.name ?? 'UNKNOWN'\r\n    };\r\n    const generatedSharedModule: Module<LangiumSharedServices, LangiumGeneratedSharedServices> = {\r\n        AstReflection: () => interpretAstReflection(grammarNode),\r\n    };\r\n    const generatedModule: Module<LangiumServices, LangiumGeneratedServices> = {\r\n        Grammar: () => grammarNode,\r\n        LanguageMetaData: () => languageMetaData,\r\n        parser: {\r\n            ParserConfig: () => parserConfig\r\n        }\r\n    };\r\n    const shared = inject(createDefaultSharedModule(EmptyFileSystem), generatedSharedModule, config.sharedModule);\r\n    const services = inject(createDefaultModule({ shared }), generatedModule, config.module);\r\n    shared.ServiceRegistry.register(services);\r\n    return services;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport { DefaultNameRegexp } from '../utils/cst-util.js';\r\nimport { isCommentTerminal } from '../utils/grammar-util.js';\r\nimport { isMultilineComment } from '../utils/regex-util.js';\r\nimport { isTerminalRule } from './generated/ast.js';\r\nimport { terminalRegex } from './internal-grammar-util.js';\r\n\r\nexport interface GrammarConfig {\r\n    /**\r\n     * Lists all rule names which are classified as multiline comment rules\r\n     */\r\n    multilineCommentRules: string[]\r\n    /**\r\n     * A regular expression which matches characters of names\r\n     */\r\n    nameRegexp: RegExp\r\n}\r\n\r\nexport function createGrammarConfig(services: LangiumServices): GrammarConfig {\r\n    const rules: string[] = [];\r\n    const grammar = services.Grammar;\r\n    for (const rule of grammar.rules) {\r\n        if (isTerminalRule(rule) && isCommentTerminal(rule) && isMultilineComment(terminalRegex(rule))) {\r\n            rules.push(rule.name);\r\n        }\r\n    }\r\n    return {\r\n        multilineCommentRules: rules,\r\n        nameRegexp: DefaultNameRegexp\r\n    };\r\n}\r\n", "/** Detect free variable `global` from Node.js. */\r\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\r\n\r\nexport default freeGlobal;\r\n", "import freeGlobal from './_freeGlobal.js';\r\n\r\n/** Detect free variable `self`. */\r\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\r\n\r\n/** Used as a reference to the global object. */\r\nvar root = freeGlobal || freeSelf || Function('return this')();\r\n\r\nexport default root;\r\n", "import root from './_root.js';\r\n\r\n/** Built-in value references. */\r\nvar Symbol = root.Symbol;\r\n\r\nexport default Symbol;\r\n", "import Symbol from './_Symbol.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar nativeObjectToString = objectProto.toString;\r\n\r\n/** Built-in value references. */\r\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\r\n\r\n/**\r\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the raw `toStringTag`.\r\n */\r\nfunction getRawTag(value) {\r\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\r\n      tag = value[symToStringTag];\r\n\r\n  try {\r\n    value[symToStringTag] = undefined;\r\n    var unmasked = true;\r\n  } catch (e) {}\r\n\r\n  var result = nativeObjectToString.call(value);\r\n  if (unmasked) {\r\n    if (isOwn) {\r\n      value[symToStringTag] = tag;\r\n    } else {\r\n      delete value[symToStringTag];\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default getRawTag;\r\n", "/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/**\r\n * Used to resolve the\r\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\r\n * of values.\r\n */\r\nvar nativeObjectToString = objectProto.toString;\r\n\r\n/**\r\n * Converts `value` to a string using `Object.prototype.toString`.\r\n *\r\n * @private\r\n * @param {*} value The value to convert.\r\n * @returns {string} Returns the converted string.\r\n */\r\nfunction objectToString(value) {\r\n  return nativeObjectToString.call(value);\r\n}\r\n\r\nexport default objectToString;\r\n", "import Symbol from './_Symbol.js';\r\nimport getRawTag from './_getRawTag.js';\r\nimport objectToString from './_objectToString.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar nullTag = '[object Null]',\r\n    undefinedTag = '[object Undefined]';\r\n\r\n/** Built-in value references. */\r\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\r\n\r\n/**\r\n * The base implementation of `getTag` without fallbacks for buggy environments.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the `toStringTag`.\r\n */\r\nfunction baseGetTag(value) {\r\n  if (value == null) {\r\n    return value === undefined ? undefinedTag : nullTag;\r\n  }\r\n  return (symToStringTag && symToStringTag in Object(value))\r\n    ? getRawTag(value)\r\n    : objectToString(value);\r\n}\r\n\r\nexport default baseGetTag;\r\n", "/**\r\n * Checks if `value` is object-like. A value is object-like if it's not `null`\r\n * and has a `typeof` result of \"object\".\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\r\n * @example\r\n *\r\n * _.isObjectLike({});\r\n * // => true\r\n *\r\n * _.isObjectLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObjectLike(_.noop);\r\n * // => false\r\n *\r\n * _.isObjectLike(null);\r\n * // => false\r\n */\r\nfunction isObjectLike(value) {\r\n  return value != null && typeof value == 'object';\r\n}\r\n\r\nexport default isObjectLike;\r\n", "import baseGetTag from './_baseGetTag.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar symbolTag = '[object Symbol]';\r\n\r\n/**\r\n * Checks if `value` is classified as a `Symbol` primitive or object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\r\n * @example\r\n *\r\n * _.isSymbol(Symbol.iterator);\r\n * // => true\r\n *\r\n * _.isSymbol('abc');\r\n * // => false\r\n */\r\nfunction isSymbol(value) {\r\n  return typeof value == 'symbol' ||\r\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\r\n}\r\n\r\nexport default isSymbol;\r\n", "/**\r\n * A specialized version of `_.map` for arrays without support for iteratee\r\n * shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns the new mapped array.\r\n */\r\nfunction arrayMap(array, iteratee) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length,\r\n      result = Array(length);\r\n\r\n  while (++index < length) {\r\n    result[index] = iteratee(array[index], index, array);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default arrayMap;\r\n", "/**\r\n * Checks if `value` is classified as an `Array` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\r\n * @example\r\n *\r\n * _.isArray([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArray(document.body.children);\r\n * // => false\r\n *\r\n * _.isArray('abc');\r\n * // => false\r\n *\r\n * _.isArray(_.noop);\r\n * // => false\r\n */\r\nvar isArray = Array.isArray;\r\n\r\nexport default isArray;\r\n", "import Symbol from './_Symbol.js';\r\nimport arrayMap from './_arrayMap.js';\r\nimport isArray from './isArray.js';\r\nimport isSymbol from './isSymbol.js';\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0;\r\n\r\n/** Used to convert symbols to primitives and strings. */\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\r\n\r\n/**\r\n * The base implementation of `_.toString` which doesn't convert nullish\r\n * values to empty strings.\r\n *\r\n * @private\r\n * @param {*} value The value to process.\r\n * @returns {string} Returns the string.\r\n */\r\nfunction baseToString(value) {\r\n  // Exit early for strings to avoid a performance hit in some environments.\r\n  if (typeof value == 'string') {\r\n    return value;\r\n  }\r\n  if (isArray(value)) {\r\n    // Recursively convert values (susceptible to call stack limits).\r\n    return arrayMap(value, baseToString) + '';\r\n  }\r\n  if (isSymbol(value)) {\r\n    return symbolToString ? symbolToString.call(value) : '';\r\n  }\r\n  var result = (value + '');\r\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\r\n}\r\n\r\nexport default baseToString;\r\n", "/** Used to match a single whitespace character. */\r\nvar reWhitespace = /\\s/;\r\n\r\n/**\r\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\r\n * character of `string`.\r\n *\r\n * @private\r\n * @param {string} string The string to inspect.\r\n * @returns {number} Returns the index of the last non-whitespace character.\r\n */\r\nfunction trimmedEndIndex(string) {\r\n  var index = string.length;\r\n\r\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\r\n  return index;\r\n}\r\n\r\nexport default trimmedEndIndex;\r\n", "import trimmedEndIndex from './_trimmedEndIndex.js';\r\n\r\n/** Used to match leading whitespace. */\r\nvar reTrimStart = /^\\s+/;\r\n\r\n/**\r\n * The base implementation of `_.trim`.\r\n *\r\n * @private\r\n * @param {string} string The string to trim.\r\n * @returns {string} Returns the trimmed string.\r\n */\r\nfunction baseTrim(string) {\r\n  return string\r\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\r\n    : string;\r\n}\r\n\r\nexport default baseTrim;\r\n", "/**\r\n * Checks if `value` is the\r\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\r\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\r\n * @example\r\n *\r\n * _.isObject({});\r\n * // => true\r\n *\r\n * _.isObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isObject(_.noop);\r\n * // => true\r\n *\r\n * _.isObject(null);\r\n * // => false\r\n */\r\nfunction isObject(value) {\r\n  var type = typeof value;\r\n  return value != null && (type == 'object' || type == 'function');\r\n}\r\n\r\nexport default isObject;\r\n", "import baseTrim from './_baseTrim.js';\r\nimport isObject from './isObject.js';\r\nimport isSymbol from './isSymbol.js';\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar NAN = 0 / 0;\r\n\r\n/** Used to detect bad signed hexadecimal string values. */\r\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\r\n\r\n/** Used to detect binary string values. */\r\nvar reIsBinary = /^0b[01]+$/i;\r\n\r\n/** Used to detect octal string values. */\r\nvar reIsOctal = /^0o[0-7]+$/i;\r\n\r\n/** Built-in method references without a dependency on `root`. */\r\nvar freeParseInt = parseInt;\r\n\r\n/**\r\n * Converts `value` to a number.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to process.\r\n * @returns {number} Returns the number.\r\n * @example\r\n *\r\n * _.toNumber(3.2);\r\n * // => 3.2\r\n *\r\n * _.toNumber(Number.MIN_VALUE);\r\n * // => 5e-324\r\n *\r\n * _.toNumber(Infinity);\r\n * // => Infinity\r\n *\r\n * _.toNumber('3.2');\r\n * // => 3.2\r\n */\r\nfunction toNumber(value) {\r\n  if (typeof value == 'number') {\r\n    return value;\r\n  }\r\n  if (isSymbol(value)) {\r\n    return NAN;\r\n  }\r\n  if (isObject(value)) {\r\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\r\n    value = isObject(other) ? (other + '') : other;\r\n  }\r\n  if (typeof value != 'string') {\r\n    return value === 0 ? value : +value;\r\n  }\r\n  value = baseTrim(value);\r\n  var isBinary = reIsBinary.test(value);\r\n  return (isBinary || reIsOctal.test(value))\r\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\r\n    : (reIsBadHex.test(value) ? NAN : +value);\r\n}\r\n\r\nexport default toNumber;\r\n", "import toNumber from './toNumber.js';\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0,\r\n    MAX_INTEGER = 1.7976931348623157e+308;\r\n\r\n/**\r\n * Converts `value` to a finite number.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.12.0\r\n * @category Lang\r\n * @param {*} value The value to convert.\r\n * @returns {number} Returns the converted number.\r\n * @example\r\n *\r\n * _.toFinite(3.2);\r\n * // => 3.2\r\n *\r\n * _.toFinite(Number.MIN_VALUE);\r\n * // => 5e-324\r\n *\r\n * _.toFinite(Infinity);\r\n * // => 1.7976931348623157e+308\r\n *\r\n * _.toFinite('3.2');\r\n * // => 3.2\r\n */\r\nfunction toFinite(value) {\r\n  if (!value) {\r\n    return value === 0 ? value : 0;\r\n  }\r\n  value = toNumber(value);\r\n  if (value === INFINITY || value === -INFINITY) {\r\n    var sign = (value < 0 ? -1 : 1);\r\n    return sign * MAX_INTEGER;\r\n  }\r\n  return value === value ? value : 0;\r\n}\r\n\r\nexport default toFinite;\r\n", "import toFinite from './toFinite.js';\r\n\r\n/**\r\n * Converts `value` to an integer.\r\n *\r\n * **Note:** This method is loosely based on\r\n * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to convert.\r\n * @returns {number} Returns the converted integer.\r\n * @example\r\n *\r\n * _.toInteger(3.2);\r\n * // => 3\r\n *\r\n * _.toInteger(Number.MIN_VALUE);\r\n * // => 0\r\n *\r\n * _.toInteger(Infinity);\r\n * // => 1.7976931348623157e+308\r\n *\r\n * _.toInteger('3.2');\r\n * // => 3\r\n */\r\nfunction toInteger(value) {\r\n  var result = toFinite(value),\r\n      remainder = result % 1;\r\n\r\n  return result === result ? (remainder ? result - remainder : result) : 0;\r\n}\r\n\r\nexport default toInteger;\r\n", "/**\r\n * This method returns the first argument it receives.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Util\r\n * @param {*} value Any value.\r\n * @returns {*} Returns `value`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n *\r\n * console.log(_.identity(object) === object);\r\n * // => true\r\n */\r\nfunction identity(value) {\r\n  return value;\r\n}\r\n\r\nexport default identity;\r\n", "import baseGetTag from './_baseGetTag.js';\r\nimport isObject from './isObject.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar asyncTag = '[object AsyncFunction]',\r\n    funcTag = '[object Function]',\r\n    genTag = '[object GeneratorFunction]',\r\n    proxyTag = '[object Proxy]';\r\n\r\n/**\r\n * Checks if `value` is classified as a `Function` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\r\n * @example\r\n *\r\n * _.isFunction(_);\r\n * // => true\r\n *\r\n * _.isFunction(/abc/);\r\n * // => false\r\n */\r\nfunction isFunction(value) {\r\n  if (!isObject(value)) {\r\n    return false;\r\n  }\r\n  // The use of `Object#toString` avoids issues with the `typeof` operator\r\n  // in Safari 9 which returns 'object' for typed arrays and other constructors.\r\n  var tag = baseGetTag(value);\r\n  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;\r\n}\r\n\r\nexport default isFunction;\r\n", "import root from './_root.js';\r\n\r\n/** Used to detect overreaching core-js shims. */\r\nvar coreJsData = root['__core-js_shared__'];\r\n\r\nexport default coreJsData;\r\n", "import coreJsData from './_coreJsData.js';\r\n\r\n/** Used to detect methods masquerading as native. */\r\nvar maskSrcKey = (function() {\r\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\r\n  return uid ? ('Symbol(src)_1.' + uid) : '';\r\n}());\r\n\r\n/**\r\n * Checks if `func` has its source masked.\r\n *\r\n * @private\r\n * @param {Function} func The function to check.\r\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\r\n */\r\nfunction isMasked(func) {\r\n  return !!maskSrcKey && (maskSrcKey in func);\r\n}\r\n\r\nexport default isMasked;\r\n", "/** Used for built-in method references. */\r\nvar funcProto = Function.prototype;\r\n\r\n/** Used to resolve the decompiled source of functions. */\r\nvar funcToString = funcProto.toString;\r\n\r\n/**\r\n * Converts `func` to its source code.\r\n *\r\n * @private\r\n * @param {Function} func The function to convert.\r\n * @returns {string} Returns the source code.\r\n */\r\nfunction toSource(func) {\r\n  if (func != null) {\r\n    try {\r\n      return funcToString.call(func);\r\n    } catch (e) {}\r\n    try {\r\n      return (func + '');\r\n    } catch (e) {}\r\n  }\r\n  return '';\r\n}\r\n\r\nexport default toSource;\r\n", "import isFunction from './isFunction.js';\r\nimport isMasked from './_isMasked.js';\r\nimport isObject from './isObject.js';\r\nimport toSource from './_toSource.js';\r\n\r\n/**\r\n * Used to match `RegExp`\r\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\r\n */\r\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\r\n\r\n/** Used to detect host constructors (Safari). */\r\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\r\n\r\n/** Used for built-in method references. */\r\nvar funcProto = Function.prototype,\r\n    objectProto = Object.prototype;\r\n\r\n/** Used to resolve the decompiled source of functions. */\r\nvar funcToString = funcProto.toString;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/** Used to detect if a method is native. */\r\nvar reIsNative = RegExp('^' +\r\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\r\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\r\n);\r\n\r\n/**\r\n * The base implementation of `_.isNative` without bad shim checks.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a native function,\r\n *  else `false`.\r\n */\r\nfunction baseIsNative(value) {\r\n  if (!isObject(value) || isMasked(value)) {\r\n    return false;\r\n  }\r\n  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;\r\n  return pattern.test(toSource(value));\r\n}\r\n\r\nexport default baseIsNative;\r\n", "/**\r\n * Gets the value at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {string} key The key of the property to get.\r\n * @returns {*} Returns the property value.\r\n */\r\nfunction getValue(object, key) {\r\n  return object == null ? undefined : object[key];\r\n}\r\n\r\nexport default getValue;\r\n", "import baseIsNative from './_baseIsNative.js';\r\nimport getValue from './_getValue.js';\r\n\r\n/**\r\n * Gets the native function at `key` of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {string} key The key of the method to get.\r\n * @returns {*} Returns the function if it's native, else `undefined`.\r\n */\r\nfunction getNative(object, key) {\r\n  var value = getValue(object, key);\r\n  return baseIsNative(value) ? value : undefined;\r\n}\r\n\r\nexport default getNative;\r\n", "import getNative from './_getNative.js';\r\nimport root from './_root.js';\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar WeakMap = getNative(root, 'WeakMap');\r\n\r\nexport default WeakMap;\r\n", "import isObject from './isObject.js';\r\n\r\n/** Built-in value references. */\r\nvar objectCreate = Object.create;\r\n\r\n/**\r\n * The base implementation of `_.create` without support for assigning\r\n * properties to the created object.\r\n *\r\n * @private\r\n * @param {Object} proto The object to inherit from.\r\n * @returns {Object} Returns the new object.\r\n */\r\nvar baseCreate = (function() {\r\n  function object() {}\r\n  return function(proto) {\r\n    if (!isObject(proto)) {\r\n      return {};\r\n    }\r\n    if (objectCreate) {\r\n      return objectCreate(proto);\r\n    }\r\n    object.prototype = proto;\r\n    var result = new object;\r\n    object.prototype = undefined;\r\n    return result;\r\n  };\r\n}());\r\n\r\nexport default baseCreate;\r\n", "/**\r\n * A faster alternative to `Function#apply`, this function invokes `func`\r\n * with the `this` binding of `thisArg` and the arguments of `args`.\r\n *\r\n * @private\r\n * @param {Function} func The function to invoke.\r\n * @param {*} thisArg The `this` binding of `func`.\r\n * @param {Array} args The arguments to invoke `func` with.\r\n * @returns {*} Returns the result of `func`.\r\n */\r\nfunction apply(func, thisArg, args) {\r\n  switch (args.length) {\r\n    case 0: return func.call(thisArg);\r\n    case 1: return func.call(thisArg, args[0]);\r\n    case 2: return func.call(thisArg, args[0], args[1]);\r\n    case 3: return func.call(thisArg, args[0], args[1], args[2]);\r\n  }\r\n  return func.apply(thisArg, args);\r\n}\r\n\r\nexport default apply;\r\n", "/**\r\n * This method returns `undefined`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 2.3.0\r\n * @category Util\r\n * @example\r\n *\r\n * _.times(2, _.noop);\r\n * // => [undefined, undefined]\r\n */\r\nfunction noop() {\r\n  // No operation performed.\r\n}\r\n\r\nexport default noop;\r\n", "/**\r\n * Copies the values of `source` to `array`.\r\n *\r\n * @private\r\n * @param {Array} source The array to copy values from.\r\n * @param {Array} [array=[]] The array to copy values to.\r\n * @returns {Array} Returns `array`.\r\n */\r\nfunction copyArray(source, array) {\r\n  var index = -1,\r\n      length = source.length;\r\n\r\n  array || (array = Array(length));\r\n  while (++index < length) {\r\n    array[index] = source[index];\r\n  }\r\n  return array;\r\n}\r\n\r\nexport default copyArray;\r\n", "/** Used to detect hot functions by number of calls within a span of milliseconds. */\r\nvar HOT_COUNT = 800,\r\n    HOT_SPAN = 16;\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeNow = Date.now;\r\n\r\n/**\r\n * Creates a function that'll short out and invoke `identity` instead\r\n * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`\r\n * milliseconds.\r\n *\r\n * @private\r\n * @param {Function} func The function to restrict.\r\n * @returns {Function} Returns the new shortable function.\r\n */\r\nfunction shortOut(func) {\r\n  var count = 0,\r\n      lastCalled = 0;\r\n\r\n  return function() {\r\n    var stamp = nativeNow(),\r\n        remaining = HOT_SPAN - (stamp - lastCalled);\r\n\r\n    lastCalled = stamp;\r\n    if (remaining > 0) {\r\n      if (++count >= HOT_COUNT) {\r\n        return arguments[0];\r\n      }\r\n    } else {\r\n      count = 0;\r\n    }\r\n    return func.apply(undefined, arguments);\r\n  };\r\n}\r\n\r\nexport default shortOut;\r\n", "/**\r\n * Creates a function that returns `value`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 2.4.0\r\n * @category Util\r\n * @param {*} value The value to return from the new function.\r\n * @returns {Function} Returns the new constant function.\r\n * @example\r\n *\r\n * var objects = _.times(2, _.constant({ 'a': 1 }));\r\n *\r\n * console.log(objects);\r\n * // => [{ 'a': 1 }, { 'a': 1 }]\r\n *\r\n * console.log(objects[0] === objects[1]);\r\n * // => true\r\n */\r\nfunction constant(value) {\r\n  return function() {\r\n    return value;\r\n  };\r\n}\r\n\r\nexport default constant;\r\n", "import getNative from './_getNative.js';\r\n\r\nvar defineProperty = (function() {\r\n  try {\r\n    var func = getNative(Object, 'defineProperty');\r\n    func({}, '', {});\r\n    return func;\r\n  } catch (e) {}\r\n}());\r\n\r\nexport default defineProperty;\r\n", "import constant from './constant.js';\r\nimport defineProperty from './_defineProperty.js';\r\nimport identity from './identity.js';\r\n\r\n/**\r\n * The base implementation of `setToString` without support for hot loop shorting.\r\n *\r\n * @private\r\n * @param {Function} func The function to modify.\r\n * @param {Function} string The `toString` result.\r\n * @returns {Function} Returns `func`.\r\n */\r\nvar baseSetToString = !defineProperty ? identity : function(func, string) {\r\n  return defineProperty(func, 'toString', {\r\n    'configurable': true,\r\n    'enumerable': false,\r\n    'value': constant(string),\r\n    'writable': true\r\n  });\r\n};\r\n\r\nexport default baseSetToString;\r\n", "import baseSetToString from './_baseSetToString.js';\r\nimport shortOut from './_shortOut.js';\r\n\r\n/**\r\n * Sets the `toString` method of `func` to return `string`.\r\n *\r\n * @private\r\n * @param {Function} func The function to modify.\r\n * @param {Function} string The `toString` result.\r\n * @returns {Function} Returns `func`.\r\n */\r\nvar setToString = shortOut(baseSetToString);\r\n\r\nexport default setToString;\r\n", "/**\r\n * A specialized version of `_.forEach` for arrays without support for\r\n * iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns `array`.\r\n */\r\nfunction arrayEach(array, iteratee) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length;\r\n\r\n  while (++index < length) {\r\n    if (iteratee(array[index], index, array) === false) {\r\n      break;\r\n    }\r\n  }\r\n  return array;\r\n}\r\n\r\nexport default arrayEach;\r\n", "/**\r\n * The base implementation of `_.findIndex` and `_.findLastIndex` without\r\n * support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @param {number} fromIndex The index to search from.\r\n * @param {boolean} [fromRight] Specify iterating from right to left.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\nfunction baseFindIndex(array, predicate, fromIndex, fromRight) {\r\n  var length = array.length,\r\n      index = fromIndex + (fromRight ? 1 : -1);\r\n\r\n  while ((fromRight ? index-- : ++index < length)) {\r\n    if (predicate(array[index], index, array)) {\r\n      return index;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nexport default baseFindIndex;\r\n", "/**\r\n * The base implementation of `_.isNaN` without support for number objects.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.\r\n */\r\nfunction baseIsNaN(value) {\r\n  return value !== value;\r\n}\r\n\r\nexport default baseIsNaN;\r\n", "/**\r\n * A specialized version of `_.indexOf` which performs strict equality\r\n * comparisons of values, i.e. `===`.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {*} value The value to search for.\r\n * @param {number} fromIndex The index to search from.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\nfunction strictIndexOf(array, value, fromIndex) {\r\n  var index = fromIndex - 1,\r\n      length = array.length;\r\n\r\n  while (++index < length) {\r\n    if (array[index] === value) {\r\n      return index;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nexport default strictIndexOf;\r\n", "import baseFindIndex from './_baseFindIndex.js';\r\nimport baseIsNaN from './_baseIsNaN.js';\r\nimport strictIndexOf from './_strictIndexOf.js';\r\n\r\n/**\r\n * The base implementation of `_.indexOf` without `fromIndex` bounds checks.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {*} value The value to search for.\r\n * @param {number} fromIndex The index to search from.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\nfunction baseIndexOf(array, value, fromIndex) {\r\n  return value === value\r\n    ? strictIndexOf(array, value, fromIndex)\r\n    : baseFindIndex(array, baseIsNaN, fromIndex);\r\n}\r\n\r\nexport default baseIndexOf;\r\n", "import baseIndexOf from './_baseIndexOf.js';\r\n\r\n/**\r\n * A specialized version of `_.includes` for arrays without support for\r\n * specifying an index to search from.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to inspect.\r\n * @param {*} target The value to search for.\r\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\r\n */\r\nfunction arrayIncludes(array, value) {\r\n  var length = array == null ? 0 : array.length;\r\n  return !!length && baseIndexOf(array, value, 0) > -1;\r\n}\r\n\r\nexport default arrayIncludes;\r\n", "/** Used as references for various `Number` constants. */\r\nvar MAX_SAFE_INTEGER = 9007199254740991;\r\n\r\n/** Used to detect unsigned integer values. */\r\nvar reIsUint = /^(?:0|[1-9]\\d*)$/;\r\n\r\n/**\r\n * Checks if `value` is a valid array-like index.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.\r\n * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.\r\n */\r\nfunction isIndex(value, length) {\r\n  var type = typeof value;\r\n  length = length == null ? MAX_SAFE_INTEGER : length;\r\n\r\n  return !!length &&\r\n    (type == 'number' ||\r\n      (type != 'symbol' && reIsUint.test(value))) &&\r\n        (value > -1 && value % 1 == 0 && value < length);\r\n}\r\n\r\nexport default isIndex;\r\n", "import defineProperty from './_defineProperty.js';\r\n\r\n/**\r\n * The base implementation of `assignValue` and `assignMergeValue` without\r\n * value checks.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\nfunction baseAssignValue(object, key, value) {\r\n  if (key == '__proto__' && defineProperty) {\r\n    defineProperty(object, key, {\r\n      'configurable': true,\r\n      'enumerable': true,\r\n      'value': value,\r\n      'writable': true\r\n    });\r\n  } else {\r\n    object[key] = value;\r\n  }\r\n}\r\n\r\nexport default baseAssignValue;\r\n", "/**\r\n * Performs a\r\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * comparison between two values to determine if they are equivalent.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to compare.\r\n * @param {*} other The other value to compare.\r\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n * @example\r\n *\r\n * var object = { 'a': 1 };\r\n * var other = { 'a': 1 };\r\n *\r\n * _.eq(object, object);\r\n * // => true\r\n *\r\n * _.eq(object, other);\r\n * // => false\r\n *\r\n * _.eq('a', 'a');\r\n * // => true\r\n *\r\n * _.eq('a', Object('a'));\r\n * // => false\r\n *\r\n * _.eq(NaN, NaN);\r\n * // => true\r\n */\r\nfunction eq(value, other) {\r\n  return value === other || (value !== value && other !== other);\r\n}\r\n\r\nexport default eq;\r\n", "import baseAssignValue from './_baseAssignValue.js';\r\nimport eq from './eq.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Assigns `value` to `key` of `object` if the existing value is not equivalent\r\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * for equality comparisons.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {string} key The key of the property to assign.\r\n * @param {*} value The value to assign.\r\n */\r\nfunction assignValue(object, key, value) {\r\n  var objValue = object[key];\r\n  if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||\r\n      (value === undefined && !(key in object))) {\r\n    baseAssignValue(object, key, value);\r\n  }\r\n}\r\n\r\nexport default assignValue;\r\n", "import assignValue from './_assignValue.js';\r\nimport baseAssignValue from './_baseAssignValue.js';\r\n\r\n/**\r\n * Copies properties of `source` to `object`.\r\n *\r\n * @private\r\n * @param {Object} source The object to copy properties from.\r\n * @param {Array} props The property identifiers to copy.\r\n * @param {Object} [object={}] The object to copy properties to.\r\n * @param {Function} [customizer] The function to customize copied values.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction copyObject(source, props, object, customizer) {\r\n  var isNew = !object;\r\n  object || (object = {});\r\n\r\n  var index = -1,\r\n      length = props.length;\r\n\r\n  while (++index < length) {\r\n    var key = props[index];\r\n\r\n    var newValue = customizer\r\n      ? customizer(object[key], source[key], key, object, source)\r\n      : undefined;\r\n\r\n    if (newValue === undefined) {\r\n      newValue = source[key];\r\n    }\r\n    if (isNew) {\r\n      baseAssignValue(object, key, newValue);\r\n    } else {\r\n      assignValue(object, key, newValue);\r\n    }\r\n  }\r\n  return object;\r\n}\r\n\r\nexport default copyObject;\r\n", "import apply from './_apply.js';\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeMax = Math.max;\r\n\r\n/**\r\n * A specialized version of `baseRest` which transforms the rest array.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n * @param {Function} transform The rest array transform.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction overRest(func, start, transform) {\r\n  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);\r\n  return function() {\r\n    var args = arguments,\r\n        index = -1,\r\n        length = nativeMax(args.length - start, 0),\r\n        array = Array(length);\r\n\r\n    while (++index < length) {\r\n      array[index] = args[start + index];\r\n    }\r\n    index = -1;\r\n    var otherArgs = Array(start + 1);\r\n    while (++index < start) {\r\n      otherArgs[index] = args[index];\r\n    }\r\n    otherArgs[start] = transform(array);\r\n    return apply(func, this, otherArgs);\r\n  };\r\n}\r\n\r\nexport default overRest;\r\n", "import identity from './identity.js';\r\nimport overRest from './_overRest.js';\r\nimport setToString from './_setToString.js';\r\n\r\n/**\r\n * The base implementation of `_.rest` which doesn't validate or coerce arguments.\r\n *\r\n * @private\r\n * @param {Function} func The function to apply a rest parameter to.\r\n * @param {number} [start=func.length-1] The start position of the rest parameter.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction baseRest(func, start) {\r\n  return setToString(overRest(func, start, identity), func + '');\r\n}\r\n\r\nexport default baseRest;\r\n", "/** Used as references for various `Number` constants. */\r\nvar MAX_SAFE_INTEGER = 9007199254740991;\r\n\r\n/**\r\n * Checks if `value` is a valid array-like length.\r\n *\r\n * **Note:** This method is loosely based on\r\n * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.\r\n * @example\r\n *\r\n * _.isLength(3);\r\n * // => true\r\n *\r\n * _.isLength(Number.MIN_VALUE);\r\n * // => false\r\n *\r\n * _.isLength(Infinity);\r\n * // => false\r\n *\r\n * _.isLength('3');\r\n * // => false\r\n */\r\nfunction isLength(value) {\r\n  return typeof value == 'number' &&\r\n    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;\r\n}\r\n\r\nexport default isLength;\r\n", "import isFunction from './isFunction.js';\r\nimport isLength from './isLength.js';\r\n\r\n/**\r\n * Checks if `value` is array-like. A value is considered array-like if it's\r\n * not a function and has a `value.length` that's an integer greater than or\r\n * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is array-like, else `false`.\r\n * @example\r\n *\r\n * _.isArrayLike([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArrayLike(document.body.children);\r\n * // => true\r\n *\r\n * _.isArrayLike('abc');\r\n * // => true\r\n *\r\n * _.isArrayLike(_.noop);\r\n * // => false\r\n */\r\nfunction isArrayLike(value) {\r\n  return value != null && isLength(value.length) && !isFunction(value);\r\n}\r\n\r\nexport default isArrayLike;\r\n", "import eq from './eq.js';\r\nimport isArrayLike from './isArrayLike.js';\r\nimport isIndex from './_isIndex.js';\r\nimport isObject from './isObject.js';\r\n\r\n/**\r\n * Checks if the given arguments are from an iteratee call.\r\n *\r\n * @private\r\n * @param {*} value The potential iteratee value argument.\r\n * @param {*} index The potential iteratee index or key argument.\r\n * @param {*} object The potential iteratee object argument.\r\n * @returns {boolean} Returns `true` if the arguments are from an iteratee call,\r\n *  else `false`.\r\n */\r\nfunction isIterateeCall(value, index, object) {\r\n  if (!isObject(object)) {\r\n    return false;\r\n  }\r\n  var type = typeof index;\r\n  if (type == 'number'\r\n        ? (isArrayLike(object) && isIndex(index, object.length))\r\n        : (type == 'string' && index in object)\r\n      ) {\r\n    return eq(object[index], value);\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default isIterateeCall;\r\n", "import baseRest from './_baseRest.js';\r\nimport isIterateeCall from './_isIterateeCall.js';\r\n\r\n/**\r\n * Creates a function like `_.assign`.\r\n *\r\n * @private\r\n * @param {Function} assigner The function to assign values.\r\n * @returns {Function} Returns the new assigner function.\r\n */\r\nfunction createAssigner(assigner) {\r\n  return baseRest(function(object, sources) {\r\n    var index = -1,\r\n        length = sources.length,\r\n        customizer = length > 1 ? sources[length - 1] : undefined,\r\n        guard = length > 2 ? sources[2] : undefined;\r\n\r\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\r\n      ? (length--, customizer)\r\n      : undefined;\r\n\r\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n      customizer = length < 3 ? undefined : customizer;\r\n      length = 1;\r\n    }\r\n    object = Object(object);\r\n    while (++index < length) {\r\n      var source = sources[index];\r\n      if (source) {\r\n        assigner(object, source, index, customizer);\r\n      }\r\n    }\r\n    return object;\r\n  });\r\n}\r\n\r\nexport default createAssigner;\r\n", "/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/**\r\n * Checks if `value` is likely a prototype object.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.\r\n */\r\nfunction isPrototype(value) {\r\n  var Ctor = value && value.constructor,\r\n      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;\r\n\r\n  return value === proto;\r\n}\r\n\r\nexport default isPrototype;\r\n", "/**\r\n * The base implementation of `_.times` without support for iteratee shorthands\r\n * or max array length checks.\r\n *\r\n * @private\r\n * @param {number} n The number of times to invoke `iteratee`.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns the array of results.\r\n */\r\nfunction baseTimes(n, iteratee) {\r\n  var index = -1,\r\n      result = Array(n);\r\n\r\n  while (++index < n) {\r\n    result[index] = iteratee(index);\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseTimes;\r\n", "import baseGetTag from './_baseGetTag.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar argsTag = '[object Arguments]';\r\n\r\n/**\r\n * The base implementation of `_.isArguments`.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n */\r\nfunction baseIsArguments(value) {\r\n  return isObjectLike(value) && baseGetTag(value) == argsTag;\r\n}\r\n\r\nexport default baseIsArguments;\r\n", "import baseIsArguments from './_baseIsArguments.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/** Built-in value references. */\r\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\r\n\r\n/**\r\n * Checks if `value` is likely an `arguments` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an `arguments` object,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.isArguments(function() { return arguments; }());\r\n * // => true\r\n *\r\n * _.isArguments([1, 2, 3]);\r\n * // => false\r\n */\r\nvar isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {\r\n  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&\r\n    !propertyIsEnumerable.call(value, 'callee');\r\n};\r\n\r\nexport default isArguments;\r\n", "/**\r\n * This method returns `false`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.13.0\r\n * @category Util\r\n * @returns {boolean} Returns `false`.\r\n * @example\r\n *\r\n * _.times(2, _.stubFalse);\r\n * // => [false, false]\r\n */\r\nfunction stubFalse() {\r\n  return false;\r\n}\r\n\r\nexport default stubFalse;\r\n", "import root from './_root.js';\r\nimport stubFalse from './stubFalse.js';\r\n\r\n/** Detect free variable `exports`. */\r\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\r\n\r\n/** Detect free variable `module`. */\r\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\r\n\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n\r\n/** Built-in value references. */\r\nvar Buffer = moduleExports ? root.Buffer : undefined;\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;\r\n\r\n/**\r\n * Checks if `value` is a buffer.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.3.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.\r\n * @example\r\n *\r\n * _.isBuffer(new Buffer(2));\r\n * // => true\r\n *\r\n * _.isBuffer(new Uint8Array(2));\r\n * // => false\r\n */\r\nvar isBuffer = nativeIsBuffer || stubFalse;\r\n\r\nexport default isBuffer;\r\n", "import baseGetTag from './_baseGetTag.js';\r\nimport isLength from './isLength.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar argsTag = '[object Arguments]',\r\n    arrayTag = '[object Array]',\r\n    boolTag = '[object Boolean]',\r\n    dateTag = '[object Date]',\r\n    errorTag = '[object Error]',\r\n    funcTag = '[object Function]',\r\n    mapTag = '[object Map]',\r\n    numberTag = '[object Number]',\r\n    objectTag = '[object Object]',\r\n    regexpTag = '[object RegExp]',\r\n    setTag = '[object Set]',\r\n    stringTag = '[object String]',\r\n    weakMapTag = '[object WeakMap]';\r\n\r\nvar arrayBufferTag = '[object ArrayBuffer]',\r\n    dataViewTag = '[object DataView]',\r\n    float32Tag = '[object Float32Array]',\r\n    float64Tag = '[object Float64Array]',\r\n    int8Tag = '[object Int8Array]',\r\n    int16Tag = '[object Int16Array]',\r\n    int32Tag = '[object Int32Array]',\r\n    uint8Tag = '[object Uint8Array]',\r\n    uint8ClampedTag = '[object Uint8ClampedArray]',\r\n    uint16Tag = '[object Uint16Array]',\r\n    uint32Tag = '[object Uint32Array]';\r\n\r\n/** Used to identify `toStringTag` values of typed arrays. */\r\nvar typedArrayTags = {};\r\ntypedArrayTags[float32Tag] = typedArrayTags[float64Tag] =\r\ntypedArrayTags[int8Tag] = typedArrayTags[int16Tag] =\r\ntypedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =\r\ntypedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =\r\ntypedArrayTags[uint32Tag] = true;\r\ntypedArrayTags[argsTag] = typedArrayTags[arrayTag] =\r\ntypedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =\r\ntypedArrayTags[dataViewTag] = typedArrayTags[dateTag] =\r\ntypedArrayTags[errorTag] = typedArrayTags[funcTag] =\r\ntypedArrayTags[mapTag] = typedArrayTags[numberTag] =\r\ntypedArrayTags[objectTag] = typedArrayTags[regexpTag] =\r\ntypedArrayTags[setTag] = typedArrayTags[stringTag] =\r\ntypedArrayTags[weakMapTag] = false;\r\n\r\n/**\r\n * The base implementation of `_.isTypedArray` without Node.js optimizations.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n */\r\nfunction baseIsTypedArray(value) {\r\n  return isObjectLike(value) &&\r\n    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];\r\n}\r\n\r\nexport default baseIsTypedArray;\r\n", "/**\r\n * The base implementation of `_.unary` without support for storing metadata.\r\n *\r\n * @private\r\n * @param {Function} func The function to cap arguments for.\r\n * @returns {Function} Returns the new capped function.\r\n */\r\nfunction baseUnary(func) {\r\n  return function(value) {\r\n    return func(value);\r\n  };\r\n}\r\n\r\nexport default baseUnary;\r\n", "import freeGlobal from './_freeGlobal.js';\r\n\r\n/** Detect free variable `exports`. */\r\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\r\n\r\n/** Detect free variable `module`. */\r\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\r\n\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n\r\n/** Detect free variable `process` from Node.js. */\r\nvar freeProcess = moduleExports && freeGlobal.process;\r\n\r\n/** Used to access faster Node.js helpers. */\r\nvar nodeUtil = (function() {\r\n  try {\r\n    // Use `util.types` for Node.js 10+.\r\n    var types = freeModule && freeModule.require && freeModule.require('util').types;\r\n\r\n    if (types) {\r\n      return types;\r\n    }\r\n\r\n    // Legacy `process.binding('util')` for Node.js < 10.\r\n    return freeProcess && freeProcess.binding && freeProcess.binding('util');\r\n  } catch (e) {}\r\n}());\r\n\r\nexport default nodeUtil;\r\n", "import baseIsTypedArray from './_baseIsTypedArray.js';\r\nimport baseUnary from './_baseUnary.js';\r\nimport nodeUtil from './_nodeUtil.js';\r\n\r\n/* Node.js helper references. */\r\nvar nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;\r\n\r\n/**\r\n * Checks if `value` is classified as a typed array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.\r\n * @example\r\n *\r\n * _.isTypedArray(new Uint8Array);\r\n * // => true\r\n *\r\n * _.isTypedArray([]);\r\n * // => false\r\n */\r\nvar isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;\r\n\r\nexport default isTypedArray;\r\n", "import baseTimes from './_baseTimes.js';\r\nimport isArguments from './isArguments.js';\r\nimport isArray from './isArray.js';\r\nimport isBuffer from './isBuffer.js';\r\nimport isIndex from './_isIndex.js';\r\nimport isTypedArray from './isTypedArray.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Creates an array of the enumerable property names of the array-like `value`.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @param {boolean} inherited Specify returning inherited property names.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction arrayLikeKeys(value, inherited) {\r\n  var isArr = isArray(value),\r\n      isArg = !isArr && isArguments(value),\r\n      isBuff = !isArr && !isArg && isBuffer(value),\r\n      isType = !isArr && !isArg && !isBuff && isTypedArray(value),\r\n      skipIndexes = isArr || isArg || isBuff || isType,\r\n      result = skipIndexes ? baseTimes(value.length, String) : [],\r\n      length = result.length;\r\n\r\n  for (var key in value) {\r\n    if ((inherited || hasOwnProperty.call(value, key)) &&\r\n        !(skipIndexes && (\r\n           // Safari 9 has enumerable `arguments.length` in strict mode.\r\n           key == 'length' ||\r\n           // Node.js 0.10 has enumerable non-index properties on buffers.\r\n           (isBuff && (key == 'offset' || key == 'parent')) ||\r\n           // PhantomJS 2 has enumerable non-index properties on typed arrays.\r\n           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||\r\n           // Skip index properties.\r\n           isIndex(key, length)\r\n        ))) {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default arrayLikeKeys;\r\n", "/**\r\n * Creates a unary function that invokes `func` with its argument transformed.\r\n *\r\n * @private\r\n * @param {Function} func The function to wrap.\r\n * @param {Function} transform The argument transform.\r\n * @returns {Function} Returns the new function.\r\n */\r\nfunction overArg(func, transform) {\r\n  return function(arg) {\r\n    return func(transform(arg));\r\n  };\r\n}\r\n\r\nexport default overArg;\r\n", "import overArg from './_overArg.js';\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeKeys = overArg(Object.keys, Object);\r\n\r\nexport default nativeKeys;\r\n", "import isPrototype from './_isPrototype.js';\r\nimport nativeKeys from './_nativeKeys.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction baseKeys(object) {\r\n  if (!isPrototype(object)) {\r\n    return nativeKeys(object);\r\n  }\r\n  var result = [];\r\n  for (var key in Object(object)) {\r\n    if (hasOwnProperty.call(object, key) && key != 'constructor') {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseKeys;\r\n", "import arrayLikeKeys from './_arrayLikeKeys.js';\r\nimport baseKeys from './_baseKeys.js';\r\nimport isArrayLike from './isArrayLike.js';\r\n\r\n/**\r\n * Creates an array of the own enumerable property names of `object`.\r\n *\r\n * **Note:** Non-object values are coerced to objects. See the\r\n * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\r\n * for more details.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.keys(new Foo);\r\n * // => ['a', 'b'] (iteration order is not guaranteed)\r\n *\r\n * _.keys('hi');\r\n * // => ['0', '1']\r\n */\r\nfunction keys(object) {\r\n  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);\r\n}\r\n\r\nexport default keys;\r\n", "import assignValue from './_assignValue.js';\r\nimport copyObject from './_copyObject.js';\r\nimport createAssigner from './_createAssigner.js';\r\nimport isArrayLike from './isArrayLike.js';\r\nimport isPrototype from './_isPrototype.js';\r\nimport keys from './keys.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Assigns own enumerable string keyed properties of source objects to the\r\n * destination object. Source objects are applied from left to right.\r\n * Subsequent sources overwrite property assignments of previous sources.\r\n *\r\n * **Note:** This method mutates `object` and is loosely based on\r\n * [`Object.assign`](https://mdn.io/Object/assign).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.10.0\r\n * @category Object\r\n * @param {Object} object The destination object.\r\n * @param {...Object} [sources] The source objects.\r\n * @returns {Object} Returns `object`.\r\n * @see _.assignIn\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n * }\r\n *\r\n * function Bar() {\r\n *   this.c = 3;\r\n * }\r\n *\r\n * Foo.prototype.b = 2;\r\n * Bar.prototype.d = 4;\r\n *\r\n * _.assign({ 'a': 0 }, new Foo, new Bar);\r\n * // => { 'a': 1, 'c': 3 }\r\n */\r\nvar assign = createAssigner(function(object, source) {\r\n  if (isPrototype(source) || isArrayLike(source)) {\r\n    copyObject(source, keys(source), object);\r\n    return;\r\n  }\r\n  for (var key in source) {\r\n    if (hasOwnProperty.call(source, key)) {\r\n      assignValue(object, key, source[key]);\r\n    }\r\n  }\r\n});\r\n\r\nexport default assign;\r\n", "/**\r\n * This function is like\r\n * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)\r\n * except that it includes inherited enumerable properties.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction nativeKeysIn(object) {\r\n  var result = [];\r\n  if (object != null) {\r\n    for (var key in Object(object)) {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default nativeKeysIn;\r\n", "import isObject from './isObject.js';\r\nimport isPrototype from './_isPrototype.js';\r\nimport nativeKeysIn from './_nativeKeysIn.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n */\r\nfunction baseKeysIn(object) {\r\n  if (!isObject(object)) {\r\n    return nativeKeysIn(object);\r\n  }\r\n  var isProto = isPrototype(object),\r\n      result = [];\r\n\r\n  for (var key in object) {\r\n    if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {\r\n      result.push(key);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseKeysIn;\r\n", "import arrayLikeKeys from './_arrayLikeKeys.js';\r\nimport baseKeysIn from './_baseKeysIn.js';\r\nimport isArrayLike from './isArrayLike.js';\r\n\r\n/**\r\n * Creates an array of the own and inherited enumerable property names of `object`.\r\n *\r\n * **Note:** Non-object values are coerced to objects.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.keysIn(new Foo);\r\n * // => ['a', 'b', 'c'] (iteration order is not guaranteed)\r\n */\r\nfunction keysIn(object) {\r\n  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);\r\n}\r\n\r\nexport default keysIn;\r\n", "import isArray from './isArray.js';\r\nimport isSymbol from './isSymbol.js';\r\n\r\n/** Used to match property names within property paths. */\r\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\r\n    reIsPlainProp = /^\\w*$/;\r\n\r\n/**\r\n * Checks if `value` is a property name and not a property path.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @param {Object} [object] The object to query keys on.\r\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\r\n */\r\nfunction isKey(value, object) {\r\n  if (isArray(value)) {\r\n    return false;\r\n  }\r\n  var type = typeof value;\r\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\r\n      value == null || isSymbol(value)) {\r\n    return true;\r\n  }\r\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\r\n    (object != null && value in Object(object));\r\n}\r\n\r\nexport default isKey;\r\n", "import getNative from './_getNative.js';\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar nativeCreate = getNative(Object, 'create');\r\n\r\nexport default nativeCreate;\r\n", "import nativeCreate from './_nativeCreate.js';\r\n\r\n/**\r\n * Removes all key-value entries from the hash.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Hash\r\n */\r\nfunction hashClear() {\r\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\r\n  this.size = 0;\r\n}\r\n\r\nexport default hashClear;\r\n", "/**\r\n * Removes `key` and its value from the hash.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Hash\r\n * @param {Object} hash The hash to modify.\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction hashDelete(key) {\r\n  var result = this.has(key) && delete this.__data__[key];\r\n  this.size -= result ? 1 : 0;\r\n  return result;\r\n}\r\n\r\nexport default hashDelete;\r\n", "import nativeCreate from './_nativeCreate.js';\r\n\r\n/** Used to stand-in for `undefined` hash values. */\r\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Gets the hash value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction hashGet(key) {\r\n  var data = this.__data__;\r\n  if (nativeCreate) {\r\n    var result = data[key];\r\n    return result === HASH_UNDEFINED ? undefined : result;\r\n  }\r\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\r\n}\r\n\r\nexport default hashGet;\r\n", "import nativeCreate from './_nativeCreate.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Checks if a hash value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Hash\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction hashHas(key) {\r\n  var data = this.__data__;\r\n  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);\r\n}\r\n\r\nexport default hashHas;\r\n", "import nativeCreate from './_nativeCreate.js';\r\n\r\n/** Used to stand-in for `undefined` hash values. */\r\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n\r\n/**\r\n * Sets the hash `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Hash\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the hash instance.\r\n */\r\nfunction hashSet(key, value) {\r\n  var data = this.__data__;\r\n  this.size += this.has(key) ? 0 : 1;\r\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\r\n  return this;\r\n}\r\n\r\nexport default hashSet;\r\n", "import hashClear from './_hashClear.js';\r\nimport hashDelete from './_hashDelete.js';\r\nimport hashGet from './_hashGet.js';\r\nimport hashHas from './_hashHas.js';\r\nimport hashSet from './_hashSet.js';\r\n\r\n/**\r\n * Creates a hash object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction Hash(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n// Add methods to `Hash`.\r\nHash.prototype.clear = hashClear;\r\nHash.prototype['delete'] = hashDelete;\r\nHash.prototype.get = hashGet;\r\nHash.prototype.has = hashHas;\r\nHash.prototype.set = hashSet;\r\n\r\nexport default Hash;\r\n", "/**\r\n * Removes all key-value entries from the list cache.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf ListCache\r\n */\r\nfunction listCacheClear() {\r\n  this.__data__ = [];\r\n  this.size = 0;\r\n}\r\n\r\nexport default listCacheClear;\r\n", "import eq from './eq.js';\r\n\r\n/**\r\n * Gets the index at which the `key` is found in `array` of key-value pairs.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {*} key The key to search for.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n */\r\nfunction assocIndexOf(array, key) {\r\n  var length = array.length;\r\n  while (length--) {\r\n    if (eq(array[length][0], key)) {\r\n      return length;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nexport default assocIndexOf;\r\n", "import assocIndexOf from './_assocIndexOf.js';\r\n\r\n/** Used for built-in method references. */\r\nvar arrayProto = Array.prototype;\r\n\r\n/** Built-in value references. */\r\nvar splice = arrayProto.splice;\r\n\r\n/**\r\n * Removes `key` and its value from the list cache.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction listCacheDelete(key) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    return false;\r\n  }\r\n  var lastIndex = data.length - 1;\r\n  if (index == lastIndex) {\r\n    data.pop();\r\n  } else {\r\n    splice.call(data, index, 1);\r\n  }\r\n  --this.size;\r\n  return true;\r\n}\r\n\r\nexport default listCacheDelete;\r\n", "import assocIndexOf from './_assocIndexOf.js';\r\n\r\n/**\r\n * Gets the list cache value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction listCacheGet(key) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  return index < 0 ? undefined : data[index][1];\r\n}\r\n\r\nexport default listCacheGet;\r\n", "import assocIndexOf from './_assocIndexOf.js';\r\n\r\n/**\r\n * Checks if a list cache value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf ListCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction listCacheHas(key) {\r\n  return assocIndexOf(this.__data__, key) > -1;\r\n}\r\n\r\nexport default listCacheHas;\r\n", "import assocIndexOf from './_assocIndexOf.js';\r\n\r\n/**\r\n * Sets the list cache `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf ListCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the list cache instance.\r\n */\r\nfunction listCacheSet(key, value) {\r\n  var data = this.__data__,\r\n      index = assocIndexOf(data, key);\r\n\r\n  if (index < 0) {\r\n    ++this.size;\r\n    data.push([key, value]);\r\n  } else {\r\n    data[index][1] = value;\r\n  }\r\n  return this;\r\n}\r\n\r\nexport default listCacheSet;\r\n", "import listCacheClear from './_listCacheClear.js';\r\nimport listCacheDelete from './_listCacheDelete.js';\r\nimport listCacheGet from './_listCacheGet.js';\r\nimport listCacheHas from './_listCacheHas.js';\r\nimport listCacheSet from './_listCacheSet.js';\r\n\r\n/**\r\n * Creates an list cache object.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction ListCache(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n// Add methods to `ListCache`.\r\nListCache.prototype.clear = listCacheClear;\r\nListCache.prototype['delete'] = listCacheDelete;\r\nListCache.prototype.get = listCacheGet;\r\nListCache.prototype.has = listCacheHas;\r\nListCache.prototype.set = listCacheSet;\r\n\r\nexport default ListCache;\r\n", "import getNative from './_getNative.js';\r\nimport root from './_root.js';\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar Map = getNative(root, 'Map');\r\n\r\nexport default Map;\r\n", "import Hash from './_Hash.js';\r\nimport ListCache from './_ListCache.js';\r\nimport Map from './_Map.js';\r\n\r\n/**\r\n * Removes all key-value entries from the map.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf MapCache\r\n */\r\nfunction mapCacheClear() {\r\n  this.size = 0;\r\n  this.__data__ = {\r\n    'hash': new Hash,\r\n    'map': new (Map || ListCache),\r\n    'string': new Hash\r\n  };\r\n}\r\n\r\nexport default mapCacheClear;\r\n", "/**\r\n * Checks if `value` is suitable for use as unique object key.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\r\n */\r\nfunction isKeyable(value) {\r\n  var type = typeof value;\r\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\r\n    ? (value !== '__proto__')\r\n    : (value === null);\r\n}\r\n\r\nexport default isKeyable;\r\n", "import isKeyable from './_isKeyable.js';\r\n\r\n/**\r\n * Gets the data for `map`.\r\n *\r\n * @private\r\n * @param {Object} map The map to query.\r\n * @param {string} key The reference key.\r\n * @returns {*} Returns the map data.\r\n */\r\nfunction getMapData(map, key) {\r\n  var data = map.__data__;\r\n  return isKeyable(key)\r\n    ? data[typeof key == 'string' ? 'string' : 'hash']\r\n    : data.map;\r\n}\r\n\r\nexport default getMapData;\r\n", "import getMapData from './_getMapData.js';\r\n\r\n/**\r\n * Removes `key` and its value from the map.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction mapCacheDelete(key) {\r\n  var result = getMapData(this, key)['delete'](key);\r\n  this.size -= result ? 1 : 0;\r\n  return result;\r\n}\r\n\r\nexport default mapCacheDelete;\r\n", "import getMapData from './_getMapData.js';\r\n\r\n/**\r\n * Gets the map value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction mapCacheGet(key) {\r\n  return getMapData(this, key).get(key);\r\n}\r\n\r\nexport default mapCacheGet;\r\n", "import getMapData from './_getMapData.js';\r\n\r\n/**\r\n * Checks if a map value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf MapCache\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction mapCacheHas(key) {\r\n  return getMapData(this, key).has(key);\r\n}\r\n\r\nexport default mapCacheHas;\r\n", "import getMapData from './_getMapData.js';\r\n\r\n/**\r\n * Sets the map `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf MapCache\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the map cache instance.\r\n */\r\nfunction mapCacheSet(key, value) {\r\n  var data = getMapData(this, key),\r\n      size = data.size;\r\n\r\n  data.set(key, value);\r\n  this.size += data.size == size ? 0 : 1;\r\n  return this;\r\n}\r\n\r\nexport default mapCacheSet;\r\n", "import mapCacheClear from './_mapCacheClear.js';\r\nimport mapCacheDelete from './_mapCacheDelete.js';\r\nimport mapCacheGet from './_mapCacheGet.js';\r\nimport mapCacheHas from './_mapCacheHas.js';\r\nimport mapCacheSet from './_mapCacheSet.js';\r\n\r\n/**\r\n * Creates a map cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction MapCache(entries) {\r\n  var index = -1,\r\n      length = entries == null ? 0 : entries.length;\r\n\r\n  this.clear();\r\n  while (++index < length) {\r\n    var entry = entries[index];\r\n    this.set(entry[0], entry[1]);\r\n  }\r\n}\r\n\r\n// Add methods to `MapCache`.\r\nMapCache.prototype.clear = mapCacheClear;\r\nMapCache.prototype['delete'] = mapCacheDelete;\r\nMapCache.prototype.get = mapCacheGet;\r\nMapCache.prototype.has = mapCacheHas;\r\nMapCache.prototype.set = mapCacheSet;\r\n\r\nexport default MapCache;\r\n", "import MapCache from './_MapCache.js';\r\n\r\n/** Error message constants. */\r\nvar FUNC_ERROR_TEXT = 'Expected a function';\r\n\r\n/**\r\n * Creates a function that memoizes the result of `func`. If `resolver` is\r\n * provided, it determines the cache key for storing the result based on the\r\n * arguments provided to the memoized function. By default, the first argument\r\n * provided to the memoized function is used as the map cache key. The `func`\r\n * is invoked with the `this` binding of the memoized function.\r\n *\r\n * **Note:** The cache is exposed as the `cache` property on the memoized\r\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\r\n * constructor with one whose instances implement the\r\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\r\n * method interface of `clear`, `delete`, `get`, `has`, and `set`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Function\r\n * @param {Function} func The function to have its output memoized.\r\n * @param {Function} [resolver] The function to resolve the cache key.\r\n * @returns {Function} Returns the new memoized function.\r\n * @example\r\n *\r\n * var object = { 'a': 1, 'b': 2 };\r\n * var other = { 'c': 3, 'd': 4 };\r\n *\r\n * var values = _.memoize(_.values);\r\n * values(object);\r\n * // => [1, 2]\r\n *\r\n * values(other);\r\n * // => [3, 4]\r\n *\r\n * object.a = 2;\r\n * values(object);\r\n * // => [1, 2]\r\n *\r\n * // Modify the result cache.\r\n * values.cache.set(object, ['a', 'b']);\r\n * values(object);\r\n * // => ['a', 'b']\r\n *\r\n * // Replace `_.memoize.Cache`.\r\n * _.memoize.Cache = WeakMap;\r\n */\r\nfunction memoize(func, resolver) {\r\n  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  var memoized = function() {\r\n    var args = arguments,\r\n        key = resolver ? resolver.apply(this, args) : args[0],\r\n        cache = memoized.cache;\r\n\r\n    if (cache.has(key)) {\r\n      return cache.get(key);\r\n    }\r\n    var result = func.apply(this, args);\r\n    memoized.cache = cache.set(key, result) || cache;\r\n    return result;\r\n  };\r\n  memoized.cache = new (memoize.Cache || MapCache);\r\n  return memoized;\r\n}\r\n\r\n// Expose `MapCache`.\r\nmemoize.Cache = MapCache;\r\n\r\nexport default memoize;\r\n", "import memoize from './memoize.js';\r\n\r\n/** Used as the maximum memoize cache size. */\r\nvar MAX_MEMOIZE_SIZE = 500;\r\n\r\n/**\r\n * A specialized version of `_.memoize` which clears the memoized function's\r\n * cache when it exceeds `MAX_MEMOIZE_SIZE`.\r\n *\r\n * @private\r\n * @param {Function} func The function to have its output memoized.\r\n * @returns {Function} Returns the new memoized function.\r\n */\r\nfunction memoizeCapped(func) {\r\n  var result = memoize(func, function(key) {\r\n    if (cache.size === MAX_MEMOIZE_SIZE) {\r\n      cache.clear();\r\n    }\r\n    return key;\r\n  });\r\n\r\n  var cache = result.cache;\r\n  return result;\r\n}\r\n\r\nexport default memoizeCapped;\r\n", "import memoizeCapped from './_memoizeCapped.js';\r\n\r\n/** Used to match property names within property paths. */\r\nvar rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\r\n\r\n/** Used to match backslashes in property paths. */\r\nvar reEscapeChar = /\\\\(\\\\)?/g;\r\n\r\n/**\r\n * Converts `string` to a property path array.\r\n *\r\n * @private\r\n * @param {string} string The string to convert.\r\n * @returns {Array} Returns the property path array.\r\n */\r\nvar stringToPath = memoizeCapped(function(string) {\r\n  var result = [];\r\n  if (string.charCodeAt(0) === 46 /* . */) {\r\n    result.push('');\r\n  }\r\n  string.replace(rePropName, function(match, number, quote, subString) {\r\n    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));\r\n  });\r\n  return result;\r\n});\r\n\r\nexport default stringToPath;\r\n", "import baseToString from './_baseToString.js';\r\n\r\n/**\r\n * Converts `value` to a string. An empty string is returned for `null`\r\n * and `undefined` values. The sign of `-0` is preserved.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to convert.\r\n * @returns {string} Returns the converted string.\r\n * @example\r\n *\r\n * _.toString(null);\r\n * // => ''\r\n *\r\n * _.toString(-0);\r\n * // => '-0'\r\n *\r\n * _.toString([1, 2, 3]);\r\n * // => '1,2,3'\r\n */\r\nfunction toString(value) {\r\n  return value == null ? '' : baseToString(value);\r\n}\r\n\r\nexport default toString;\r\n", "import isArray from './isArray.js';\r\nimport isKey from './_isKey.js';\r\nimport stringToPath from './_stringToPath.js';\r\nimport toString from './toString.js';\r\n\r\n/**\r\n * Casts `value` to a path array if it's not one.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @param {Object} [object] The object to query keys on.\r\n * @returns {Array} Returns the cast property path array.\r\n */\r\nfunction castPath(value, object) {\r\n  if (isArray(value)) {\r\n    return value;\r\n  }\r\n  return isKey(value, object) ? [value] : stringToPath(toString(value));\r\n}\r\n\r\nexport default castPath;\r\n", "import isSymbol from './isSymbol.js';\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0;\r\n\r\n/**\r\n * Converts `value` to a string key if it's not a string or symbol.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {string|symbol} Returns the key.\r\n */\r\nfunction toKey(value) {\r\n  if (typeof value == 'string' || isSymbol(value)) {\r\n    return value;\r\n  }\r\n  var result = (value + '');\r\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\r\n}\r\n\r\nexport default toKey;\r\n", "import castPath from './_castPath.js';\r\nimport toKey from './_toKey.js';\r\n\r\n/**\r\n * The base implementation of `_.get` without support for default values.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path of the property to get.\r\n * @returns {*} Returns the resolved value.\r\n */\r\nfunction baseGet(object, path) {\r\n  path = castPath(path, object);\r\n\r\n  var index = 0,\r\n      length = path.length;\r\n\r\n  while (object != null && index < length) {\r\n    object = object[toKey(path[index++])];\r\n  }\r\n  return (index && index == length) ? object : undefined;\r\n}\r\n\r\nexport default baseGet;\r\n", "import baseGet from './_baseGet.js';\r\n\r\n/**\r\n * Gets the value at `path` of `object`. If the resolved value is\r\n * `undefined`, the `defaultValue` is returned in its place.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.7.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path of the property to get.\r\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\r\n * @returns {*} Returns the resolved value.\r\n * @example\r\n *\r\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\r\n *\r\n * _.get(object, 'a[0].b.c');\r\n * // => 3\r\n *\r\n * _.get(object, ['a', '0', 'b', 'c']);\r\n * // => 3\r\n *\r\n * _.get(object, 'a.b.c', 'default');\r\n * // => 'default'\r\n */\r\nfunction get(object, path, defaultValue) {\r\n  var result = object == null ? undefined : baseGet(object, path);\r\n  return result === undefined ? defaultValue : result;\r\n}\r\n\r\nexport default get;\r\n", "/**\r\n * Appends the elements of `values` to `array`.\r\n *\r\n * @private\r\n * @param {Array} array The array to modify.\r\n * @param {Array} values The values to append.\r\n * @returns {Array} Returns `array`.\r\n */\r\nfunction arrayPush(array, values) {\r\n  var index = -1,\r\n      length = values.length,\r\n      offset = array.length;\r\n\r\n  while (++index < length) {\r\n    array[offset + index] = values[index];\r\n  }\r\n  return array;\r\n}\r\n\r\nexport default arrayPush;\r\n", "import Symbol from './_Symbol.js';\r\nimport isArguments from './isArguments.js';\r\nimport isArray from './isArray.js';\r\n\r\n/** Built-in value references. */\r\nvar spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;\r\n\r\n/**\r\n * Checks if `value` is a flattenable `arguments` object or array.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.\r\n */\r\nfunction isFlattenable(value) {\r\n  return isArray(value) || isArguments(value) ||\r\n    !!(spreadableSymbol && value && value[spreadableSymbol]);\r\n}\r\n\r\nexport default isFlattenable;\r\n", "import arrayPush from './_arrayPush.js';\r\nimport isFlattenable from './_isFlattenable.js';\r\n\r\n/**\r\n * The base implementation of `_.flatten` with support for restricting flattening.\r\n *\r\n * @private\r\n * @param {Array} array The array to flatten.\r\n * @param {number} depth The maximum recursion depth.\r\n * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.\r\n * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.\r\n * @param {Array} [result=[]] The initial result value.\r\n * @returns {Array} Returns the new flattened array.\r\n */\r\nfunction baseFlatten(array, depth, predicate, isStrict, result) {\r\n  var index = -1,\r\n      length = array.length;\r\n\r\n  predicate || (predicate = isFlattenable);\r\n  result || (result = []);\r\n\r\n  while (++index < length) {\r\n    var value = array[index];\r\n    if (depth > 0 && predicate(value)) {\r\n      if (depth > 1) {\r\n        // Recursively flatten arrays (susceptible to call stack limits).\r\n        baseFlatten(value, depth - 1, predicate, isStrict, result);\r\n      } else {\r\n        arrayPush(result, value);\r\n      }\r\n    } else if (!isStrict) {\r\n      result[result.length] = value;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseFlatten;\r\n", "import baseFlatten from './_baseFlatten.js';\r\n\r\n/**\r\n * Flattens `array` a single level deep.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to flatten.\r\n * @returns {Array} Returns the new flattened array.\r\n * @example\r\n *\r\n * _.flatten([1, [2, [3, [4]], 5]]);\r\n * // => [1, 2, [3, [4]], 5]\r\n */\r\nfunction flatten(array) {\r\n  var length = array == null ? 0 : array.length;\r\n  return length ? baseFlatten(array, 1) : [];\r\n}\r\n\r\nexport default flatten;\r\n", "import overArg from './_overArg.js';\r\n\r\n/** Built-in value references. */\r\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\r\n\r\nexport default getPrototype;\r\n", "/**\r\n * The base implementation of `_.slice` without an iteratee call guard.\r\n *\r\n * @private\r\n * @param {Array} array The array to slice.\r\n * @param {number} [start=0] The start position.\r\n * @param {number} [end=array.length] The end position.\r\n * @returns {Array} Returns the slice of `array`.\r\n */\r\nfunction baseSlice(array, start, end) {\r\n  var index = -1,\r\n      length = array.length;\r\n\r\n  if (start < 0) {\r\n    start = -start > length ? 0 : (length + start);\r\n  }\r\n  end = end > length ? length : end;\r\n  if (end < 0) {\r\n    end += length;\r\n  }\r\n  length = start > end ? 0 : ((end - start) >>> 0);\r\n  start >>>= 0;\r\n\r\n  var result = Array(length);\r\n  while (++index < length) {\r\n    result[index] = array[index + start];\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseSlice;\r\n", "/**\r\n * A specialized version of `_.reduce` for arrays without support for\r\n * iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @param {*} [accumulator] The initial value.\r\n * @param {boolean} [initAccum] Specify using the first element of `array` as\r\n *  the initial value.\r\n * @returns {*} Returns the accumulated value.\r\n */\r\nfunction arrayReduce(array, iteratee, accumulator, initAccum) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length;\r\n\r\n  if (initAccum && length) {\r\n    accumulator = array[++index];\r\n  }\r\n  while (++index < length) {\r\n    accumulator = iteratee(accumulator, array[index], index, array);\r\n  }\r\n  return accumulator;\r\n}\r\n\r\nexport default arrayReduce;\r\n", "import ListCache from './_ListCache.js';\r\n\r\n/**\r\n * Removes all key-value entries from the stack.\r\n *\r\n * @private\r\n * @name clear\r\n * @memberOf Stack\r\n */\r\nfunction stackClear() {\r\n  this.__data__ = new ListCache;\r\n  this.size = 0;\r\n}\r\n\r\nexport default stackClear;\r\n", "/**\r\n * Removes `key` and its value from the stack.\r\n *\r\n * @private\r\n * @name delete\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to remove.\r\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\r\n */\r\nfunction stackDelete(key) {\r\n  var data = this.__data__,\r\n      result = data['delete'](key);\r\n\r\n  this.size = data.size;\r\n  return result;\r\n}\r\n\r\nexport default stackDelete;\r\n", "/**\r\n * Gets the stack value for `key`.\r\n *\r\n * @private\r\n * @name get\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to get.\r\n * @returns {*} Returns the entry value.\r\n */\r\nfunction stackGet(key) {\r\n  return this.__data__.get(key);\r\n}\r\n\r\nexport default stackGet;\r\n", "/**\r\n * Checks if a stack value for `key` exists.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf Stack\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction stackHas(key) {\r\n  return this.__data__.has(key);\r\n}\r\n\r\nexport default stackHas;\r\n", "import ListCache from './_ListCache.js';\r\nimport Map from './_Map.js';\r\nimport MapCache from './_MapCache.js';\r\n\r\n/** Used as the size to enable large array optimizations. */\r\nvar LARGE_ARRAY_SIZE = 200;\r\n\r\n/**\r\n * Sets the stack `key` to `value`.\r\n *\r\n * @private\r\n * @name set\r\n * @memberOf Stack\r\n * @param {string} key The key of the value to set.\r\n * @param {*} value The value to set.\r\n * @returns {Object} Returns the stack cache instance.\r\n */\r\nfunction stackSet(key, value) {\r\n  var data = this.__data__;\r\n  if (data instanceof ListCache) {\r\n    var pairs = data.__data__;\r\n    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {\r\n      pairs.push([key, value]);\r\n      this.size = ++data.size;\r\n      return this;\r\n    }\r\n    data = this.__data__ = new MapCache(pairs);\r\n  }\r\n  data.set(key, value);\r\n  this.size = data.size;\r\n  return this;\r\n}\r\n\r\nexport default stackSet;\r\n", "import ListCache from './_ListCache.js';\r\nimport stackClear from './_stackClear.js';\r\nimport stackDelete from './_stackDelete.js';\r\nimport stackGet from './_stackGet.js';\r\nimport stackHas from './_stackHas.js';\r\nimport stackSet from './_stackSet.js';\r\n\r\n/**\r\n * Creates a stack cache object to store key-value pairs.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [entries] The key-value pairs to cache.\r\n */\r\nfunction Stack(entries) {\r\n  var data = this.__data__ = new ListCache(entries);\r\n  this.size = data.size;\r\n}\r\n\r\n// Add methods to `Stack`.\r\nStack.prototype.clear = stackClear;\r\nStack.prototype['delete'] = stackDelete;\r\nStack.prototype.get = stackGet;\r\nStack.prototype.has = stackHas;\r\nStack.prototype.set = stackSet;\r\n\r\nexport default Stack;\r\n", "import copyObject from './_copyObject.js';\r\nimport keys from './keys.js';\r\n\r\n/**\r\n * The base implementation of `_.assign` without support for multiple sources\r\n * or `customizer` functions.\r\n *\r\n * @private\r\n * @param {Object} object The destination object.\r\n * @param {Object} source The source object.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction baseAssign(object, source) {\r\n  return object && copyObject(source, keys(source), object);\r\n}\r\n\r\nexport default baseAssign;\r\n", "import copyObject from './_copyObject.js';\r\nimport keysIn from './keysIn.js';\r\n\r\n/**\r\n * The base implementation of `_.assignIn` without support for multiple sources\r\n * or `customizer` functions.\r\n *\r\n * @private\r\n * @param {Object} object The destination object.\r\n * @param {Object} source The source object.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction baseAssignIn(object, source) {\r\n  return object && copyObject(source, keysIn(source), object);\r\n}\r\n\r\nexport default baseAssignIn;\r\n", "import root from './_root.js';\r\n\r\n/** Detect free variable `exports`. */\r\nvar freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;\r\n\r\n/** Detect free variable `module`. */\r\nvar freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;\r\n\r\n/** Detect the popular CommonJS extension `module.exports`. */\r\nvar moduleExports = freeModule && freeModule.exports === freeExports;\r\n\r\n/** Built-in value references. */\r\nvar Buffer = moduleExports ? root.Buffer : undefined,\r\n    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;\r\n\r\n/**\r\n * Creates a clone of  `buffer`.\r\n *\r\n * @private\r\n * @param {Buffer} buffer The buffer to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Buffer} Returns the cloned buffer.\r\n */\r\nfunction cloneBuffer(buffer, isDeep) {\r\n  if (isDeep) {\r\n    return buffer.slice();\r\n  }\r\n  var length = buffer.length,\r\n      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);\r\n\r\n  buffer.copy(result);\r\n  return result;\r\n}\r\n\r\nexport default cloneBuffer;\r\n", "/**\r\n * A specialized version of `_.filter` for arrays without support for\r\n * iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @returns {Array} Returns the new filtered array.\r\n */\r\nfunction arrayFilter(array, predicate) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length,\r\n      resIndex = 0,\r\n      result = [];\r\n\r\n  while (++index < length) {\r\n    var value = array[index];\r\n    if (predicate(value, index, array)) {\r\n      result[resIndex++] = value;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default arrayFilter;\r\n", "/**\r\n * This method returns a new empty array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.13.0\r\n * @category Util\r\n * @returns {Array} Returns the new empty array.\r\n * @example\r\n *\r\n * var arrays = _.times(2, _.stubArray);\r\n *\r\n * console.log(arrays);\r\n * // => [[], []]\r\n *\r\n * console.log(arrays[0] === arrays[1]);\r\n * // => false\r\n */\r\nfunction stubArray() {\r\n  return [];\r\n}\r\n\r\nexport default stubArray;\r\n", "import arrayFilter from './_arrayFilter.js';\r\nimport stubArray from './stubArray.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Built-in value references. */\r\nvar propertyIsEnumerable = objectProto.propertyIsEnumerable;\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\r\n\r\n/**\r\n * Creates an array of the own enumerable symbols of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of symbols.\r\n */\r\nvar getSymbols = !nativeGetSymbols ? stubArray : function(object) {\r\n  if (object == null) {\r\n    return [];\r\n  }\r\n  object = Object(object);\r\n  return arrayFilter(nativeGetSymbols(object), function(symbol) {\r\n    return propertyIsEnumerable.call(object, symbol);\r\n  });\r\n};\r\n\r\nexport default getSymbols;\r\n", "import copyObject from './_copyObject.js';\r\nimport getSymbols from './_getSymbols.js';\r\n\r\n/**\r\n * Copies own symbols of `source` to `object`.\r\n *\r\n * @private\r\n * @param {Object} source The object to copy symbols from.\r\n * @param {Object} [object={}] The object to copy symbols to.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction copySymbols(source, object) {\r\n  return copyObject(source, getSymbols(source), object);\r\n}\r\n\r\nexport default copySymbols;\r\n", "import arrayPush from './_arrayPush.js';\r\nimport getPrototype from './_getPrototype.js';\r\nimport getSymbols from './_getSymbols.js';\r\nimport stubArray from './stubArray.js';\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeGetSymbols = Object.getOwnPropertySymbols;\r\n\r\n/**\r\n * Creates an array of the own and inherited enumerable symbols of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of symbols.\r\n */\r\nvar getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {\r\n  var result = [];\r\n  while (object) {\r\n    arrayPush(result, getSymbols(object));\r\n    object = getPrototype(object);\r\n  }\r\n  return result;\r\n};\r\n\r\nexport default getSymbolsIn;\r\n", "import copyObject from './_copyObject.js';\r\nimport getSymbolsIn from './_getSymbolsIn.js';\r\n\r\n/**\r\n * Copies own and inherited symbols of `source` to `object`.\r\n *\r\n * @private\r\n * @param {Object} source The object to copy symbols from.\r\n * @param {Object} [object={}] The object to copy symbols to.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction copySymbolsIn(source, object) {\r\n  return copyObject(source, getSymbolsIn(source), object);\r\n}\r\n\r\nexport default copySymbolsIn;\r\n", "import arrayPush from './_arrayPush.js';\r\nimport isArray from './isArray.js';\r\n\r\n/**\r\n * The base implementation of `getAllKeys` and `getAllKeysIn` which uses\r\n * `keysFunc` and `symbolsFunc` to get the enumerable property names and\r\n * symbols of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Function} keysFunc The function to get the keys of `object`.\r\n * @param {Function} symbolsFunc The function to get the symbols of `object`.\r\n * @returns {Array} Returns the array of property names and symbols.\r\n */\r\nfunction baseGetAllKeys(object, keysFunc, symbolsFunc) {\r\n  var result = keysFunc(object);\r\n  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));\r\n}\r\n\r\nexport default baseGetAllKeys;\r\n", "import baseGetAllKeys from './_baseGetAllKeys.js';\r\nimport getSymbols from './_getSymbols.js';\r\nimport keys from './keys.js';\r\n\r\n/**\r\n * Creates an array of own enumerable property names and symbols of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names and symbols.\r\n */\r\nfunction getAllKeys(object) {\r\n  return baseGetAllKeys(object, keys, getSymbols);\r\n}\r\n\r\nexport default getAllKeys;\r\n", "import baseGetAllKeys from './_baseGetAllKeys.js';\r\nimport getSymbolsIn from './_getSymbolsIn.js';\r\nimport keysIn from './keysIn.js';\r\n\r\n/**\r\n * Creates an array of own and inherited enumerable property names and\r\n * symbols of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property names and symbols.\r\n */\r\nfunction getAllKeysIn(object) {\r\n  return baseGetAllKeys(object, keysIn, getSymbolsIn);\r\n}\r\n\r\nexport default getAllKeysIn;\r\n", "import getNative from './_getNative.js';\r\nimport root from './_root.js';\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar DataView = getNative(root, 'DataView');\r\n\r\nexport default DataView;\r\n", "import getNative from './_getNative.js';\r\nimport root from './_root.js';\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar Promise = getNative(root, 'Promise');\r\n\r\nexport default Promise;\r\n", "import getNative from './_getNative.js';\r\nimport root from './_root.js';\r\n\r\n/* Built-in method references that are verified to be native. */\r\nvar Set = getNative(root, 'Set');\r\n\r\nexport default Set;\r\n", "import DataView from './_DataView.js';\r\nimport Map from './_Map.js';\r\nimport Promise from './_Promise.js';\r\nimport Set from './_Set.js';\r\nimport WeakMap from './_WeakMap.js';\r\nimport baseGetTag from './_baseGetTag.js';\r\nimport toSource from './_toSource.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar mapTag = '[object Map]',\r\n    objectTag = '[object Object]',\r\n    promiseTag = '[object Promise]',\r\n    setTag = '[object Set]',\r\n    weakMapTag = '[object WeakMap]';\r\n\r\nvar dataViewTag = '[object DataView]';\r\n\r\n/** Used to detect maps, sets, and weakmaps. */\r\nvar dataViewCtorString = toSource(DataView),\r\n    mapCtorString = toSource(Map),\r\n    promiseCtorString = toSource(Promise),\r\n    setCtorString = toSource(Set),\r\n    weakMapCtorString = toSource(WeakMap);\r\n\r\n/**\r\n * Gets the `toStringTag` of `value`.\r\n *\r\n * @private\r\n * @param {*} value The value to query.\r\n * @returns {string} Returns the `toStringTag`.\r\n */\r\nvar getTag = baseGetTag;\r\n\r\n// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.\r\nif ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||\r\n    (Map && getTag(new Map) != mapTag) ||\r\n    (Promise && getTag(Promise.resolve()) != promiseTag) ||\r\n    (Set && getTag(new Set) != setTag) ||\r\n    (WeakMap && getTag(new WeakMap) != weakMapTag)) {\r\n  getTag = function(value) {\r\n    var result = baseGetTag(value),\r\n        Ctor = result == objectTag ? value.constructor : undefined,\r\n        ctorString = Ctor ? toSource(Ctor) : '';\r\n\r\n    if (ctorString) {\r\n      switch (ctorString) {\r\n        case dataViewCtorString: return dataViewTag;\r\n        case mapCtorString: return mapTag;\r\n        case promiseCtorString: return promiseTag;\r\n        case setCtorString: return setTag;\r\n        case weakMapCtorString: return weakMapTag;\r\n      }\r\n    }\r\n    return result;\r\n  };\r\n}\r\n\r\nexport default getTag;\r\n", "/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Initializes an array clone.\r\n *\r\n * @private\r\n * @param {Array} array The array to clone.\r\n * @returns {Array} Returns the initialized clone.\r\n */\r\nfunction initCloneArray(array) {\r\n  var length = array.length,\r\n      result = new array.constructor(length);\r\n\r\n  // Add properties assigned by `RegExp#exec`.\r\n  if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {\r\n    result.index = array.index;\r\n    result.input = array.input;\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default initCloneArray;\r\n", "import root from './_root.js';\r\n\r\n/** Built-in value references. */\r\nvar Uint8Array = root.Uint8Array;\r\n\r\nexport default Uint8Array;\r\n", "import Uint8Array from './_Uint8Array.js';\r\n\r\n/**\r\n * Creates a clone of `arrayBuffer`.\r\n *\r\n * @private\r\n * @param {ArrayBuffer} arrayBuffer The array buffer to clone.\r\n * @returns {ArrayBuffer} Returns the cloned array buffer.\r\n */\r\nfunction cloneArrayBuffer(arrayBuffer) {\r\n  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);\r\n  new Uint8Array(result).set(new Uint8Array(arrayBuffer));\r\n  return result;\r\n}\r\n\r\nexport default cloneArrayBuffer;\r\n", "import cloneArrayBuffer from './_cloneArrayBuffer.js';\r\n\r\n/**\r\n * Creates a clone of `dataView`.\r\n *\r\n * @private\r\n * @param {Object} dataView The data view to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Object} Returns the cloned data view.\r\n */\r\nfunction cloneDataView(dataView, isDeep) {\r\n  var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;\r\n  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);\r\n}\r\n\r\nexport default cloneDataView;\r\n", "/** Used to match `RegExp` flags from their coerced string values. */\r\nvar reFlags = /\\w*$/;\r\n\r\n/**\r\n * Creates a clone of `regexp`.\r\n *\r\n * @private\r\n * @param {Object} regexp The regexp to clone.\r\n * @returns {Object} Returns the cloned regexp.\r\n */\r\nfunction cloneRegExp(regexp) {\r\n  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));\r\n  result.lastIndex = regexp.lastIndex;\r\n  return result;\r\n}\r\n\r\nexport default cloneRegExp;\r\n", "import Symbol from './_Symbol.js';\r\n\r\n/** Used to convert symbols to primitives and strings. */\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\r\n\r\n/**\r\n * Creates a clone of the `symbol` object.\r\n *\r\n * @private\r\n * @param {Object} symbol The symbol object to clone.\r\n * @returns {Object} Returns the cloned symbol object.\r\n */\r\nfunction cloneSymbol(symbol) {\r\n  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};\r\n}\r\n\r\nexport default cloneSymbol;\r\n", "import cloneArrayBuffer from './_cloneArrayBuffer.js';\r\n\r\n/**\r\n * Creates a clone of `typedArray`.\r\n *\r\n * @private\r\n * @param {Object} typedArray The typed array to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Object} Returns the cloned typed array.\r\n */\r\nfunction cloneTypedArray(typedArray, isDeep) {\r\n  var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;\r\n  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);\r\n}\r\n\r\nexport default cloneTypedArray;\r\n", "import cloneArrayBuffer from './_cloneArrayBuffer.js';\r\nimport cloneDataView from './_cloneDataView.js';\r\nimport cloneRegExp from './_cloneRegExp.js';\r\nimport cloneSymbol from './_cloneSymbol.js';\r\nimport cloneTypedArray from './_cloneTypedArray.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar boolTag = '[object Boolean]',\r\n    dateTag = '[object Date]',\r\n    mapTag = '[object Map]',\r\n    numberTag = '[object Number]',\r\n    regexpTag = '[object RegExp]',\r\n    setTag = '[object Set]',\r\n    stringTag = '[object String]',\r\n    symbolTag = '[object Symbol]';\r\n\r\nvar arrayBufferTag = '[object ArrayBuffer]',\r\n    dataViewTag = '[object DataView]',\r\n    float32Tag = '[object Float32Array]',\r\n    float64Tag = '[object Float64Array]',\r\n    int8Tag = '[object Int8Array]',\r\n    int16Tag = '[object Int16Array]',\r\n    int32Tag = '[object Int32Array]',\r\n    uint8Tag = '[object Uint8Array]',\r\n    uint8ClampedTag = '[object Uint8ClampedArray]',\r\n    uint16Tag = '[object Uint16Array]',\r\n    uint32Tag = '[object Uint32Array]';\r\n\r\n/**\r\n * Initializes an object clone based on its `toStringTag`.\r\n *\r\n * **Note:** This function only supports cloning values with tags of\r\n * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.\r\n *\r\n * @private\r\n * @param {Object} object The object to clone.\r\n * @param {string} tag The `toStringTag` of the object to clone.\r\n * @param {boolean} [isDeep] Specify a deep clone.\r\n * @returns {Object} Returns the initialized clone.\r\n */\r\nfunction initCloneByTag(object, tag, isDeep) {\r\n  var Ctor = object.constructor;\r\n  switch (tag) {\r\n    case arrayBufferTag:\r\n      return cloneArrayBuffer(object);\r\n\r\n    case boolTag:\r\n    case dateTag:\r\n      return new Ctor(+object);\r\n\r\n    case dataViewTag:\r\n      return cloneDataView(object, isDeep);\r\n\r\n    case float32Tag: case float64Tag:\r\n    case int8Tag: case int16Tag: case int32Tag:\r\n    case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:\r\n      return cloneTypedArray(object, isDeep);\r\n\r\n    case mapTag:\r\n      return new Ctor;\r\n\r\n    case numberTag:\r\n    case stringTag:\r\n      return new Ctor(object);\r\n\r\n    case regexpTag:\r\n      return cloneRegExp(object);\r\n\r\n    case setTag:\r\n      return new Ctor;\r\n\r\n    case symbolTag:\r\n      return cloneSymbol(object);\r\n  }\r\n}\r\n\r\nexport default initCloneByTag;\r\n", "import baseCreate from './_baseCreate.js';\r\nimport getPrototype from './_getPrototype.js';\r\nimport isPrototype from './_isPrototype.js';\r\n\r\n/**\r\n * Initializes an object clone.\r\n *\r\n * @private\r\n * @param {Object} object The object to clone.\r\n * @returns {Object} Returns the initialized clone.\r\n */\r\nfunction initCloneObject(object) {\r\n  return (typeof object.constructor == 'function' && !isPrototype(object))\r\n    ? baseCreate(getPrototype(object))\r\n    : {};\r\n}\r\n\r\nexport default initCloneObject;\r\n", "import getTag from './_getTag.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar mapTag = '[object Map]';\r\n\r\n/**\r\n * The base implementation of `_.isMap` without Node.js optimizations.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\r\n */\r\nfunction baseIsMap(value) {\r\n  return isObjectLike(value) && getTag(value) == mapTag;\r\n}\r\n\r\nexport default baseIsMap;\r\n", "import baseIsMap from './_baseIsMap.js';\r\nimport baseUnary from './_baseUnary.js';\r\nimport nodeUtil from './_nodeUtil.js';\r\n\r\n/* Node.js helper references. */\r\nvar nodeIsMap = nodeUtil && nodeUtil.isMap;\r\n\r\n/**\r\n * Checks if `value` is classified as a `Map` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.3.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a map, else `false`.\r\n * @example\r\n *\r\n * _.isMap(new Map);\r\n * // => true\r\n *\r\n * _.isMap(new WeakMap);\r\n * // => false\r\n */\r\nvar isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;\r\n\r\nexport default isMap;\r\n", "import getTag from './_getTag.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar setTag = '[object Set]';\r\n\r\n/**\r\n * The base implementation of `_.isSet` without Node.js optimizations.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\r\n */\r\nfunction baseIsSet(value) {\r\n  return isObjectLike(value) && getTag(value) == setTag;\r\n}\r\n\r\nexport default baseIsSet;\r\n", "import baseIsSet from './_baseIsSet.js';\r\nimport baseUnary from './_baseUnary.js';\r\nimport nodeUtil from './_nodeUtil.js';\r\n\r\n/* Node.js helper references. */\r\nvar nodeIsSet = nodeUtil && nodeUtil.isSet;\r\n\r\n/**\r\n * Checks if `value` is classified as a `Set` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.3.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a set, else `false`.\r\n * @example\r\n *\r\n * _.isSet(new Set);\r\n * // => true\r\n *\r\n * _.isSet(new WeakSet);\r\n * // => false\r\n */\r\nvar isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;\r\n\r\nexport default isSet;\r\n", "import Stack from './_Stack.js';\r\nimport arrayEach from './_arrayEach.js';\r\nimport assignValue from './_assignValue.js';\r\nimport baseAssign from './_baseAssign.js';\r\nimport baseAssignIn from './_baseAssignIn.js';\r\nimport cloneBuffer from './_cloneBuffer.js';\r\nimport copyArray from './_copyArray.js';\r\nimport copySymbols from './_copySymbols.js';\r\nimport copySymbolsIn from './_copySymbolsIn.js';\r\nimport getAllKeys from './_getAllKeys.js';\r\nimport getAllKeysIn from './_getAllKeysIn.js';\r\nimport getTag from './_getTag.js';\r\nimport initCloneArray from './_initCloneArray.js';\r\nimport initCloneByTag from './_initCloneByTag.js';\r\nimport initCloneObject from './_initCloneObject.js';\r\nimport isArray from './isArray.js';\r\nimport isBuffer from './isBuffer.js';\r\nimport isMap from './isMap.js';\r\nimport isObject from './isObject.js';\r\nimport isSet from './isSet.js';\r\nimport keys from './keys.js';\r\nimport keysIn from './keysIn.js';\r\n\r\n/** Used to compose bitmasks for cloning. */\r\nvar CLONE_DEEP_FLAG = 1,\r\n    CLONE_FLAT_FLAG = 2,\r\n    CLONE_SYMBOLS_FLAG = 4;\r\n\r\n/** `Object#toString` result references. */\r\nvar argsTag = '[object Arguments]',\r\n    arrayTag = '[object Array]',\r\n    boolTag = '[object Boolean]',\r\n    dateTag = '[object Date]',\r\n    errorTag = '[object Error]',\r\n    funcTag = '[object Function]',\r\n    genTag = '[object GeneratorFunction]',\r\n    mapTag = '[object Map]',\r\n    numberTag = '[object Number]',\r\n    objectTag = '[object Object]',\r\n    regexpTag = '[object RegExp]',\r\n    setTag = '[object Set]',\r\n    stringTag = '[object String]',\r\n    symbolTag = '[object Symbol]',\r\n    weakMapTag = '[object WeakMap]';\r\n\r\nvar arrayBufferTag = '[object ArrayBuffer]',\r\n    dataViewTag = '[object DataView]',\r\n    float32Tag = '[object Float32Array]',\r\n    float64Tag = '[object Float64Array]',\r\n    int8Tag = '[object Int8Array]',\r\n    int16Tag = '[object Int16Array]',\r\n    int32Tag = '[object Int32Array]',\r\n    uint8Tag = '[object Uint8Array]',\r\n    uint8ClampedTag = '[object Uint8ClampedArray]',\r\n    uint16Tag = '[object Uint16Array]',\r\n    uint32Tag = '[object Uint32Array]';\r\n\r\n/** Used to identify `toStringTag` values supported by `_.clone`. */\r\nvar cloneableTags = {};\r\ncloneableTags[argsTag] = cloneableTags[arrayTag] =\r\ncloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =\r\ncloneableTags[boolTag] = cloneableTags[dateTag] =\r\ncloneableTags[float32Tag] = cloneableTags[float64Tag] =\r\ncloneableTags[int8Tag] = cloneableTags[int16Tag] =\r\ncloneableTags[int32Tag] = cloneableTags[mapTag] =\r\ncloneableTags[numberTag] = cloneableTags[objectTag] =\r\ncloneableTags[regexpTag] = cloneableTags[setTag] =\r\ncloneableTags[stringTag] = cloneableTags[symbolTag] =\r\ncloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =\r\ncloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;\r\ncloneableTags[errorTag] = cloneableTags[funcTag] =\r\ncloneableTags[weakMapTag] = false;\r\n\r\n/**\r\n * The base implementation of `_.clone` and `_.cloneDeep` which tracks\r\n * traversed objects.\r\n *\r\n * @private\r\n * @param {*} value The value to clone.\r\n * @param {boolean} bitmask The bitmask flags.\r\n *  1 - Deep clone\r\n *  2 - Flatten inherited properties\r\n *  4 - Clone symbols\r\n * @param {Function} [customizer] The function to customize cloning.\r\n * @param {string} [key] The key of `value`.\r\n * @param {Object} [object] The parent object of `value`.\r\n * @param {Object} [stack] Tracks traversed objects and their clone counterparts.\r\n * @returns {*} Returns the cloned value.\r\n */\r\nfunction baseClone(value, bitmask, customizer, key, object, stack) {\r\n  var result,\r\n      isDeep = bitmask & CLONE_DEEP_FLAG,\r\n      isFlat = bitmask & CLONE_FLAT_FLAG,\r\n      isFull = bitmask & CLONE_SYMBOLS_FLAG;\r\n\r\n  if (customizer) {\r\n    result = object ? customizer(value, key, object, stack) : customizer(value);\r\n  }\r\n  if (result !== undefined) {\r\n    return result;\r\n  }\r\n  if (!isObject(value)) {\r\n    return value;\r\n  }\r\n  var isArr = isArray(value);\r\n  if (isArr) {\r\n    result = initCloneArray(value);\r\n    if (!isDeep) {\r\n      return copyArray(value, result);\r\n    }\r\n  } else {\r\n    var tag = getTag(value),\r\n        isFunc = tag == funcTag || tag == genTag;\r\n\r\n    if (isBuffer(value)) {\r\n      return cloneBuffer(value, isDeep);\r\n    }\r\n    if (tag == objectTag || tag == argsTag || (isFunc && !object)) {\r\n      result = (isFlat || isFunc) ? {} : initCloneObject(value);\r\n      if (!isDeep) {\r\n        return isFlat\r\n          ? copySymbolsIn(value, baseAssignIn(result, value))\r\n          : copySymbols(value, baseAssign(result, value));\r\n      }\r\n    } else {\r\n      if (!cloneableTags[tag]) {\r\n        return object ? value : {};\r\n      }\r\n      result = initCloneByTag(value, tag, isDeep);\r\n    }\r\n  }\r\n  // Check for circular references and return its corresponding clone.\r\n  stack || (stack = new Stack);\r\n  var stacked = stack.get(value);\r\n  if (stacked) {\r\n    return stacked;\r\n  }\r\n  stack.set(value, result);\r\n\r\n  if (isSet(value)) {\r\n    value.forEach(function(subValue) {\r\n      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));\r\n    });\r\n  } else if (isMap(value)) {\r\n    value.forEach(function(subValue, key) {\r\n      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));\r\n    });\r\n  }\r\n\r\n  var keysFunc = isFull\r\n    ? (isFlat ? getAllKeysIn : getAllKeys)\r\n    : (isFlat ? keysIn : keys);\r\n\r\n  var props = isArr ? undefined : keysFunc(value);\r\n  arrayEach(props || value, function(subValue, key) {\r\n    if (props) {\r\n      key = subValue;\r\n      subValue = value[key];\r\n    }\r\n    // Recursively populate clone (susceptible to call stack limits).\r\n    assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));\r\n  });\r\n  return result;\r\n}\r\n\r\nexport default baseClone;\r\n", "import baseClone from './_baseClone.js';\r\n\r\n/** Used to compose bitmasks for cloning. */\r\nvar CLONE_SYMBOLS_FLAG = 4;\r\n\r\n/**\r\n * Creates a shallow clone of `value`.\r\n *\r\n * **Note:** This method is loosely based on the\r\n * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)\r\n * and supports cloning arrays, array buffers, booleans, date objects, maps,\r\n * numbers, `Object` objects, regexes, sets, strings, symbols, and typed\r\n * arrays. The own enumerable properties of `arguments` objects are cloned\r\n * as plain objects. An empty object is returned for uncloneable values such\r\n * as error objects, functions, DOM nodes, and WeakMaps.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to clone.\r\n * @returns {*} Returns the cloned value.\r\n * @see _.cloneDeep\r\n * @example\r\n *\r\n * var objects = [{ 'a': 1 }, { 'b': 2 }];\r\n *\r\n * var shallow = _.clone(objects);\r\n * console.log(shallow[0] === objects[0]);\r\n * // => true\r\n */\r\nfunction clone(value) {\r\n  return baseClone(value, CLONE_SYMBOLS_FLAG);\r\n}\r\n\r\nexport default clone;\r\n", "/**\r\n * Creates an array with all falsey values removed. The values `false`, `null`,\r\n * `0`, `\"\"`, `undefined`, and `NaN` are falsey.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to compact.\r\n * @returns {Array} Returns the new array of filtered values.\r\n * @example\r\n *\r\n * _.compact([0, 1, false, 2, '', 3]);\r\n * // => [1, 2, 3]\r\n */\r\nfunction compact(array) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length,\r\n      resIndex = 0,\r\n      result = [];\r\n\r\n  while (++index < length) {\r\n    var value = array[index];\r\n    if (value) {\r\n      result[resIndex++] = value;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default compact;\r\n", "/** Used to stand-in for `undefined` hash values. */\r\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\r\n\r\n/**\r\n * Adds `value` to the array cache.\r\n *\r\n * @private\r\n * @name add\r\n * @memberOf SetCache\r\n * @alias push\r\n * @param {*} value The value to cache.\r\n * @returns {Object} Returns the cache instance.\r\n */\r\nfunction setCacheAdd(value) {\r\n  this.__data__.set(value, HASH_UNDEFINED);\r\n  return this;\r\n}\r\n\r\nexport default setCacheAdd;\r\n", "/**\r\n * Checks if `value` is in the array cache.\r\n *\r\n * @private\r\n * @name has\r\n * @memberOf SetCache\r\n * @param {*} value The value to search for.\r\n * @returns {number} Returns `true` if `value` is found, else `false`.\r\n */\r\nfunction setCacheHas(value) {\r\n  return this.__data__.has(value);\r\n}\r\n\r\nexport default setCacheHas;\r\n", "import MapCache from './_MapCache.js';\r\nimport setCacheAdd from './_setCacheAdd.js';\r\nimport setCacheHas from './_setCacheHas.js';\r\n\r\n/**\r\n *\r\n * Creates an array cache object to store unique values.\r\n *\r\n * @private\r\n * @constructor\r\n * @param {Array} [values] The values to cache.\r\n */\r\nfunction SetCache(values) {\r\n  var index = -1,\r\n      length = values == null ? 0 : values.length;\r\n\r\n  this.__data__ = new MapCache;\r\n  while (++index < length) {\r\n    this.add(values[index]);\r\n  }\r\n}\r\n\r\n// Add methods to `SetCache`.\r\nSetCache.prototype.add = SetCache.prototype.push = setCacheAdd;\r\nSetCache.prototype.has = setCacheHas;\r\n\r\nexport default SetCache;\r\n", "/**\r\n * A specialized version of `_.some` for arrays without support for iteratee\r\n * shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n *  else `false`.\r\n */\r\nfunction arraySome(array, predicate) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length;\r\n\r\n  while (++index < length) {\r\n    if (predicate(array[index], index, array)) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default arraySome;\r\n", "/**\r\n * Checks if a `cache` value for `key` exists.\r\n *\r\n * @private\r\n * @param {Object} cache The cache to query.\r\n * @param {string} key The key of the entry to check.\r\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\r\n */\r\nfunction cacheHas(cache, key) {\r\n  return cache.has(key);\r\n}\r\n\r\nexport default cacheHas;\r\n", "import SetCache from './_SetCache.js';\r\nimport arraySome from './_arraySome.js';\r\nimport cacheHas from './_cacheHas.js';\r\n\r\n/** Used to compose bitmasks for value comparisons. */\r\nvar COMPARE_PARTIAL_FLAG = 1,\r\n    COMPARE_UNORDERED_FLAG = 2;\r\n\r\n/**\r\n * A specialized version of `baseIsEqualDeep` for arrays with support for\r\n * partial deep comparisons.\r\n *\r\n * @private\r\n * @param {Array} array The array to compare.\r\n * @param {Array} other The other array to compare.\r\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n * @param {Function} customizer The function to customize comparisons.\r\n * @param {Function} equalFunc The function to determine equivalents of values.\r\n * @param {Object} stack Tracks traversed `array` and `other` objects.\r\n * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.\r\n */\r\nfunction equalArrays(array, other, bitmask, customizer, equalFunc, stack) {\r\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\r\n      arrLength = array.length,\r\n      othLength = other.length;\r\n\r\n  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {\r\n    return false;\r\n  }\r\n  // Check that cyclic values are equal.\r\n  var arrStacked = stack.get(array);\r\n  var othStacked = stack.get(other);\r\n  if (arrStacked && othStacked) {\r\n    return arrStacked == other && othStacked == array;\r\n  }\r\n  var index = -1,\r\n      result = true,\r\n      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;\r\n\r\n  stack.set(array, other);\r\n  stack.set(other, array);\r\n\r\n  // Ignore non-index properties.\r\n  while (++index < arrLength) {\r\n    var arrValue = array[index],\r\n        othValue = other[index];\r\n\r\n    if (customizer) {\r\n      var compared = isPartial\r\n        ? customizer(othValue, arrValue, index, other, array, stack)\r\n        : customizer(arrValue, othValue, index, array, other, stack);\r\n    }\r\n    if (compared !== undefined) {\r\n      if (compared) {\r\n        continue;\r\n      }\r\n      result = false;\r\n      break;\r\n    }\r\n    // Recursively compare arrays (susceptible to call stack limits).\r\n    if (seen) {\r\n      if (!arraySome(other, function(othValue, othIndex) {\r\n            if (!cacheHas(seen, othIndex) &&\r\n                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {\r\n              return seen.push(othIndex);\r\n            }\r\n          })) {\r\n        result = false;\r\n        break;\r\n      }\r\n    } else if (!(\r\n          arrValue === othValue ||\r\n            equalFunc(arrValue, othValue, bitmask, customizer, stack)\r\n        )) {\r\n      result = false;\r\n      break;\r\n    }\r\n  }\r\n  stack['delete'](array);\r\n  stack['delete'](other);\r\n  return result;\r\n}\r\n\r\nexport default equalArrays;\r\n", "/**\r\n * Converts `map` to its key-value pairs.\r\n *\r\n * @private\r\n * @param {Object} map The map to convert.\r\n * @returns {Array} Returns the key-value pairs.\r\n */\r\nfunction mapToArray(map) {\r\n  var index = -1,\r\n      result = Array(map.size);\r\n\r\n  map.forEach(function(value, key) {\r\n    result[++index] = [key, value];\r\n  });\r\n  return result;\r\n}\r\n\r\nexport default mapToArray;\r\n", "/**\r\n * Converts `set` to an array of its values.\r\n *\r\n * @private\r\n * @param {Object} set The set to convert.\r\n * @returns {Array} Returns the values.\r\n */\r\nfunction setToArray(set) {\r\n  var index = -1,\r\n      result = Array(set.size);\r\n\r\n  set.forEach(function(value) {\r\n    result[++index] = value;\r\n  });\r\n  return result;\r\n}\r\n\r\nexport default setToArray;\r\n", "import Symbol from './_Symbol.js';\r\nimport Uint8Array from './_Uint8Array.js';\r\nimport eq from './eq.js';\r\nimport equalArrays from './_equalArrays.js';\r\nimport mapToArray from './_mapToArray.js';\r\nimport setToArray from './_setToArray.js';\r\n\r\n/** Used to compose bitmasks for value comparisons. */\r\nvar COMPARE_PARTIAL_FLAG = 1,\r\n    COMPARE_UNORDERED_FLAG = 2;\r\n\r\n/** `Object#toString` result references. */\r\nvar boolTag = '[object Boolean]',\r\n    dateTag = '[object Date]',\r\n    errorTag = '[object Error]',\r\n    mapTag = '[object Map]',\r\n    numberTag = '[object Number]',\r\n    regexpTag = '[object RegExp]',\r\n    setTag = '[object Set]',\r\n    stringTag = '[object String]',\r\n    symbolTag = '[object Symbol]';\r\n\r\nvar arrayBufferTag = '[object ArrayBuffer]',\r\n    dataViewTag = '[object DataView]';\r\n\r\n/** Used to convert symbols to primitives and strings. */\r\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\r\n    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;\r\n\r\n/**\r\n * A specialized version of `baseIsEqualDeep` for comparing objects of\r\n * the same `toStringTag`.\r\n *\r\n * **Note:** This function only supports comparing values with tags of\r\n * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.\r\n *\r\n * @private\r\n * @param {Object} object The object to compare.\r\n * @param {Object} other The other object to compare.\r\n * @param {string} tag The `toStringTag` of the objects to compare.\r\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n * @param {Function} customizer The function to customize comparisons.\r\n * @param {Function} equalFunc The function to determine equivalents of values.\r\n * @param {Object} stack Tracks traversed `object` and `other` objects.\r\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n */\r\nfunction equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {\r\n  switch (tag) {\r\n    case dataViewTag:\r\n      if ((object.byteLength != other.byteLength) ||\r\n          (object.byteOffset != other.byteOffset)) {\r\n        return false;\r\n      }\r\n      object = object.buffer;\r\n      other = other.buffer;\r\n\r\n    case arrayBufferTag:\r\n      if ((object.byteLength != other.byteLength) ||\r\n          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {\r\n        return false;\r\n      }\r\n      return true;\r\n\r\n    case boolTag:\r\n    case dateTag:\r\n    case numberTag:\r\n      // Coerce booleans to `1` or `0` and dates to milliseconds.\r\n      // Invalid dates are coerced to `NaN`.\r\n      return eq(+object, +other);\r\n\r\n    case errorTag:\r\n      return object.name == other.name && object.message == other.message;\r\n\r\n    case regexpTag:\r\n    case stringTag:\r\n      // Coerce regexes to strings and treat strings, primitives and objects,\r\n      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring\r\n      // for more details.\r\n      return object == (other + '');\r\n\r\n    case mapTag:\r\n      var convert = mapToArray;\r\n\r\n    case setTag:\r\n      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;\r\n      convert || (convert = setToArray);\r\n\r\n      if (object.size != other.size && !isPartial) {\r\n        return false;\r\n      }\r\n      // Assume cyclic values are equal.\r\n      var stacked = stack.get(object);\r\n      if (stacked) {\r\n        return stacked == other;\r\n      }\r\n      bitmask |= COMPARE_UNORDERED_FLAG;\r\n\r\n      // Recursively compare objects (susceptible to call stack limits).\r\n      stack.set(object, other);\r\n      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);\r\n      stack['delete'](object);\r\n      return result;\r\n\r\n    case symbolTag:\r\n      if (symbolValueOf) {\r\n        return symbolValueOf.call(object) == symbolValueOf.call(other);\r\n      }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default equalByTag;\r\n", "import getAllKeys from './_getAllKeys.js';\r\n\r\n/** Used to compose bitmasks for value comparisons. */\r\nvar COMPARE_PARTIAL_FLAG = 1;\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * A specialized version of `baseIsEqualDeep` for objects with support for\r\n * partial deep comparisons.\r\n *\r\n * @private\r\n * @param {Object} object The object to compare.\r\n * @param {Object} other The other object to compare.\r\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n * @param {Function} customizer The function to customize comparisons.\r\n * @param {Function} equalFunc The function to determine equivalents of values.\r\n * @param {Object} stack Tracks traversed `object` and `other` objects.\r\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n */\r\nfunction equalObjects(object, other, bitmask, customizer, equalFunc, stack) {\r\n  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,\r\n      objProps = getAllKeys(object),\r\n      objLength = objProps.length,\r\n      othProps = getAllKeys(other),\r\n      othLength = othProps.length;\r\n\r\n  if (objLength != othLength && !isPartial) {\r\n    return false;\r\n  }\r\n  var index = objLength;\r\n  while (index--) {\r\n    var key = objProps[index];\r\n    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {\r\n      return false;\r\n    }\r\n  }\r\n  // Check that cyclic values are equal.\r\n  var objStacked = stack.get(object);\r\n  var othStacked = stack.get(other);\r\n  if (objStacked && othStacked) {\r\n    return objStacked == other && othStacked == object;\r\n  }\r\n  var result = true;\r\n  stack.set(object, other);\r\n  stack.set(other, object);\r\n\r\n  var skipCtor = isPartial;\r\n  while (++index < objLength) {\r\n    key = objProps[index];\r\n    var objValue = object[key],\r\n        othValue = other[key];\r\n\r\n    if (customizer) {\r\n      var compared = isPartial\r\n        ? customizer(othValue, objValue, key, other, object, stack)\r\n        : customizer(objValue, othValue, key, object, other, stack);\r\n    }\r\n    // Recursively compare objects (susceptible to call stack limits).\r\n    if (!(compared === undefined\r\n          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))\r\n          : compared\r\n        )) {\r\n      result = false;\r\n      break;\r\n    }\r\n    skipCtor || (skipCtor = key == 'constructor');\r\n  }\r\n  if (result && !skipCtor) {\r\n    var objCtor = object.constructor,\r\n        othCtor = other.constructor;\r\n\r\n    // Non `Object` object instances with different constructors are not equal.\r\n    if (objCtor != othCtor &&\r\n        ('constructor' in object && 'constructor' in other) &&\r\n        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&\r\n          typeof othCtor == 'function' && othCtor instanceof othCtor)) {\r\n      result = false;\r\n    }\r\n  }\r\n  stack['delete'](object);\r\n  stack['delete'](other);\r\n  return result;\r\n}\r\n\r\nexport default equalObjects;\r\n", "import Stack from './_Stack.js';\r\nimport equalArrays from './_equalArrays.js';\r\nimport equalByTag from './_equalByTag.js';\r\nimport equalObjects from './_equalObjects.js';\r\nimport getTag from './_getTag.js';\r\nimport isArray from './isArray.js';\r\nimport isBuffer from './isBuffer.js';\r\nimport isTypedArray from './isTypedArray.js';\r\n\r\n/** Used to compose bitmasks for value comparisons. */\r\nvar COMPARE_PARTIAL_FLAG = 1;\r\n\r\n/** `Object#toString` result references. */\r\nvar argsTag = '[object Arguments]',\r\n    arrayTag = '[object Array]',\r\n    objectTag = '[object Object]';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * A specialized version of `baseIsEqual` for arrays and objects which performs\r\n * deep comparisons and tracks traversed objects enabling objects with circular\r\n * references to be compared.\r\n *\r\n * @private\r\n * @param {Object} object The object to compare.\r\n * @param {Object} other The other object to compare.\r\n * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.\r\n * @param {Function} customizer The function to customize comparisons.\r\n * @param {Function} equalFunc The function to determine equivalents of values.\r\n * @param {Object} [stack] Tracks traversed `object` and `other` objects.\r\n * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.\r\n */\r\nfunction baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {\r\n  var objIsArr = isArray(object),\r\n      othIsArr = isArray(other),\r\n      objTag = objIsArr ? arrayTag : getTag(object),\r\n      othTag = othIsArr ? arrayTag : getTag(other);\r\n\r\n  objTag = objTag == argsTag ? objectTag : objTag;\r\n  othTag = othTag == argsTag ? objectTag : othTag;\r\n\r\n  var objIsObj = objTag == objectTag,\r\n      othIsObj = othTag == objectTag,\r\n      isSameTag = objTag == othTag;\r\n\r\n  if (isSameTag && isBuffer(object)) {\r\n    if (!isBuffer(other)) {\r\n      return false;\r\n    }\r\n    objIsArr = true;\r\n    objIsObj = false;\r\n  }\r\n  if (isSameTag && !objIsObj) {\r\n    stack || (stack = new Stack);\r\n    return (objIsArr || isTypedArray(object))\r\n      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)\r\n      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);\r\n  }\r\n  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {\r\n    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),\r\n        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');\r\n\r\n    if (objIsWrapped || othIsWrapped) {\r\n      var objUnwrapped = objIsWrapped ? object.value() : object,\r\n          othUnwrapped = othIsWrapped ? other.value() : other;\r\n\r\n      stack || (stack = new Stack);\r\n      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);\r\n    }\r\n  }\r\n  if (!isSameTag) {\r\n    return false;\r\n  }\r\n  stack || (stack = new Stack);\r\n  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);\r\n}\r\n\r\nexport default baseIsEqualDeep;\r\n", "import baseIsEqualDeep from './_baseIsEqualDeep.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/**\r\n * The base implementation of `_.isEqual` which supports partial comparisons\r\n * and tracks traversed objects.\r\n *\r\n * @private\r\n * @param {*} value The value to compare.\r\n * @param {*} other The other value to compare.\r\n * @param {boolean} bitmask The bitmask flags.\r\n *  1 - Unordered comparison\r\n *  2 - Partial comparison\r\n * @param {Function} [customizer] The function to customize comparisons.\r\n * @param {Object} [stack] Tracks traversed `value` and `other` objects.\r\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\r\n */\r\nfunction baseIsEqual(value, other, bitmask, customizer, stack) {\r\n  if (value === other) {\r\n    return true;\r\n  }\r\n  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {\r\n    return value !== value && other !== other;\r\n  }\r\n  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);\r\n}\r\n\r\nexport default baseIsEqual;\r\n", "import Stack from './_Stack.js';\r\nimport baseIsEqual from './_baseIsEqual.js';\r\n\r\n/** Used to compose bitmasks for value comparisons. */\r\nvar COMPARE_PARTIAL_FLAG = 1,\r\n    COMPARE_UNORDERED_FLAG = 2;\r\n\r\n/**\r\n * The base implementation of `_.isMatch` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Object} object The object to inspect.\r\n * @param {Object} source The object of property values to match.\r\n * @param {Array} matchData The property names, values, and compare flags to match.\r\n * @param {Function} [customizer] The function to customize comparisons.\r\n * @returns {boolean} Returns `true` if `object` is a match, else `false`.\r\n */\r\nfunction baseIsMatch(object, source, matchData, customizer) {\r\n  var index = matchData.length,\r\n      length = index,\r\n      noCustomizer = !customizer;\r\n\r\n  if (object == null) {\r\n    return !length;\r\n  }\r\n  object = Object(object);\r\n  while (index--) {\r\n    var data = matchData[index];\r\n    if ((noCustomizer && data[2])\r\n          ? data[1] !== object[data[0]]\r\n          : !(data[0] in object)\r\n        ) {\r\n      return false;\r\n    }\r\n  }\r\n  while (++index < length) {\r\n    data = matchData[index];\r\n    var key = data[0],\r\n        objValue = object[key],\r\n        srcValue = data[1];\r\n\r\n    if (noCustomizer && data[2]) {\r\n      if (objValue === undefined && !(key in object)) {\r\n        return false;\r\n      }\r\n    } else {\r\n      var stack = new Stack;\r\n      if (customizer) {\r\n        var result = customizer(objValue, srcValue, key, object, source, stack);\r\n      }\r\n      if (!(result === undefined\r\n            ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)\r\n            : result\r\n          )) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport default baseIsMatch;\r\n", "import isObject from './isObject.js';\r\n\r\n/**\r\n * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` if suitable for strict\r\n *  equality comparisons, else `false`.\r\n */\r\nfunction isStrictComparable(value) {\r\n  return value === value && !isObject(value);\r\n}\r\n\r\nexport default isStrictComparable;\r\n", "import isStrictComparable from './_isStrictComparable.js';\r\nimport keys from './keys.js';\r\n\r\n/**\r\n * Gets the property names, values, and compare flags of `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the match data of `object`.\r\n */\r\nfunction getMatchData(object) {\r\n  var result = keys(object),\r\n      length = result.length;\r\n\r\n  while (length--) {\r\n    var key = result[length],\r\n        value = object[key];\r\n\r\n    result[length] = [key, value, isStrictComparable(value)];\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default getMatchData;\r\n", "/**\r\n * A specialized version of `matchesProperty` for source values suitable\r\n * for strict equality comparisons, i.e. `===`.\r\n *\r\n * @private\r\n * @param {string} key The key of the property to get.\r\n * @param {*} srcValue The value to match.\r\n * @returns {Function} Returns the new spec function.\r\n */\r\nfunction matchesStrictComparable(key, srcValue) {\r\n  return function(object) {\r\n    if (object == null) {\r\n      return false;\r\n    }\r\n    return object[key] === srcValue &&\r\n      (srcValue !== undefined || (key in Object(object)));\r\n  };\r\n}\r\n\r\nexport default matchesStrictComparable;\r\n", "import baseIsMatch from './_baseIsMatch.js';\r\nimport getMatchData from './_getMatchData.js';\r\nimport matchesStrictComparable from './_matchesStrictComparable.js';\r\n\r\n/**\r\n * The base implementation of `_.matches` which doesn't clone `source`.\r\n *\r\n * @private\r\n * @param {Object} source The object of property values to match.\r\n * @returns {Function} Returns the new spec function.\r\n */\r\nfunction baseMatches(source) {\r\n  var matchData = getMatchData(source);\r\n  if (matchData.length == 1 && matchData[0][2]) {\r\n    return matchesStrictComparable(matchData[0][0], matchData[0][1]);\r\n  }\r\n  return function(object) {\r\n    return object === source || baseIsMatch(object, source, matchData);\r\n  };\r\n}\r\n\r\nexport default baseMatches;\r\n", "/**\r\n * The base implementation of `_.hasIn` without support for deep paths.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {Array|string} key The key to check.\r\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\r\n */\r\nfunction baseHasIn(object, key) {\r\n  return object != null && key in Object(object);\r\n}\r\n\r\nexport default baseHasIn;\r\n", "import castPath from './_castPath.js';\r\nimport isArguments from './isArguments.js';\r\nimport isArray from './isArray.js';\r\nimport isIndex from './_isIndex.js';\r\nimport isLength from './isLength.js';\r\nimport toKey from './_toKey.js';\r\n\r\n/**\r\n * Checks if `path` exists on `object`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path to check.\r\n * @param {Function} hasFunc The function to check properties.\r\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n */\r\nfunction hasPath(object, path, hasFunc) {\r\n  path = castPath(path, object);\r\n\r\n  var index = -1,\r\n      length = path.length,\r\n      result = false;\r\n\r\n  while (++index < length) {\r\n    var key = toKey(path[index]);\r\n    if (!(result = object != null && hasFunc(object, key))) {\r\n      break;\r\n    }\r\n    object = object[key];\r\n  }\r\n  if (result || ++index != length) {\r\n    return result;\r\n  }\r\n  length = object == null ? 0 : object.length;\r\n  return !!length && isLength(length) && isIndex(key, length) &&\r\n    (isArray(object) || isArguments(object));\r\n}\r\n\r\nexport default hasPath;\r\n", "import baseHasIn from './_baseHasIn.js';\r\nimport hasPath from './_hasPath.js';\r\n\r\n/**\r\n * Checks if `path` is a direct or inherited property of `object`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path to check.\r\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n * @example\r\n *\r\n * var object = _.create({ 'a': _.create({ 'b': 2 }) });\r\n *\r\n * _.hasIn(object, 'a');\r\n * // => true\r\n *\r\n * _.hasIn(object, 'a.b');\r\n * // => true\r\n *\r\n * _.hasIn(object, ['a', 'b']);\r\n * // => true\r\n *\r\n * _.hasIn(object, 'b');\r\n * // => false\r\n */\r\nfunction hasIn(object, path) {\r\n  return object != null && hasPath(object, path, baseHasIn);\r\n}\r\n\r\nexport default hasIn;\r\n", "import baseIsEqual from './_baseIsEqual.js';\r\nimport get from './get.js';\r\nimport hasIn from './hasIn.js';\r\nimport isKey from './_isKey.js';\r\nimport isStrictComparable from './_isStrictComparable.js';\r\nimport matchesStrictComparable from './_matchesStrictComparable.js';\r\nimport toKey from './_toKey.js';\r\n\r\n/** Used to compose bitmasks for value comparisons. */\r\nvar COMPARE_PARTIAL_FLAG = 1,\r\n    COMPARE_UNORDERED_FLAG = 2;\r\n\r\n/**\r\n * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.\r\n *\r\n * @private\r\n * @param {string} path The path of the property to get.\r\n * @param {*} srcValue The value to match.\r\n * @returns {Function} Returns the new spec function.\r\n */\r\nfunction baseMatchesProperty(path, srcValue) {\r\n  if (isKey(path) && isStrictComparable(srcValue)) {\r\n    return matchesStrictComparable(toKey(path), srcValue);\r\n  }\r\n  return function(object) {\r\n    var objValue = get(object, path);\r\n    return (objValue === undefined && objValue === srcValue)\r\n      ? hasIn(object, path)\r\n      : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);\r\n  };\r\n}\r\n\r\nexport default baseMatchesProperty;\r\n", "/**\r\n * The base implementation of `_.property` without support for deep paths.\r\n *\r\n * @private\r\n * @param {string} key The key of the property to get.\r\n * @returns {Function} Returns the new accessor function.\r\n */\r\nfunction baseProperty(key) {\r\n  return function(object) {\r\n    return object == null ? undefined : object[key];\r\n  };\r\n}\r\n\r\nexport default baseProperty;\r\n", "import baseGet from './_baseGet.js';\r\n\r\n/**\r\n * A specialized version of `baseProperty` which supports deep paths.\r\n *\r\n * @private\r\n * @param {Array|string} path The path of the property to get.\r\n * @returns {Function} Returns the new accessor function.\r\n */\r\nfunction basePropertyDeep(path) {\r\n  return function(object) {\r\n    return baseGet(object, path);\r\n  };\r\n}\r\n\r\nexport default basePropertyDeep;\r\n", "import baseProperty from './_baseProperty.js';\r\nimport basePropertyDeep from './_basePropertyDeep.js';\r\nimport isKey from './_isKey.js';\r\nimport toKey from './_toKey.js';\r\n\r\n/**\r\n * Creates a function that returns the value at `path` of a given object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 2.4.0\r\n * @category Util\r\n * @param {Array|string} path The path of the property to get.\r\n * @returns {Function} Returns the new accessor function.\r\n * @example\r\n *\r\n * var objects = [\r\n *   { 'a': { 'b': 2 } },\r\n *   { 'a': { 'b': 1 } }\r\n * ];\r\n *\r\n * _.map(objects, _.property('a.b'));\r\n * // => [2, 1]\r\n *\r\n * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');\r\n * // => [1, 2]\r\n */\r\nfunction property(path) {\r\n  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);\r\n}\r\n\r\nexport default property;\r\n", "import baseMatches from './_baseMatches.js';\r\nimport baseMatchesProperty from './_baseMatchesProperty.js';\r\nimport identity from './identity.js';\r\nimport isArray from './isArray.js';\r\nimport property from './property.js';\r\n\r\n/**\r\n * The base implementation of `_.iteratee`.\r\n *\r\n * @private\r\n * @param {*} [value=_.identity] The value to convert to an iteratee.\r\n * @returns {Function} Returns the iteratee.\r\n */\r\nfunction baseIteratee(value) {\r\n  // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.\r\n  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.\r\n  if (typeof value == 'function') {\r\n    return value;\r\n  }\r\n  if (value == null) {\r\n    return identity;\r\n  }\r\n  if (typeof value == 'object') {\r\n    return isArray(value)\r\n      ? baseMatchesProperty(value[0], value[1])\r\n      : baseMatches(value);\r\n  }\r\n  return property(value);\r\n}\r\n\r\nexport default baseIteratee;\r\n", "/**\r\n * A specialized version of `baseAggregator` for arrays.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} setter The function to set `accumulator` values.\r\n * @param {Function} iteratee The iteratee to transform keys.\r\n * @param {Object} accumulator The initial aggregated object.\r\n * @returns {Function} Returns `accumulator`.\r\n */\r\nfunction arrayAggregator(array, setter, iteratee, accumulator) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length;\r\n\r\n  while (++index < length) {\r\n    var value = array[index];\r\n    setter(accumulator, value, iteratee(value), array);\r\n  }\r\n  return accumulator;\r\n}\r\n\r\nexport default arrayAggregator;\r\n", "/**\r\n * Creates a base function for methods like `_.forIn` and `_.forOwn`.\r\n *\r\n * @private\r\n * @param {boolean} [fromRight] Specify iterating from right to left.\r\n * @returns {Function} Returns the new base function.\r\n */\r\nfunction createBaseFor(fromRight) {\r\n  return function(object, iteratee, keysFunc) {\r\n    var index = -1,\r\n        iterable = Object(object),\r\n        props = keysFunc(object),\r\n        length = props.length;\r\n\r\n    while (length--) {\r\n      var key = props[fromRight ? length : ++index];\r\n      if (iteratee(iterable[key], key, iterable) === false) {\r\n        break;\r\n      }\r\n    }\r\n    return object;\r\n  };\r\n}\r\n\r\nexport default createBaseFor;\r\n", "import createBaseFor from './_createBaseFor.js';\r\n\r\n/**\r\n * The base implementation of `baseForOwn` which iterates over `object`\r\n * properties returned by `keysFunc` and invokes `iteratee` for each property.\r\n * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n *\r\n * @private\r\n * @param {Object} object The object to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @param {Function} keysFunc The function to get the keys of `object`.\r\n * @returns {Object} Returns `object`.\r\n */\r\nvar baseFor = createBaseFor();\r\n\r\nexport default baseFor;\r\n", "import baseFor from './_baseFor.js';\r\nimport keys from './keys.js';\r\n\r\n/**\r\n * The base implementation of `_.forOwn` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Object} object The object to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction baseForOwn(object, iteratee) {\r\n  return object && baseFor(object, iteratee, keys);\r\n}\r\n\r\nexport default baseForOwn;\r\n", "import isArrayLike from './isArrayLike.js';\r\n\r\n/**\r\n * Creates a `baseEach` or `baseEachRight` function.\r\n *\r\n * @private\r\n * @param {Function} eachFunc The function to iterate over a collection.\r\n * @param {boolean} [fromRight] Specify iterating from right to left.\r\n * @returns {Function} Returns the new base function.\r\n */\r\nfunction createBaseEach(eachFunc, fromRight) {\r\n  return function(collection, iteratee) {\r\n    if (collection == null) {\r\n      return collection;\r\n    }\r\n    if (!isArrayLike(collection)) {\r\n      return eachFunc(collection, iteratee);\r\n    }\r\n    var length = collection.length,\r\n        index = fromRight ? length : -1,\r\n        iterable = Object(collection);\r\n\r\n    while ((fromRight ? index-- : ++index < length)) {\r\n      if (iteratee(iterable[index], index, iterable) === false) {\r\n        break;\r\n      }\r\n    }\r\n    return collection;\r\n  };\r\n}\r\n\r\nexport default createBaseEach;\r\n", "import baseForOwn from './_baseForOwn.js';\r\nimport createBaseEach from './_createBaseEach.js';\r\n\r\n/**\r\n * The base implementation of `_.forEach` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array|Object} Returns `collection`.\r\n */\r\nvar baseEach = createBaseEach(baseForOwn);\r\n\r\nexport default baseEach;\r\n", "import baseEach from './_baseEach.js';\r\n\r\n/**\r\n * Aggregates elements of `collection` on `accumulator` with keys transformed\r\n * by `iteratee` and values set by `setter`.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} setter The function to set `accumulator` values.\r\n * @param {Function} iteratee The iteratee to transform keys.\r\n * @param {Object} accumulator The initial aggregated object.\r\n * @returns {Function} Returns `accumulator`.\r\n */\r\nfunction baseAggregator(collection, setter, iteratee, accumulator) {\r\n  baseEach(collection, function(value, key, collection) {\r\n    setter(accumulator, value, iteratee(value), collection);\r\n  });\r\n  return accumulator;\r\n}\r\n\r\nexport default baseAggregator;\r\n", "import arrayAggregator from './_arrayAggregator.js';\r\nimport baseAggregator from './_baseAggregator.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport isArray from './isArray.js';\r\n\r\n/**\r\n * Creates a function like `_.groupBy`.\r\n *\r\n * @private\r\n * @param {Function} setter The function to set accumulator values.\r\n * @param {Function} [initializer] The accumulator object initializer.\r\n * @returns {Function} Returns the new aggregator function.\r\n */\r\nfunction createAggregator(setter, initializer) {\r\n  return function(collection, iteratee) {\r\n    var func = isArray(collection) ? arrayAggregator : baseAggregator,\r\n        accumulator = initializer ? initializer() : {};\r\n\r\n    return func(collection, setter, baseIteratee(iteratee, 2), accumulator);\r\n  };\r\n}\r\n\r\nexport default createAggregator;\r\n", "import baseRest from './_baseRest.js';\r\nimport eq from './eq.js';\r\nimport isIterateeCall from './_isIterateeCall.js';\r\nimport keysIn from './keysIn.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Assigns own and inherited enumerable string keyed properties of source\r\n * objects to the destination object for all destination properties that\r\n * resolve to `undefined`. Source objects are applied from left to right.\r\n * Once a property is set, additional values of the same property are ignored.\r\n *\r\n * **Note:** This method mutates `object`.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Object\r\n * @param {Object} object The destination object.\r\n * @param {...Object} [sources] The source objects.\r\n * @returns {Object} Returns `object`.\r\n * @see _.defaultsDeep\r\n * @example\r\n *\r\n * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });\r\n * // => { 'a': 1, 'b': 2 }\r\n */\r\nvar defaults = baseRest(function(object, sources) {\r\n  object = Object(object);\r\n\r\n  var index = -1;\r\n  var length = sources.length;\r\n  var guard = length > 2 ? sources[2] : undefined;\r\n\r\n  if (guard && isIterateeCall(sources[0], sources[1], guard)) {\r\n    length = 1;\r\n  }\r\n\r\n  while (++index < length) {\r\n    var source = sources[index];\r\n    var props = keysIn(source);\r\n    var propsIndex = -1;\r\n    var propsLength = props.length;\r\n\r\n    while (++propsIndex < propsLength) {\r\n      var key = props[propsIndex];\r\n      var value = object[key];\r\n\r\n      if (value === undefined ||\r\n          (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {\r\n        object[key] = source[key];\r\n      }\r\n    }\r\n  }\r\n\r\n  return object;\r\n});\r\n\r\nexport default defaults;\r\n", "import isArrayLike from './isArrayLike.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/**\r\n * This method is like `_.isArrayLike` except that it also checks if `value`\r\n * is an object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is an array-like object,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.isArrayLikeObject([1, 2, 3]);\r\n * // => true\r\n *\r\n * _.isArrayLikeObject(document.body.children);\r\n * // => true\r\n *\r\n * _.isArrayLikeObject('abc');\r\n * // => false\r\n *\r\n * _.isArrayLikeObject(_.noop);\r\n * // => false\r\n */\r\nfunction isArrayLikeObject(value) {\r\n  return isObjectLike(value) && isArrayLike(value);\r\n}\r\n\r\nexport default isArrayLikeObject;\r\n", "/**\r\n * This function is like `arrayIncludes` except that it accepts a comparator.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to inspect.\r\n * @param {*} target The value to search for.\r\n * @param {Function} comparator The comparator invoked per element.\r\n * @returns {boolean} Returns `true` if `target` is found, else `false`.\r\n */\r\nfunction arrayIncludesWith(array, value, comparator) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length;\r\n\r\n  while (++index < length) {\r\n    if (comparator(value, array[index])) {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport default arrayIncludesWith;\r\n", "import SetCache from './_SetCache.js';\r\nimport arrayIncludes from './_arrayIncludes.js';\r\nimport arrayIncludesWith from './_arrayIncludesWith.js';\r\nimport arrayMap from './_arrayMap.js';\r\nimport baseUnary from './_baseUnary.js';\r\nimport cacheHas from './_cacheHas.js';\r\n\r\n/** Used as the size to enable large array optimizations. */\r\nvar LARGE_ARRAY_SIZE = 200;\r\n\r\n/**\r\n * The base implementation of methods like `_.difference` without support\r\n * for excluding multiple arrays or iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {Array} values The values to exclude.\r\n * @param {Function} [iteratee] The iteratee invoked per element.\r\n * @param {Function} [comparator] The comparator invoked per element.\r\n * @returns {Array} Returns the new array of filtered values.\r\n */\r\nfunction baseDifference(array, values, iteratee, comparator) {\r\n  var index = -1,\r\n      includes = arrayIncludes,\r\n      isCommon = true,\r\n      length = array.length,\r\n      result = [],\r\n      valuesLength = values.length;\r\n\r\n  if (!length) {\r\n    return result;\r\n  }\r\n  if (iteratee) {\r\n    values = arrayMap(values, baseUnary(iteratee));\r\n  }\r\n  if (comparator) {\r\n    includes = arrayIncludesWith;\r\n    isCommon = false;\r\n  }\r\n  else if (values.length >= LARGE_ARRAY_SIZE) {\r\n    includes = cacheHas;\r\n    isCommon = false;\r\n    values = new SetCache(values);\r\n  }\r\n  outer:\r\n  while (++index < length) {\r\n    var value = array[index],\r\n        computed = iteratee == null ? value : iteratee(value);\r\n\r\n    value = (comparator || value !== 0) ? value : 0;\r\n    if (isCommon && computed === computed) {\r\n      var valuesIndex = valuesLength;\r\n      while (valuesIndex--) {\r\n        if (values[valuesIndex] === computed) {\r\n          continue outer;\r\n        }\r\n      }\r\n      result.push(value);\r\n    }\r\n    else if (!includes(values, computed, comparator)) {\r\n      result.push(value);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseDifference;\r\n", "import baseDifference from './_baseDifference.js';\r\nimport baseFlatten from './_baseFlatten.js';\r\nimport baseRest from './_baseRest.js';\r\nimport isArrayLikeObject from './isArrayLikeObject.js';\r\n\r\n/**\r\n * Creates an array of `array` values not included in the other given arrays\r\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * for equality comparisons. The order and references of result values are\r\n * determined by the first array.\r\n *\r\n * **Note:** Unlike `_.pullAll`, this method returns a new array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to inspect.\r\n * @param {...Array} [values] The values to exclude.\r\n * @returns {Array} Returns the new array of filtered values.\r\n * @see _.without, _.xor\r\n * @example\r\n *\r\n * _.difference([2, 1], [2, 3]);\r\n * // => [1]\r\n */\r\nvar difference = baseRest(function(array, values) {\r\n  return isArrayLikeObject(array)\r\n    ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))\r\n    : [];\r\n});\r\n\r\nexport default difference;\r\n", "/**\r\n * Gets the last element of `array`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to query.\r\n * @returns {*} Returns the last element of `array`.\r\n * @example\r\n *\r\n * _.last([1, 2, 3]);\r\n * // => 3\r\n */\r\nfunction last(array) {\r\n  var length = array == null ? 0 : array.length;\r\n  return length ? array[length - 1] : undefined;\r\n}\r\n\r\nexport default last;\r\n", "import baseSlice from './_baseSlice.js';\r\nimport toInteger from './toInteger.js';\r\n\r\n/**\r\n * Creates a slice of `array` with `n` elements dropped from the beginning.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.5.0\r\n * @category Array\r\n * @param {Array} array The array to query.\r\n * @param {number} [n=1] The number of elements to drop.\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n * @returns {Array} Returns the slice of `array`.\r\n * @example\r\n *\r\n * _.drop([1, 2, 3]);\r\n * // => [2, 3]\r\n *\r\n * _.drop([1, 2, 3], 2);\r\n * // => [3]\r\n *\r\n * _.drop([1, 2, 3], 5);\r\n * // => []\r\n *\r\n * _.drop([1, 2, 3], 0);\r\n * // => [1, 2, 3]\r\n */\r\nfunction drop(array, n, guard) {\r\n  var length = array == null ? 0 : array.length;\r\n  if (!length) {\r\n    return [];\r\n  }\r\n  n = (guard || n === undefined) ? 1 : toInteger(n);\r\n  return baseSlice(array, n < 0 ? 0 : n, length);\r\n}\r\n\r\nexport default drop;\r\n", "import baseSlice from './_baseSlice.js';\r\nimport toInteger from './toInteger.js';\r\n\r\n/**\r\n * Creates a slice of `array` with `n` elements dropped from the end.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Array\r\n * @param {Array} array The array to query.\r\n * @param {number} [n=1] The number of elements to drop.\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n * @returns {Array} Returns the slice of `array`.\r\n * @example\r\n *\r\n * _.dropRight([1, 2, 3]);\r\n * // => [1, 2]\r\n *\r\n * _.dropRight([1, 2, 3], 2);\r\n * // => [1]\r\n *\r\n * _.dropRight([1, 2, 3], 5);\r\n * // => []\r\n *\r\n * _.dropRight([1, 2, 3], 0);\r\n * // => [1, 2, 3]\r\n */\r\nfunction dropRight(array, n, guard) {\r\n  var length = array == null ? 0 : array.length;\r\n  if (!length) {\r\n    return [];\r\n  }\r\n  n = (guard || n === undefined) ? 1 : toInteger(n);\r\n  n = length - n;\r\n  return baseSlice(array, 0, n < 0 ? 0 : n);\r\n}\r\n\r\nexport default dropRight;\r\n", "import identity from './identity.js';\r\n\r\n/**\r\n * Casts `value` to `identity` if it's not a function.\r\n *\r\n * @private\r\n * @param {*} value The value to inspect.\r\n * @returns {Function} Returns cast function.\r\n */\r\nfunction castFunction(value) {\r\n  return typeof value == 'function' ? value : identity;\r\n}\r\n\r\nexport default castFunction;\r\n", "import arrayEach from './_arrayEach.js';\r\nimport baseEach from './_baseEach.js';\r\nimport castFunction from './_castFunction.js';\r\nimport isArray from './isArray.js';\r\n\r\n/**\r\n * Iterates over elements of `collection` and invokes `iteratee` for each element.\r\n * The iteratee is invoked with three arguments: (value, index|key, collection).\r\n * Iteratee functions may exit iteration early by explicitly returning `false`.\r\n *\r\n * **Note:** As with other \"Collections\" methods, objects with a \"length\"\r\n * property are iterated like arrays. To avoid this behavior use `_.forIn`\r\n * or `_.forOwn` for object iteration.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @alias each\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n * @returns {Array|Object} Returns `collection`.\r\n * @see _.forEachRight\r\n * @example\r\n *\r\n * _.forEach([1, 2], function(value) {\r\n *   console.log(value);\r\n * });\r\n * // => Logs `1` then `2`.\r\n *\r\n * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {\r\n *   console.log(key);\r\n * });\r\n * // => Logs 'a' then 'b' (iteration order is not guaranteed).\r\n */\r\nfunction forEach(collection, iteratee) {\r\n  var func = isArray(collection) ? arrayEach : baseEach;\r\n  return func(collection, castFunction(iteratee));\r\n}\r\n\r\nexport default forEach;\r\n", "/**\r\n * A specialized version of `_.every` for arrays without support for\r\n * iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} [array] The array to iterate over.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n *  else `false`.\r\n */\r\nfunction arrayEvery(array, predicate) {\r\n  var index = -1,\r\n      length = array == null ? 0 : array.length;\r\n\r\n  while (++index < length) {\r\n    if (!predicate(array[index], index, array)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport default arrayEvery;\r\n", "import baseEach from './_baseEach.js';\r\n\r\n/**\r\n * The base implementation of `_.every` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n *  else `false`\r\n */\r\nfunction baseEvery(collection, predicate) {\r\n  var result = true;\r\n  baseEach(collection, function(value, index, collection) {\r\n    result = !!predicate(value, index, collection);\r\n    return result;\r\n  });\r\n  return result;\r\n}\r\n\r\nexport default baseEvery;\r\n", "import arrayEvery from './_arrayEvery.js';\r\nimport baseEvery from './_baseEvery.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport isArray from './isArray.js';\r\nimport isIterateeCall from './_isIterateeCall.js';\r\n\r\n/**\r\n * Checks if `predicate` returns truthy for **all** elements of `collection`.\r\n * Iteration is stopped once `predicate` returns falsey. The predicate is\r\n * invoked with three arguments: (value, index|key, collection).\r\n *\r\n * **Note:** This method returns `true` for\r\n * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because\r\n * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of\r\n * elements of empty collections.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n * @returns {boolean} Returns `true` if all elements pass the predicate check,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.every([true, 1, null, 'yes'], Boolean);\r\n * // => false\r\n *\r\n * var users = [\r\n *   { 'user': 'barney', 'age': 36, 'active': false },\r\n *   { 'user': 'fred',   'age': 40, 'active': false }\r\n * ];\r\n *\r\n * // The `_.matches` iteratee shorthand.\r\n * _.every(users, { 'user': 'barney', 'active': false });\r\n * // => false\r\n *\r\n * // The `_.matchesProperty` iteratee shorthand.\r\n * _.every(users, ['active', false]);\r\n * // => true\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.every(users, 'active');\r\n * // => false\r\n */\r\nfunction every(collection, predicate, guard) {\r\n  var func = isArray(collection) ? arrayEvery : baseEvery;\r\n  if (guard && isIterateeCall(collection, predicate, guard)) {\r\n    predicate = undefined;\r\n  }\r\n  return func(collection, baseIteratee(predicate, 3));\r\n}\r\n\r\nexport default every;\r\n", "import baseEach from './_baseEach.js';\r\n\r\n/**\r\n * The base implementation of `_.filter` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @returns {Array} Returns the new filtered array.\r\n */\r\nfunction baseFilter(collection, predicate) {\r\n  var result = [];\r\n  baseEach(collection, function(value, index, collection) {\r\n    if (predicate(value, index, collection)) {\r\n      result.push(value);\r\n    }\r\n  });\r\n  return result;\r\n}\r\n\r\nexport default baseFilter;\r\n", "import arrayFilter from './_arrayFilter.js';\r\nimport baseFilter from './_baseFilter.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport isArray from './isArray.js';\r\n\r\n/**\r\n * Iterates over elements of `collection`, returning an array of all elements\r\n * `predicate` returns truthy for. The predicate is invoked with three\r\n * arguments: (value, index|key, collection).\r\n *\r\n * **Note:** Unlike `_.remove`, this method returns a new array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n * @returns {Array} Returns the new filtered array.\r\n * @see _.reject\r\n * @example\r\n *\r\n * var users = [\r\n *   { 'user': 'barney', 'age': 36, 'active': true },\r\n *   { 'user': 'fred',   'age': 40, 'active': false }\r\n * ];\r\n *\r\n * _.filter(users, function(o) { return !o.active; });\r\n * // => objects for ['fred']\r\n *\r\n * // The `_.matches` iteratee shorthand.\r\n * _.filter(users, { 'age': 36, 'active': true });\r\n * // => objects for ['barney']\r\n *\r\n * // The `_.matchesProperty` iteratee shorthand.\r\n * _.filter(users, ['active', false]);\r\n * // => objects for ['fred']\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.filter(users, 'active');\r\n * // => objects for ['barney']\r\n *\r\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\r\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\r\n * // => objects for ['fred', 'barney']\r\n */\r\nfunction filter(collection, predicate) {\r\n  var func = isArray(collection) ? arrayFilter : baseFilter;\r\n  return func(collection, baseIteratee(predicate, 3));\r\n}\r\n\r\nexport default filter;\r\n", "import baseIteratee from './_baseIteratee.js';\r\nimport isArrayLike from './isArrayLike.js';\r\nimport keys from './keys.js';\r\n\r\n/**\r\n * Creates a `_.find` or `_.findLast` function.\r\n *\r\n * @private\r\n * @param {Function} findIndexFunc The function to find the collection index.\r\n * @returns {Function} Returns the new find function.\r\n */\r\nfunction createFind(findIndexFunc) {\r\n  return function(collection, predicate, fromIndex) {\r\n    var iterable = Object(collection);\r\n    if (!isArrayLike(collection)) {\r\n      var iteratee = baseIteratee(predicate, 3);\r\n      collection = keys(collection);\r\n      predicate = function(key) { return iteratee(iterable[key], key, iterable); };\r\n    }\r\n    var index = findIndexFunc(collection, predicate, fromIndex);\r\n    return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;\r\n  };\r\n}\r\n\r\nexport default createFind;\r\n", "import baseFindIndex from './_baseFindIndex.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport toInteger from './toInteger.js';\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeMax = Math.max;\r\n\r\n/**\r\n * This method is like `_.find` except that it returns the index of the first\r\n * element `predicate` returns truthy for instead of the element itself.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 1.1.0\r\n * @category Array\r\n * @param {Array} array The array to inspect.\r\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n * @param {number} [fromIndex=0] The index to search from.\r\n * @returns {number} Returns the index of the found element, else `-1`.\r\n * @example\r\n *\r\n * var users = [\r\n *   { 'user': 'barney',  'active': false },\r\n *   { 'user': 'fred',    'active': false },\r\n *   { 'user': 'pebbles', 'active': true }\r\n * ];\r\n *\r\n * _.findIndex(users, function(o) { return o.user == 'barney'; });\r\n * // => 0\r\n *\r\n * // The `_.matches` iteratee shorthand.\r\n * _.findIndex(users, { 'user': 'fred', 'active': false });\r\n * // => 1\r\n *\r\n * // The `_.matchesProperty` iteratee shorthand.\r\n * _.findIndex(users, ['active', false]);\r\n * // => 0\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.findIndex(users, 'active');\r\n * // => 2\r\n */\r\nfunction findIndex(array, predicate, fromIndex) {\r\n  var length = array == null ? 0 : array.length;\r\n  if (!length) {\r\n    return -1;\r\n  }\r\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\r\n  if (index < 0) {\r\n    index = nativeMax(length + index, 0);\r\n  }\r\n  return baseFindIndex(array, baseIteratee(predicate, 3), index);\r\n}\r\n\r\nexport default findIndex;\r\n", "import createFind from './_createFind.js';\r\nimport findIndex from './findIndex.js';\r\n\r\n/**\r\n * Iterates over elements of `collection`, returning the first element\r\n * `predicate` returns truthy for. The predicate is invoked with three\r\n * arguments: (value, index|key, collection).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to inspect.\r\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n * @param {number} [fromIndex=0] The index to search from.\r\n * @returns {*} Returns the matched element, else `undefined`.\r\n * @example\r\n *\r\n * var users = [\r\n *   { 'user': 'barney',  'age': 36, 'active': true },\r\n *   { 'user': 'fred',    'age': 40, 'active': false },\r\n *   { 'user': 'pebbles', 'age': 1,  'active': true }\r\n * ];\r\n *\r\n * _.find(users, function(o) { return o.age < 40; });\r\n * // => object for 'barney'\r\n *\r\n * // The `_.matches` iteratee shorthand.\r\n * _.find(users, { 'age': 1, 'active': true });\r\n * // => object for 'pebbles'\r\n *\r\n * // The `_.matchesProperty` iteratee shorthand.\r\n * _.find(users, ['active', false]);\r\n * // => object for 'fred'\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.find(users, 'active');\r\n * // => object for 'barney'\r\n */\r\nvar find = createFind(findIndex);\r\n\r\nexport default find;\r\n", "/**\r\n * Gets the first element of `array`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @alias first\r\n * @category Array\r\n * @param {Array} array The array to query.\r\n * @returns {*} Returns the first element of `array`.\r\n * @example\r\n *\r\n * _.head([1, 2, 3]);\r\n * // => 1\r\n *\r\n * _.head([]);\r\n * // => undefined\r\n */\r\nfunction head(array) {\r\n  return (array && array.length) ? array[0] : undefined;\r\n}\r\n\r\nexport default head;\r\n", "import baseEach from './_baseEach.js';\r\nimport isArrayLike from './isArrayLike.js';\r\n\r\n/**\r\n * The base implementation of `_.map` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @returns {Array} Returns the new mapped array.\r\n */\r\nfunction baseMap(collection, iteratee) {\r\n  var index = -1,\r\n      result = isArrayLike(collection) ? Array(collection.length) : [];\r\n\r\n  baseEach(collection, function(value, key, collection) {\r\n    result[++index] = iteratee(value, key, collection);\r\n  });\r\n  return result;\r\n}\r\n\r\nexport default baseMap;\r\n", "import arrayMap from './_arrayMap.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport baseMap from './_baseMap.js';\r\nimport isArray from './isArray.js';\r\n\r\n/**\r\n * Creates an array of values by running each element in `collection` thru\r\n * `iteratee`. The iteratee is invoked with three arguments:\r\n * (value, index|key, collection).\r\n *\r\n * Many lodash methods are guarded to work as iteratees for methods like\r\n * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.\r\n *\r\n * The guarded methods are:\r\n * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,\r\n * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,\r\n * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,\r\n * `template`, `trim`, `trimEnd`, `trimStart`, and `words`\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n * @returns {Array} Returns the new mapped array.\r\n * @example\r\n *\r\n * function square(n) {\r\n *   return n * n;\r\n * }\r\n *\r\n * _.map([4, 8], square);\r\n * // => [16, 64]\r\n *\r\n * _.map({ 'a': 4, 'b': 8 }, square);\r\n * // => [16, 64] (iteration order is not guaranteed)\r\n *\r\n * var users = [\r\n *   { 'user': 'barney' },\r\n *   { 'user': 'fred' }\r\n * ];\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.map(users, 'user');\r\n * // => ['barney', 'fred']\r\n */\r\nfunction map(collection, iteratee) {\r\n  var func = isArray(collection) ? arrayMap : baseMap;\r\n  return func(collection, baseIteratee(iteratee, 3));\r\n}\r\n\r\nexport default map;\r\n", "import baseFlatten from './_baseFlatten.js';\r\nimport map from './map.js';\r\n\r\n/**\r\n * Creates a flattened array of values by running each element in `collection`\r\n * thru `iteratee` and flattening the mapped results. The iteratee is invoked\r\n * with three arguments: (value, index|key, collection).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n * @returns {Array} Returns the new flattened array.\r\n * @example\r\n *\r\n * function duplicate(n) {\r\n *   return [n, n];\r\n * }\r\n *\r\n * _.flatMap([1, 2], duplicate);\r\n * // => [1, 1, 2, 2]\r\n */\r\nfunction flatMap(collection, iteratee) {\r\n  return baseFlatten(map(collection, iteratee), 1);\r\n}\r\n\r\nexport default flatMap;\r\n", "import baseAssignValue from './_baseAssignValue.js';\r\nimport createAggregator from './_createAggregator.js';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Creates an object composed of keys generated from the results of running\r\n * each element of `collection` thru `iteratee`. The order of grouped values\r\n * is determined by the order they occur in `collection`. The corresponding\r\n * value of each key is an array of elements responsible for generating the\r\n * key. The iteratee is invoked with one argument: (value).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [iteratee=_.identity] The iteratee to transform keys.\r\n * @returns {Object} Returns the composed aggregate object.\r\n * @example\r\n *\r\n * _.groupBy([6.1, 4.2, 6.3], Math.floor);\r\n * // => { '4': [4.2], '6': [6.1, 6.3] }\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.groupBy(['one', 'two', 'three'], 'length');\r\n * // => { '3': ['one', 'two'], '5': ['three'] }\r\n */\r\nvar groupBy = createAggregator(function(result, value, key) {\r\n  if (hasOwnProperty.call(result, key)) {\r\n    result[key].push(value);\r\n  } else {\r\n    baseAssignValue(result, key, [value]);\r\n  }\r\n});\r\n\r\nexport default groupBy;\r\n", "/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * The base implementation of `_.has` without support for deep paths.\r\n *\r\n * @private\r\n * @param {Object} [object] The object to query.\r\n * @param {Array|string} key The key to check.\r\n * @returns {boolean} Returns `true` if `key` exists, else `false`.\r\n */\r\nfunction baseHas(object, key) {\r\n  return object != null && hasOwnProperty.call(object, key);\r\n}\r\n\r\nexport default baseHas;\r\n", "import baseHas from './_baseHas.js';\r\nimport hasPath from './_hasPath.js';\r\n\r\n/**\r\n * Checks if `path` is a direct property of `object`.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @param {Array|string} path The path to check.\r\n * @returns {boolean} Returns `true` if `path` exists, else `false`.\r\n * @example\r\n *\r\n * var object = { 'a': { 'b': 2 } };\r\n * var other = _.create({ 'a': _.create({ 'b': 2 }) });\r\n *\r\n * _.has(object, 'a');\r\n * // => true\r\n *\r\n * _.has(object, 'a.b');\r\n * // => true\r\n *\r\n * _.has(object, ['a', 'b']);\r\n * // => true\r\n *\r\n * _.has(other, 'a');\r\n * // => false\r\n */\r\nfunction has(object, path) {\r\n  return object != null && hasPath(object, path, baseHas);\r\n}\r\n\r\nexport default has;\r\n", "import baseGetTag from './_baseGetTag.js';\r\nimport isArray from './isArray.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar stringTag = '[object String]';\r\n\r\n/**\r\n * Checks if `value` is classified as a `String` primitive or object.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a string, else `false`.\r\n * @example\r\n *\r\n * _.isString('abc');\r\n * // => true\r\n *\r\n * _.isString(1);\r\n * // => false\r\n */\r\nfunction isString(value) {\r\n  return typeof value == 'string' ||\r\n    (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);\r\n}\r\n\r\nexport default isString;\r\n", "import arrayMap from './_arrayMap.js';\r\n\r\n/**\r\n * The base implementation of `_.values` and `_.valuesIn` which creates an\r\n * array of `object` property values corresponding to the property names\r\n * of `props`.\r\n *\r\n * @private\r\n * @param {Object} object The object to query.\r\n * @param {Array} props The property names to get values for.\r\n * @returns {Object} Returns the array of property values.\r\n */\r\nfunction baseValues(object, props) {\r\n  return arrayMap(props, function(key) {\r\n    return object[key];\r\n  });\r\n}\r\n\r\nexport default baseValues;\r\n", "import baseValues from './_baseValues.js';\r\nimport keys from './keys.js';\r\n\r\n/**\r\n * Creates an array of the own enumerable string keyed property values of `object`.\r\n *\r\n * **Note:** Non-object values are coerced to objects.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Object\r\n * @param {Object} object The object to query.\r\n * @returns {Array} Returns the array of property values.\r\n * @example\r\n *\r\n * function Foo() {\r\n *   this.a = 1;\r\n *   this.b = 2;\r\n * }\r\n *\r\n * Foo.prototype.c = 3;\r\n *\r\n * _.values(new Foo);\r\n * // => [1, 2] (iteration order is not guaranteed)\r\n *\r\n * _.values('hi');\r\n * // => ['h', 'i']\r\n */\r\nfunction values(object) {\r\n  return object == null ? [] : baseValues(object, keys(object));\r\n}\r\n\r\nexport default values;\r\n", "import baseIndexOf from './_baseIndexOf.js';\r\nimport isArrayLike from './isArrayLike.js';\r\nimport isString from './isString.js';\r\nimport toInteger from './toInteger.js';\r\nimport values from './values.js';\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeMax = Math.max;\r\n\r\n/**\r\n * Checks if `value` is in `collection`. If `collection` is a string, it's\r\n * checked for a substring of `value`, otherwise\r\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * is used for equality comparisons. If `fromIndex` is negative, it's used as\r\n * the offset from the end of `collection`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object|string} collection The collection to inspect.\r\n * @param {*} value The value to search for.\r\n * @param {number} [fromIndex=0] The index to search from.\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.\r\n * @returns {boolean} Returns `true` if `value` is found, else `false`.\r\n * @example\r\n *\r\n * _.includes([1, 2, 3], 1);\r\n * // => true\r\n *\r\n * _.includes([1, 2, 3], 1, 2);\r\n * // => false\r\n *\r\n * _.includes({ 'a': 1, 'b': 2 }, 1);\r\n * // => true\r\n *\r\n * _.includes('abcd', 'bc');\r\n * // => true\r\n */\r\nfunction includes(collection, value, fromIndex, guard) {\r\n  collection = isArrayLike(collection) ? collection : values(collection);\r\n  fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;\r\n\r\n  var length = collection.length;\r\n  if (fromIndex < 0) {\r\n    fromIndex = nativeMax(length + fromIndex, 0);\r\n  }\r\n  return isString(collection)\r\n    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)\r\n    : (!!length && baseIndexOf(collection, value, fromIndex) > -1);\r\n}\r\n\r\nexport default includes;\r\n", "import baseIndexOf from './_baseIndexOf.js';\r\nimport toInteger from './toInteger.js';\r\n\r\n/* Built-in method references for those with the same name as other `lodash` methods. */\r\nvar nativeMax = Math.max;\r\n\r\n/**\r\n * Gets the index at which the first occurrence of `value` is found in `array`\r\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * for equality comparisons. If `fromIndex` is negative, it's used as the\r\n * offset from the end of `array`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to inspect.\r\n * @param {*} value The value to search for.\r\n * @param {number} [fromIndex=0] The index to search from.\r\n * @returns {number} Returns the index of the matched value, else `-1`.\r\n * @example\r\n *\r\n * _.indexOf([1, 2, 1, 2], 2);\r\n * // => 1\r\n *\r\n * // Search from the `fromIndex`.\r\n * _.indexOf([1, 2, 1, 2], 2, 2);\r\n * // => 3\r\n */\r\nfunction indexOf(array, value, fromIndex) {\r\n  var length = array == null ? 0 : array.length;\r\n  if (!length) {\r\n    return -1;\r\n  }\r\n  var index = fromIndex == null ? 0 : toInteger(fromIndex);\r\n  if (index < 0) {\r\n    index = nativeMax(length + index, 0);\r\n  }\r\n  return baseIndexOf(array, value, index);\r\n}\r\n\r\nexport default indexOf;\r\n", "import baseKeys from './_baseKeys.js';\r\nimport getTag from './_getTag.js';\r\nimport isArguments from './isArguments.js';\r\nimport isArray from './isArray.js';\r\nimport isArrayLike from './isArrayLike.js';\r\nimport isBuffer from './isBuffer.js';\r\nimport isPrototype from './_isPrototype.js';\r\nimport isTypedArray from './isTypedArray.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar mapTag = '[object Map]',\r\n    setTag = '[object Set]';\r\n\r\n/** Used for built-in method references. */\r\nvar objectProto = Object.prototype;\r\n\r\n/** Used to check objects for own properties. */\r\nvar hasOwnProperty = objectProto.hasOwnProperty;\r\n\r\n/**\r\n * Checks if `value` is an empty object, collection, map, or set.\r\n *\r\n * Objects are considered empty if they have no own enumerable string keyed\r\n * properties.\r\n *\r\n * Array-like values such as `arguments` objects, arrays, buffers, strings, or\r\n * jQuery-like collections are considered empty if they have a `length` of `0`.\r\n * Similarly, maps and sets are considered empty if they have a `size` of `0`.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is empty, else `false`.\r\n * @example\r\n *\r\n * _.isEmpty(null);\r\n * // => true\r\n *\r\n * _.isEmpty(true);\r\n * // => true\r\n *\r\n * _.isEmpty(1);\r\n * // => true\r\n *\r\n * _.isEmpty([1, 2, 3]);\r\n * // => false\r\n *\r\n * _.isEmpty({ 'a': 1 });\r\n * // => false\r\n */\r\nfunction isEmpty(value) {\r\n  if (value == null) {\r\n    return true;\r\n  }\r\n  if (isArrayLike(value) &&\r\n      (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||\r\n        isBuffer(value) || isTypedArray(value) || isArguments(value))) {\r\n    return !value.length;\r\n  }\r\n  var tag = getTag(value);\r\n  if (tag == mapTag || tag == setTag) {\r\n    return !value.size;\r\n  }\r\n  if (isPrototype(value)) {\r\n    return !baseKeys(value).length;\r\n  }\r\n  for (var key in value) {\r\n    if (hasOwnProperty.call(value, key)) {\r\n      return false;\r\n    }\r\n  }\r\n  return true;\r\n}\r\n\r\nexport default isEmpty;\r\n", "import baseGetTag from './_baseGetTag.js';\r\nimport isObjectLike from './isObjectLike.js';\r\n\r\n/** `Object#toString` result references. */\r\nvar regexpTag = '[object RegExp]';\r\n\r\n/**\r\n * The base implementation of `_.isRegExp` without Node.js optimizations.\r\n *\r\n * @private\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\r\n */\r\nfunction baseIsRegExp(value) {\r\n  return isObjectLike(value) && baseGetTag(value) == regexpTag;\r\n}\r\n\r\nexport default baseIsRegExp;\r\n", "import baseIsRegExp from './_baseIsRegExp.js';\r\nimport baseUnary from './_baseUnary.js';\r\nimport nodeUtil from './_nodeUtil.js';\r\n\r\n/* Node.js helper references. */\r\nvar nodeIsRegExp = nodeUtil && nodeUtil.isRegExp;\r\n\r\n/**\r\n * Checks if `value` is classified as a `RegExp` object.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.\r\n * @example\r\n *\r\n * _.isRegExp(/abc/);\r\n * // => true\r\n *\r\n * _.isRegExp('/abc/');\r\n * // => false\r\n */\r\nvar isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;\r\n\r\nexport default isRegExp;\r\n", "/**\r\n * Checks if `value` is `undefined`.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Lang\r\n * @param {*} value The value to check.\r\n * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.\r\n * @example\r\n *\r\n * _.isUndefined(void 0);\r\n * // => true\r\n *\r\n * _.isUndefined(null);\r\n * // => false\r\n */\r\nfunction isUndefined(value) {\r\n  return value === undefined;\r\n}\r\n\r\nexport default isUndefined;\r\n", "/**\r\n * The base implementation of `_.lt` which doesn't coerce arguments.\r\n *\r\n * @private\r\n * @param {*} value The value to compare.\r\n * @param {*} other The other value to compare.\r\n * @returns {boolean} Returns `true` if `value` is less than `other`,\r\n *  else `false`.\r\n */\r\nfunction baseLt(value, other) {\r\n  return value < other;\r\n}\r\n\r\nexport default baseLt;\r\n", "import isSymbol from './isSymbol.js';\r\n\r\n/**\r\n * The base implementation of methods like `_.max` and `_.min` which accepts a\r\n * `comparator` to determine the extremum value.\r\n *\r\n * @private\r\n * @param {Array} array The array to iterate over.\r\n * @param {Function} iteratee The iteratee invoked per iteration.\r\n * @param {Function} comparator The comparator used to compare values.\r\n * @returns {*} Returns the extremum value.\r\n */\r\nfunction baseExtremum(array, iteratee, comparator) {\r\n  var index = -1,\r\n      length = array.length;\r\n\r\n  while (++index < length) {\r\n    var value = array[index],\r\n        current = iteratee(value);\r\n\r\n    if (current != null && (computed === undefined\r\n          ? (current === current && !isSymbol(current))\r\n          : comparator(current, computed)\r\n        )) {\r\n      var computed = current,\r\n          result = value;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseExtremum;\r\n", "import baseExtremum from './_baseExtremum.js';\r\nimport baseLt from './_baseLt.js';\r\nimport identity from './identity.js';\r\n\r\n/**\r\n * Computes the minimum value of `array`. If `array` is empty or falsey,\r\n * `undefined` is returned.\r\n *\r\n * @static\r\n * @since 0.1.0\r\n * @memberOf _\r\n * @category Math\r\n * @param {Array} array The array to iterate over.\r\n * @returns {*} Returns the minimum value.\r\n * @example\r\n *\r\n * _.min([4, 2, 8, 6]);\r\n * // => 2\r\n *\r\n * _.min([]);\r\n * // => undefined\r\n */\r\nfunction min(array) {\r\n  return (array && array.length)\r\n    ? baseExtremum(array, identity, baseLt)\r\n    : undefined;\r\n}\r\n\r\nexport default min;\r\n", "/** Error message constants. */\r\nvar FUNC_ERROR_TEXT = 'Expected a function';\r\n\r\n/**\r\n * Creates a function that negates the result of the predicate `func`. The\r\n * `func` predicate is invoked with the `this` binding and arguments of the\r\n * created function.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 3.0.0\r\n * @category Function\r\n * @param {Function} predicate The predicate to negate.\r\n * @returns {Function} Returns the new negated function.\r\n * @example\r\n *\r\n * function isEven(n) {\r\n *   return n % 2 == 0;\r\n * }\r\n *\r\n * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));\r\n * // => [1, 3, 5]\r\n */\r\nfunction negate(predicate) {\r\n  if (typeof predicate != 'function') {\r\n    throw new TypeError(FUNC_ERROR_TEXT);\r\n  }\r\n  return function() {\r\n    var args = arguments;\r\n    switch (args.length) {\r\n      case 0: return !predicate.call(this);\r\n      case 1: return !predicate.call(this, args[0]);\r\n      case 2: return !predicate.call(this, args[0], args[1]);\r\n      case 3: return !predicate.call(this, args[0], args[1], args[2]);\r\n    }\r\n    return !predicate.apply(this, args);\r\n  };\r\n}\r\n\r\nexport default negate;\r\n", "import assignValue from './_assignValue.js';\r\nimport castPath from './_castPath.js';\r\nimport isIndex from './_isIndex.js';\r\nimport isObject from './isObject.js';\r\nimport toKey from './_toKey.js';\r\n\r\n/**\r\n * The base implementation of `_.set`.\r\n *\r\n * @private\r\n * @param {Object} object The object to modify.\r\n * @param {Array|string} path The path of the property to set.\r\n * @param {*} value The value to set.\r\n * @param {Function} [customizer] The function to customize path creation.\r\n * @returns {Object} Returns `object`.\r\n */\r\nfunction baseSet(object, path, value, customizer) {\r\n  if (!isObject(object)) {\r\n    return object;\r\n  }\r\n  path = castPath(path, object);\r\n\r\n  var index = -1,\r\n      length = path.length,\r\n      lastIndex = length - 1,\r\n      nested = object;\r\n\r\n  while (nested != null && ++index < length) {\r\n    var key = toKey(path[index]),\r\n        newValue = value;\r\n\r\n    if (key === '__proto__' || key === 'constructor' || key === 'prototype') {\r\n      return object;\r\n    }\r\n\r\n    if (index != lastIndex) {\r\n      var objValue = nested[key];\r\n      newValue = customizer ? customizer(objValue, key, nested) : undefined;\r\n      if (newValue === undefined) {\r\n        newValue = isObject(objValue)\r\n          ? objValue\r\n          : (isIndex(path[index + 1]) ? [] : {});\r\n      }\r\n    }\r\n    assignValue(nested, key, newValue);\r\n    nested = nested[key];\r\n  }\r\n  return object;\r\n}\r\n\r\nexport default baseSet;\r\n", "import baseGet from './_baseGet.js';\r\nimport baseSet from './_baseSet.js';\r\nimport castPath from './_castPath.js';\r\n\r\n/**\r\n * The base implementation of  `_.pickBy` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Object} object The source object.\r\n * @param {string[]} paths The property paths to pick.\r\n * @param {Function} predicate The function invoked per property.\r\n * @returns {Object} Returns the new object.\r\n */\r\nfunction basePickBy(object, paths, predicate) {\r\n  var index = -1,\r\n      length = paths.length,\r\n      result = {};\r\n\r\n  while (++index < length) {\r\n    var path = paths[index],\r\n        value = baseGet(object, path);\r\n\r\n    if (predicate(value, path)) {\r\n      baseSet(result, castPath(path, object), value);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default basePickBy;\r\n", "import arrayMap from './_arrayMap.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport basePickBy from './_basePickBy.js';\r\nimport getAllKeysIn from './_getAllKeysIn.js';\r\n\r\n/**\r\n * Creates an object composed of the `object` properties `predicate` returns\r\n * truthy for. The predicate is invoked with two arguments: (value, key).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Object\r\n * @param {Object} object The source object.\r\n * @param {Function} [predicate=_.identity] The function invoked per property.\r\n * @returns {Object} Returns the new object.\r\n * @example\r\n *\r\n * var object = { 'a': 1, 'b': '2', 'c': 3 };\r\n *\r\n * _.pickBy(object, _.isNumber);\r\n * // => { 'a': 1, 'c': 3 }\r\n */\r\nfunction pickBy(object, predicate) {\r\n  if (object == null) {\r\n    return {};\r\n  }\r\n  var props = arrayMap(getAllKeysIn(object), function(prop) {\r\n    return [prop];\r\n  });\r\n  predicate = baseIteratee(predicate);\r\n  return basePickBy(object, props, function(value, path) {\r\n    return predicate(value, path[0]);\r\n  });\r\n}\r\n\r\nexport default pickBy;\r\n", "/**\r\n * The base implementation of `_.reduce` and `_.reduceRight`, without support\r\n * for iteratee shorthands, which iterates over `collection` using `eachFunc`.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} iteratee The function invoked per iteration.\r\n * @param {*} accumulator The initial value.\r\n * @param {boolean} initAccum Specify using the first or last element of\r\n *  `collection` as the initial value.\r\n * @param {Function} eachFunc The function to iterate over `collection`.\r\n * @returns {*} Returns the accumulated value.\r\n */\r\nfunction baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {\r\n  eachFunc(collection, function(value, index, collection) {\r\n    accumulator = initAccum\r\n      ? (initAccum = false, value)\r\n      : iteratee(accumulator, value, index, collection);\r\n  });\r\n  return accumulator;\r\n}\r\n\r\nexport default baseReduce;\r\n", "import arrayReduce from './_arrayReduce.js';\r\nimport baseEach from './_baseEach.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport baseReduce from './_baseReduce.js';\r\nimport isArray from './isArray.js';\r\n\r\n/**\r\n * Reduces `collection` to a value which is the accumulated result of running\r\n * each element in `collection` thru `iteratee`, where each successive\r\n * invocation is supplied the return value of the previous. If `accumulator`\r\n * is not given, the first element of `collection` is used as the initial\r\n * value. The iteratee is invoked with four arguments:\r\n * (accumulator, value, index|key, collection).\r\n *\r\n * Many lodash methods are guarded to work as iteratees for methods like\r\n * `_.reduce`, `_.reduceRight`, and `_.transform`.\r\n *\r\n * The guarded methods are:\r\n * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,\r\n * and `sortBy`\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [iteratee=_.identity] The function invoked per iteration.\r\n * @param {*} [accumulator] The initial value.\r\n * @returns {*} Returns the accumulated value.\r\n * @see _.reduceRight\r\n * @example\r\n *\r\n * _.reduce([1, 2], function(sum, n) {\r\n *   return sum + n;\r\n * }, 0);\r\n * // => 3\r\n *\r\n * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {\r\n *   (result[value] || (result[value] = [])).push(key);\r\n *   return result;\r\n * }, {});\r\n * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)\r\n */\r\nfunction reduce(collection, iteratee, accumulator) {\r\n  var func = isArray(collection) ? arrayReduce : baseReduce,\r\n      initAccum = arguments.length < 3;\r\n\r\n  return func(collection, baseIteratee(iteratee, 4), accumulator, initAccum, baseEach);\r\n}\r\n\r\nexport default reduce;\r\n", "import arrayFilter from './_arrayFilter.js';\r\nimport baseFilter from './_baseFilter.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport isArray from './isArray.js';\r\nimport negate from './negate.js';\r\n\r\n/**\r\n * The opposite of `_.filter`; this method returns the elements of `collection`\r\n * that `predicate` does **not** return truthy for.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n * @returns {Array} Returns the new filtered array.\r\n * @see _.filter\r\n * @example\r\n *\r\n * var users = [\r\n *   { 'user': 'barney', 'age': 36, 'active': false },\r\n *   { 'user': 'fred',   'age': 40, 'active': true }\r\n * ];\r\n *\r\n * _.reject(users, function(o) { return !o.active; });\r\n * // => objects for ['fred']\r\n *\r\n * // The `_.matches` iteratee shorthand.\r\n * _.reject(users, { 'age': 40, 'active': true });\r\n * // => objects for ['barney']\r\n *\r\n * // The `_.matchesProperty` iteratee shorthand.\r\n * _.reject(users, ['active', false]);\r\n * // => objects for ['fred']\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.reject(users, 'active');\r\n * // => objects for ['barney']\r\n */\r\nfunction reject(collection, predicate) {\r\n  var func = isArray(collection) ? arrayFilter : baseFilter;\r\n  return func(collection, negate(baseIteratee(predicate, 3)));\r\n}\r\n\r\nexport default reject;\r\n", "import baseEach from './_baseEach.js';\r\n\r\n/**\r\n * The base implementation of `_.some` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} predicate The function invoked per iteration.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n *  else `false`.\r\n */\r\nfunction baseSome(collection, predicate) {\r\n  var result;\r\n\r\n  baseEach(collection, function(value, index, collection) {\r\n    result = predicate(value, index, collection);\r\n    return !result;\r\n  });\r\n  return !!result;\r\n}\r\n\r\nexport default baseSome;\r\n", "import arraySome from './_arraySome.js';\r\nimport baseIteratee from './_baseIteratee.js';\r\nimport baseSome from './_baseSome.js';\r\nimport isArray from './isArray.js';\r\nimport isIterateeCall from './_isIterateeCall.js';\r\n\r\n/**\r\n * Checks if `predicate` returns truthy for **any** element of `collection`.\r\n * Iteration is stopped once `predicate` returns truthy. The predicate is\r\n * invoked with three arguments: (value, index|key, collection).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Collection\r\n * @param {Array|Object} collection The collection to iterate over.\r\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\r\n * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.\r\n * @returns {boolean} Returns `true` if any element passes the predicate check,\r\n *  else `false`.\r\n * @example\r\n *\r\n * _.some([null, 0, 'yes', false], Boolean);\r\n * // => true\r\n *\r\n * var users = [\r\n *   { 'user': 'barney', 'active': true },\r\n *   { 'user': 'fred',   'active': false }\r\n * ];\r\n *\r\n * // The `_.matches` iteratee shorthand.\r\n * _.some(users, { 'user': 'barney', 'active': false });\r\n * // => false\r\n *\r\n * // The `_.matchesProperty` iteratee shorthand.\r\n * _.some(users, ['active', false]);\r\n * // => true\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.some(users, 'active');\r\n * // => true\r\n */\r\nfunction some(collection, predicate, guard) {\r\n  var func = isArray(collection) ? arraySome : baseSome;\r\n  if (guard && isIterateeCall(collection, predicate, guard)) {\r\n    predicate = undefined;\r\n  }\r\n  return func(collection, baseIteratee(predicate, 3));\r\n}\r\n\r\nexport default some;\r\n", "import Set from './_Set.js';\r\nimport noop from './noop.js';\r\nimport setToArray from './_setToArray.js';\r\n\r\n/** Used as references for various `Number` constants. */\r\nvar INFINITY = 1 / 0;\r\n\r\n/**\r\n * Creates a set object of `values`.\r\n *\r\n * @private\r\n * @param {Array} values The values to add to the set.\r\n * @returns {Object} Returns the new set.\r\n */\r\nvar createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {\r\n  return new Set(values);\r\n};\r\n\r\nexport default createSet;\r\n", "import SetCache from './_SetCache.js';\r\nimport arrayIncludes from './_arrayIncludes.js';\r\nimport arrayIncludesWith from './_arrayIncludesWith.js';\r\nimport cacheHas from './_cacheHas.js';\r\nimport createSet from './_createSet.js';\r\nimport setToArray from './_setToArray.js';\r\n\r\n/** Used as the size to enable large array optimizations. */\r\nvar LARGE_ARRAY_SIZE = 200;\r\n\r\n/**\r\n * The base implementation of `_.uniqBy` without support for iteratee shorthands.\r\n *\r\n * @private\r\n * @param {Array} array The array to inspect.\r\n * @param {Function} [iteratee] The iteratee invoked per element.\r\n * @param {Function} [comparator] The comparator invoked per element.\r\n * @returns {Array} Returns the new duplicate free array.\r\n */\r\nfunction baseUniq(array, iteratee, comparator) {\r\n  var index = -1,\r\n      includes = arrayIncludes,\r\n      length = array.length,\r\n      isCommon = true,\r\n      result = [],\r\n      seen = result;\r\n\r\n  if (comparator) {\r\n    isCommon = false;\r\n    includes = arrayIncludesWith;\r\n  }\r\n  else if (length >= LARGE_ARRAY_SIZE) {\r\n    var set = iteratee ? null : createSet(array);\r\n    if (set) {\r\n      return setToArray(set);\r\n    }\r\n    isCommon = false;\r\n    includes = cacheHas;\r\n    seen = new SetCache;\r\n  }\r\n  else {\r\n    seen = iteratee ? [] : result;\r\n  }\r\n  outer:\r\n  while (++index < length) {\r\n    var value = array[index],\r\n        computed = iteratee ? iteratee(value) : value;\r\n\r\n    value = (comparator || value !== 0) ? value : 0;\r\n    if (isCommon && computed === computed) {\r\n      var seenIndex = seen.length;\r\n      while (seenIndex--) {\r\n        if (seen[seenIndex] === computed) {\r\n          continue outer;\r\n        }\r\n      }\r\n      if (iteratee) {\r\n        seen.push(computed);\r\n      }\r\n      result.push(value);\r\n    }\r\n    else if (!includes(seen, computed, comparator)) {\r\n      if (seen !== result) {\r\n        seen.push(computed);\r\n      }\r\n      result.push(value);\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport default baseUniq;\r\n", "import baseUniq from './_baseUniq.js';\r\n\r\n/**\r\n * Creates a duplicate-free version of an array, using\r\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\r\n * for equality comparisons, in which only the first occurrence of each element\r\n * is kept. The order of result values is determined by the order they occur\r\n * in the array.\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 0.1.0\r\n * @category Array\r\n * @param {Array} array The array to inspect.\r\n * @returns {Array} Returns the new duplicate free array.\r\n * @example\r\n *\r\n * _.uniq([2, 1, 2]);\r\n * // => [2, 1]\r\n */\r\nfunction uniq(array) {\r\n  return (array && array.length) ? baseUniq(array) : [];\r\n}\r\n\r\nexport default uniq;\r\n", "import baseIteratee from './_baseIteratee.js';\r\nimport baseUniq from './_baseUniq.js';\r\n\r\n/**\r\n * This method is like `_.uniq` except that it accepts `iteratee` which is\r\n * invoked for each element in `array` to generate the criterion by which\r\n * uniqueness is computed. The order of result values is determined by the\r\n * order they occur in the array. The iteratee is invoked with one argument:\r\n * (value).\r\n *\r\n * @static\r\n * @memberOf _\r\n * @since 4.0.0\r\n * @category Array\r\n * @param {Array} array The array to inspect.\r\n * @param {Function} [iteratee=_.identity] The iteratee invoked per element.\r\n * @returns {Array} Returns the new duplicate free array.\r\n * @example\r\n *\r\n * _.uniqBy([2.1, 1.2, 2.3], Math.floor);\r\n * // => [2.1, 1.2]\r\n *\r\n * // The `_.property` iteratee shorthand.\r\n * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');\r\n * // => [{ 'x': 1 }, { 'x': 2 }]\r\n */\r\nfunction uniqBy(array, iteratee) {\r\n  return (array && array.length) ? baseUniq(array, baseIteratee(iteratee, 2)) : [];\r\n}\r\n\r\nexport default uniqBy;\r\n", "export function PRINT_ERROR(msg: string) {\r\n  /* istanbul ignore else - can't override global.console in node.js */\r\n  if (console && console.error) {\r\n    console.error(`Error: ${msg}`);\r\n  }\r\n}\r\n\r\nexport function PRINT_WARNING(msg: string) {\r\n  /* istanbul ignore else - can't override global.console in node.js*/\r\n  if (console && console.warn) {\r\n    // TODO: modify docs accordingly\r\n    console.warn(`Warning: ${msg}`);\r\n  }\r\n}\r\n", "export function timer<T>(func: () => T): { time: number; value: T } {\r\n  const start = new Date().getTime();\r\n  const val = func();\r\n  const end = new Date().getTime();\r\n  const total = end - start;\r\n  return { time: total, value: val };\r\n}\r\n", "// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216\r\nexport function toFastProperties(toBecomeFast: any) {\r\n  function FakeConstructor() {}\r\n\r\n  // If our object is used as a constructor, it would receive\r\n  FakeConstructor.prototype = toBecomeFast;\r\n  const fakeInstance = new (FakeConstructor as any)();\r\n\r\n  function fakeAccess() {\r\n    return typeof fakeInstance.bar;\r\n  }\r\n\r\n  // help V8 understand this is a \"real\" prototype by actually using\r\n  // the fake instance.\r\n  fakeAccess();\r\n  fakeAccess();\r\n\r\n  // Always true condition to suppress the Firefox warning of unreachable\r\n  // code after a return statement.\r\n  if (1) return toBecomeFast;\r\n\r\n  // Eval prevents optimization of this method (even though this is dead code)\r\n  // - https://esbuild.github.io/content-types/#direct-eval\r\n  /* istanbul ignore next */\r\n  // tslint:disable-next-line\r\n  (0, eval)(toBecomeFast);\r\n}\r\n", "import { assign, forEach, isRegExp, isString, map, pickBy } from \"lodash-es\";\r\nimport type {\r\n  IGASTVisitor,\r\n  IProduction,\r\n  IProductionWithOccurrence,\r\n  ISerializedGast,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\n\r\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\r\nfunction tokenLabel(tokType: TokenType): string {\r\n  if (hasTokenLabel(tokType)) {\r\n    return tokType.LABEL;\r\n  } else {\r\n    return tokType.name;\r\n  }\r\n}\r\n\r\n// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?\r\nfunction hasTokenLabel(\r\n  obj: TokenType,\r\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\r\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\r\n}\r\n\r\nexport abstract class AbstractProduction<T extends IProduction = IProduction>\r\n  implements IProduction\r\n{\r\n  public get definition(): T[] {\r\n    return this._definition;\r\n  }\r\n  public set definition(value: T[]) {\r\n    this._definition = value;\r\n  }\r\n\r\n  constructor(protected _definition: T[]) {}\r\n\r\n  accept(visitor: IGASTVisitor): void {\r\n    visitor.visit(this);\r\n    forEach(this.definition, (prod) => {\r\n      prod.accept(visitor);\r\n    });\r\n  }\r\n}\r\n\r\nexport class NonTerminal\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public nonTerminalName!: string;\r\n  public label?: string;\r\n  public referencedRule!: Rule;\r\n  public idx: number = 1;\r\n\r\n  constructor(options: {\r\n    nonTerminalName: string;\r\n    label?: string;\r\n    referencedRule?: Rule;\r\n    idx?: number;\r\n  }) {\r\n    super([]);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n\r\n  set definition(definition: IProduction[]) {\r\n    // immutable\r\n  }\r\n\r\n  get definition(): IProduction[] {\r\n    if (this.referencedRule !== undefined) {\r\n      return this.referencedRule.definition;\r\n    }\r\n    return [];\r\n  }\r\n\r\n  accept(visitor: IGASTVisitor): void {\r\n    visitor.visit(this);\r\n    // don't visit children of a reference, we will get cyclic infinite loops if we do so\r\n  }\r\n}\r\n\r\nexport class Rule extends AbstractProduction {\r\n  public name!: string;\r\n  public orgText: string = \"\";\r\n\r\n  constructor(options: {\r\n    name: string;\r\n    definition: IProduction[];\r\n    orgText?: string;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Alternative extends AbstractProduction {\r\n  public ignoreAmbiguities: boolean = false;\r\n\r\n  constructor(options: {\r\n    definition: IProduction[];\r\n    ignoreAmbiguities?: boolean;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Option\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public idx: number = 1;\r\n  public maxLookahead?: number;\r\n\r\n  constructor(options: {\r\n    definition: IProduction[];\r\n    idx?: number;\r\n    maxLookahead?: number;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class RepetitionMandatory\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public idx: number = 1;\r\n  public maxLookahead?: number;\r\n\r\n  constructor(options: {\r\n    definition: IProduction[];\r\n    idx?: number;\r\n    maxLookahead?: number;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class RepetitionMandatoryWithSeparator\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public separator!: TokenType;\r\n  public idx: number = 1;\r\n  public maxLookahead?: number;\r\n\r\n  constructor(options: {\r\n    definition: IProduction[];\r\n    separator: TokenType;\r\n    idx?: number;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Repetition\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public separator!: TokenType;\r\n  public idx: number = 1;\r\n  public maxLookahead?: number;\r\n\r\n  constructor(options: {\r\n    definition: IProduction[];\r\n    idx?: number;\r\n    maxLookahead?: number;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class RepetitionWithSeparator\r\n  extends AbstractProduction\r\n  implements IProductionWithOccurrence\r\n{\r\n  public separator!: TokenType;\r\n  public idx: number = 1;\r\n  public maxLookahead?: number;\r\n\r\n  constructor(options: {\r\n    definition: IProduction[];\r\n    separator: TokenType;\r\n    idx?: number;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Alternation\r\n  extends AbstractProduction<Alternative>\r\n  implements IProductionWithOccurrence\r\n{\r\n  public idx: number = 1;\r\n  public ignoreAmbiguities: boolean = false;\r\n  public hasPredicates: boolean = false;\r\n  public maxLookahead?: number;\r\n\r\n  public get definition(): Alternative[] {\r\n    return this._definition;\r\n  }\r\n  public set definition(value: Alternative[]) {\r\n    this._definition = value;\r\n  }\r\n\r\n  constructor(options: {\r\n    definition: Alternative[];\r\n    idx?: number;\r\n    ignoreAmbiguities?: boolean;\r\n    hasPredicates?: boolean;\r\n    maxLookahead?: number;\r\n  }) {\r\n    super(options.definition);\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n}\r\n\r\nexport class Terminal implements IProductionWithOccurrence {\r\n  public terminalType!: TokenType;\r\n  public label?: string;\r\n  public idx: number = 1;\r\n\r\n  constructor(options: {\r\n    terminalType: TokenType;\r\n    label?: string;\r\n    idx?: number;\r\n  }) {\r\n    assign(\r\n      this,\r\n      pickBy(options, (v) => v !== undefined),\r\n    );\r\n  }\r\n\r\n  accept(visitor: IGASTVisitor): void {\r\n    visitor.visit(this);\r\n  }\r\n}\r\n\r\nexport interface ISerializedBasic extends ISerializedGast {\r\n  type:\r\n    | \"Alternative\"\r\n    | \"Option\"\r\n    | \"RepetitionMandatory\"\r\n    | \"Repetition\"\r\n    | \"Alternation\";\r\n  idx?: number;\r\n}\r\n\r\nexport interface ISerializedGastRule extends ISerializedGast {\r\n  type: \"Rule\";\r\n  name: string;\r\n  orgText: string;\r\n}\r\n\r\nexport interface ISerializedNonTerminal extends ISerializedGast {\r\n  type: \"NonTerminal\";\r\n  name: string;\r\n  label?: string;\r\n  idx: number;\r\n}\r\n\r\nexport interface ISerializedTerminal extends ISerializedGast {\r\n  type: \"Terminal\";\r\n  name: string;\r\n  terminalLabel?: string;\r\n  label?: string;\r\n  pattern?: string;\r\n  idx: number;\r\n}\r\n\r\nexport interface ISerializedTerminalWithSeparator extends ISerializedGast {\r\n  type: \"RepetitionMandatoryWithSeparator\" | \"RepetitionWithSeparator\";\r\n  idx: number;\r\n  separator: ISerializedTerminal;\r\n}\r\n\r\nexport type ISerializedGastAny =\r\n  | ISerializedBasic\r\n  | ISerializedGastRule\r\n  | ISerializedNonTerminal\r\n  | ISerializedTerminal\r\n  | ISerializedTerminalWithSeparator;\r\n\r\nexport function serializeGrammar(topRules: Rule[]): ISerializedGast[] {\r\n  return map(topRules, serializeProduction);\r\n}\r\n\r\nexport function serializeProduction(node: IProduction): ISerializedGast {\r\n  function convertDefinition(definition: IProduction[]): ISerializedGast[] {\r\n    return map(definition, serializeProduction);\r\n  }\r\n  /* istanbul ignore else */\r\n  if (node instanceof NonTerminal) {\r\n    const serializedNonTerminal: ISerializedNonTerminal = {\r\n      type: \"NonTerminal\",\r\n      name: node.nonTerminalName,\r\n      idx: node.idx,\r\n    };\r\n\r\n    if (isString(node.label)) {\r\n      serializedNonTerminal.label = node.label;\r\n    }\r\n\r\n    return serializedNonTerminal;\r\n  } else if (node instanceof Alternative) {\r\n    return <ISerializedBasic>{\r\n      type: \"Alternative\",\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof Option) {\r\n    return <ISerializedBasic>{\r\n      type: \"Option\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof RepetitionMandatory) {\r\n    return <ISerializedBasic>{\r\n      type: \"RepetitionMandatory\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof RepetitionMandatoryWithSeparator) {\r\n    return <ISerializedTerminalWithSeparator>{\r\n      type: \"RepetitionMandatoryWithSeparator\",\r\n      idx: node.idx,\r\n      separator: <ISerializedTerminal>(\r\n        serializeProduction(new Terminal({ terminalType: node.separator }))\r\n      ),\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof RepetitionWithSeparator) {\r\n    return <ISerializedTerminalWithSeparator>{\r\n      type: \"RepetitionWithSeparator\",\r\n      idx: node.idx,\r\n      separator: <ISerializedTerminal>(\r\n        serializeProduction(new Terminal({ terminalType: node.separator }))\r\n      ),\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof Repetition) {\r\n    return <ISerializedBasic>{\r\n      type: \"Repetition\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof Alternation) {\r\n    return <ISerializedBasic>{\r\n      type: \"Alternation\",\r\n      idx: node.idx,\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n  } else if (node instanceof Terminal) {\r\n    const serializedTerminal = <ISerializedTerminal>{\r\n      type: \"Terminal\",\r\n      name: node.terminalType.name,\r\n      label: tokenLabel(node.terminalType),\r\n      idx: node.idx,\r\n    };\r\n\r\n    if (isString(node.label)) {\r\n      serializedTerminal.terminalLabel = node.label;\r\n    }\r\n\r\n    const pattern = node.terminalType.PATTERN;\r\n    if (node.terminalType.PATTERN) {\r\n      serializedTerminal.pattern = isRegExp(pattern)\r\n        ? (<any>pattern).source\r\n        : pattern;\r\n    }\r\n\r\n    return serializedTerminal;\r\n  } else if (node instanceof Rule) {\r\n    return <ISerializedGastRule>{\r\n      type: \"Rule\",\r\n      name: node.name,\r\n      orgText: node.orgText,\r\n      definition: convertDefinition(node.definition),\r\n    };\r\n    /* c8 ignore next 3 */\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n", "import {\r\n  Alternation,\r\n  Alternative,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n  Terminal,\r\n} from \"./model.js\";\r\nimport type { IProduction } from \"@chevrotain/types\";\r\n\r\nexport abstract class GAstVisitor {\r\n  public visit(node: IProduction): any {\r\n    const nodeAny: any = node;\r\n    switch (nodeAny.constructor) {\r\n      case NonTerminal:\r\n        return this.visitNonTerminal(nodeAny);\r\n      case Alternative:\r\n        return this.visitAlternative(nodeAny);\r\n      case Option:\r\n        return this.visitOption(nodeAny);\r\n      case RepetitionMandatory:\r\n        return this.visitRepetitionMandatory(nodeAny);\r\n      case RepetitionMandatoryWithSeparator:\r\n        return this.visitRepetitionMandatoryWithSeparator(nodeAny);\r\n      case RepetitionWithSeparator:\r\n        return this.visitRepetitionWithSeparator(nodeAny);\r\n      case Repetition:\r\n        return this.visitRepetition(nodeAny);\r\n      case Alternation:\r\n        return this.visitAlternation(nodeAny);\r\n      case Terminal:\r\n        return this.visitTerminal(nodeAny);\r\n      case Rule:\r\n        return this.visitRule(nodeAny);\r\n      /* c8 ignore next 2 */\r\n      default:\r\n        throw Error(\"non exhaustive match\");\r\n    }\r\n  }\r\n\r\n  /* c8 ignore next */\r\n  public visitNonTerminal(node: NonTerminal): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitAlternative(node: Alternative): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitOption(node: Option): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitRepetition(node: Repetition): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitRepetitionMandatory(node: RepetitionMandatory): any {}\r\n\r\n  /* c8 ignore next 3 */\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    node: RepetitionMandatoryWithSeparator,\r\n  ): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitAlternation(node: Alternation): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitTerminal(node: Terminal): any {}\r\n\r\n  /* c8 ignore next */\r\n  public visitRule(node: Rule): any {}\r\n}\r\n", "import { every, includes, some } from \"lodash-es\";\r\nimport {\r\n  AbstractProduction,\r\n  Alternation,\r\n  Alternative,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n  Terminal,\r\n} from \"./model.js\";\r\nimport type { IProduction, IProductionWithOccurrence } from \"@chevrotain/types\";\r\n\r\nexport function isSequenceProd(\r\n  prod: IProduction,\r\n): prod is { definition: IProduction[] } & IProduction {\r\n  return (\r\n    prod instanceof Alternative ||\r\n    prod instanceof Option ||\r\n    prod instanceof Repetition ||\r\n    prod instanceof RepetitionMandatory ||\r\n    prod instanceof RepetitionMandatoryWithSeparator ||\r\n    prod instanceof RepetitionWithSeparator ||\r\n    prod instanceof Terminal ||\r\n    prod instanceof Rule\r\n  );\r\n}\r\n\r\nexport function isOptionalProd(\r\n  prod: IProduction,\r\n  alreadyVisited: NonTerminal[] = [],\r\n): boolean {\r\n  const isDirectlyOptional =\r\n    prod instanceof Option ||\r\n    prod instanceof Repetition ||\r\n    prod instanceof RepetitionWithSeparator;\r\n  if (isDirectlyOptional) {\r\n    return true;\r\n  }\r\n\r\n  // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another\r\n  // empty optional top rule\r\n  // may be indirectly optional ((A?B?C?) | (D?E?F?))\r\n  if (prod instanceof Alternation) {\r\n    // for OR its enough for just one of the alternatives to be optional\r\n    return some((<Alternation>prod).definition, (subProd: IProduction) => {\r\n      return isOptionalProd(subProd, alreadyVisited);\r\n    });\r\n  } else if (prod instanceof NonTerminal && includes(alreadyVisited, prod)) {\r\n    // avoiding stack overflow due to infinite recursion\r\n    return false;\r\n  } else if (prod instanceof AbstractProduction) {\r\n    if (prod instanceof NonTerminal) {\r\n      alreadyVisited.push(prod);\r\n    }\r\n    return every(\r\n      (<AbstractProduction>prod).definition,\r\n      (subProd: IProduction) => {\r\n        return isOptionalProd(subProd, alreadyVisited);\r\n      },\r\n    );\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\nexport function isBranchingProd(\r\n  prod: IProduction,\r\n): prod is { definition: IProduction[] } & IProduction {\r\n  return prod instanceof Alternation;\r\n}\r\n\r\nexport function getProductionDslName(prod: IProductionWithOccurrence): string {\r\n  /* istanbul ignore else */\r\n  if (prod instanceof NonTerminal) {\r\n    return \"SUBRULE\";\r\n  } else if (prod instanceof Option) {\r\n    return \"OPTION\";\r\n  } else if (prod instanceof Alternation) {\r\n    return \"OR\";\r\n  } else if (prod instanceof RepetitionMandatory) {\r\n    return \"AT_LEAST_ONE\";\r\n  } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n    return \"AT_LEAST_ONE_SEP\";\r\n  } else if (prod instanceof RepetitionWithSeparator) {\r\n    return \"MANY_SEP\";\r\n  } else if (prod instanceof Repetition) {\r\n    return \"MANY\";\r\n  } else if (prod instanceof Terminal) {\r\n    return \"CONSUME\";\r\n    /* c8 ignore next 3 */\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n", "import { drop, forEach } from \"lodash-es\";\r\nimport {\r\n  Alternation,\r\n  Alternative,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Terminal,\r\n} from \"@chevrotain/gast\";\r\nimport { IProduction } from \"@chevrotain/types\";\r\n\r\n/**\r\n *  A Grammar Walker that computes the \"remaining\" grammar \"after\" a productions in the grammar.\r\n */\r\nexport abstract class RestWalker {\r\n  walk(prod: { definition: IProduction[] }, prevRest: any[] = []): void {\r\n    forEach(prod.definition, (subProd: IProduction, index) => {\r\n      const currRest = drop(prod.definition, index + 1);\r\n      /* istanbul ignore else */\r\n      if (subProd instanceof NonTerminal) {\r\n        this.walkProdRef(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof Terminal) {\r\n        this.walkTerminal(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof Alternative) {\r\n        this.walkFlat(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof Option) {\r\n        this.walkOption(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof RepetitionMandatory) {\r\n        this.walkAtLeastOne(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof RepetitionMandatoryWithSeparator) {\r\n        this.walkAtLeastOneSep(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof RepetitionWithSeparator) {\r\n        this.walkManySep(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof Repetition) {\r\n        this.walkMany(subProd, currRest, prevRest);\r\n      } else if (subProd instanceof Alternation) {\r\n        this.walkOr(subProd, currRest, prevRest);\r\n      } else {\r\n        throw Error(\"non exhaustive match\");\r\n      }\r\n    });\r\n  }\r\n\r\n  walkTerminal(\r\n    terminal: Terminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {}\r\n\r\n  walkProdRef(\r\n    refProd: NonTerminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {}\r\n\r\n  walkFlat(\r\n    flatProd: Alternative,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABCDEF => after the D the rest is EF\r\n    const fullOrRest = currRest.concat(prevRest);\r\n    this.walk(flatProd, <any>fullOrRest);\r\n  }\r\n\r\n  walkOption(\r\n    optionProd: Option,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABC(DE)?F => after the (DE)? the rest is F\r\n    const fullOrRest = currRest.concat(prevRest);\r\n    this.walk(optionProd, <any>fullOrRest);\r\n  }\r\n\r\n  walkAtLeastOne(\r\n    atLeastOneProd: RepetitionMandatory,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABC(DE)+F => after the (DE)+ the rest is (DE)?F\r\n    const fullAtLeastOneRest: IProduction[] = [\r\n      new Option({ definition: atLeastOneProd.definition }),\r\n    ].concat(<any>currRest, <any>prevRest);\r\n    this.walk(atLeastOneProd, fullAtLeastOneRest);\r\n  }\r\n\r\n  walkAtLeastOneSep(\r\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F\r\n    const fullAtLeastOneSepRest = restForRepetitionWithSeparator(\r\n      atLeastOneSepProd,\r\n      currRest,\r\n      prevRest,\r\n    );\r\n    this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);\r\n  }\r\n\r\n  walkMany(\r\n    manyProd: Repetition,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABC(DE)*F => after the (DE)* the rest is (DE)?F\r\n    const fullManyRest: IProduction[] = [\r\n      new Option({ definition: manyProd.definition }),\r\n    ].concat(<any>currRest, <any>prevRest);\r\n    this.walk(manyProd, fullManyRest);\r\n  }\r\n\r\n  walkManySep(\r\n    manySepProd: RepetitionWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F\r\n    const fullManySepRest = restForRepetitionWithSeparator(\r\n      manySepProd,\r\n      currRest,\r\n      prevRest,\r\n    );\r\n    this.walk(manySepProd, fullManySepRest);\r\n  }\r\n\r\n  walkOr(\r\n    orProd: Alternation,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // ABC(D|E|F)G => when finding the (D|E|F) the rest is G\r\n    const fullOrRest = currRest.concat(prevRest);\r\n    // walk all different alternatives\r\n    forEach(orProd.definition, (alt) => {\r\n      // wrapping each alternative in a single definition wrapper\r\n      // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows\r\n      // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1\r\n      const prodWrapper = new Alternative({ definition: [alt] });\r\n      this.walk(prodWrapper, <any>fullOrRest);\r\n    });\r\n  }\r\n}\r\n\r\nfunction restForRepetitionWithSeparator(\r\n  repSepProd: RepetitionWithSeparator,\r\n  currRest: IProduction[],\r\n  prevRest: IProduction[],\r\n) {\r\n  const repSepRest = [\r\n    new Option({\r\n      definition: [\r\n        new Terminal({ terminalType: repSepProd.separator }) as IProduction,\r\n      ].concat(repSepProd.definition),\r\n    }) as IProduction,\r\n  ];\r\n  const fullRepSepRest: IProduction[] = repSepRest.concat(currRest, prevRest);\r\n  return fullRepSepRest;\r\n}\r\n", "import { flatten, map, uniq } from \"lodash-es\";\r\nimport {\r\n  isBranchingProd,\r\n  isOptionalProd,\r\n  isSequenceProd,\r\n  NonTerminal,\r\n  Terminal,\r\n} from \"@chevrotain/gast\";\r\nimport { IProduction, TokenType } from \"@chevrotain/types\";\r\n\r\nexport function first(prod: IProduction): TokenType[] {\r\n  /* istanbul ignore else */\r\n  if (prod instanceof NonTerminal) {\r\n    // this could in theory cause infinite loops if\r\n    // (1) prod A refs prod B.\r\n    // (2) prod B refs prod A\r\n    // (3) AB can match the empty set\r\n    // in other words a cycle where everything is optional so the first will keep\r\n    // looking ahead for the next optional part and will never exit\r\n    // currently there is no safeguard for this unique edge case because\r\n    // (1) not sure a grammar in which this can happen is useful for anything (productive)\r\n    return first((<NonTerminal>prod).referencedRule);\r\n  } else if (prod instanceof Terminal) {\r\n    return firstForTerminal(<Terminal>prod);\r\n  } else if (isSequenceProd(prod)) {\r\n    return firstForSequence(prod);\r\n  } else if (isBranchingProd(prod)) {\r\n    return firstForBranching(prod);\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n\r\nexport function firstForSequence(prod: {\r\n  definition: IProduction[];\r\n}): TokenType[] {\r\n  let firstSet: TokenType[] = [];\r\n  const seq = prod.definition;\r\n  let nextSubProdIdx = 0;\r\n  let hasInnerProdsRemaining = seq.length > nextSubProdIdx;\r\n  let currSubProd;\r\n  // so we enter the loop at least once (if the definition is not empty\r\n  let isLastInnerProdOptional = true;\r\n  // scan a sequence until it's end or until we have found a NONE optional production in it\r\n  while (hasInnerProdsRemaining && isLastInnerProdOptional) {\r\n    currSubProd = seq[nextSubProdIdx];\r\n    isLastInnerProdOptional = isOptionalProd(currSubProd);\r\n    firstSet = firstSet.concat(first(currSubProd));\r\n    nextSubProdIdx = nextSubProdIdx + 1;\r\n    hasInnerProdsRemaining = seq.length > nextSubProdIdx;\r\n  }\r\n\r\n  return uniq(firstSet);\r\n}\r\n\r\nexport function firstForBranching(prod: {\r\n  definition: IProduction[];\r\n}): TokenType[] {\r\n  const allAlternativesFirsts: TokenType[][] = map(\r\n    prod.definition,\r\n    (innerProd) => {\r\n      return first(innerProd);\r\n    },\r\n  );\r\n  return uniq(flatten<TokenType>(allAlternativesFirsts));\r\n}\r\n\r\nexport function firstForTerminal(terminal: Terminal): TokenType[] {\r\n  return [terminal.terminalType];\r\n}\r\n", "// TODO: can this be removed? where is it used?\r\nexport const IN = \"_~IN~_\";\r\n", "import { RestWalker } from \"./rest.js\";\r\nimport { first } from \"./first.js\";\r\nimport { assign, forEach } from \"lodash-es\";\r\nimport { IN } from \"../constants.js\";\r\nimport { Alternative, NonTerminal, Rule, Terminal } from \"@chevrotain/gast\";\r\nimport { IProduction, TokenType } from \"@chevrotain/types\";\r\n\r\n// This ResyncFollowsWalker computes all of the follows required for RESYNC\r\n// (skipping reference production).\r\nexport class ResyncFollowsWalker extends RestWalker {\r\n  public follows: Record<string, TokenType[]> = {};\r\n\r\n  constructor(private topProd: Rule) {\r\n    super();\r\n  }\r\n\r\n  startWalking(): Record<string, TokenType[]> {\r\n    this.walk(this.topProd);\r\n    return this.follows;\r\n  }\r\n\r\n  walkTerminal(\r\n    terminal: Terminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // do nothing! just like in the public sector after 13:00\r\n  }\r\n\r\n  walkProdRef(\r\n    refProd: NonTerminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    const followName =\r\n      buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +\r\n      this.topProd.name;\r\n    const fullRest: IProduction[] = currRest.concat(prevRest);\r\n    const restProd = new Alternative({ definition: fullRest });\r\n    const t_in_topProd_follows = first(restProd);\r\n    this.follows[followName] = t_in_topProd_follows;\r\n  }\r\n}\r\n\r\nexport function computeAllProdsFollows(\r\n  topProductions: Rule[],\r\n): Record<string, TokenType[]> {\r\n  const reSyncFollows = {};\r\n\r\n  forEach(topProductions, (topProd) => {\r\n    const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();\r\n    assign(reSyncFollows, currRefsFollow);\r\n  });\r\n  return reSyncFollows;\r\n}\r\n\r\nexport function buildBetweenProdsFollowPrefix(\r\n  inner: Rule,\r\n  occurenceInParent: number,\r\n): string {\r\n  return inner.name + occurenceInParent + IN;\r\n}\r\n\r\nexport function buildInProdFollowPrefix(terminal: Terminal): string {\r\n  const terminalName = terminal.terminalType.name;\r\n  return terminalName + terminal.idx + IN;\r\n}\r\n", "import {\r\n  Alternative,\r\n  Assertion,\r\n  Atom,\r\n  Disjunction,\r\n  RegExpParser,\r\n  RegExpPattern,\r\n} from \"@chevrotain/regexp-to-ast\";\r\n\r\nlet regExpAstCache: { [regex: string]: RegExpPattern } = {};\r\nconst regExpParser = new RegExpParser();\r\n\r\n// this should be moved to regexp-to-ast\r\nexport type ASTNode =\r\n  | RegExpPattern\r\n  | Disjunction\r\n  | Alternative\r\n  | Assertion\r\n  | Atom;\r\n\r\nexport function getRegExpAst(regExp: RegExp): RegExpPattern {\r\n  const regExpStr = regExp.toString();\r\n  if (regExpAstCache.hasOwnProperty(regExpStr)) {\r\n    return regExpAstCache[regExpStr];\r\n  } else {\r\n    const regExpAst = regExpParser.pattern(regExpStr);\r\n    regExpAstCache[regExpStr] = regExpAst;\r\n    return regExpAst;\r\n  }\r\n}\r\n\r\nexport function clearRegExpParserCache() {\r\n  regExpAstCache = {};\r\n}\r\n", "import {\r\n  Alternative,\r\n  Atom,\r\n  BaseRegExpVisitor,\r\n  Character,\r\n  Disjunction,\r\n  Group,\r\n  Set,\r\n} from \"@chevrotain/regexp-to-ast\";\r\nimport { every, find, forEach, includes, isArray, values } from \"lodash-es\";\r\nimport { PRINT_ERROR, PRINT_WARNING } from \"@chevrotain/utils\";\r\nimport { ASTNode, getRegExpAst } from \"./reg_exp_parser.js\";\r\nimport { charCodeToOptimizedIndex, minOptimizationVal } from \"./lexer.js\";\r\n\r\nconst complementErrorMessage =\r\n  \"Complement Sets are not supported for first char optimization\";\r\nexport const failedOptimizationPrefixMsg =\r\n  'Unable to use \"first char\" lexer optimizations:\\n';\r\n\r\nexport function getOptimizedStartCodesIndices(\r\n  regExp: RegExp,\r\n  ensureOptimizations = false,\r\n): number[] {\r\n  try {\r\n    const ast = getRegExpAst(regExp);\r\n    const firstChars = firstCharOptimizedIndices(\r\n      ast.value,\r\n      {},\r\n      ast.flags.ignoreCase,\r\n    );\r\n    return firstChars;\r\n  } catch (e) {\r\n    /* istanbul ignore next */\r\n    // Testing this relies on the regexp-to-ast library having a bug... */\r\n    // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc\r\n    if (e.message === complementErrorMessage) {\r\n      if (ensureOptimizations) {\r\n        PRINT_WARNING(\r\n          `${failedOptimizationPrefixMsg}` +\r\n            `\\tUnable to optimize: < ${regExp.toString()} >\\n` +\r\n            \"\\tComplement Sets cannot be automatically optimized.\\n\" +\r\n            \"\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n            \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.\",\r\n        );\r\n      }\r\n    } else {\r\n      let msgSuffix = \"\";\r\n      if (ensureOptimizations) {\r\n        msgSuffix =\r\n          \"\\n\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n          \"\\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.\";\r\n      }\r\n      PRINT_ERROR(\r\n        `${failedOptimizationPrefixMsg}\\n` +\r\n          `\\tFailed parsing: < ${regExp.toString()} >\\n` +\r\n          `\\tUsing the @chevrotain/regexp-to-ast library\\n` +\r\n          \"\\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues\" +\r\n          msgSuffix,\r\n      );\r\n    }\r\n  }\r\n\r\n  return [];\r\n}\r\n\r\nexport function firstCharOptimizedIndices(\r\n  ast: ASTNode,\r\n  result: { [charCode: number]: number },\r\n  ignoreCase: boolean,\r\n): number[] {\r\n  switch (ast.type) {\r\n    case \"Disjunction\":\r\n      for (let i = 0; i < ast.value.length; i++) {\r\n        firstCharOptimizedIndices(ast.value[i], result, ignoreCase);\r\n      }\r\n      break;\r\n    case \"Alternative\":\r\n      const terms = ast.value;\r\n      for (let i = 0; i < terms.length; i++) {\r\n        const term = terms[i];\r\n\r\n        // skip terms that cannot effect the first char results\r\n        switch (term.type) {\r\n          case \"EndAnchor\":\r\n          // A group back reference cannot affect potential starting char.\r\n          // because if a back reference is the first production than automatically\r\n          // the group being referenced has had to come BEFORE so its codes have already been added\r\n          case \"GroupBackReference\":\r\n          // assertions do not affect potential starting codes\r\n          case \"Lookahead\":\r\n          case \"NegativeLookahead\":\r\n          case \"StartAnchor\":\r\n          case \"WordBoundary\":\r\n          case \"NonWordBoundary\":\r\n            continue;\r\n        }\r\n\r\n        const atom = term;\r\n        switch (atom.type) {\r\n          case \"Character\":\r\n            addOptimizedIdxToResult(atom.value, result, ignoreCase);\r\n            break;\r\n          case \"Set\":\r\n            if (atom.complement === true) {\r\n              throw Error(complementErrorMessage);\r\n            }\r\n            forEach(atom.value, (code) => {\r\n              if (typeof code === \"number\") {\r\n                addOptimizedIdxToResult(code, result, ignoreCase);\r\n              } else {\r\n                // range\r\n                const range = code as any;\r\n                // cannot optimize when ignoreCase is\r\n                if (ignoreCase === true) {\r\n                  for (\r\n                    let rangeCode = range.from;\r\n                    rangeCode <= range.to;\r\n                    rangeCode++\r\n                  ) {\r\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\r\n                  }\r\n                }\r\n                // Optimization (2 orders of magnitude less work for very large ranges)\r\n                else {\r\n                  // handle unoptimized values\r\n                  for (\r\n                    let rangeCode = range.from;\r\n                    rangeCode <= range.to && rangeCode < minOptimizationVal;\r\n                    rangeCode++\r\n                  ) {\r\n                    addOptimizedIdxToResult(rangeCode, result, ignoreCase);\r\n                  }\r\n\r\n                  // Less common charCode where we optimize for faster init time, by using larger \"buckets\"\r\n                  if (range.to >= minOptimizationVal) {\r\n                    const minUnOptVal =\r\n                      range.from >= minOptimizationVal\r\n                        ? range.from\r\n                        : minOptimizationVal;\r\n                    const maxUnOptVal = range.to;\r\n                    const minOptIdx = charCodeToOptimizedIndex(minUnOptVal);\r\n                    const maxOptIdx = charCodeToOptimizedIndex(maxUnOptVal);\r\n\r\n                    for (\r\n                      let currOptIdx = minOptIdx;\r\n                      currOptIdx <= maxOptIdx;\r\n                      currOptIdx++\r\n                    ) {\r\n                      result[currOptIdx] = currOptIdx;\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            });\r\n            break;\r\n          case \"Group\":\r\n            firstCharOptimizedIndices(atom.value, result, ignoreCase);\r\n            break;\r\n          /* istanbul ignore next */\r\n          default:\r\n            throw Error(\"Non Exhaustive Match\");\r\n        }\r\n\r\n        // reached a mandatory production, no more **start** codes can be found on this alternative\r\n        const isOptionalQuantifier =\r\n          atom.quantifier !== undefined && atom.quantifier.atLeast === 0;\r\n        if (\r\n          // A group may be optional due to empty contents /(?:)/\r\n          // or if everything inside it is optional /((a)?)/\r\n          (atom.type === \"Group\" && isWholeOptional(atom) === false) ||\r\n          // If this term is not a group it may only be optional if it has an optional quantifier\r\n          (atom.type !== \"Group\" && isOptionalQuantifier === false)\r\n        ) {\r\n          break;\r\n        }\r\n      }\r\n      break;\r\n    /* istanbul ignore next */\r\n    default:\r\n      throw Error(\"non exhaustive match!\");\r\n  }\r\n\r\n  // console.log(Object.keys(result).length)\r\n  return values(result);\r\n}\r\n\r\nfunction addOptimizedIdxToResult(\r\n  code: number,\r\n  result: { [charCode: number]: number },\r\n  ignoreCase: boolean,\r\n) {\r\n  const optimizedCharIdx = charCodeToOptimizedIndex(code);\r\n  result[optimizedCharIdx] = optimizedCharIdx;\r\n\r\n  if (ignoreCase === true) {\r\n    handleIgnoreCase(code, result);\r\n  }\r\n}\r\n\r\nfunction handleIgnoreCase(\r\n  code: number,\r\n  result: { [charCode: number]: number },\r\n) {\r\n  const char = String.fromCharCode(code);\r\n  const upperChar = char.toUpperCase();\r\n  /* istanbul ignore else */\r\n  if (upperChar !== char) {\r\n    const optimizedCharIdx = charCodeToOptimizedIndex(upperChar.charCodeAt(0));\r\n    result[optimizedCharIdx] = optimizedCharIdx;\r\n  } else {\r\n    const lowerChar = char.toLowerCase();\r\n    if (lowerChar !== char) {\r\n      const optimizedCharIdx = charCodeToOptimizedIndex(\r\n        lowerChar.charCodeAt(0),\r\n      );\r\n      result[optimizedCharIdx] = optimizedCharIdx;\r\n    }\r\n  }\r\n}\r\n\r\nfunction findCode(setNode: Set, targetCharCodes: number[]) {\r\n  return find(setNode.value, (codeOrRange) => {\r\n    if (typeof codeOrRange === \"number\") {\r\n      return includes(targetCharCodes, codeOrRange);\r\n    } else {\r\n      // range\r\n      const range = <any>codeOrRange;\r\n      return (\r\n        find(\r\n          targetCharCodes,\r\n          (targetCode) => range.from <= targetCode && targetCode <= range.to,\r\n        ) !== undefined\r\n      );\r\n    }\r\n  });\r\n}\r\n\r\nfunction isWholeOptional(ast: any): boolean {\r\n  const quantifier = (ast as Atom).quantifier;\r\n  if (quantifier && quantifier.atLeast === 0) {\r\n    return true;\r\n  }\r\n\r\n  if (!ast.value) {\r\n    return false;\r\n  }\r\n\r\n  return isArray(ast.value)\r\n    ? every(ast.value, isWholeOptional)\r\n    : isWholeOptional(ast.value);\r\n}\r\n\r\nclass CharCodeFinder extends BaseRegExpVisitor {\r\n  found: boolean = false;\r\n\r\n  constructor(private targetCharCodes: number[]) {\r\n    super();\r\n  }\r\n\r\n  visitChildren(node: ASTNode) {\r\n    // No need to keep looking...\r\n    if (this.found === true) {\r\n      return;\r\n    }\r\n\r\n    // switch lookaheads as they do not actually consume any characters thus\r\n    // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.\r\n    switch (node.type) {\r\n      case \"Lookahead\":\r\n        this.visitLookahead(node);\r\n        return;\r\n      case \"NegativeLookahead\":\r\n        this.visitNegativeLookahead(node);\r\n        return;\r\n    }\r\n\r\n    super.visitChildren(node);\r\n  }\r\n\r\n  visitCharacter(node: Character) {\r\n    if (includes(this.targetCharCodes, node.value)) {\r\n      this.found = true;\r\n    }\r\n  }\r\n\r\n  visitSet(node: Set) {\r\n    if (node.complement) {\r\n      if (findCode(node, this.targetCharCodes) === undefined) {\r\n        this.found = true;\r\n      }\r\n    } else {\r\n      if (findCode(node, this.targetCharCodes) !== undefined) {\r\n        this.found = true;\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function canMatchCharCode(\r\n  charCodes: number[],\r\n  pattern: RegExp | string,\r\n) {\r\n  if (pattern instanceof RegExp) {\r\n    const ast = getRegExpAst(pattern);\r\n    const charCodeFinder = new CharCodeFinder(charCodes);\r\n    charCodeFinder.visit(ast);\r\n    return charCodeFinder.found;\r\n  } else {\r\n    return (\r\n      find(<any>pattern, (char) => {\r\n        return includes(charCodes, (<string>char).charCodeAt(0));\r\n      }) !== undefined\r\n    );\r\n  }\r\n}\r\n", "import { BaseRegExpVisitor } from \"@chevrotain/regexp-to-ast\";\r\nimport {\r\n  IRegExpExec,\r\n  Lexer,\r\n  LexerDefinitionErrorType,\r\n} from \"./lexer_public.js\";\r\nimport {\r\n  compact,\r\n  defaults,\r\n  difference,\r\n  filter,\r\n  find,\r\n  first,\r\n  flatten,\r\n  forEach,\r\n  has,\r\n  includes,\r\n  indexOf,\r\n  isArray,\r\n  isEmpty,\r\n  isFunction,\r\n  isRegExp,\r\n  isString,\r\n  isUndefined,\r\n  keys,\r\n  map,\r\n  reduce,\r\n  reject,\r\n  values,\r\n} from \"lodash-es\";\r\nimport { PRINT_ERROR } from \"@chevrotain/utils\";\r\nimport {\r\n  canMatchCharCode,\r\n  failedOptimizationPrefixMsg,\r\n  getOptimizedStartCodesIndices,\r\n} from \"./reg_exp.js\";\r\nimport {\r\n  ILexerDefinitionError,\r\n  ILineTerminatorsTester,\r\n  IMultiModeLexerDefinition,\r\n  IToken,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport { getRegExpAst } from \"./reg_exp_parser.js\";\r\n\r\nconst PATTERN = \"PATTERN\";\r\nexport const DEFAULT_MODE = \"defaultMode\";\r\nexport const MODES = \"modes\";\r\n\r\nexport interface IPatternConfig {\r\n  pattern: IRegExpExec | string;\r\n  longerAlt: number[] | undefined;\r\n  canLineTerminator: boolean;\r\n  isCustom: boolean;\r\n  short: number | false;\r\n  group: string | undefined | false;\r\n  push: string | undefined;\r\n  pop: boolean;\r\n  tokenType: TokenType;\r\n  tokenTypeIdx: number;\r\n}\r\n\r\nexport interface IAnalyzeResult {\r\n  patternIdxToConfig: IPatternConfig[];\r\n  charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] };\r\n  emptyGroups: { [groupName: string]: IToken[] };\r\n  hasCustom: boolean;\r\n  canBeOptimized: boolean;\r\n}\r\n\r\nexport let SUPPORT_STICKY =\r\n  typeof (<any>new RegExp(\"(?:)\")).sticky === \"boolean\";\r\n\r\nexport function disableSticky() {\r\n  SUPPORT_STICKY = false;\r\n}\r\n\r\nexport function enableSticky() {\r\n  SUPPORT_STICKY = true;\r\n}\r\n\r\nexport function analyzeTokenTypes(\r\n  tokenTypes: TokenType[],\r\n  options: {\r\n    positionTracking?: \"full\" | \"onlyStart\" | \"onlyOffset\";\r\n    ensureOptimizations?: boolean;\r\n    lineTerminatorCharacters?: (number | string)[];\r\n    // TODO: should `useSticky` be an argument here?\r\n    useSticky?: boolean;\r\n    safeMode?: boolean;\r\n    tracer?: (msg: string, action: () => void) => void;\r\n  },\r\n): IAnalyzeResult {\r\n  options = defaults(options, {\r\n    useSticky: SUPPORT_STICKY,\r\n    debug: false as boolean,\r\n    safeMode: false as boolean,\r\n    positionTracking: \"full\",\r\n    lineTerminatorCharacters: [\"\\r\", \"\\n\"],\r\n    tracer: (msg: string, action: Function) => action(),\r\n  });\r\n\r\n  const tracer = options.tracer!;\r\n\r\n  tracer(\"initCharCodeToOptimizedIndexMap\", () => {\r\n    initCharCodeToOptimizedIndexMap();\r\n  });\r\n\r\n  let onlyRelevantTypes: TokenType[];\r\n  tracer(\"Reject Lexer.NA\", () => {\r\n    onlyRelevantTypes = reject(tokenTypes, (currType) => {\r\n      return currType[PATTERN] === Lexer.NA;\r\n    });\r\n  });\r\n\r\n  let hasCustom = false;\r\n  let allTransformedPatterns: (IRegExpExec | string)[];\r\n  tracer(\"Transform Patterns\", () => {\r\n    hasCustom = false;\r\n    allTransformedPatterns = map(\r\n      onlyRelevantTypes,\r\n      (currType): IRegExpExec | string => {\r\n        const currPattern = currType[PATTERN];\r\n\r\n        /* istanbul ignore else */\r\n        if (isRegExp(currPattern)) {\r\n          const regExpSource = currPattern.source;\r\n          if (\r\n            regExpSource.length === 1 &&\r\n            // only these regExp meta characters which can appear in a length one regExp\r\n            regExpSource !== \"^\" &&\r\n            regExpSource !== \"$\" &&\r\n            regExpSource !== \".\" &&\r\n            !currPattern.ignoreCase\r\n          ) {\r\n            return regExpSource;\r\n          } else if (\r\n            regExpSource.length === 2 &&\r\n            regExpSource[0] === \"\\\\\" &&\r\n            // not a meta character\r\n            !includes(\r\n              [\r\n                \"d\",\r\n                \"D\",\r\n                \"s\",\r\n                \"S\",\r\n                \"t\",\r\n                \"r\",\r\n                \"n\",\r\n                \"t\",\r\n                \"0\",\r\n                \"c\",\r\n                \"b\",\r\n                \"B\",\r\n                \"f\",\r\n                \"v\",\r\n                \"w\",\r\n                \"W\",\r\n              ],\r\n              regExpSource[1],\r\n            )\r\n          ) {\r\n            // escaped meta Characters: /\\+/ /\\[/\r\n            // or redundant escaping: /\\a/\r\n            // without the escaping \"\\\"\r\n            return regExpSource[1];\r\n          } else {\r\n            return options.useSticky\r\n              ? addStickyFlag(currPattern)\r\n              : addStartOfInput(currPattern);\r\n          }\r\n        } else if (isFunction(currPattern)) {\r\n          hasCustom = true;\r\n          // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\r\n          return { exec: currPattern };\r\n        } else if (typeof currPattern === \"object\") {\r\n          hasCustom = true;\r\n          // ICustomPattern\r\n          return currPattern;\r\n        } else if (typeof currPattern === \"string\") {\r\n          if (currPattern.length === 1) {\r\n            return currPattern;\r\n          } else {\r\n            const escapedRegExpString = currPattern.replace(\r\n              /[\\\\^$.*+?()[\\]{}|]/g,\r\n              \"\\\\$&\",\r\n            );\r\n            const wrappedRegExp = new RegExp(escapedRegExpString);\r\n            return options.useSticky\r\n              ? addStickyFlag(wrappedRegExp)\r\n              : addStartOfInput(wrappedRegExp);\r\n          }\r\n        } else {\r\n          throw Error(\"non exhaustive match\");\r\n        }\r\n      },\r\n    );\r\n  });\r\n\r\n  let patternIdxToType: number[];\r\n  let patternIdxToGroup: (string | undefined | false)[];\r\n  let patternIdxToLongerAltIdxArr: (number[] | undefined)[];\r\n  let patternIdxToPushMode: (string | undefined)[];\r\n  let patternIdxToPopMode: boolean[];\r\n  tracer(\"misc mapping\", () => {\r\n    patternIdxToType = map(\r\n      onlyRelevantTypes,\r\n      (currType) => currType.tokenTypeIdx!,\r\n    );\r\n\r\n    patternIdxToGroup = map(onlyRelevantTypes, (clazz: any) => {\r\n      const groupName = clazz.GROUP;\r\n      /* istanbul ignore next */\r\n      if (groupName === Lexer.SKIPPED) {\r\n        return undefined;\r\n      } else if (isString(groupName)) {\r\n        return groupName;\r\n      } else if (isUndefined(groupName)) {\r\n        return false;\r\n      } else {\r\n        throw Error(\"non exhaustive match\");\r\n      }\r\n    });\r\n\r\n    patternIdxToLongerAltIdxArr = map(onlyRelevantTypes, (clazz: any) => {\r\n      const longerAltType = clazz.LONGER_ALT;\r\n\r\n      if (longerAltType) {\r\n        const longerAltIdxArr = isArray(longerAltType)\r\n          ? map(longerAltType, (type: any) => indexOf(onlyRelevantTypes, type))\r\n          : [indexOf(onlyRelevantTypes, longerAltType)];\r\n        return longerAltIdxArr;\r\n      }\r\n    });\r\n\r\n    patternIdxToPushMode = map(\r\n      onlyRelevantTypes,\r\n      (clazz: any) => clazz.PUSH_MODE,\r\n    );\r\n\r\n    patternIdxToPopMode = map(onlyRelevantTypes, (clazz: any) =>\r\n      has(clazz, \"POP_MODE\"),\r\n    );\r\n  });\r\n\r\n  let patternIdxToCanLineTerminator: boolean[];\r\n  tracer(\"Line Terminator Handling\", () => {\r\n    const lineTerminatorCharCodes = getCharCodes(\r\n      options.lineTerminatorCharacters!,\r\n    );\r\n    patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => false);\r\n    if (options.positionTracking !== \"onlyOffset\") {\r\n      patternIdxToCanLineTerminator = map(onlyRelevantTypes, (tokType) => {\r\n        if (has(tokType, \"LINE_BREAKS\")) {\r\n          return !!tokType.LINE_BREAKS;\r\n        } else {\r\n          return (\r\n            checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&\r\n            canMatchCharCode(\r\n              lineTerminatorCharCodes,\r\n              tokType.PATTERN as RegExp | string,\r\n            )\r\n          );\r\n        }\r\n      });\r\n    }\r\n  });\r\n\r\n  let patternIdxToIsCustom: boolean[];\r\n  let patternIdxToShort: (number | false)[];\r\n  let emptyGroups!: { [groupName: string]: IToken[] };\r\n  let patternIdxToConfig!: IPatternConfig[];\r\n  tracer(\"Misc Mapping #2\", () => {\r\n    patternIdxToIsCustom = map(onlyRelevantTypes, isCustomPattern);\r\n    patternIdxToShort = map(allTransformedPatterns, isShortPattern);\r\n\r\n    emptyGroups = reduce(\r\n      onlyRelevantTypes,\r\n      (acc, clazz: any) => {\r\n        const groupName = clazz.GROUP;\r\n        if (isString(groupName) && !(groupName === Lexer.SKIPPED)) {\r\n          acc[groupName] = [];\r\n        }\r\n        return acc;\r\n      },\r\n      {} as { [groupName: string]: IToken[] },\r\n    );\r\n\r\n    patternIdxToConfig = map(\r\n      allTransformedPatterns,\r\n      (x, idx): IPatternConfig => {\r\n        return {\r\n          pattern: allTransformedPatterns[idx],\r\n          longerAlt: patternIdxToLongerAltIdxArr[idx],\r\n          canLineTerminator: patternIdxToCanLineTerminator[idx],\r\n          isCustom: patternIdxToIsCustom[idx],\r\n          short: patternIdxToShort[idx],\r\n          group: patternIdxToGroup[idx],\r\n          push: patternIdxToPushMode[idx],\r\n          pop: patternIdxToPopMode[idx],\r\n          tokenTypeIdx: patternIdxToType[idx],\r\n          tokenType: onlyRelevantTypes[idx],\r\n        };\r\n      },\r\n    );\r\n  });\r\n\r\n  let canBeOptimized = true;\r\n  let charCodeToPatternIdxToConfig: { [charCode: number]: IPatternConfig[] } =\r\n    [];\r\n\r\n  if (!options.safeMode) {\r\n    tracer(\"First Char Optimization\", () => {\r\n      charCodeToPatternIdxToConfig = reduce(\r\n        onlyRelevantTypes,\r\n        (result, currTokType, idx) => {\r\n          if (typeof currTokType.PATTERN === \"string\") {\r\n            const charCode = currTokType.PATTERN.charCodeAt(0);\r\n            const optimizedIdx = charCodeToOptimizedIndex(charCode);\r\n            addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);\r\n          } else if (isArray(currTokType.START_CHARS_HINT)) {\r\n            let lastOptimizedIdx: number;\r\n            forEach(currTokType.START_CHARS_HINT, (charOrInt) => {\r\n              const charCode =\r\n                typeof charOrInt === \"string\"\r\n                  ? charOrInt.charCodeAt(0)\r\n                  : charOrInt;\r\n              const currOptimizedIdx = charCodeToOptimizedIndex(charCode);\r\n              // Avoid adding the config multiple times\r\n              /* istanbul ignore else */\r\n              // - Difficult to check this scenario effects as it is only a performance\r\n              //   optimization that does not change correctness\r\n              if (lastOptimizedIdx !== currOptimizedIdx) {\r\n                lastOptimizedIdx = currOptimizedIdx;\r\n                addToMapOfArrays(\r\n                  result,\r\n                  currOptimizedIdx,\r\n                  patternIdxToConfig[idx],\r\n                );\r\n              }\r\n            });\r\n          } else if (isRegExp(currTokType.PATTERN)) {\r\n            if (currTokType.PATTERN.unicode) {\r\n              canBeOptimized = false;\r\n              if (options.ensureOptimizations) {\r\n                PRINT_ERROR(\r\n                  `${failedOptimizationPrefixMsg}` +\r\n                    `\\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\\n` +\r\n                    \"\\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\\n\" +\r\n                    \"\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n                    \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE\",\r\n                );\r\n              }\r\n            } else {\r\n              const optimizedCodes = getOptimizedStartCodesIndices(\r\n                currTokType.PATTERN,\r\n                options.ensureOptimizations,\r\n              );\r\n              /* istanbul ignore if */\r\n              // start code will only be empty given an empty regExp or failure of regexp-to-ast library\r\n              // the first should be a different validation and the second cannot be tested.\r\n              if (isEmpty(optimizedCodes)) {\r\n                // we cannot understand what codes may start possible matches\r\n                // The optimization correctness requires knowing start codes for ALL patterns.\r\n                // Not actually sure this is an error, no debug message\r\n                canBeOptimized = false;\r\n              }\r\n              forEach(optimizedCodes, (code) => {\r\n                addToMapOfArrays(result, code, patternIdxToConfig[idx]);\r\n              });\r\n            }\r\n          } else {\r\n            if (options.ensureOptimizations) {\r\n              PRINT_ERROR(\r\n                `${failedOptimizationPrefixMsg}` +\r\n                  `\\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\\n` +\r\n                  \"\\tThis will disable the lexer's first char optimizations.\\n\" +\r\n                  \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE\",\r\n              );\r\n            }\r\n            canBeOptimized = false;\r\n          }\r\n\r\n          return result;\r\n        },\r\n        [] as { [charCode: number]: IPatternConfig[] },\r\n      );\r\n    });\r\n  }\r\n\r\n  return {\r\n    emptyGroups: emptyGroups,\r\n    patternIdxToConfig: patternIdxToConfig,\r\n    charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,\r\n    hasCustom: hasCustom,\r\n    canBeOptimized: canBeOptimized,\r\n  };\r\n}\r\n\r\nexport function validatePatterns(\r\n  tokenTypes: TokenType[],\r\n  validModesNames: string[],\r\n): ILexerDefinitionError[] {\r\n  let errors: ILexerDefinitionError[] = [];\r\n\r\n  const missingResult = findMissingPatterns(tokenTypes);\r\n  errors = errors.concat(missingResult.errors);\r\n\r\n  const invalidResult = findInvalidPatterns(missingResult.valid);\r\n  const validTokenTypes = invalidResult.valid;\r\n  errors = errors.concat(invalidResult.errors);\r\n\r\n  errors = errors.concat(validateRegExpPattern(validTokenTypes));\r\n\r\n  errors = errors.concat(findInvalidGroupType(validTokenTypes));\r\n\r\n  errors = errors.concat(\r\n    findModesThatDoNotExist(validTokenTypes, validModesNames),\r\n  );\r\n\r\n  errors = errors.concat(findUnreachablePatterns(validTokenTypes));\r\n\r\n  return errors;\r\n}\r\n\r\nfunction validateRegExpPattern(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  let errors: ILexerDefinitionError[] = [];\r\n  const withRegExpPatterns = filter(tokenTypes, (currTokType) =>\r\n    isRegExp(currTokType[PATTERN]),\r\n  );\r\n\r\n  errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));\r\n\r\n  errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));\r\n\r\n  errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));\r\n\r\n  errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));\r\n\r\n  errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));\r\n\r\n  return errors;\r\n}\r\n\r\nexport interface ILexerFilterResult {\r\n  errors: ILexerDefinitionError[];\r\n  valid: TokenType[];\r\n}\r\n\r\nexport function findMissingPatterns(\r\n  tokenTypes: TokenType[],\r\n): ILexerFilterResult {\r\n  const tokenTypesWithMissingPattern = filter(tokenTypes, (currType) => {\r\n    return !has(currType, PATTERN);\r\n  });\r\n\r\n  const errors = map(tokenTypesWithMissingPattern, (currType) => {\r\n    return {\r\n      message:\r\n        \"Token Type: ->\" +\r\n        currType.name +\r\n        \"<- missing static 'PATTERN' property\",\r\n      type: LexerDefinitionErrorType.MISSING_PATTERN,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  const valid = difference(tokenTypes, tokenTypesWithMissingPattern);\r\n  return { errors, valid };\r\n}\r\n\r\nexport function findInvalidPatterns(\r\n  tokenTypes: TokenType[],\r\n): ILexerFilterResult {\r\n  const tokenTypesWithInvalidPattern = filter(tokenTypes, (currType) => {\r\n    const pattern = currType[PATTERN];\r\n    return (\r\n      !isRegExp(pattern) &&\r\n      !isFunction(pattern) &&\r\n      !has(pattern, \"exec\") &&\r\n      !isString(pattern)\r\n    );\r\n  });\r\n\r\n  const errors = map(tokenTypesWithInvalidPattern, (currType) => {\r\n    return {\r\n      message:\r\n        \"Token Type: ->\" +\r\n        currType.name +\r\n        \"<- static 'PATTERN' can only be a RegExp, a\" +\r\n        \" Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.\",\r\n      type: LexerDefinitionErrorType.INVALID_PATTERN,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  const valid = difference(tokenTypes, tokenTypesWithInvalidPattern);\r\n  return { errors, valid };\r\n}\r\n\r\nconst end_of_input = /[^\\\\][$]/;\r\n\r\nexport function findEndOfInputAnchor(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  class EndAnchorFinder extends BaseRegExpVisitor {\r\n    found = false;\r\n\r\n    visitEndAnchor(node: unknown) {\r\n      this.found = true;\r\n    }\r\n  }\r\n\r\n  const invalidRegex = filter(tokenTypes, (currType) => {\r\n    const pattern = currType.PATTERN;\r\n\r\n    try {\r\n      const regexpAst = getRegExpAst(pattern as RegExp);\r\n      const endAnchorVisitor = new EndAnchorFinder();\r\n      endAnchorVisitor.visit(regexpAst);\r\n\r\n      return endAnchorVisitor.found;\r\n    } catch (e) {\r\n      // old behavior in case of runtime exceptions with regexp-to-ast.\r\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\r\n      return end_of_input.test((pattern as RegExp).source);\r\n    }\r\n  });\r\n\r\n  const errors = map(invalidRegex, (currType) => {\r\n    return {\r\n      message:\r\n        \"Unexpected RegExp Anchor Error:\\n\" +\r\n        \"\\tToken Type: ->\" +\r\n        currType.name +\r\n        \"<- static 'PATTERN' cannot contain end of input anchor '$'\\n\" +\r\n        \"\\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\r\n        \"\\tfor details.\",\r\n      type: LexerDefinitionErrorType.EOI_ANCHOR_FOUND,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport function findEmptyMatchRegExps(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  const matchesEmptyString = filter(tokenTypes, (currType) => {\r\n    const pattern = currType.PATTERN as RegExp;\r\n    return pattern.test(\"\");\r\n  });\r\n\r\n  const errors = map(matchesEmptyString, (currType) => {\r\n    return {\r\n      message:\r\n        \"Token Type: ->\" +\r\n        currType.name +\r\n        \"<- static 'PATTERN' must not match an empty string\",\r\n      type: LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nconst start_of_input = /[^\\\\[][\\^]|^\\^/;\r\n\r\nexport function findStartOfInputAnchor(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  class StartAnchorFinder extends BaseRegExpVisitor {\r\n    found = false;\r\n\r\n    visitStartAnchor(node: unknown) {\r\n      this.found = true;\r\n    }\r\n  }\r\n\r\n  const invalidRegex = filter(tokenTypes, (currType) => {\r\n    const pattern = currType.PATTERN as RegExp;\r\n    try {\r\n      const regexpAst = getRegExpAst(pattern);\r\n      const startAnchorVisitor = new StartAnchorFinder();\r\n      startAnchorVisitor.visit(regexpAst);\r\n\r\n      return startAnchorVisitor.found;\r\n    } catch (e) {\r\n      // old behavior in case of runtime exceptions with regexp-to-ast.\r\n      /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/\r\n      return start_of_input.test(pattern.source);\r\n    }\r\n  });\r\n\r\n  const errors = map(invalidRegex, (currType) => {\r\n    return {\r\n      message:\r\n        \"Unexpected RegExp Anchor Error:\\n\" +\r\n        \"\\tToken Type: ->\" +\r\n        currType.name +\r\n        \"<- static 'PATTERN' cannot contain start of input anchor '^'\\n\" +\r\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS\" +\r\n        \"\\tfor details.\",\r\n      type: LexerDefinitionErrorType.SOI_ANCHOR_FOUND,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport function findUnsupportedFlags(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  const invalidFlags = filter(tokenTypes, (currType) => {\r\n    const pattern = currType[PATTERN];\r\n    return pattern instanceof RegExp && (pattern.multiline || pattern.global);\r\n  });\r\n\r\n  const errors = map(invalidFlags, (currType) => {\r\n    return {\r\n      message:\r\n        \"Token Type: ->\" +\r\n        currType.name +\r\n        \"<- static 'PATTERN' may NOT contain global('g') or multiline('m')\",\r\n      type: LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\n// This can only test for identical duplicate RegExps, not semantically equivalent ones.\r\nexport function findDuplicatePatterns(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  const found: TokenType[] = [];\r\n  let identicalPatterns = map(tokenTypes, (outerType: any) => {\r\n    return reduce(\r\n      tokenTypes,\r\n      (result, innerType) => {\r\n        if (\r\n          outerType.PATTERN.source === (innerType.PATTERN as RegExp).source &&\r\n          !includes(found, innerType) &&\r\n          innerType.PATTERN !== Lexer.NA\r\n        ) {\r\n          // this avoids duplicates in the result, each Token Type may only appear in one \"set\"\r\n          // in essence we are creating Equivalence classes on equality relation.\r\n          found.push(innerType);\r\n          result.push(innerType);\r\n          return result;\r\n        }\r\n        return result;\r\n      },\r\n      [] as TokenType[],\r\n    );\r\n  });\r\n\r\n  identicalPatterns = compact(identicalPatterns);\r\n\r\n  const duplicatePatterns = filter(identicalPatterns, (currIdenticalSet) => {\r\n    return currIdenticalSet.length > 1;\r\n  });\r\n\r\n  const errors = map(duplicatePatterns, (setOfIdentical: any) => {\r\n    const tokenTypeNames = map(setOfIdentical, (currType: any) => {\r\n      return currType.name;\r\n    });\r\n\r\n    const dupPatternSrc = (<any>first(setOfIdentical)).PATTERN;\r\n    return {\r\n      message:\r\n        `The same RegExp pattern ->${dupPatternSrc}<-` +\r\n        `has been used in all of the following Token Types: ${tokenTypeNames.join(\r\n          \", \",\r\n        )} <-`,\r\n      type: LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,\r\n      tokenTypes: setOfIdentical,\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport function findInvalidGroupType(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  const invalidTypes = filter(tokenTypes, (clazz: any) => {\r\n    if (!has(clazz, \"GROUP\")) {\r\n      return false;\r\n    }\r\n    const group = clazz.GROUP;\r\n\r\n    return group !== Lexer.SKIPPED && group !== Lexer.NA && !isString(group);\r\n  });\r\n\r\n  const errors = map(invalidTypes, (currType) => {\r\n    return {\r\n      message:\r\n        \"Token Type: ->\" +\r\n        currType.name +\r\n        \"<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String\",\r\n      type: LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,\r\n      tokenTypes: [currType],\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport function findModesThatDoNotExist(\r\n  tokenTypes: TokenType[],\r\n  validModes: string[],\r\n): ILexerDefinitionError[] {\r\n  const invalidModes = filter(tokenTypes, (clazz: any) => {\r\n    return (\r\n      clazz.PUSH_MODE !== undefined && !includes(validModes, clazz.PUSH_MODE)\r\n    );\r\n  });\r\n\r\n  const errors = map(invalidModes, (tokType) => {\r\n    const msg =\r\n      `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +\r\n      `which does not exist`;\r\n    return {\r\n      message: msg,\r\n      type: LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,\r\n      tokenTypes: [tokType],\r\n    };\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport function findUnreachablePatterns(\r\n  tokenTypes: TokenType[],\r\n): ILexerDefinitionError[] {\r\n  const errors: ILexerDefinitionError[] = [];\r\n\r\n  const canBeTested = reduce(\r\n    tokenTypes,\r\n    (result, tokType, idx) => {\r\n      const pattern = tokType.PATTERN;\r\n\r\n      if (pattern === Lexer.NA) {\r\n        return result;\r\n      }\r\n\r\n      // a more comprehensive validation for all forms of regExps would require\r\n      // deeper regExp analysis capabilities\r\n      if (isString(pattern)) {\r\n        result.push({ str: pattern, idx, tokenType: tokType });\r\n      } else if (isRegExp(pattern) && noMetaChar(pattern)) {\r\n        result.push({ str: pattern.source, idx, tokenType: tokType });\r\n      }\r\n      return result;\r\n    },\r\n    [] as { str: string; idx: number; tokenType: TokenType }[],\r\n  );\r\n\r\n  forEach(tokenTypes, (tokType, testIdx) => {\r\n    forEach(canBeTested, ({ str, idx, tokenType }) => {\r\n      if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {\r\n        const msg =\r\n          `Token: ->${tokenType.name}<- can never be matched.\\n` +\r\n          `Because it appears AFTER the Token Type ->${tokType.name}<-` +\r\n          `in the lexer's definition.\\n` +\r\n          `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;\r\n        errors.push({\r\n          message: msg,\r\n          type: LexerDefinitionErrorType.UNREACHABLE_PATTERN,\r\n          tokenTypes: [tokType, tokenType],\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nfunction testTokenType(str: string, pattern: any): boolean {\r\n  /* istanbul ignore else */\r\n  if (isRegExp(pattern)) {\r\n    const regExpArray = pattern.exec(str);\r\n    return regExpArray !== null && regExpArray.index === 0;\r\n  } else if (isFunction(pattern)) {\r\n    // maintain the API of custom patterns\r\n    return pattern(str, 0, [], {});\r\n  } else if (has(pattern, \"exec\")) {\r\n    // maintain the API of custom patterns\r\n    return pattern.exec(str, 0, [], {});\r\n  } else if (typeof pattern === \"string\") {\r\n    return pattern === str;\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n\r\nfunction noMetaChar(regExp: RegExp): boolean {\r\n  //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp\r\n  const metaChars = [\r\n    \".\",\r\n    \"\\\\\",\r\n    \"[\",\r\n    \"]\",\r\n    \"|\",\r\n    \"^\",\r\n    \"$\",\r\n    \"(\",\r\n    \")\",\r\n    \"?\",\r\n    \"*\",\r\n    \"+\",\r\n    \"{\",\r\n  ];\r\n  return (\r\n    find(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined\r\n  );\r\n}\r\n\r\nexport function addStartOfInput(pattern: RegExp): RegExp {\r\n  const flags = pattern.ignoreCase ? \"i\" : \"\";\r\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\r\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\r\n  return new RegExp(`^(?:${pattern.source})`, flags);\r\n}\r\n\r\nexport function addStickyFlag(pattern: RegExp): RegExp {\r\n  const flags = pattern.ignoreCase ? \"iy\" : \"y\";\r\n  // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.\r\n  // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)\r\n  return new RegExp(`${pattern.source}`, flags);\r\n}\r\n\r\nexport function performRuntimeChecks(\r\n  lexerDefinition: IMultiModeLexerDefinition,\r\n  trackLines: boolean,\r\n  lineTerminatorCharacters: (number | string)[],\r\n): ILexerDefinitionError[] {\r\n  const errors: ILexerDefinitionError[] = [];\r\n\r\n  // some run time checks to help the end users.\r\n  if (!has(lexerDefinition, DEFAULT_MODE)) {\r\n    errors.push({\r\n      message:\r\n        \"A MultiMode Lexer cannot be initialized without a <\" +\r\n        DEFAULT_MODE +\r\n        \"> property in its definition\\n\",\r\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\r\n    });\r\n  }\r\n  if (!has(lexerDefinition, MODES)) {\r\n    errors.push({\r\n      message:\r\n        \"A MultiMode Lexer cannot be initialized without a <\" +\r\n        MODES +\r\n        \"> property in its definition\\n\",\r\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\r\n    });\r\n  }\r\n\r\n  if (\r\n    has(lexerDefinition, MODES) &&\r\n    has(lexerDefinition, DEFAULT_MODE) &&\r\n    !has(lexerDefinition.modes, lexerDefinition.defaultMode)\r\n  ) {\r\n    errors.push({\r\n      message:\r\n        `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +\r\n        `which does not exist\\n`,\r\n      type: LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\r\n    });\r\n  }\r\n\r\n  if (has(lexerDefinition, MODES)) {\r\n    forEach(lexerDefinition.modes, (currModeValue, currModeName) => {\r\n      forEach(currModeValue, (currTokType, currIdx) => {\r\n        if (isUndefined(currTokType)) {\r\n          errors.push({\r\n            message:\r\n              `A Lexer cannot be initialized using an undefined Token Type. Mode:` +\r\n              `<${currModeName}> at index: <${currIdx}>\\n`,\r\n            type: LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\r\n          });\r\n        } else if (has(currTokType, \"LONGER_ALT\")) {\r\n          const longerAlt = isArray(currTokType.LONGER_ALT)\r\n            ? currTokType.LONGER_ALT\r\n            : [currTokType.LONGER_ALT];\r\n          forEach(longerAlt, (currLongerAlt) => {\r\n            if (\r\n              !isUndefined(currLongerAlt) &&\r\n              !includes(currModeValue, currLongerAlt)\r\n            ) {\r\n              errors.push({\r\n                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\\n`,\r\n                type: LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\r\n              });\r\n            }\r\n          });\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nexport function performWarningRuntimeChecks(\r\n  lexerDefinition: IMultiModeLexerDefinition,\r\n  trackLines: boolean,\r\n  lineTerminatorCharacters: (number | string)[],\r\n): ILexerDefinitionError[] {\r\n  const warnings = [];\r\n  let hasAnyLineBreak = false;\r\n  const allTokenTypes = compact(flatten(values(lexerDefinition.modes)));\r\n\r\n  const concreteTokenTypes = reject(\r\n    allTokenTypes,\r\n    (currType) => currType[PATTERN] === Lexer.NA,\r\n  );\r\n  const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);\r\n  if (trackLines) {\r\n    forEach(concreteTokenTypes, (tokType) => {\r\n      const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);\r\n      if (currIssue !== false) {\r\n        const message = buildLineBreakIssueMessage(tokType, currIssue);\r\n        const warningDescriptor = {\r\n          message,\r\n          type: currIssue.issue,\r\n          tokenType: tokType,\r\n        };\r\n        warnings.push(warningDescriptor);\r\n      } else {\r\n        // we don't want to attempt to scan if the user explicitly specified the line_breaks option.\r\n        if (has(tokType, \"LINE_BREAKS\")) {\r\n          if (tokType.LINE_BREAKS === true) {\r\n            hasAnyLineBreak = true;\r\n          }\r\n        } else {\r\n          if (\r\n            canMatchCharCode(terminatorCharCodes, tokType.PATTERN as RegExp)\r\n          ) {\r\n            hasAnyLineBreak = true;\r\n          }\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  if (trackLines && !hasAnyLineBreak) {\r\n    warnings.push({\r\n      message:\r\n        \"Warning: No LINE_BREAKS Found.\\n\" +\r\n        \"\\tThis Lexer has been defined to track line and column information,\\n\" +\r\n        \"\\tBut none of the Token Types can be identified as matching a line terminator.\\n\" +\r\n        \"\\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \\n\" +\r\n        \"\\tfor details.\",\r\n      type: LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,\r\n    });\r\n  }\r\n  return warnings;\r\n}\r\n\r\nexport function cloneEmptyGroups(emptyGroups: {\r\n  [groupName: string]: IToken;\r\n}): { [groupName: string]: IToken } {\r\n  const clonedResult: any = {};\r\n  const groupKeys = keys(emptyGroups);\r\n\r\n  forEach(groupKeys, (currKey) => {\r\n    const currGroupValue = emptyGroups[currKey];\r\n\r\n    /* istanbul ignore else */\r\n    if (isArray(currGroupValue)) {\r\n      clonedResult[currKey] = [];\r\n    } else {\r\n      throw Error(\"non exhaustive match\");\r\n    }\r\n  });\r\n\r\n  return clonedResult;\r\n}\r\n\r\n// TODO: refactor to avoid duplication\r\nexport function isCustomPattern(tokenType: TokenType): boolean {\r\n  const pattern = tokenType.PATTERN;\r\n  /* istanbul ignore else */\r\n  if (isRegExp(pattern)) {\r\n    return false;\r\n  } else if (isFunction(pattern)) {\r\n    // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object\r\n    return true;\r\n  } else if (has(pattern, \"exec\")) {\r\n    // ICustomPattern\r\n    return true;\r\n  } else if (isString(pattern)) {\r\n    return false;\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n\r\nexport function isShortPattern(pattern: any): number | false {\r\n  if (isString(pattern) && pattern.length === 1) {\r\n    return pattern.charCodeAt(0);\r\n  } else {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Faster than using a RegExp for default newline detection during lexing.\r\n */\r\nexport const LineTerminatorOptimizedTester: ILineTerminatorsTester = {\r\n  // implements /\\n|\\r\\n?/g.test\r\n  test: function (text) {\r\n    const len = text.length;\r\n    for (let i = this.lastIndex; i < len; i++) {\r\n      const c = text.charCodeAt(i);\r\n      if (c === 10) {\r\n        this.lastIndex = i + 1;\r\n        return true;\r\n      } else if (c === 13) {\r\n        if (text.charCodeAt(i + 1) === 10) {\r\n          this.lastIndex = i + 2;\r\n        } else {\r\n          this.lastIndex = i + 1;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  },\r\n\r\n  lastIndex: 0,\r\n};\r\n\r\nfunction checkLineBreaksIssues(\r\n  tokType: TokenType,\r\n  lineTerminatorCharCodes: number[],\r\n):\r\n  | {\r\n      issue:\r\n        | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\r\n        | LexerDefinitionErrorType.CUSTOM_LINE_BREAK;\r\n      errMsg?: string;\r\n    }\r\n  | false {\r\n  if (has(tokType, \"LINE_BREAKS\")) {\r\n    // if the user explicitly declared the line_breaks option we will respect their choice\r\n    // and assume it is correct.\r\n    return false;\r\n  } else {\r\n    /* istanbul ignore else */\r\n    if (isRegExp(tokType.PATTERN)) {\r\n      try {\r\n        // TODO: why is the casting suddenly needed?\r\n        canMatchCharCode(lineTerminatorCharCodes, tokType.PATTERN as RegExp);\r\n      } catch (e) {\r\n        /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */\r\n        return {\r\n          issue: LexerDefinitionErrorType.IDENTIFY_TERMINATOR,\r\n          errMsg: (e as Error).message,\r\n        };\r\n      }\r\n      return false;\r\n    } else if (isString(tokType.PATTERN)) {\r\n      // string literal patterns can always be analyzed to detect line terminator usage\r\n      return false;\r\n    } else if (isCustomPattern(tokType)) {\r\n      // custom token types\r\n      return { issue: LexerDefinitionErrorType.CUSTOM_LINE_BREAK };\r\n    } else {\r\n      throw Error(\"non exhaustive match\");\r\n    }\r\n  }\r\n}\r\n\r\nexport function buildLineBreakIssueMessage(\r\n  tokType: TokenType,\r\n  details: {\r\n    issue:\r\n      | LexerDefinitionErrorType.IDENTIFY_TERMINATOR\r\n      | LexerDefinitionErrorType.CUSTOM_LINE_BREAK;\r\n    errMsg?: string;\r\n  },\r\n): string {\r\n  /* istanbul ignore else */\r\n  if (details.issue === LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {\r\n    return (\r\n      \"Warning: unable to identify line terminator usage in pattern.\\n\" +\r\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\r\n      `\\t Root cause: ${details.errMsg}.\\n` +\r\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR\"\r\n    );\r\n  } else if (details.issue === LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {\r\n    return (\r\n      \"Warning: A Custom Token Pattern should specify the <line_breaks> option.\\n\" +\r\n      `\\tThe problem is in the <${tokType.name}> Token Type\\n` +\r\n      \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK\"\r\n    );\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n\r\nfunction getCharCodes(charsOrCodes: (number | string)[]): number[] {\r\n  const charCodes = map(charsOrCodes, (numOrString) => {\r\n    if (isString(numOrString)) {\r\n      return numOrString.charCodeAt(0);\r\n    } else {\r\n      return numOrString;\r\n    }\r\n  });\r\n\r\n  return charCodes;\r\n}\r\n\r\nfunction addToMapOfArrays<T>(\r\n  map: Record<number, T[]>,\r\n  key: number,\r\n  value: T,\r\n): void {\r\n  if (map[key] === undefined) {\r\n    map[key] = [value];\r\n  } else {\r\n    map[key].push(value);\r\n  }\r\n}\r\n\r\nexport const minOptimizationVal = 256;\r\n\r\n/**\r\n * We are mapping charCode above ASCI (256) into buckets each in the size of 256.\r\n * This is because ASCI are the most common start chars so each one of those will get its own\r\n * possible token configs vector.\r\n *\r\n * Tokens starting with charCodes \"above\" ASCI are uncommon, so we can \"afford\"\r\n * to place these into buckets of possible token configs, What we gain from\r\n * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'\r\n * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).\r\n * Our 'charCodeToPatternIdxToConfig' max size will now be:\r\n * 256 + (2^16 / 2^8) - 1 === 511\r\n *\r\n * note the hack for fast division integer part extraction\r\n * See: https://stackoverflow.com/a/4228528\r\n */\r\nlet charCodeToOptimizedIdxMap: number[] = [];\r\nexport function charCodeToOptimizedIndex(charCode: number): number {\r\n  return charCode < minOptimizationVal\r\n    ? charCode\r\n    : charCodeToOptimizedIdxMap[charCode];\r\n}\r\n\r\n/**\r\n * This is a compromise between cold start / hot running performance\r\n * Creating this array takes ~3ms on a modern machine,\r\n * But if we perform the computation at runtime as needed the CSS Lexer benchmark\r\n * performance degrades by ~10%\r\n *\r\n * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.\r\n */\r\nfunction initCharCodeToOptimizedIndexMap() {\r\n  if (isEmpty(charCodeToOptimizedIdxMap)) {\r\n    charCodeToOptimizedIdxMap = new Array(65536);\r\n    for (let i = 0; i < 65536; i++) {\r\n      charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  clone,\r\n  compact,\r\n  difference,\r\n  flatten,\r\n  forEach,\r\n  has,\r\n  includes,\r\n  isArray,\r\n  isEmpty,\r\n  map,\r\n} from \"lodash-es\";\r\nimport { IToken, TokenType } from \"@chevrotain/types\";\r\n\r\nexport function tokenStructuredMatcher(\r\n  tokInstance: IToken,\r\n  tokConstructor: TokenType,\r\n) {\r\n  const instanceType = tokInstance.tokenTypeIdx;\r\n  if (instanceType === tokConstructor.tokenTypeIdx) {\r\n    return true;\r\n  } else {\r\n    return (\r\n      tokConstructor.isParent === true &&\r\n      tokConstructor.categoryMatchesMap![instanceType] === true\r\n    );\r\n  }\r\n}\r\n\r\n// Optimized tokenMatcher in case our grammar does not use token categories\r\n// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead\r\nexport function tokenStructuredMatcherNoCategories(\r\n  token: IToken,\r\n  tokType: TokenType,\r\n) {\r\n  return token.tokenTypeIdx === tokType.tokenTypeIdx;\r\n}\r\n\r\nexport let tokenShortNameIdx = 1;\r\nexport const tokenIdxToClass: { [tokenIdx: number]: TokenType } = {};\r\n\r\nexport function augmentTokenTypes(tokenTypes: TokenType[]): void {\r\n  // collect the parent Token Types as well.\r\n  const tokenTypesAndParents = expandCategories(tokenTypes);\r\n\r\n  // add required tokenType and categoryMatches properties\r\n  assignTokenDefaultProps(tokenTypesAndParents);\r\n\r\n  // fill up the categoryMatches\r\n  assignCategoriesMapProp(tokenTypesAndParents);\r\n  assignCategoriesTokensProp(tokenTypesAndParents);\r\n\r\n  forEach(tokenTypesAndParents, (tokType) => {\r\n    tokType.isParent = tokType.categoryMatches!.length > 0;\r\n  });\r\n}\r\n\r\nexport function expandCategories(tokenTypes: TokenType[]): TokenType[] {\r\n  let result = clone(tokenTypes);\r\n\r\n  let categories = tokenTypes;\r\n  let searching = true;\r\n  while (searching) {\r\n    categories = compact(\r\n      flatten(map(categories, (currTokType) => currTokType.CATEGORIES)),\r\n    );\r\n\r\n    const newCategories = difference(categories, result);\r\n\r\n    result = result.concat(newCategories);\r\n\r\n    if (isEmpty(newCategories)) {\r\n      searching = false;\r\n    } else {\r\n      categories = newCategories;\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nexport function assignTokenDefaultProps(tokenTypes: TokenType[]): void {\r\n  forEach(tokenTypes, (currTokType) => {\r\n    if (!hasShortKeyProperty(currTokType)) {\r\n      tokenIdxToClass[tokenShortNameIdx] = currTokType;\r\n      (<any>currTokType).tokenTypeIdx = tokenShortNameIdx++;\r\n    }\r\n\r\n    // CATEGORIES? : TokenType | TokenType[]\r\n    if (\r\n      hasCategoriesProperty(currTokType) &&\r\n      !isArray(currTokType.CATEGORIES)\r\n      // &&\r\n      // !isUndefined(currTokType.CATEGORIES.PATTERN)\r\n    ) {\r\n      currTokType.CATEGORIES = [currTokType.CATEGORIES as unknown as TokenType];\r\n    }\r\n\r\n    if (!hasCategoriesProperty(currTokType)) {\r\n      currTokType.CATEGORIES = [];\r\n    }\r\n\r\n    if (!hasExtendingTokensTypesProperty(currTokType)) {\r\n      currTokType.categoryMatches = [];\r\n    }\r\n\r\n    if (!hasExtendingTokensTypesMapProperty(currTokType)) {\r\n      currTokType.categoryMatchesMap = {};\r\n    }\r\n  });\r\n}\r\n\r\nexport function assignCategoriesTokensProp(tokenTypes: TokenType[]): void {\r\n  forEach(tokenTypes, (currTokType) => {\r\n    // avoid duplications\r\n    currTokType.categoryMatches = [];\r\n    forEach(currTokType.categoryMatchesMap!, (val, key) => {\r\n      currTokType.categoryMatches!.push(\r\n        tokenIdxToClass[key as unknown as number].tokenTypeIdx!,\r\n      );\r\n    });\r\n  });\r\n}\r\n\r\nexport function assignCategoriesMapProp(tokenTypes: TokenType[]): void {\r\n  forEach(tokenTypes, (currTokType) => {\r\n    singleAssignCategoriesToksMap([], currTokType);\r\n  });\r\n}\r\n\r\nexport function singleAssignCategoriesToksMap(\r\n  path: TokenType[],\r\n  nextNode: TokenType,\r\n): void {\r\n  forEach(path, (pathNode) => {\r\n    nextNode.categoryMatchesMap![pathNode.tokenTypeIdx!] = true;\r\n  });\r\n\r\n  forEach(nextNode.CATEGORIES, (nextCategory) => {\r\n    const newPath = path.concat(nextNode);\r\n    // avoids infinite loops due to cyclic categories.\r\n    if (!includes(newPath, nextCategory)) {\r\n      singleAssignCategoriesToksMap(newPath, nextCategory);\r\n    }\r\n  });\r\n}\r\n\r\nexport function hasShortKeyProperty(tokType: TokenType): boolean {\r\n  return has(tokType, \"tokenTypeIdx\");\r\n}\r\n\r\nexport function hasCategoriesProperty(tokType: TokenType): boolean {\r\n  return has(tokType, \"CATEGORIES\");\r\n}\r\n\r\nexport function hasExtendingTokensTypesProperty(tokType: TokenType): boolean {\r\n  return has(tokType, \"categoryMatches\");\r\n}\r\n\r\nexport function hasExtendingTokensTypesMapProperty(\r\n  tokType: TokenType,\r\n): boolean {\r\n  return has(tokType, \"categoryMatchesMap\");\r\n}\r\n\r\nexport function isTokenType(tokType: TokenType): boolean {\r\n  return has(tokType, \"tokenTypeIdx\");\r\n}\r\n", "import { ILexerErrorMessageProvider, IToken } from \"@chevrotain/types\";\r\n\r\nexport const defaultLexerErrorProvider: ILexerErrorMessageProvider = {\r\n  buildUnableToPopLexerModeMessage(token: IToken): string {\r\n    return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;\r\n  },\r\n\r\n  buildUnexpectedCharactersMessage(\r\n    fullText: string,\r\n    startOffset: number,\r\n    length: number,\r\n    line?: number,\r\n    column?: number,\r\n  ): string {\r\n    return (\r\n      `unexpected character: ->${fullText.charAt(\r\n        startOffset,\r\n      )}<- at offset: ${startOffset},` + ` skipped ${length} characters.`\r\n    );\r\n  },\r\n};\r\n", "import {\r\n  analyzeTokenTypes,\r\n  charCodeToOptimizedIndex,\r\n  cloneEmptyGroups,\r\n  DEFAULT_MODE,\r\n  IAnalyzeResult,\r\n  IPatternConfig,\r\n  LineTerminatorOptimizedTester,\r\n  performRuntimeChecks,\r\n  performWarningRuntimeChecks,\r\n  SUPPORT_STICKY,\r\n  validatePatterns,\r\n} from \"./lexer.js\";\r\nimport {\r\n  assign,\r\n  clone,\r\n  forEach,\r\n  identity,\r\n  isArray,\r\n  isEmpty,\r\n  isUndefined,\r\n  keys,\r\n  last,\r\n  map,\r\n  noop,\r\n  reduce,\r\n  reject,\r\n} from \"lodash-es\";\r\nimport { PRINT_WARNING, timer, toFastProperties } from \"@chevrotain/utils\";\r\nimport { augmentTokenTypes } from \"./tokens.js\";\r\nimport {\r\n  CustomPatternMatcherFunc,\r\n  CustomPatternMatcherReturn,\r\n  ILexerConfig,\r\n  ILexerDefinitionError,\r\n  ILexingError,\r\n  IMultiModeLexerDefinition,\r\n  IToken,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport { defaultLexerErrorProvider } from \"./lexer_errors_public.js\";\r\nimport { clearRegExpParserCache } from \"./reg_exp_parser.js\";\r\n\r\nexport interface ILexingResult {\r\n  tokens: IToken[];\r\n  groups: { [groupName: string]: IToken[] };\r\n  errors: ILexingError[];\r\n}\r\n\r\nexport enum LexerDefinitionErrorType {\r\n  MISSING_PATTERN,\r\n  INVALID_PATTERN,\r\n  EOI_ANCHOR_FOUND,\r\n  UNSUPPORTED_FLAGS_FOUND,\r\n  DUPLICATE_PATTERNS_FOUND,\r\n  INVALID_GROUP_TYPE_FOUND,\r\n  PUSH_MODE_DOES_NOT_EXIST,\r\n  MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,\r\n  MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,\r\n  MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,\r\n  LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,\r\n  SOI_ANCHOR_FOUND,\r\n  EMPTY_MATCH_PATTERN,\r\n  NO_LINE_BREAKS_FLAGS,\r\n  UNREACHABLE_PATTERN,\r\n  IDENTIFY_TERMINATOR,\r\n  CUSTOM_LINE_BREAK,\r\n  MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,\r\n}\r\n\r\nexport interface IRegExpExec {\r\n  exec: CustomPatternMatcherFunc;\r\n}\r\n\r\nconst DEFAULT_LEXER_CONFIG: Required<ILexerConfig> = {\r\n  deferDefinitionErrorsHandling: false,\r\n  positionTracking: \"full\",\r\n  lineTerminatorsPattern: /\\n|\\r\\n?/g,\r\n  lineTerminatorCharacters: [\"\\n\", \"\\r\"],\r\n  ensureOptimizations: false,\r\n  safeMode: false,\r\n  errorMessageProvider: defaultLexerErrorProvider,\r\n  traceInitPerf: false,\r\n  skipValidations: false,\r\n  recoveryEnabled: true,\r\n};\r\n\r\nObject.freeze(DEFAULT_LEXER_CONFIG);\r\n\r\nexport class Lexer {\r\n  public static SKIPPED =\r\n    \"This marks a skipped Token pattern, this means each token identified by it will\" +\r\n    \"be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.\";\r\n\r\n  public static NA = /NOT_APPLICABLE/;\r\n  public lexerDefinitionErrors: ILexerDefinitionError[] = [];\r\n  public lexerDefinitionWarning: ILexerDefinitionError[] = [];\r\n\r\n  protected patternIdxToConfig: Record<string, IPatternConfig[]> = {};\r\n  protected charCodeToPatternIdxToConfig: {\r\n    [modeName: string]: { [charCode: number]: IPatternConfig[] };\r\n  } = {};\r\n\r\n  protected modes: string[] = [];\r\n  protected defaultMode!: string;\r\n  protected emptyGroups: { [groupName: string]: IToken } = {};\r\n\r\n  private config: Required<ILexerConfig>;\r\n  private trackStartLines: boolean = true;\r\n  private trackEndLines: boolean = true;\r\n  private hasCustom: boolean = false;\r\n  private canModeBeOptimized: Record<string, boolean> = {};\r\n\r\n  private traceInitPerf!: boolean | number;\r\n  private traceInitMaxIdent!: number;\r\n  private traceInitIndent: number;\r\n\r\n  constructor(\r\n    protected lexerDefinition: TokenType[] | IMultiModeLexerDefinition,\r\n    config: ILexerConfig = DEFAULT_LEXER_CONFIG,\r\n  ) {\r\n    if (typeof config === \"boolean\") {\r\n      throw Error(\r\n        \"The second argument to the Lexer constructor is now an ILexerConfig Object.\\n\" +\r\n          \"a boolean 2nd argument is no longer supported\",\r\n      );\r\n    }\r\n\r\n    // todo: defaults func?\r\n    this.config = assign({}, DEFAULT_LEXER_CONFIG, config) as any;\r\n\r\n    const traceInitVal = this.config.traceInitPerf;\r\n    if (traceInitVal === true) {\r\n      this.traceInitMaxIdent = Infinity;\r\n      this.traceInitPerf = true;\r\n    } else if (typeof traceInitVal === \"number\") {\r\n      this.traceInitMaxIdent = traceInitVal;\r\n      this.traceInitPerf = true;\r\n    }\r\n    this.traceInitIndent = -1;\r\n\r\n    this.TRACE_INIT(\"Lexer Constructor\", () => {\r\n      let actualDefinition!: IMultiModeLexerDefinition;\r\n      let hasOnlySingleMode = true;\r\n      this.TRACE_INIT(\"Lexer Config handling\", () => {\r\n        if (\r\n          this.config.lineTerminatorsPattern ===\r\n          DEFAULT_LEXER_CONFIG.lineTerminatorsPattern\r\n        ) {\r\n          // optimized built-in implementation for the defaults definition of lineTerminators\r\n          this.config.lineTerminatorsPattern = LineTerminatorOptimizedTester;\r\n        } else {\r\n          if (\r\n            this.config.lineTerminatorCharacters ===\r\n            DEFAULT_LEXER_CONFIG.lineTerminatorCharacters\r\n          ) {\r\n            throw Error(\r\n              \"Error: Missing <lineTerminatorCharacters> property on the Lexer config.\\n\" +\r\n                \"\\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS\",\r\n            );\r\n          }\r\n        }\r\n\r\n        if (config.safeMode && config.ensureOptimizations) {\r\n          throw Error(\r\n            '\"safeMode\" and \"ensureOptimizations\" flags are mutually exclusive.',\r\n          );\r\n        }\r\n\r\n        this.trackStartLines = /full|onlyStart/i.test(\r\n          this.config.positionTracking,\r\n        );\r\n        this.trackEndLines = /full/i.test(this.config.positionTracking);\r\n\r\n        // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.\r\n        if (isArray(lexerDefinition)) {\r\n          actualDefinition = {\r\n            modes: { defaultMode: clone(lexerDefinition) },\r\n            defaultMode: DEFAULT_MODE,\r\n          };\r\n        } else {\r\n          // no conversion needed, input should already be a IMultiModeLexerDefinition\r\n          hasOnlySingleMode = false;\r\n          actualDefinition = clone(<IMultiModeLexerDefinition>lexerDefinition);\r\n        }\r\n      });\r\n\r\n      if (this.config.skipValidations === false) {\r\n        this.TRACE_INIT(\"performRuntimeChecks\", () => {\r\n          this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\r\n            performRuntimeChecks(\r\n              actualDefinition,\r\n              this.trackStartLines,\r\n              this.config.lineTerminatorCharacters,\r\n            ),\r\n          );\r\n        });\r\n\r\n        this.TRACE_INIT(\"performWarningRuntimeChecks\", () => {\r\n          this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat(\r\n            performWarningRuntimeChecks(\r\n              actualDefinition,\r\n              this.trackStartLines,\r\n              this.config.lineTerminatorCharacters,\r\n            ),\r\n          );\r\n        });\r\n      }\r\n\r\n      // for extra robustness to avoid throwing an none informative error message\r\n      actualDefinition.modes = actualDefinition.modes\r\n        ? actualDefinition.modes\r\n        : {};\r\n\r\n      // an error of undefined TokenTypes will be detected in \"performRuntimeChecks\" above.\r\n      // this transformation is to increase robustness in the case of partially invalid lexer definition.\r\n      forEach(actualDefinition.modes, (currModeValue, currModeName) => {\r\n        actualDefinition.modes[currModeName] = reject<TokenType>(\r\n          currModeValue,\r\n          (currTokType) => isUndefined(currTokType),\r\n        );\r\n      });\r\n\r\n      const allModeNames = keys(actualDefinition.modes);\r\n\r\n      forEach(\r\n        actualDefinition.modes,\r\n        (currModDef: TokenType[], currModName) => {\r\n          this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {\r\n            this.modes.push(currModName);\r\n\r\n            if (this.config.skipValidations === false) {\r\n              this.TRACE_INIT(`validatePatterns`, () => {\r\n                this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat(\r\n                  validatePatterns(currModDef, allModeNames),\r\n                );\r\n              });\r\n            }\r\n\r\n            // If definition errors were encountered, the analysis phase may fail unexpectedly/\r\n            // Considering a lexer with definition errors may never be used, there is no point\r\n            // to performing the analysis anyhow...\r\n            if (isEmpty(this.lexerDefinitionErrors)) {\r\n              augmentTokenTypes(currModDef);\r\n\r\n              let currAnalyzeResult!: IAnalyzeResult;\r\n              this.TRACE_INIT(`analyzeTokenTypes`, () => {\r\n                currAnalyzeResult = analyzeTokenTypes(currModDef, {\r\n                  lineTerminatorCharacters:\r\n                    this.config.lineTerminatorCharacters,\r\n                  positionTracking: config.positionTracking,\r\n                  ensureOptimizations: config.ensureOptimizations,\r\n                  safeMode: config.safeMode,\r\n                  tracer: this.TRACE_INIT,\r\n                });\r\n              });\r\n\r\n              this.patternIdxToConfig[currModName] =\r\n                currAnalyzeResult.patternIdxToConfig;\r\n\r\n              this.charCodeToPatternIdxToConfig[currModName] =\r\n                currAnalyzeResult.charCodeToPatternIdxToConfig;\r\n\r\n              this.emptyGroups = assign(\r\n                {},\r\n                this.emptyGroups,\r\n                currAnalyzeResult.emptyGroups,\r\n              ) as any;\r\n\r\n              this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;\r\n\r\n              this.canModeBeOptimized[currModName] =\r\n                currAnalyzeResult.canBeOptimized;\r\n            }\r\n          });\r\n        },\r\n      );\r\n\r\n      this.defaultMode = actualDefinition.defaultMode;\r\n\r\n      if (\r\n        !isEmpty(this.lexerDefinitionErrors) &&\r\n        !this.config.deferDefinitionErrorsHandling\r\n      ) {\r\n        const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\r\n          return error.message;\r\n        });\r\n        const allErrMessagesString = allErrMessages.join(\r\n          \"-----------------------\\n\",\r\n        );\r\n        throw new Error(\r\n          \"Errors detected in definition of Lexer:\\n\" + allErrMessagesString,\r\n        );\r\n      }\r\n\r\n      // Only print warning if there are no errors, This will avoid pl\r\n      forEach(this.lexerDefinitionWarning, (warningDescriptor) => {\r\n        PRINT_WARNING(warningDescriptor.message);\r\n      });\r\n\r\n      this.TRACE_INIT(\"Choosing sub-methods implementations\", () => {\r\n        // Choose the relevant internal implementations for this specific parser.\r\n        // These implementations should be in-lined by the JavaScript engine\r\n        // to provide optimal performance in each scenario.\r\n        if (SUPPORT_STICKY) {\r\n          this.chopInput = <any>identity;\r\n          this.match = this.matchWithTest;\r\n        } else {\r\n          this.updateLastIndex = noop;\r\n          this.match = this.matchWithExec;\r\n        }\r\n\r\n        if (hasOnlySingleMode) {\r\n          this.handleModes = noop;\r\n        }\r\n\r\n        if (this.trackStartLines === false) {\r\n          this.computeNewColumn = identity;\r\n        }\r\n\r\n        if (this.trackEndLines === false) {\r\n          this.updateTokenEndLineColumnLocation = noop;\r\n        }\r\n\r\n        if (/full/i.test(this.config.positionTracking)) {\r\n          this.createTokenInstance = this.createFullToken;\r\n        } else if (/onlyStart/i.test(this.config.positionTracking)) {\r\n          this.createTokenInstance = this.createStartOnlyToken;\r\n        } else if (/onlyOffset/i.test(this.config.positionTracking)) {\r\n          this.createTokenInstance = this.createOffsetOnlyToken;\r\n        } else {\r\n          throw Error(\r\n            `Invalid <positionTracking> config option: \"${this.config.positionTracking}\"`,\r\n          );\r\n        }\r\n\r\n        if (this.hasCustom) {\r\n          this.addToken = this.addTokenUsingPush;\r\n          this.handlePayload = this.handlePayloadWithCustom;\r\n        } else {\r\n          this.addToken = this.addTokenUsingMemberAccess;\r\n          this.handlePayload = this.handlePayloadNoCustom;\r\n        }\r\n      });\r\n\r\n      this.TRACE_INIT(\"Failed Optimization Warnings\", () => {\r\n        const unOptimizedModes = reduce(\r\n          this.canModeBeOptimized,\r\n          (cannotBeOptimized, canBeOptimized, modeName) => {\r\n            if (canBeOptimized === false) {\r\n              cannotBeOptimized.push(modeName);\r\n            }\r\n            return cannotBeOptimized;\r\n          },\r\n          [] as string[],\r\n        );\r\n\r\n        if (config.ensureOptimizations && !isEmpty(unOptimizedModes)) {\r\n          throw Error(\r\n            `Lexer Modes: < ${unOptimizedModes.join(\r\n              \", \",\r\n            )} > cannot be optimized.\\n` +\r\n              '\\t Disable the \"ensureOptimizations\" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\\n' +\r\n              \"\\t Or inspect the console log for details on how to resolve these issues.\",\r\n          );\r\n        }\r\n      });\r\n\r\n      this.TRACE_INIT(\"clearRegExpParserCache\", () => {\r\n        clearRegExpParserCache();\r\n      });\r\n\r\n      this.TRACE_INIT(\"toFastProperties\", () => {\r\n        toFastProperties(this);\r\n      });\r\n    });\r\n  }\r\n\r\n  public tokenize(\r\n    text: string,\r\n    initialMode: string = this.defaultMode,\r\n  ): ILexingResult {\r\n    if (!isEmpty(this.lexerDefinitionErrors)) {\r\n      const allErrMessages = map(this.lexerDefinitionErrors, (error) => {\r\n        return error.message;\r\n      });\r\n      const allErrMessagesString = allErrMessages.join(\r\n        \"-----------------------\\n\",\r\n      );\r\n      throw new Error(\r\n        \"Unable to Tokenize because Errors detected in definition of Lexer:\\n\" +\r\n          allErrMessagesString,\r\n      );\r\n    }\r\n\r\n    return this.tokenizeInternal(text, initialMode);\r\n  }\r\n\r\n  // There is quite a bit of duplication between this and \"tokenizeInternalLazy\"\r\n  // This is intentional due to performance considerations.\r\n  // this method also used quite a bit of `!` none null assertions because it is too optimized\r\n  // for `tsc` to always understand it is \"safe\"\r\n  private tokenizeInternal(text: string, initialMode: string): ILexingResult {\r\n    let i,\r\n      j,\r\n      k,\r\n      matchAltImage,\r\n      longerAlt,\r\n      matchedImage: string | null,\r\n      payload,\r\n      altPayload,\r\n      imageLength,\r\n      group,\r\n      tokType,\r\n      newToken: IToken,\r\n      errLength,\r\n      droppedChar,\r\n      msg,\r\n      match;\r\n    const orgText = text;\r\n    const orgLength = orgText.length;\r\n    let offset = 0;\r\n    let matchedTokensIndex = 0;\r\n    // initializing the tokensArray to the \"guessed\" size.\r\n    // guessing too little will still reduce the number of array re-sizes on pushes.\r\n    // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory\r\n    // but would still have a faster runtime by avoiding (All but one) array resizing.\r\n    const guessedNumberOfTokens = this.hasCustom\r\n      ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.\r\n      : Math.floor(text.length / 10);\r\n    const matchedTokens = new Array(guessedNumberOfTokens);\r\n    const errors: ILexingError[] = [];\r\n    let line = this.trackStartLines ? 1 : undefined;\r\n    let column = this.trackStartLines ? 1 : undefined;\r\n    const groups: any = cloneEmptyGroups(this.emptyGroups);\r\n    const trackLines = this.trackStartLines;\r\n    const lineTerminatorPattern = this.config.lineTerminatorsPattern;\r\n\r\n    let currModePatternsLength = 0;\r\n    let patternIdxToConfig: IPatternConfig[] = [];\r\n    let currCharCodeToPatternIdxToConfig: {\r\n      [charCode: number]: IPatternConfig[];\r\n    } = [];\r\n\r\n    const modeStack: string[] = [];\r\n\r\n    const emptyArray: IPatternConfig[] = [];\r\n    Object.freeze(emptyArray);\r\n    let getPossiblePatterns!: (charCode: number) => IPatternConfig[];\r\n\r\n    function getPossiblePatternsSlow() {\r\n      return patternIdxToConfig;\r\n    }\r\n\r\n    function getPossiblePatternsOptimized(charCode: number): IPatternConfig[] {\r\n      const optimizedCharIdx = charCodeToOptimizedIndex(charCode);\r\n      const possiblePatterns =\r\n        currCharCodeToPatternIdxToConfig[optimizedCharIdx];\r\n      if (possiblePatterns === undefined) {\r\n        return emptyArray;\r\n      } else {\r\n        return possiblePatterns;\r\n      }\r\n    }\r\n\r\n    const pop_mode = (popToken: IToken) => {\r\n      // TODO: perhaps avoid this error in the edge case there is no more input?\r\n      if (\r\n        modeStack.length === 1 &&\r\n        // if we have both a POP_MODE and a PUSH_MODE this is in-fact a \"transition\"\r\n        // So no error should occur.\r\n        popToken.tokenType.PUSH_MODE === undefined\r\n      ) {\r\n        // if we try to pop the last mode there lexer will no longer have ANY mode.\r\n        // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.\r\n        const msg =\r\n          this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(\r\n            popToken,\r\n          );\r\n\r\n        errors.push({\r\n          offset: popToken.startOffset,\r\n          line: popToken.startLine,\r\n          column: popToken.startColumn,\r\n          length: popToken.image.length,\r\n          message: msg,\r\n        });\r\n      } else {\r\n        modeStack.pop();\r\n        const newMode = last(modeStack)!;\r\n        patternIdxToConfig = this.patternIdxToConfig[newMode];\r\n        currCharCodeToPatternIdxToConfig =\r\n          this.charCodeToPatternIdxToConfig[newMode];\r\n        currModePatternsLength = patternIdxToConfig.length;\r\n        const modeCanBeOptimized =\r\n          this.canModeBeOptimized[newMode] && this.config.safeMode === false;\r\n\r\n        if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\r\n          getPossiblePatterns = getPossiblePatternsOptimized;\r\n        } else {\r\n          getPossiblePatterns = getPossiblePatternsSlow;\r\n        }\r\n      }\r\n    };\r\n\r\n    function push_mode(this: Lexer, newMode: string) {\r\n      modeStack.push(newMode);\r\n      currCharCodeToPatternIdxToConfig =\r\n        this.charCodeToPatternIdxToConfig[newMode];\r\n\r\n      patternIdxToConfig = this.patternIdxToConfig[newMode];\r\n      currModePatternsLength = patternIdxToConfig.length;\r\n\r\n      currModePatternsLength = patternIdxToConfig.length;\r\n      const modeCanBeOptimized =\r\n        this.canModeBeOptimized[newMode] && this.config.safeMode === false;\r\n\r\n      if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {\r\n        getPossiblePatterns = getPossiblePatternsOptimized;\r\n      } else {\r\n        getPossiblePatterns = getPossiblePatternsSlow;\r\n      }\r\n    }\r\n\r\n    // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not\r\n    // seem to matter performance wise.\r\n    push_mode.call(this, initialMode);\r\n\r\n    let currConfig!: IPatternConfig;\r\n\r\n    const recoveryEnabled = this.config.recoveryEnabled;\r\n\r\n    while (offset < orgLength) {\r\n      matchedImage = null;\r\n\r\n      const nextCharCode = orgText.charCodeAt(offset);\r\n      const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);\r\n      const chosenPatternsLength = chosenPatternIdxToConfig.length;\r\n\r\n      for (i = 0; i < chosenPatternsLength; i++) {\r\n        currConfig = chosenPatternIdxToConfig[i];\r\n        const currPattern = currConfig.pattern;\r\n        payload = null;\r\n\r\n        // manually in-lined because > 600 chars won't be in-lined in V8\r\n        const singleCharCode = currConfig.short;\r\n        if (singleCharCode !== false) {\r\n          if (nextCharCode === singleCharCode) {\r\n            // single character string\r\n            matchedImage = currPattern as string;\r\n          }\r\n        } else if (currConfig.isCustom === true) {\r\n          match = (currPattern as IRegExpExec).exec(\r\n            orgText,\r\n            offset,\r\n            matchedTokens,\r\n            groups,\r\n          );\r\n          if (match !== null) {\r\n            matchedImage = match[0];\r\n            if ((match as CustomPatternMatcherReturn).payload !== undefined) {\r\n              payload = (match as CustomPatternMatcherReturn).payload;\r\n            }\r\n          } else {\r\n            matchedImage = null;\r\n          }\r\n        } else {\r\n          this.updateLastIndex(currPattern as RegExp, offset);\r\n          matchedImage = this.match(currPattern as RegExp, text, offset);\r\n        }\r\n\r\n        if (matchedImage !== null) {\r\n          // even though this pattern matched we must try a another longer alternative.\r\n          // this can be used to prioritize keywords over identifiers\r\n          longerAlt = currConfig.longerAlt;\r\n          if (longerAlt !== undefined) {\r\n            // TODO: micro optimize, avoid extra prop access\r\n            // by saving/linking longerAlt on the original config?\r\n            const longerAltLength = longerAlt.length;\r\n            for (k = 0; k < longerAltLength; k++) {\r\n              const longerAltConfig = patternIdxToConfig[longerAlt[k]];\r\n              const longerAltPattern = longerAltConfig.pattern;\r\n              altPayload = null;\r\n\r\n              // single Char can never be a longer alt so no need to test it.\r\n              // manually in-lined because > 600 chars won't be in-lined in V8\r\n              if (longerAltConfig.isCustom === true) {\r\n                match = (longerAltPattern as IRegExpExec).exec(\r\n                  orgText,\r\n                  offset,\r\n                  matchedTokens,\r\n                  groups,\r\n                );\r\n                if (match !== null) {\r\n                  matchAltImage = match[0];\r\n                  if (\r\n                    (match as CustomPatternMatcherReturn).payload !== undefined\r\n                  ) {\r\n                    altPayload = (match as CustomPatternMatcherReturn).payload;\r\n                  }\r\n                } else {\r\n                  matchAltImage = null;\r\n                }\r\n              } else {\r\n                this.updateLastIndex(longerAltPattern as RegExp, offset);\r\n                matchAltImage = this.match(\r\n                  longerAltPattern as RegExp,\r\n                  text,\r\n                  offset,\r\n                );\r\n              }\r\n\r\n              if (matchAltImage && matchAltImage.length > matchedImage.length) {\r\n                matchedImage = matchAltImage;\r\n                payload = altPayload;\r\n                currConfig = longerAltConfig;\r\n                // Exit the loop early after matching one of the longer alternatives\r\n                // The first matched alternative takes precedence\r\n                break;\r\n              }\r\n            }\r\n          }\r\n          break;\r\n        }\r\n      }\r\n\r\n      // successful match\r\n      if (matchedImage !== null) {\r\n        imageLength = matchedImage.length;\r\n        group = currConfig.group;\r\n        if (group !== undefined) {\r\n          tokType = currConfig.tokenTypeIdx;\r\n          // TODO: \"offset + imageLength\" and the new column may be computed twice in case of \"full\" location information inside\r\n          // createFullToken method\r\n          newToken = this.createTokenInstance(\r\n            matchedImage,\r\n            offset,\r\n            tokType,\r\n            currConfig.tokenType,\r\n            line,\r\n            column,\r\n            imageLength,\r\n          );\r\n\r\n          this.handlePayload(newToken, payload);\r\n\r\n          // TODO: optimize NOOP in case there are no special groups?\r\n          if (group === false) {\r\n            matchedTokensIndex = this.addToken(\r\n              matchedTokens,\r\n              matchedTokensIndex,\r\n              newToken,\r\n            );\r\n          } else {\r\n            groups[group].push(newToken);\r\n          }\r\n        }\r\n        text = this.chopInput(text, imageLength);\r\n        offset = offset + imageLength;\r\n\r\n        // TODO: with newlines the column may be assigned twice\r\n        column = this.computeNewColumn(column!, imageLength);\r\n\r\n        if (trackLines === true && currConfig.canLineTerminator === true) {\r\n          let numOfLTsInMatch = 0;\r\n          let foundTerminator;\r\n          let lastLTEndOffset: number;\r\n          lineTerminatorPattern.lastIndex = 0;\r\n          do {\r\n            foundTerminator = lineTerminatorPattern.test(matchedImage);\r\n            if (foundTerminator === true) {\r\n              lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;\r\n              numOfLTsInMatch++;\r\n            }\r\n          } while (foundTerminator === true);\r\n\r\n          if (numOfLTsInMatch !== 0) {\r\n            line = line! + numOfLTsInMatch;\r\n            column = imageLength - lastLTEndOffset!;\r\n            this.updateTokenEndLineColumnLocation(\r\n              newToken!,\r\n              group!,\r\n              lastLTEndOffset!,\r\n              numOfLTsInMatch,\r\n              line,\r\n              column,\r\n              imageLength,\r\n            );\r\n          }\r\n        }\r\n        // will be NOOP if no modes present\r\n        this.handleModes(currConfig, pop_mode, push_mode, newToken!);\r\n      } else {\r\n        // error recovery, drop characters until we identify a valid token's start point\r\n        const errorStartOffset = offset;\r\n        const errorLine = line;\r\n        const errorColumn = column;\r\n        let foundResyncPoint = recoveryEnabled === false;\r\n\r\n        while (foundResyncPoint === false && offset < orgLength) {\r\n          // Identity Func (when sticky flag is enabled)\r\n          text = this.chopInput(text, 1);\r\n          offset++;\r\n          for (j = 0; j < currModePatternsLength; j++) {\r\n            const currConfig = patternIdxToConfig[j];\r\n            const currPattern = currConfig.pattern;\r\n\r\n            // manually in-lined because > 600 chars won't be in-lined in V8\r\n            const singleCharCode = currConfig.short;\r\n            if (singleCharCode !== false) {\r\n              if (orgText.charCodeAt(offset) === singleCharCode) {\r\n                // single character string\r\n                foundResyncPoint = true;\r\n              }\r\n            } else if (currConfig.isCustom === true) {\r\n              foundResyncPoint =\r\n                (currPattern as IRegExpExec).exec(\r\n                  orgText,\r\n                  offset,\r\n                  matchedTokens,\r\n                  groups,\r\n                ) !== null;\r\n            } else {\r\n              this.updateLastIndex(currPattern as RegExp, offset);\r\n              foundResyncPoint = (currPattern as RegExp).exec(text) !== null;\r\n            }\r\n\r\n            if (foundResyncPoint === true) {\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        errLength = offset - errorStartOffset;\r\n        column = this.computeNewColumn(column!, errLength);\r\n        // at this point we either re-synced or reached the end of the input text\r\n        msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(\r\n          orgText,\r\n          errorStartOffset,\r\n          errLength,\r\n          errorLine,\r\n          errorColumn,\r\n        );\r\n        errors.push({\r\n          offset: errorStartOffset,\r\n          line: errorLine,\r\n          column: errorColumn,\r\n          length: errLength,\r\n          message: msg,\r\n        });\r\n\r\n        if (recoveryEnabled === false) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    // if we do have custom patterns which push directly into the\r\n    // TODO: custom tokens should not push directly??\r\n    if (!this.hasCustom) {\r\n      // if we guessed a too large size for the tokens array this will shrink it to the right size.\r\n      matchedTokens.length = matchedTokensIndex;\r\n    }\r\n\r\n    return {\r\n      tokens: matchedTokens,\r\n      groups: groups,\r\n      errors: errors,\r\n    };\r\n  }\r\n\r\n  private handleModes(\r\n    config: IPatternConfig,\r\n    pop_mode: (tok: IToken) => void,\r\n    push_mode: (this: Lexer, pushMode: string) => void,\r\n    newToken: IToken,\r\n  ) {\r\n    if (config.pop === true) {\r\n      // need to save the PUSH_MODE property as if the mode is popped\r\n      // patternIdxToPopMode is updated to reflect the new mode after popping the stack\r\n      const pushMode = config.push;\r\n      pop_mode(newToken);\r\n      if (pushMode !== undefined) {\r\n        push_mode.call(this, pushMode);\r\n      }\r\n    } else if (config.push !== undefined) {\r\n      push_mode.call(this, config.push);\r\n    }\r\n  }\r\n\r\n  private chopInput(text: string, length: number): string {\r\n    return text.substring(length);\r\n  }\r\n\r\n  private updateLastIndex(regExp: RegExp, newLastIndex: number): void {\r\n    regExp.lastIndex = newLastIndex;\r\n  }\r\n\r\n  // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler\r\n  private updateTokenEndLineColumnLocation(\r\n    newToken: IToken,\r\n    group: string | false,\r\n    lastLTIdx: number,\r\n    numOfLTsInMatch: number,\r\n    line: number,\r\n    column: number,\r\n    imageLength: number,\r\n  ): void {\r\n    let lastCharIsLT, fixForEndingInLT;\r\n    if (group !== undefined) {\r\n      // a none skipped multi line Token, need to update endLine/endColumn\r\n      lastCharIsLT = lastLTIdx === imageLength - 1;\r\n      fixForEndingInLT = lastCharIsLT ? -1 : 0;\r\n      if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {\r\n        // if a token ends in a LT that last LT only affects the line numbering of following Tokens\r\n        newToken.endLine = line + fixForEndingInLT;\r\n        // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)\r\n        // inclusive to exclusive range.\r\n        newToken.endColumn = column - 1 + -fixForEndingInLT;\r\n      }\r\n      // else single LT in the last character of a token, no need to modify the endLine/EndColumn\r\n    }\r\n  }\r\n\r\n  private computeNewColumn(oldColumn: number, imageLength: number) {\r\n    return oldColumn + imageLength;\r\n  }\r\n\r\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\r\n  /* istanbul ignore next - place holder */\r\n  private createTokenInstance!: (...args: any[]) => IToken;\r\n\r\n  private createOffsetOnlyToken(\r\n    image: string,\r\n    startOffset: number,\r\n    tokenTypeIdx: number,\r\n    tokenType: TokenType,\r\n  ) {\r\n    return {\r\n      image,\r\n      startOffset,\r\n      tokenTypeIdx,\r\n      tokenType,\r\n    };\r\n  }\r\n\r\n  private createStartOnlyToken(\r\n    image: string,\r\n    startOffset: number,\r\n    tokenTypeIdx: number,\r\n    tokenType: TokenType,\r\n    startLine: number,\r\n    startColumn: number,\r\n  ) {\r\n    return {\r\n      image,\r\n      startOffset,\r\n      startLine,\r\n      startColumn,\r\n      tokenTypeIdx,\r\n      tokenType,\r\n    };\r\n  }\r\n\r\n  private createFullToken(\r\n    image: string,\r\n    startOffset: number,\r\n    tokenTypeIdx: number,\r\n    tokenType: TokenType,\r\n    startLine: number,\r\n    startColumn: number,\r\n    imageLength: number,\r\n  ): IToken {\r\n    return {\r\n      image,\r\n      startOffset,\r\n      endOffset: startOffset + imageLength - 1,\r\n      startLine,\r\n      endLine: startLine,\r\n      startColumn,\r\n      endColumn: startColumn + imageLength - 1,\r\n      tokenTypeIdx,\r\n      tokenType,\r\n    };\r\n  }\r\n\r\n  // Place holder, will be replaced by the correct variant according to the locationTracking option at runtime.\r\n  /* istanbul ignore next - place holder */\r\n  private addToken!: (\r\n    tokenVector: IToken[],\r\n    index: number,\r\n    tokenToAdd: IToken,\r\n  ) => number;\r\n\r\n  private addTokenUsingPush(\r\n    tokenVector: IToken[],\r\n    index: number,\r\n    tokenToAdd: IToken,\r\n  ): number {\r\n    tokenVector.push(tokenToAdd);\r\n    return index;\r\n  }\r\n\r\n  private addTokenUsingMemberAccess(\r\n    tokenVector: IToken[],\r\n    index: number,\r\n    tokenToAdd: IToken,\r\n  ): number {\r\n    tokenVector[index] = tokenToAdd;\r\n    index++;\r\n    return index;\r\n  }\r\n\r\n  // Place holder, will be replaced by the correct variant according to the hasCustom flag option at runtime.\r\n  private handlePayload: (token: IToken, payload: any) => void;\r\n\r\n  private handlePayloadNoCustom(token: IToken, payload: any): void {}\r\n\r\n  private handlePayloadWithCustom(token: IToken, payload: any): void {\r\n    if (payload !== null) {\r\n      token.payload = payload;\r\n    }\r\n  }\r\n\r\n  // place holder to be replaced with chosen alternative at runtime\r\n  private match!: (\r\n    pattern: RegExp,\r\n    text: string,\r\n    offset: number,\r\n  ) => string | null;\r\n\r\n  private matchWithTest(\r\n    pattern: RegExp,\r\n    text: string,\r\n    offset: number,\r\n  ): string | null {\r\n    const found = pattern.test(text);\r\n    if (found === true) {\r\n      return text.substring(offset, pattern.lastIndex);\r\n    }\r\n    return null;\r\n  }\r\n\r\n  private matchWithExec(pattern: RegExp, text: string): string | null {\r\n    const regExpArray = pattern.exec(text);\r\n    return regExpArray !== null ? regExpArray[0] : null;\r\n  }\r\n\r\n  // Duplicated from the parser's perf trace trait to allow future extraction\r\n  // of the lexer to a separate package.\r\n  TRACE_INIT = <T>(phaseDesc: string, phaseImpl: () => T): T => {\r\n    // No need to optimize this using NOOP pattern because\r\n    // It is not called in a hot spot...\r\n    if (this.traceInitPerf === true) {\r\n      this.traceInitIndent++;\r\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\r\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\r\n        console.log(`${indent}--> <${phaseDesc}>`);\r\n      }\r\n      const { time, value } = timer(phaseImpl);\r\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\r\n      const traceMethod = time > 10 ? console.warn : console.log;\r\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\r\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\r\n      }\r\n      this.traceInitIndent--;\r\n      return value;\r\n    } else {\r\n      return phaseImpl();\r\n    }\r\n  };\r\n}\r\n", "import { has, isString, isUndefined } from \"lodash-es\";\r\nimport { Lexer } from \"./lexer_public.js\";\r\nimport { augmentTokenTypes, tokenStructuredMatcher } from \"./tokens.js\";\r\nimport { IToken, ITokenConfig, TokenType } from \"@chevrotain/types\";\r\n\r\nexport function tokenLabel(tokType: TokenType): string {\r\n  if (hasTokenLabel(tokType)) {\r\n    return tokType.LABEL;\r\n  } else {\r\n    return tokType.name;\r\n  }\r\n}\r\n\r\nexport function tokenName(tokType: TokenType): string {\r\n  return tokType.name;\r\n}\r\n\r\nexport function hasTokenLabel(\r\n  obj: TokenType,\r\n): obj is TokenType & Pick<Required<TokenType>, \"LABEL\"> {\r\n  return isString(obj.LABEL) && obj.LABEL !== \"\";\r\n}\r\n\r\nconst PARENT = \"parent\";\r\nconst CATEGORIES = \"categories\";\r\nconst LABEL = \"label\";\r\nconst GROUP = \"group\";\r\nconst PUSH_MODE = \"push_mode\";\r\nconst POP_MODE = \"pop_mode\";\r\nconst LONGER_ALT = \"longer_alt\";\r\nconst LINE_BREAKS = \"line_breaks\";\r\nconst START_CHARS_HINT = \"start_chars_hint\";\r\n\r\nexport function createToken(config: ITokenConfig): TokenType {\r\n  return createTokenInternal(config);\r\n}\r\n\r\nfunction createTokenInternal(config: ITokenConfig): TokenType {\r\n  const pattern = config.pattern;\r\n\r\n  const tokenType: TokenType = <any>{};\r\n  tokenType.name = config.name;\r\n\r\n  if (!isUndefined(pattern)) {\r\n    tokenType.PATTERN = pattern;\r\n  }\r\n\r\n  if (has(config, PARENT)) {\r\n    throw (\r\n      \"The parent property is no longer supported.\\n\" +\r\n      \"See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.\"\r\n    );\r\n  }\r\n\r\n  if (has(config, CATEGORIES)) {\r\n    // casting to ANY as this will be fixed inside `augmentTokenTypes``\r\n    tokenType.CATEGORIES = <any>config[CATEGORIES];\r\n  }\r\n\r\n  augmentTokenTypes([tokenType]);\r\n\r\n  if (has(config, LABEL)) {\r\n    tokenType.LABEL = config[LABEL];\r\n  }\r\n\r\n  if (has(config, GROUP)) {\r\n    tokenType.GROUP = config[GROUP];\r\n  }\r\n\r\n  if (has(config, POP_MODE)) {\r\n    tokenType.POP_MODE = config[POP_MODE];\r\n  }\r\n\r\n  if (has(config, PUSH_MODE)) {\r\n    tokenType.PUSH_MODE = config[PUSH_MODE];\r\n  }\r\n\r\n  if (has(config, LONGER_ALT)) {\r\n    tokenType.LONGER_ALT = config[LONGER_ALT];\r\n  }\r\n\r\n  if (has(config, LINE_BREAKS)) {\r\n    tokenType.LINE_BREAKS = config[LINE_BREAKS];\r\n  }\r\n\r\n  if (has(config, START_CHARS_HINT)) {\r\n    tokenType.START_CHARS_HINT = config[START_CHARS_HINT];\r\n  }\r\n\r\n  return tokenType;\r\n}\r\n\r\nexport const EOF = createToken({ name: \"EOF\", pattern: Lexer.NA });\r\naugmentTokenTypes([EOF]);\r\n\r\nexport function createTokenInstance(\r\n  tokType: TokenType,\r\n  image: string,\r\n  startOffset: number,\r\n  endOffset: number,\r\n  startLine: number,\r\n  endLine: number,\r\n  startColumn: number,\r\n  endColumn: number,\r\n): IToken {\r\n  return {\r\n    image,\r\n    startOffset,\r\n    endOffset,\r\n    startLine,\r\n    endLine,\r\n    startColumn,\r\n    endColumn,\r\n    tokenTypeIdx: (<any>tokType).tokenTypeIdx,\r\n    tokenType: tokType,\r\n  };\r\n}\r\n\r\nexport function tokenMatcher(token: IToken, tokType: TokenType): boolean {\r\n  return tokenStructuredMatcher(token, tokType);\r\n}\r\n", "import { hasTokenLabel, tokenLabel } from \"../scan/tokens_public.js\";\r\nimport { first, map, reduce } from \"lodash-es\";\r\nimport {\r\n  Alternation,\r\n  getProductionDslName,\r\n  NonTerminal,\r\n  Rule,\r\n  Terminal,\r\n} from \"@chevrotain/gast\";\r\nimport {\r\n  IParserErrorMessageProvider,\r\n  IProductionWithOccurrence,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  IGrammarResolverErrorMessageProvider,\r\n  IGrammarValidatorErrorMessageProvider,\r\n} from \"./grammar/types.js\";\r\n\r\nexport const defaultParserErrorProvider: IParserErrorMessageProvider = {\r\n  buildMismatchTokenMessage({ expected, actual, previous, ruleName }): string {\r\n    const hasLabel = hasTokenLabel(expected);\r\n    const expectedMsg = hasLabel\r\n      ? `--> ${tokenLabel(expected)} <--`\r\n      : `token of type --> ${expected.name} <--`;\r\n\r\n    const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;\r\n\r\n    return msg;\r\n  },\r\n\r\n  buildNotAllInputParsedMessage({ firstRedundant, ruleName }): string {\r\n    return \"Redundant input, expecting EOF but found: \" + firstRedundant.image;\r\n  },\r\n\r\n  buildNoViableAltMessage({\r\n    expectedPathsPerAlt,\r\n    actual,\r\n    previous,\r\n    customUserDescription,\r\n    ruleName,\r\n  }): string {\r\n    const errPrefix = \"Expecting: \";\r\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\r\n    const actualText = first(actual)!.image;\r\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\r\n\r\n    if (customUserDescription) {\r\n      return errPrefix + customUserDescription + errSuffix;\r\n    } else {\r\n      const allLookAheadPaths = reduce(\r\n        expectedPathsPerAlt,\r\n        (result, currAltPaths) => result.concat(currAltPaths),\r\n        [] as TokenType[][],\r\n      );\r\n      const nextValidTokenSequences = map(\r\n        allLookAheadPaths,\r\n        (currPath) =>\r\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\r\n            \", \",\r\n          )}]`,\r\n      );\r\n      const nextValidSequenceItems = map(\r\n        nextValidTokenSequences,\r\n        (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`,\r\n      );\r\n      const calculatedDescription = `one of these possible Token sequences:\\n${nextValidSequenceItems.join(\r\n        \"\\n\",\r\n      )}`;\r\n\r\n      return errPrefix + calculatedDescription + errSuffix;\r\n    }\r\n  },\r\n\r\n  buildEarlyExitMessage({\r\n    expectedIterationPaths,\r\n    actual,\r\n    customUserDescription,\r\n    ruleName,\r\n  }): string {\r\n    const errPrefix = \"Expecting: \";\r\n    // TODO: issue: No Viable Alternative Error may have incomplete details. #502\r\n    const actualText = first(actual)!.image;\r\n    const errSuffix = \"\\nbut found: '\" + actualText + \"'\";\r\n\r\n    if (customUserDescription) {\r\n      return errPrefix + customUserDescription + errSuffix;\r\n    } else {\r\n      const nextValidTokenSequences = map(\r\n        expectedIterationPaths,\r\n        (currPath) =>\r\n          `[${map(currPath, (currTokenType) => tokenLabel(currTokenType)).join(\r\n            \",\",\r\n          )}]`,\r\n      );\r\n      const calculatedDescription =\r\n        `expecting at least one iteration which starts with one of these possible Token sequences::\\n  ` +\r\n        `<${nextValidTokenSequences.join(\" ,\")}>`;\r\n\r\n      return errPrefix + calculatedDescription + errSuffix;\r\n    }\r\n  },\r\n};\r\n\r\nObject.freeze(defaultParserErrorProvider);\r\n\r\nexport const defaultGrammarResolverErrorProvider: IGrammarResolverErrorMessageProvider =\r\n  {\r\n    buildRuleNotFoundError(\r\n      topLevelRule: Rule,\r\n      undefinedRule: NonTerminal,\r\n    ): string {\r\n      const msg =\r\n        \"Invalid grammar, reference to a rule which is not defined: ->\" +\r\n        undefinedRule.nonTerminalName +\r\n        \"<-\\n\" +\r\n        \"inside top level rule: ->\" +\r\n        topLevelRule.name +\r\n        \"<-\";\r\n      return msg;\r\n    },\r\n  };\r\n\r\nexport const defaultGrammarValidatorErrorProvider: IGrammarValidatorErrorMessageProvider =\r\n  {\r\n    buildDuplicateFoundError(\r\n      topLevelRule: Rule,\r\n      duplicateProds: IProductionWithOccurrence[],\r\n    ): string {\r\n      function getExtraProductionArgument(\r\n        prod: IProductionWithOccurrence,\r\n      ): string {\r\n        if (prod instanceof Terminal) {\r\n          return prod.terminalType.name;\r\n        } else if (prod instanceof NonTerminal) {\r\n          return prod.nonTerminalName;\r\n        } else {\r\n          return \"\";\r\n        }\r\n      }\r\n\r\n      const topLevelName = topLevelRule.name;\r\n      const duplicateProd = first(duplicateProds)!;\r\n      const index = duplicateProd.idx;\r\n      const dslName = getProductionDslName(duplicateProd);\r\n      const extraArgument = getExtraProductionArgument(duplicateProd);\r\n\r\n      const hasExplicitIndex = index > 0;\r\n      let msg = `->${dslName}${hasExplicitIndex ? index : \"\"}<- ${\r\n        extraArgument ? `with argument: ->${extraArgument}<-` : \"\"\r\n      }\r\n                  appears more than once (${\r\n                    duplicateProds.length\r\n                  } times) in the top level rule: ->${topLevelName}<-.                  \r\n                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES \r\n                  `;\r\n\r\n      // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...\r\n      msg = msg.replace(/[ \\t]+/g, \" \");\r\n      msg = msg.replace(/\\s\\s+/g, \"\\n\");\r\n\r\n      return msg;\r\n    },\r\n\r\n    buildNamespaceConflictError(rule: Rule): string {\r\n      const errMsg =\r\n        `Namespace conflict found in grammar.\\n` +\r\n        `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\\n` +\r\n        `To resolve this make sure each Terminal and Non-Terminal names are unique\\n` +\r\n        `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\\n` +\r\n        `and Non-Terminal names start with a lower case letter.`;\r\n\r\n      return errMsg;\r\n    },\r\n\r\n    buildAlternationPrefixAmbiguityError(options: {\r\n      topLevelRule: Rule;\r\n      prefixPath: TokenType[];\r\n      ambiguityIndices: number[];\r\n      alternation: Alternation;\r\n    }): string {\r\n      const pathMsg = map(options.prefixPath, (currTok) =>\r\n        tokenLabel(currTok),\r\n      ).join(\", \");\r\n      const occurrence =\r\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\r\n      const errMsg =\r\n        `Ambiguous alternatives: <${options.ambiguityIndices.join(\r\n          \" ,\",\r\n        )}> due to common lookahead prefix\\n` +\r\n        `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\\n` +\r\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n` +\r\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\\n` +\r\n        `For Further details.`;\r\n\r\n      return errMsg;\r\n    },\r\n\r\n    buildAlternationAmbiguityError(options: {\r\n      topLevelRule: Rule;\r\n      prefixPath: TokenType[];\r\n      ambiguityIndices: number[];\r\n      alternation: Alternation;\r\n    }): string {\r\n      const pathMsg = map(options.prefixPath, (currtok) =>\r\n        tokenLabel(currtok),\r\n      ).join(\", \");\r\n      const occurrence =\r\n        options.alternation.idx === 0 ? \"\" : options.alternation.idx;\r\n      let currMessage =\r\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\r\n          \" ,\",\r\n        )}> in <OR${occurrence}>` +\r\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\r\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`;\r\n\r\n      currMessage =\r\n        currMessage +\r\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\r\n        `For Further details.`;\r\n      return currMessage;\r\n    },\r\n\r\n    buildEmptyRepetitionError(options: {\r\n      topLevelRule: Rule;\r\n      repetition: IProductionWithOccurrence;\r\n    }): string {\r\n      let dslName = getProductionDslName(options.repetition);\r\n      if (options.repetition.idx !== 0) {\r\n        dslName += options.repetition.idx;\r\n      }\r\n\r\n      const errMsg =\r\n        `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\\n` +\r\n        `This could lead to an infinite loop.`;\r\n\r\n      return errMsg;\r\n    },\r\n\r\n    // TODO: remove - `errors_public` from nyc.config.js exclude\r\n    //       once this method is fully removed from this file\r\n    buildTokenNameError(options: {\r\n      tokenType: TokenType;\r\n      expectedPattern: RegExp;\r\n    }): string {\r\n      /* istanbul ignore next */\r\n      return \"deprecated\";\r\n    },\r\n\r\n    buildEmptyAlternationError(options: {\r\n      topLevelRule: Rule;\r\n      alternation: Alternation;\r\n      emptyChoiceIdx: number;\r\n    }): string {\r\n      const errMsg =\r\n        `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +\r\n        ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\\n` +\r\n        `Only the last alternative may be an empty alternative.`;\r\n\r\n      return errMsg;\r\n    },\r\n\r\n    buildTooManyAlternativesError(options: {\r\n      topLevelRule: Rule;\r\n      alternation: Alternation;\r\n    }): string {\r\n      const errMsg =\r\n        `An Alternation cannot have more than 256 alternatives:\\n` +\r\n        `<OR${options.alternation.idx}> inside <${\r\n          options.topLevelRule.name\r\n        }> Rule.\\n has ${\r\n          options.alternation.definition.length + 1\r\n        } alternatives.`;\r\n\r\n      return errMsg;\r\n    },\r\n\r\n    buildLeftRecursionError(options: {\r\n      topLevelRule: Rule;\r\n      leftRecursionPath: Rule[];\r\n    }): string {\r\n      const ruleName = options.topLevelRule.name;\r\n      const pathNames = map(\r\n        options.leftRecursionPath,\r\n        (currRule) => currRule.name,\r\n      );\r\n      const leftRecursivePath = `${ruleName} --> ${pathNames\r\n        .concat([ruleName])\r\n        .join(\" --> \")}`;\r\n      const errMsg =\r\n        `Left Recursion found in grammar.\\n` +\r\n        `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\\n` +\r\n        `without consuming any Tokens. The grammar path that causes this is: \\n ${leftRecursivePath}\\n` +\r\n        ` To fix this refactor your grammar to remove the left recursion.\\n` +\r\n        `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;\r\n\r\n      return errMsg;\r\n    },\r\n\r\n    // TODO: remove - `errors_public` from nyc.config.js exclude\r\n    //       once this method is fully removed from this file\r\n    buildInvalidRuleNameError(options: {\r\n      topLevelRule: Rule;\r\n      expectedPattern: RegExp;\r\n    }): string {\r\n      /* istanbul ignore next */\r\n      return \"deprecated\";\r\n    },\r\n\r\n    buildDuplicateRuleNameError(options: {\r\n      topLevelRule: Rule | string;\r\n      grammarName: string;\r\n    }): string {\r\n      let ruleName;\r\n      if (options.topLevelRule instanceof Rule) {\r\n        ruleName = options.topLevelRule.name;\r\n      } else {\r\n        ruleName = options.topLevelRule;\r\n      }\r\n\r\n      const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;\r\n\r\n      return errMsg;\r\n    },\r\n  };\r\n", "import {\r\n  IParserUnresolvedRefDefinitionError,\r\n  ParserDefinitionErrorType,\r\n} from \"../parser/parser.js\";\r\nimport { forEach, values } from \"lodash-es\";\r\nimport { GAstVisitor, NonTerminal, Rule } from \"@chevrotain/gast\";\r\nimport {\r\n  IGrammarResolverErrorMessageProvider,\r\n  IParserDefinitionError,\r\n} from \"./types.js\";\r\n\r\nexport function resolveGrammar(\r\n  topLevels: Record<string, Rule>,\r\n  errMsgProvider: IGrammarResolverErrorMessageProvider,\r\n): IParserDefinitionError[] {\r\n  const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);\r\n  refResolver.resolveRefs();\r\n  return refResolver.errors;\r\n}\r\n\r\nexport class GastRefResolverVisitor extends GAstVisitor {\r\n  public errors: IParserUnresolvedRefDefinitionError[] = [];\r\n  private currTopLevel: Rule;\r\n\r\n  constructor(\r\n    private nameToTopRule: Record<string, Rule>,\r\n    private errMsgProvider: IGrammarResolverErrorMessageProvider,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  public resolveRefs(): void {\r\n    forEach(values(this.nameToTopRule), (prod) => {\r\n      this.currTopLevel = prod;\r\n      prod.accept(this);\r\n    });\r\n  }\r\n\r\n  public visitNonTerminal(node: NonTerminal): void {\r\n    const ref = this.nameToTopRule[node.nonTerminalName];\r\n\r\n    if (!ref) {\r\n      const msg = this.errMsgProvider.buildRuleNotFoundError(\r\n        this.currTopLevel,\r\n        node,\r\n      );\r\n      this.errors.push({\r\n        message: msg,\r\n        type: ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,\r\n        ruleName: this.currTopLevel.name,\r\n        unresolvedRefName: node.nonTerminalName,\r\n      });\r\n    } else {\r\n      node.referencedRule = ref;\r\n    }\r\n  }\r\n}\r\n", "import {\r\n  clone,\r\n  drop,\r\n  dropRight,\r\n  first as _first,\r\n  forEach,\r\n  isEmpty,\r\n  last,\r\n} from \"lodash-es\";\r\nimport { first } from \"./first.js\";\r\nimport { RestWalker } from \"./rest.js\";\r\nimport { TokenMatcher } from \"../parser/parser.js\";\r\nimport {\r\n  Alternation,\r\n  Alternative,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n  Terminal,\r\n} from \"@chevrotain/gast\";\r\nimport {\r\n  IGrammarPath,\r\n  IProduction,\r\n  ISyntacticContentAssistPath,\r\n  IToken,\r\n  ITokenGrammarPath,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\n\r\nexport abstract class AbstractNextPossibleTokensWalker extends RestWalker {\r\n  protected possibleTokTypes: TokenType[] = [];\r\n  protected ruleStack: string[];\r\n  protected occurrenceStack: number[];\r\n\r\n  protected nextProductionName = \"\";\r\n  protected nextProductionOccurrence = 0;\r\n  protected found = false;\r\n  protected isAtEndOfPath = false;\r\n\r\n  constructor(\r\n    protected topProd: Rule,\r\n    protected path: IGrammarPath,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  startWalking(): TokenType[] {\r\n    this.found = false;\r\n\r\n    if (this.path.ruleStack[0] !== this.topProd.name) {\r\n      throw Error(\"The path does not start with the walker's top Rule!\");\r\n    }\r\n\r\n    // immutable for the win\r\n    this.ruleStack = clone(this.path.ruleStack).reverse(); // intelij bug requires assertion\r\n    this.occurrenceStack = clone(this.path.occurrenceStack).reverse(); // intelij bug requires assertion\r\n\r\n    // already verified that the first production is valid, we now seek the 2nd production\r\n    this.ruleStack.pop();\r\n    this.occurrenceStack.pop();\r\n\r\n    this.updateExpectedNext();\r\n    this.walk(this.topProd);\r\n\r\n    return this.possibleTokTypes;\r\n  }\r\n\r\n  walk(\r\n    prod: { definition: IProduction[] },\r\n    prevRest: IProduction[] = [],\r\n  ): void {\r\n    // stop scanning once we found the path\r\n    if (!this.found) {\r\n      super.walk(prod, prevRest);\r\n    }\r\n  }\r\n\r\n  walkProdRef(\r\n    refProd: NonTerminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    // found the next production, need to keep walking in it\r\n    if (\r\n      refProd.referencedRule.name === this.nextProductionName &&\r\n      refProd.idx === this.nextProductionOccurrence\r\n    ) {\r\n      const fullRest = currRest.concat(prevRest);\r\n      this.updateExpectedNext();\r\n      this.walk(refProd.referencedRule, <any>fullRest);\r\n    }\r\n  }\r\n\r\n  updateExpectedNext(): void {\r\n    // need to consume the Terminal\r\n    if (isEmpty(this.ruleStack)) {\r\n      // must reset nextProductionXXX to avoid walking down another Top Level production while what we are\r\n      // really seeking is the last Terminal...\r\n      this.nextProductionName = \"\";\r\n      this.nextProductionOccurrence = 0;\r\n      this.isAtEndOfPath = true;\r\n    } else {\r\n      this.nextProductionName = this.ruleStack.pop()!;\r\n      this.nextProductionOccurrence = this.occurrenceStack.pop()!;\r\n    }\r\n  }\r\n}\r\n\r\nexport class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {\r\n  private nextTerminalName = \"\";\r\n  private nextTerminalOccurrence = 0;\r\n\r\n  constructor(\r\n    topProd: Rule,\r\n    protected path: ITokenGrammarPath,\r\n  ) {\r\n    super(topProd, path);\r\n    this.nextTerminalName = this.path.lastTok.name;\r\n    this.nextTerminalOccurrence = this.path.lastTokOccurrence;\r\n  }\r\n\r\n  walkTerminal(\r\n    terminal: Terminal,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (\r\n      this.isAtEndOfPath &&\r\n      terminal.terminalType.name === this.nextTerminalName &&\r\n      terminal.idx === this.nextTerminalOccurrence &&\r\n      !this.found\r\n    ) {\r\n      const fullRest = currRest.concat(prevRest);\r\n      const restProd = new Alternative({ definition: fullRest });\r\n      this.possibleTokTypes = first(restProd);\r\n      this.found = true;\r\n    }\r\n  }\r\n}\r\n\r\nexport type AlternativesFirstTokens = TokenType[][];\r\n\r\nexport interface IFirstAfterRepetition {\r\n  token: TokenType | undefined;\r\n  occurrence: number | undefined;\r\n  isEndOfRule: boolean | undefined;\r\n}\r\n\r\n/**\r\n * This walker only \"walks\" a single \"TOP\" level in the Grammar Ast, this means\r\n * it never \"follows\" production refs\r\n */\r\nexport class AbstractNextTerminalAfterProductionWalker extends RestWalker {\r\n  protected result: IFirstAfterRepetition = {\r\n    token: undefined,\r\n    occurrence: undefined,\r\n    isEndOfRule: undefined,\r\n  };\r\n\r\n  constructor(\r\n    protected topRule: Rule,\r\n    protected occurrence: number,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  startWalking(): IFirstAfterRepetition {\r\n    this.walk(this.topRule);\r\n    return this.result;\r\n  }\r\n}\r\n\r\nexport class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkMany(\r\n    manyProd: Repetition,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (manyProd.idx === this.occurrence) {\r\n      const firstAfterMany = _first(currRest.concat(prevRest));\r\n      this.result.isEndOfRule = firstAfterMany === undefined;\r\n      if (firstAfterMany instanceof Terminal) {\r\n        this.result.token = firstAfterMany.terminalType;\r\n        this.result.occurrence = firstAfterMany.idx;\r\n      }\r\n    } else {\r\n      super.walkMany(manyProd, currRest, prevRest);\r\n    }\r\n  }\r\n}\r\n\r\nexport class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkManySep(\r\n    manySepProd: RepetitionWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (manySepProd.idx === this.occurrence) {\r\n      const firstAfterManySep = _first(currRest.concat(prevRest));\r\n      this.result.isEndOfRule = firstAfterManySep === undefined;\r\n      if (firstAfterManySep instanceof Terminal) {\r\n        this.result.token = firstAfterManySep.terminalType;\r\n        this.result.occurrence = firstAfterManySep.idx;\r\n      }\r\n    } else {\r\n      super.walkManySep(manySepProd, currRest, prevRest);\r\n    }\r\n  }\r\n}\r\n\r\nexport class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkAtLeastOne(\r\n    atLeastOneProd: RepetitionMandatory,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (atLeastOneProd.idx === this.occurrence) {\r\n      const firstAfterAtLeastOne = _first(currRest.concat(prevRest));\r\n      this.result.isEndOfRule = firstAfterAtLeastOne === undefined;\r\n      if (firstAfterAtLeastOne instanceof Terminal) {\r\n        this.result.token = firstAfterAtLeastOne.terminalType;\r\n        this.result.occurrence = firstAfterAtLeastOne.idx;\r\n      }\r\n    } else {\r\n      super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);\r\n    }\r\n  }\r\n}\r\n\r\n// TODO: reduce code duplication in the AfterWalkers\r\nexport class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {\r\n  walkAtLeastOneSep(\r\n    atleastOneSepProd: RepetitionMandatoryWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (atleastOneSepProd.idx === this.occurrence) {\r\n      const firstAfterfirstAfterAtLeastOneSep = _first(\r\n        currRest.concat(prevRest),\r\n      );\r\n      this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;\r\n      if (firstAfterfirstAfterAtLeastOneSep instanceof Terminal) {\r\n        this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;\r\n        this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;\r\n      }\r\n    } else {\r\n      super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);\r\n    }\r\n  }\r\n}\r\n\r\nexport interface PartialPathAndSuffixes {\r\n  partialPath: TokenType[];\r\n  suffixDef: IProduction[];\r\n}\r\n\r\nexport function possiblePathsFrom(\r\n  targetDef: IProduction[],\r\n  maxLength: number,\r\n  currPath: TokenType[] = [],\r\n): PartialPathAndSuffixes[] {\r\n  // avoid side effects\r\n  currPath = clone(currPath);\r\n  let result: PartialPathAndSuffixes[] = [];\r\n  let i = 0;\r\n\r\n  // TODO: avoid inner funcs\r\n  function remainingPathWith(nextDef: IProduction[]) {\r\n    return nextDef.concat(drop(targetDef, i + 1));\r\n  }\r\n\r\n  // TODO: avoid inner funcs\r\n  function getAlternativesForProd(definition: IProduction[]) {\r\n    const alternatives = possiblePathsFrom(\r\n      remainingPathWith(definition),\r\n      maxLength,\r\n      currPath,\r\n    );\r\n    return result.concat(alternatives);\r\n  }\r\n\r\n  /**\r\n   * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the\r\n   * following (rest) of the targetDef.\r\n   *\r\n   * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the\r\n   * the optional production.\r\n   */\r\n  while (currPath.length < maxLength && i < targetDef.length) {\r\n    const prod = targetDef[i];\r\n\r\n    /* istanbul ignore else */\r\n    if (prod instanceof Alternative) {\r\n      return getAlternativesForProd(prod.definition);\r\n    } else if (prod instanceof NonTerminal) {\r\n      return getAlternativesForProd(prod.definition);\r\n    } else if (prod instanceof Option) {\r\n      result = getAlternativesForProd(prod.definition);\r\n    } else if (prod instanceof RepetitionMandatory) {\r\n      const newDef = prod.definition.concat([\r\n        new Repetition({\r\n          definition: prod.definition,\r\n        }),\r\n      ]);\r\n      return getAlternativesForProd(newDef);\r\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n      const newDef = [\r\n        new Alternative({ definition: prod.definition }),\r\n        new Repetition({\r\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\r\n            <any>prod.definition,\r\n          ),\r\n        }),\r\n      ];\r\n      return getAlternativesForProd(newDef);\r\n    } else if (prod instanceof RepetitionWithSeparator) {\r\n      const newDef = prod.definition.concat([\r\n        new Repetition({\r\n          definition: [new Terminal({ terminalType: prod.separator })].concat(\r\n            <any>prod.definition,\r\n          ),\r\n        }),\r\n      ]);\r\n      result = getAlternativesForProd(newDef);\r\n    } else if (prod instanceof Repetition) {\r\n      const newDef = prod.definition.concat([\r\n        new Repetition({\r\n          definition: prod.definition,\r\n        }),\r\n      ]);\r\n      result = getAlternativesForProd(newDef);\r\n    } else if (prod instanceof Alternation) {\r\n      forEach(prod.definition, (currAlt) => {\r\n        // TODO: this is a limited check for empty alternatives\r\n        //   It would prevent a common case of infinite loops during parser initialization.\r\n        //   However **in-directly** empty alternatives may still cause issues.\r\n        if (isEmpty(currAlt.definition) === false) {\r\n          result = getAlternativesForProd(currAlt.definition);\r\n        }\r\n      });\r\n      return result;\r\n    } else if (prod instanceof Terminal) {\r\n      currPath.push(prod.terminalType);\r\n    } else {\r\n      throw Error(\"non exhaustive match\");\r\n    }\r\n\r\n    i++;\r\n  }\r\n  result.push({\r\n    partialPath: currPath,\r\n    suffixDef: drop(targetDef, i),\r\n  });\r\n\r\n  return result;\r\n}\r\n\r\ninterface IPathToExamine {\r\n  idx: number;\r\n  def: IProduction[];\r\n  ruleStack: string[];\r\n  occurrenceStack: number[];\r\n}\r\n\r\nexport function nextPossibleTokensAfter(\r\n  initialDef: IProduction[],\r\n  tokenVector: IToken[],\r\n  tokMatcher: TokenMatcher,\r\n  maxLookAhead: number,\r\n): ISyntacticContentAssistPath[] {\r\n  const EXIT_NON_TERMINAL: any = \"EXIT_NONE_TERMINAL\";\r\n  // to avoid creating a new Array each time.\r\n  const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];\r\n  const EXIT_ALTERNATIVE: any = \"EXIT_ALTERNATIVE\";\r\n  let foundCompletePath = false;\r\n\r\n  const tokenVectorLength = tokenVector.length;\r\n  const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;\r\n\r\n  const result: ISyntacticContentAssistPath[] = [];\r\n\r\n  const possiblePaths: IPathToExamine[] = [];\r\n  possiblePaths.push({\r\n    idx: -1,\r\n    def: initialDef,\r\n    ruleStack: [],\r\n    occurrenceStack: [],\r\n  });\r\n\r\n  while (!isEmpty(possiblePaths)) {\r\n    const currPath = possiblePaths.pop()!;\r\n\r\n    // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)\r\n    if (currPath === EXIT_ALTERNATIVE) {\r\n      if (\r\n        foundCompletePath &&\r\n        last(possiblePaths)!.idx <= minimalAlternativesIndex\r\n      ) {\r\n        // remove irrelevant alternative\r\n        possiblePaths.pop();\r\n      }\r\n      continue;\r\n    }\r\n\r\n    const currDef = currPath.def;\r\n    const currIdx = currPath.idx;\r\n    const currRuleStack = currPath.ruleStack;\r\n    const currOccurrenceStack = currPath.occurrenceStack;\r\n\r\n    // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT\r\n    if (isEmpty(currDef)) {\r\n      continue;\r\n    }\r\n\r\n    const prod = currDef[0];\r\n    /* istanbul ignore else */\r\n    if (prod === EXIT_NON_TERMINAL) {\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: dropRight(currRuleStack),\r\n        occurrenceStack: dropRight(currOccurrenceStack),\r\n      };\r\n      possiblePaths.push(nextPath);\r\n    } else if (prod instanceof Terminal) {\r\n      /* istanbul ignore else */\r\n      if (currIdx < tokenVectorLength - 1) {\r\n        const nextIdx = currIdx + 1;\r\n        const actualToken = tokenVector[nextIdx];\r\n        if (tokMatcher!(actualToken, prod.terminalType)) {\r\n          const nextPath = {\r\n            idx: nextIdx,\r\n            def: drop(currDef),\r\n            ruleStack: currRuleStack,\r\n            occurrenceStack: currOccurrenceStack,\r\n          };\r\n          possiblePaths.push(nextPath);\r\n        }\r\n        // end of the line\r\n      } else if (currIdx === tokenVectorLength - 1) {\r\n        // IGNORE ABOVE ELSE\r\n        result.push({\r\n          nextTokenType: prod.terminalType,\r\n          nextTokenOccurrence: prod.idx,\r\n          ruleStack: currRuleStack,\r\n          occurrenceStack: currOccurrenceStack,\r\n        });\r\n        foundCompletePath = true;\r\n      } else {\r\n        throw Error(\"non exhaustive match\");\r\n      }\r\n    } else if (prod instanceof NonTerminal) {\r\n      const newRuleStack = clone(currRuleStack);\r\n      newRuleStack.push(prod.nonTerminalName);\r\n\r\n      const newOccurrenceStack = clone(currOccurrenceStack);\r\n      newOccurrenceStack.push(prod.idx);\r\n\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, drop(currDef)),\r\n        ruleStack: newRuleStack,\r\n        occurrenceStack: newOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPath);\r\n    } else if (prod instanceof Option) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      const nextPathWithout = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPathWithout);\r\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n      possiblePaths.push(EXIT_ALTERNATIVE);\r\n\r\n      const nextPathWith = {\r\n        idx: currIdx,\r\n        def: prod.definition.concat(drop(currDef)),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPathWith);\r\n    } else if (prod instanceof RepetitionMandatory) {\r\n      // TODO:(THE NEW operators here take a while...) (convert once?)\r\n      const secondIteration = new Repetition({\r\n        definition: prod.definition,\r\n        idx: prod.idx,\r\n      });\r\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPath);\r\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n      // TODO:(THE NEW operators here take a while...) (convert once?)\r\n      const separatorGast = new Terminal({\r\n        terminalType: prod.separator,\r\n      });\r\n      const secondIteration = new Repetition({\r\n        definition: [<any>separatorGast].concat(prod.definition),\r\n        idx: prod.idx,\r\n      });\r\n      const nextDef = prod.definition.concat([secondIteration], drop(currDef));\r\n      const nextPath = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPath);\r\n    } else if (prod instanceof RepetitionWithSeparator) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      const nextPathWithout = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPathWithout);\r\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n      possiblePaths.push(EXIT_ALTERNATIVE);\r\n\r\n      const separatorGast = new Terminal({\r\n        terminalType: prod.separator,\r\n      });\r\n      const nthRepetition = new Repetition({\r\n        definition: [<any>separatorGast].concat(prod.definition),\r\n        idx: prod.idx,\r\n      });\r\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\r\n      const nextPathWith = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPathWith);\r\n    } else if (prod instanceof Repetition) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      const nextPathWithout = {\r\n        idx: currIdx,\r\n        def: drop(currDef),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPathWithout);\r\n      // required marker to avoid backtracking paths whose higher priority alternatives already matched\r\n      possiblePaths.push(EXIT_ALTERNATIVE);\r\n\r\n      // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?\r\n      const nthRepetition = new Repetition({\r\n        definition: prod.definition,\r\n        idx: prod.idx,\r\n      });\r\n      const nextDef = prod.definition.concat([nthRepetition], drop(currDef));\r\n      const nextPathWith = {\r\n        idx: currIdx,\r\n        def: nextDef,\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      };\r\n      possiblePaths.push(nextPathWith);\r\n    } else if (prod instanceof Alternation) {\r\n      // the order of alternatives is meaningful, FILO (Last path will be traversed first).\r\n      for (let i = prod.definition.length - 1; i >= 0; i--) {\r\n        const currAlt: any = prod.definition[i];\r\n        const currAltPath = {\r\n          idx: currIdx,\r\n          def: currAlt.definition.concat(drop(currDef)),\r\n          ruleStack: currRuleStack,\r\n          occurrenceStack: currOccurrenceStack,\r\n        };\r\n        possiblePaths.push(currAltPath);\r\n        possiblePaths.push(EXIT_ALTERNATIVE);\r\n      }\r\n    } else if (prod instanceof Alternative) {\r\n      possiblePaths.push({\r\n        idx: currIdx,\r\n        def: prod.definition.concat(drop(currDef)),\r\n        ruleStack: currRuleStack,\r\n        occurrenceStack: currOccurrenceStack,\r\n      });\r\n    } else if (prod instanceof Rule) {\r\n      // last because we should only encounter at most a single one of these per invocation.\r\n      possiblePaths.push(\r\n        expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack),\r\n      );\r\n    } else {\r\n      throw Error(\"non exhaustive match\");\r\n    }\r\n  }\r\n  return result;\r\n}\r\n\r\nfunction expandTopLevelRule(\r\n  topRule: Rule,\r\n  currIdx: number,\r\n  currRuleStack: string[],\r\n  currOccurrenceStack: number[],\r\n): IPathToExamine {\r\n  const newRuleStack = clone(currRuleStack);\r\n  newRuleStack.push(topRule.name);\r\n\r\n  const newCurrOccurrenceStack = clone(currOccurrenceStack);\r\n  // top rule is always assumed to have been called with occurrence index 1\r\n  newCurrOccurrenceStack.push(1);\r\n\r\n  return {\r\n    idx: currIdx,\r\n    def: topRule.definition,\r\n    ruleStack: newRuleStack,\r\n    occurrenceStack: newCurrOccurrenceStack,\r\n  };\r\n}\r\n", "import { every, flatten, forEach, has, isEmpty, map, reduce } from \"lodash-es\";\r\nimport { possiblePathsFrom } from \"./interpreter.js\";\r\nimport { RestWalker } from \"./rest.js\";\r\nimport { Predicate, TokenMatcher } from \"../parser/parser.js\";\r\nimport {\r\n  tokenStructuredMatcher,\r\n  tokenStructuredMatcherNoCategories,\r\n} from \"../../scan/tokens.js\";\r\nimport {\r\n  Alternation,\r\n  Alternative as AlternativeGAST,\r\n  GAstVisitor,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n} from \"@chevrotain/gast\";\r\nimport {\r\n  BaseParser,\r\n  IOrAlt,\r\n  IProduction,\r\n  IProductionWithOccurrence,\r\n  LookaheadProductionType,\r\n  LookaheadSequence,\r\n  Rule,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\n\r\nexport enum PROD_TYPE {\r\n  OPTION,\r\n  REPETITION,\r\n  REPETITION_MANDATORY,\r\n  REPETITION_MANDATORY_WITH_SEPARATOR,\r\n  REPETITION_WITH_SEPARATOR,\r\n  ALTERNATION,\r\n}\r\n\r\nexport function getProdType(\r\n  prod: IProduction | LookaheadProductionType,\r\n): PROD_TYPE {\r\n  /* istanbul ignore else */\r\n  if (prod instanceof Option || prod === \"Option\") {\r\n    return PROD_TYPE.OPTION;\r\n  } else if (prod instanceof Repetition || prod === \"Repetition\") {\r\n    return PROD_TYPE.REPETITION;\r\n  } else if (\r\n    prod instanceof RepetitionMandatory ||\r\n    prod === \"RepetitionMandatory\"\r\n  ) {\r\n    return PROD_TYPE.REPETITION_MANDATORY;\r\n  } else if (\r\n    prod instanceof RepetitionMandatoryWithSeparator ||\r\n    prod === \"RepetitionMandatoryWithSeparator\"\r\n  ) {\r\n    return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;\r\n  } else if (\r\n    prod instanceof RepetitionWithSeparator ||\r\n    prod === \"RepetitionWithSeparator\"\r\n  ) {\r\n    return PROD_TYPE.REPETITION_WITH_SEPARATOR;\r\n  } else if (prod instanceof Alternation || prod === \"Alternation\") {\r\n    return PROD_TYPE.ALTERNATION;\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n}\r\n\r\nexport function getLookaheadPaths(options: {\r\n  occurrence: number;\r\n  rule: Rule;\r\n  prodType: LookaheadProductionType;\r\n  maxLookahead: number;\r\n}): LookaheadSequence[] {\r\n  const { occurrence, rule, prodType, maxLookahead } = options;\r\n  const type = getProdType(prodType);\r\n  if (type === PROD_TYPE.ALTERNATION) {\r\n    return getLookaheadPathsForOr(occurrence, rule, maxLookahead);\r\n  } else {\r\n    return getLookaheadPathsForOptionalProd(\r\n      occurrence,\r\n      rule,\r\n      type,\r\n      maxLookahead,\r\n    );\r\n  }\r\n}\r\n\r\nexport function buildLookaheadFuncForOr(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  maxLookahead: number,\r\n  hasPredicates: boolean,\r\n  dynamicTokensEnabled: boolean,\r\n  laFuncBuilder: Function,\r\n): (orAlts?: IOrAlt<any>[]) => number | undefined {\r\n  const lookAheadPaths = getLookaheadPathsForOr(\r\n    occurrence,\r\n    ruleGrammar,\r\n    maxLookahead,\r\n  );\r\n\r\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\r\n    ? tokenStructuredMatcherNoCategories\r\n    : tokenStructuredMatcher;\r\n\r\n  return laFuncBuilder(\r\n    lookAheadPaths,\r\n    hasPredicates,\r\n    tokenMatcher,\r\n    dynamicTokensEnabled,\r\n  );\r\n}\r\n\r\n/**\r\n *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare\r\n *  the lookahead \"inside\" the production and the lookahead immediately \"after\" it in the same top level rule (context free).\r\n *\r\n *  Example: given a production:\r\n *  ABC(DE)?DF\r\n *\r\n *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two\r\n *  alternatives.\r\n *\r\n *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.\r\n */\r\nexport function buildLookaheadFuncForOptionalProd(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  k: number,\r\n  dynamicTokensEnabled: boolean,\r\n  prodType: PROD_TYPE,\r\n  lookaheadBuilder: (\r\n    lookAheadSequence: LookaheadSequence,\r\n    tokenMatcher: TokenMatcher,\r\n    dynamicTokensEnabled: boolean,\r\n  ) => () => boolean,\r\n): () => boolean {\r\n  const lookAheadPaths = getLookaheadPathsForOptionalProd(\r\n    occurrence,\r\n    ruleGrammar,\r\n    prodType,\r\n    k,\r\n  );\r\n\r\n  const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)\r\n    ? tokenStructuredMatcherNoCategories\r\n    : tokenStructuredMatcher;\r\n\r\n  return lookaheadBuilder(\r\n    lookAheadPaths[0],\r\n    tokenMatcher,\r\n    dynamicTokensEnabled,\r\n  );\r\n}\r\n\r\nexport type Alternative = TokenType[][];\r\n\r\nexport function buildAlternativesLookAheadFunc(\r\n  alts: LookaheadSequence[],\r\n  hasPredicates: boolean,\r\n  tokenMatcher: TokenMatcher,\r\n  dynamicTokensEnabled: boolean,\r\n): (orAlts: IOrAlt<any>[]) => number | undefined {\r\n  const numOfAlts = alts.length;\r\n  const areAllOneTokenLookahead = every(alts, (currAlt) => {\r\n    return every(currAlt, (currPath) => {\r\n      return currPath.length === 1;\r\n    });\r\n  });\r\n\r\n  // This version takes into account the predicates as well.\r\n  if (hasPredicates) {\r\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\r\n    return function (\r\n      this: BaseParser,\r\n      orAlts: IOrAlt<any>[],\r\n    ): number | undefined {\r\n      // unfortunately the predicates must be extracted every single time\r\n      // as they cannot be cached due to references to parameters(vars) which are no longer valid.\r\n      // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)\r\n      const predicates: (Predicate | undefined)[] = map(\r\n        orAlts,\r\n        (currAlt) => currAlt.GATE,\r\n      );\r\n\r\n      for (let t = 0; t < numOfAlts; t++) {\r\n        const currAlt = alts[t];\r\n        const currNumOfPaths = currAlt.length;\r\n\r\n        const currPredicate = predicates[t];\r\n        if (currPredicate !== undefined && currPredicate.call(this) === false) {\r\n          // if the predicate does not match there is no point in checking the paths\r\n          continue;\r\n        }\r\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\r\n          const currPath = currAlt[j];\r\n          const currPathLength = currPath.length;\r\n          for (let i = 0; i < currPathLength; i++) {\r\n            const nextToken = this.LA(i + 1);\r\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\r\n              // mismatch in current path\r\n              // try the next pth\r\n              continue nextPath;\r\n            }\r\n          }\r\n          // found a full path that matches.\r\n          // this will also work for an empty ALT as the loop will be skipped\r\n          return t;\r\n        }\r\n        // none of the paths for the current alternative matched\r\n        // try the next alternative\r\n      }\r\n      // none of the alternatives could be matched\r\n      return undefined;\r\n    };\r\n  } else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\r\n    // optimized (common) case of all the lookaheads paths requiring only\r\n    // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.\r\n    const singleTokenAlts = map(alts, (currAlt) => {\r\n      return flatten(currAlt);\r\n    });\r\n\r\n    const choiceToAlt = reduce(\r\n      singleTokenAlts,\r\n      (result, currAlt, idx) => {\r\n        forEach(currAlt, (currTokType) => {\r\n          if (!has(result, currTokType.tokenTypeIdx!)) {\r\n            result[currTokType.tokenTypeIdx!] = idx;\r\n          }\r\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\r\n            if (!has(result, currExtendingType)) {\r\n              result[currExtendingType] = idx;\r\n            }\r\n          });\r\n        });\r\n        return result;\r\n      },\r\n      {} as Record<number, number>,\r\n    );\r\n\r\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\r\n    return function (this: BaseParser): number {\r\n      const nextToken = this.LA(1);\r\n      return choiceToAlt[nextToken.tokenTypeIdx];\r\n    };\r\n  } else {\r\n    // optimized lookahead without needing to check the predicates at all.\r\n    // this causes code duplication which is intentional to improve performance.\r\n    /**\r\n     * @returns {number} - The chosen alternative index\r\n     */\r\n    return function (this: BaseParser): number | undefined {\r\n      for (let t = 0; t < numOfAlts; t++) {\r\n        const currAlt = alts[t];\r\n        const currNumOfPaths = currAlt.length;\r\n        nextPath: for (let j = 0; j < currNumOfPaths; j++) {\r\n          const currPath = currAlt[j];\r\n          const currPathLength = currPath.length;\r\n          for (let i = 0; i < currPathLength; i++) {\r\n            const nextToken = this.LA(i + 1);\r\n            if (tokenMatcher(nextToken, currPath[i]) === false) {\r\n              // mismatch in current path\r\n              // try the next pth\r\n              continue nextPath;\r\n            }\r\n          }\r\n          // found a full path that matches.\r\n          // this will also work for an empty ALT as the loop will be skipped\r\n          return t;\r\n        }\r\n        // none of the paths for the current alternative matched\r\n        // try the next alternative\r\n      }\r\n      // none of the alternatives could be matched\r\n      return undefined;\r\n    };\r\n  }\r\n}\r\n\r\nexport function buildSingleAlternativeLookaheadFunction(\r\n  alt: LookaheadSequence,\r\n  tokenMatcher: TokenMatcher,\r\n  dynamicTokensEnabled: boolean,\r\n): () => boolean {\r\n  const areAllOneTokenLookahead = every(alt, (currPath) => {\r\n    return currPath.length === 1;\r\n  });\r\n\r\n  const numOfPaths = alt.length;\r\n\r\n  // optimized (common) case of all the lookaheads paths requiring only\r\n  // a single token lookahead.\r\n  if (areAllOneTokenLookahead && !dynamicTokensEnabled) {\r\n    const singleTokensTypes = flatten(alt);\r\n\r\n    if (\r\n      singleTokensTypes.length === 1 &&\r\n      isEmpty((<any>singleTokensTypes[0]).categoryMatches)\r\n    ) {\r\n      const expectedTokenType = singleTokensTypes[0];\r\n      const expectedTokenUniqueKey = (<any>expectedTokenType).tokenTypeIdx;\r\n\r\n      return function (this: BaseParser): boolean {\r\n        return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;\r\n      };\r\n    } else {\r\n      const choiceToAlt = reduce(\r\n        singleTokensTypes,\r\n        (result, currTokType, idx) => {\r\n          result[currTokType.tokenTypeIdx!] = true;\r\n          forEach(currTokType.categoryMatches!, (currExtendingType) => {\r\n            result[currExtendingType] = true;\r\n          });\r\n          return result;\r\n        },\r\n        [] as boolean[],\r\n      );\r\n\r\n      return function (this: BaseParser): boolean {\r\n        const nextToken = this.LA(1);\r\n        return choiceToAlt[nextToken.tokenTypeIdx] === true;\r\n      };\r\n    }\r\n  } else {\r\n    return function (this: BaseParser): boolean {\r\n      nextPath: for (let j = 0; j < numOfPaths; j++) {\r\n        const currPath = alt[j];\r\n        const currPathLength = currPath.length;\r\n        for (let i = 0; i < currPathLength; i++) {\r\n          const nextToken = this.LA(i + 1);\r\n          if (tokenMatcher(nextToken, currPath[i]) === false) {\r\n            // mismatch in current path\r\n            // try the next pth\r\n            continue nextPath;\r\n          }\r\n        }\r\n        // found a full path that matches.\r\n        return true;\r\n      }\r\n\r\n      // none of the paths matched\r\n      return false;\r\n    };\r\n  }\r\n}\r\n\r\nclass RestDefinitionFinderWalker extends RestWalker {\r\n  private restDef: IProduction[];\r\n\r\n  constructor(\r\n    private topProd: Rule,\r\n    private targetOccurrence: number,\r\n    private targetProdType: PROD_TYPE,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  startWalking(): IProduction[] {\r\n    this.walk(this.topProd);\r\n    return this.restDef;\r\n  }\r\n\r\n  private checkIsTarget(\r\n    node: IProductionWithOccurrence,\r\n    expectedProdType: PROD_TYPE,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): boolean {\r\n    if (\r\n      node.idx === this.targetOccurrence &&\r\n      this.targetProdType === expectedProdType\r\n    ) {\r\n      this.restDef = currRest.concat(prevRest);\r\n      return true;\r\n    }\r\n    // performance optimization, do not iterate over the entire Grammar ast after we have found the target\r\n    return false;\r\n  }\r\n\r\n  walkOption(\r\n    optionProd: Option,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {\r\n      super.walkOption(optionProd, currRest, prevRest);\r\n    }\r\n  }\r\n\r\n  walkAtLeastOne(\r\n    atLeastOneProd: RepetitionMandatory,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(\r\n        atLeastOneProd,\r\n        PROD_TYPE.REPETITION_MANDATORY,\r\n        currRest,\r\n        prevRest,\r\n      )\r\n    ) {\r\n      super.walkOption(atLeastOneProd, currRest, prevRest);\r\n    }\r\n  }\r\n\r\n  walkAtLeastOneSep(\r\n    atLeastOneSepProd: RepetitionMandatoryWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(\r\n        atLeastOneSepProd,\r\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\r\n        currRest,\r\n        prevRest,\r\n      )\r\n    ) {\r\n      super.walkOption(atLeastOneSepProd, currRest, prevRest);\r\n    }\r\n  }\r\n\r\n  walkMany(\r\n    manyProd: Repetition,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)\r\n    ) {\r\n      super.walkOption(manyProd, currRest, prevRest);\r\n    }\r\n  }\r\n\r\n  walkManySep(\r\n    manySepProd: RepetitionWithSeparator,\r\n    currRest: IProduction[],\r\n    prevRest: IProduction[],\r\n  ): void {\r\n    if (\r\n      !this.checkIsTarget(\r\n        manySepProd,\r\n        PROD_TYPE.REPETITION_WITH_SEPARATOR,\r\n        currRest,\r\n        prevRest,\r\n      )\r\n    ) {\r\n      super.walkOption(manySepProd, currRest, prevRest);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Returns the definition of a target production in a top level level rule.\r\n */\r\nclass InsideDefinitionFinderVisitor extends GAstVisitor {\r\n  public result: IProduction[] = [];\r\n\r\n  constructor(\r\n    private targetOccurrence: number,\r\n    private targetProdType: PROD_TYPE,\r\n    private targetRef?: any,\r\n  ) {\r\n    super();\r\n  }\r\n\r\n  private checkIsTarget(\r\n    node: { definition: IProduction[] } & IProductionWithOccurrence,\r\n    expectedProdName: PROD_TYPE,\r\n  ): void {\r\n    if (\r\n      node.idx === this.targetOccurrence &&\r\n      this.targetProdType === expectedProdName &&\r\n      (this.targetRef === undefined || node === this.targetRef)\r\n    ) {\r\n      this.result = node.definition;\r\n    }\r\n  }\r\n\r\n  public visitOption(node: Option): void {\r\n    this.checkIsTarget(node, PROD_TYPE.OPTION);\r\n  }\r\n\r\n  public visitRepetition(node: Repetition): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION);\r\n  }\r\n\r\n  public visitRepetitionMandatory(node: RepetitionMandatory): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    node: RepetitionMandatoryWithSeparator,\r\n  ): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);\r\n  }\r\n\r\n  public visitRepetitionWithSeparator(node: RepetitionWithSeparator): void {\r\n    this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);\r\n  }\r\n\r\n  public visitAlternation(node: Alternation): void {\r\n    this.checkIsTarget(node, PROD_TYPE.ALTERNATION);\r\n  }\r\n}\r\n\r\nfunction initializeArrayOfArrays(size: number): any[][] {\r\n  const result = new Array(size);\r\n  for (let i = 0; i < size; i++) {\r\n    result[i] = [];\r\n  }\r\n  return result;\r\n}\r\n\r\n/**\r\n * A sort of hash function between a Path in the grammar and a string.\r\n * Note that this returns multiple \"hashes\" to support the scenario of token categories.\r\n * -  A single path with categories may match multiple **actual** paths.\r\n */\r\nfunction pathToHashKeys(path: TokenType[]): string[] {\r\n  let keys = [\"\"];\r\n  for (let i = 0; i < path.length; i++) {\r\n    const tokType = path[i];\r\n    const longerKeys = [];\r\n    for (let j = 0; j < keys.length; j++) {\r\n      const currShorterKey = keys[j];\r\n      longerKeys.push(currShorterKey + \"_\" + tokType.tokenTypeIdx);\r\n      for (let t = 0; t < tokType.categoryMatches!.length; t++) {\r\n        const categoriesKeySuffix = \"_\" + tokType.categoryMatches![t];\r\n        longerKeys.push(currShorterKey + categoriesKeySuffix);\r\n      }\r\n    }\r\n    keys = longerKeys;\r\n  }\r\n  return keys;\r\n}\r\n\r\n/**\r\n * Imperative style due to being called from a hot spot\r\n */\r\nfunction isUniquePrefixHash(\r\n  altKnownPathsKeys: Record<string, boolean>[],\r\n  searchPathKeys: string[],\r\n  idx: number,\r\n): boolean {\r\n  for (\r\n    let currAltIdx = 0;\r\n    currAltIdx < altKnownPathsKeys.length;\r\n    currAltIdx++\r\n  ) {\r\n    // We only want to test vs the other alternatives\r\n    if (currAltIdx === idx) {\r\n      continue;\r\n    }\r\n    const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];\r\n    for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {\r\n      const searchKey = searchPathKeys[searchIdx];\r\n      if (otherAltKnownPathsKeys[searchKey] === true) {\r\n        return false;\r\n      }\r\n    }\r\n  }\r\n  // None of the SearchPathKeys were found in any of the other alternatives\r\n  return true;\r\n}\r\n\r\nexport function lookAheadSequenceFromAlternatives(\r\n  altsDefs: IProduction[],\r\n  k: number,\r\n): LookaheadSequence[] {\r\n  const partialAlts = map(altsDefs, (currAlt) =>\r\n    possiblePathsFrom([currAlt], 1),\r\n  );\r\n  const finalResult = initializeArrayOfArrays(partialAlts.length);\r\n  const altsHashes = map(partialAlts, (currAltPaths) => {\r\n    const dict: { [key: string]: boolean } = {};\r\n    forEach(currAltPaths, (item) => {\r\n      const keys = pathToHashKeys(item.partialPath);\r\n      forEach(keys, (currKey) => {\r\n        dict[currKey] = true;\r\n      });\r\n    });\r\n    return dict;\r\n  });\r\n  let newData = partialAlts;\r\n\r\n  // maxLookahead loop\r\n  for (let pathLength = 1; pathLength <= k; pathLength++) {\r\n    const currDataset = newData;\r\n    newData = initializeArrayOfArrays(currDataset.length);\r\n\r\n    // alternatives loop\r\n    for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {\r\n      const currAltPathsAndSuffixes = currDataset[altIdx];\r\n      // paths in current alternative loop\r\n      for (\r\n        let currPathIdx = 0;\r\n        currPathIdx < currAltPathsAndSuffixes.length;\r\n        currPathIdx++\r\n      ) {\r\n        const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;\r\n        const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;\r\n        const prefixKeys = pathToHashKeys(currPathPrefix);\r\n        const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);\r\n        // End of the line for this path.\r\n        if (isUnique || isEmpty(suffixDef) || currPathPrefix.length === k) {\r\n          const currAltResult = finalResult[altIdx];\r\n          // TODO: Can we implement a containsPath using Maps/Dictionaries?\r\n          if (containsPath(currAltResult, currPathPrefix) === false) {\r\n            currAltResult.push(currPathPrefix);\r\n            // Update all new  keys for the current path.\r\n            for (let j = 0; j < prefixKeys.length; j++) {\r\n              const currKey = prefixKeys[j];\r\n              altsHashes[altIdx][currKey] = true;\r\n            }\r\n          }\r\n        }\r\n        // Expand longer paths\r\n        else {\r\n          const newPartialPathsAndSuffixes = possiblePathsFrom(\r\n            suffixDef,\r\n            pathLength + 1,\r\n            currPathPrefix,\r\n          );\r\n          newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);\r\n\r\n          // Update keys for new known paths\r\n          forEach(newPartialPathsAndSuffixes, (item) => {\r\n            const prefixKeys = pathToHashKeys(item.partialPath);\r\n            forEach(prefixKeys, (key) => {\r\n              altsHashes[altIdx][key] = true;\r\n            });\r\n          });\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return finalResult;\r\n}\r\n\r\nexport function getLookaheadPathsForOr(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  k: number,\r\n  orProd?: Alternation,\r\n): LookaheadSequence[] {\r\n  const visitor = new InsideDefinitionFinderVisitor(\r\n    occurrence,\r\n    PROD_TYPE.ALTERNATION,\r\n    orProd,\r\n  );\r\n  ruleGrammar.accept(visitor);\r\n  return lookAheadSequenceFromAlternatives(visitor.result, k);\r\n}\r\n\r\nexport function getLookaheadPathsForOptionalProd(\r\n  occurrence: number,\r\n  ruleGrammar: Rule,\r\n  prodType: PROD_TYPE,\r\n  k: number,\r\n): LookaheadSequence[] {\r\n  const insideDefVisitor = new InsideDefinitionFinderVisitor(\r\n    occurrence,\r\n    prodType,\r\n  );\r\n  ruleGrammar.accept(insideDefVisitor);\r\n  const insideDef = insideDefVisitor.result;\r\n\r\n  const afterDefWalker = new RestDefinitionFinderWalker(\r\n    ruleGrammar,\r\n    occurrence,\r\n    prodType,\r\n  );\r\n  const afterDef = afterDefWalker.startWalking();\r\n\r\n  const insideFlat = new AlternativeGAST({ definition: insideDef });\r\n  const afterFlat = new AlternativeGAST({ definition: afterDef });\r\n\r\n  return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);\r\n}\r\n\r\nexport function containsPath(\r\n  alternative: Alternative,\r\n  searchPath: TokenType[],\r\n): boolean {\r\n  compareOtherPath: for (let i = 0; i < alternative.length; i++) {\r\n    const otherPath = alternative[i];\r\n    if (otherPath.length !== searchPath.length) {\r\n      continue;\r\n    }\r\n    for (let j = 0; j < otherPath.length; j++) {\r\n      const searchTok = searchPath[j];\r\n      const otherTok = otherPath[j];\r\n\r\n      const matchingTokens =\r\n        searchTok === otherTok ||\r\n        otherTok.categoryMatchesMap![searchTok.tokenTypeIdx!] !== undefined;\r\n      if (matchingTokens === false) {\r\n        continue compareOtherPath;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  return false;\r\n}\r\n\r\nexport function isStrictPrefixOfPath(\r\n  prefix: TokenType[],\r\n  other: TokenType[],\r\n): boolean {\r\n  return (\r\n    prefix.length < other.length &&\r\n    every(prefix, (tokType, idx) => {\r\n      const otherTokType = other[idx];\r\n      return (\r\n        tokType === otherTokType ||\r\n        otherTokType.categoryMatchesMap![tokType.tokenTypeIdx!]\r\n      );\r\n    })\r\n  );\r\n}\r\n\r\nexport function areTokenCategoriesNotUsed(\r\n  lookAheadPaths: LookaheadSequence[],\r\n): boolean {\r\n  return every(lookAheadPaths, (singleAltPaths) =>\r\n    every(singleAltPaths, (singlePath) =>\r\n      every(singlePath, (token) => isEmpty(token.categoryMatches!)),\r\n    ),\r\n  );\r\n}\r\n", "import {\r\n  clone,\r\n  compact,\r\n  difference,\r\n  drop,\r\n  dropRight,\r\n  filter,\r\n  first,\r\n  flatMap,\r\n  flatten,\r\n  forEach,\r\n  groupBy,\r\n  includes,\r\n  isEmpty,\r\n  map,\r\n  pickBy,\r\n  reduce,\r\n  reject,\r\n  values,\r\n} from \"lodash-es\";\r\nimport {\r\n  IParserAmbiguousAlternativesDefinitionError,\r\n  IParserDuplicatesDefinitionError,\r\n  IParserEmptyAlternativeDefinitionError,\r\n  ParserDefinitionErrorType,\r\n} from \"../parser/parser.js\";\r\nimport {\r\n  Alternation,\r\n  Alternative as AlternativeGAST,\r\n  GAstVisitor,\r\n  getProductionDslName,\r\n  isOptionalProd,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Terminal,\r\n} from \"@chevrotain/gast\";\r\nimport {\r\n  Alternative,\r\n  containsPath,\r\n  getLookaheadPathsForOptionalProd,\r\n  getLookaheadPathsForOr,\r\n  getProdType,\r\n  isStrictPrefixOfPath,\r\n} from \"./lookahead.js\";\r\nimport { nextPossibleTokensAfter } from \"./interpreter.js\";\r\nimport {\r\n  ILookaheadStrategy,\r\n  IProduction,\r\n  IProductionWithOccurrence,\r\n  Rule,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  IGrammarValidatorErrorMessageProvider,\r\n  IParserDefinitionError,\r\n} from \"./types.js\";\r\nimport { tokenStructuredMatcher } from \"../../scan/tokens.js\";\r\n\r\nexport function validateLookahead(options: {\r\n  lookaheadStrategy: ILookaheadStrategy;\r\n  rules: Rule[];\r\n  tokenTypes: TokenType[];\r\n  grammarName: string;\r\n}): IParserDefinitionError[] {\r\n  const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({\r\n    rules: options.rules,\r\n    tokenTypes: options.tokenTypes,\r\n    grammarName: options.grammarName,\r\n  });\r\n  return map(lookaheadValidationErrorMessages, (errorMessage) => ({\r\n    type: ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION,\r\n    ...errorMessage,\r\n  }));\r\n}\r\n\r\nexport function validateGrammar(\r\n  topLevels: Rule[],\r\n  tokenTypes: TokenType[],\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n  grammarName: string,\r\n): IParserDefinitionError[] {\r\n  const duplicateErrors: IParserDefinitionError[] = flatMap(\r\n    topLevels,\r\n    (currTopLevel) =>\r\n      validateDuplicateProductions(currTopLevel, errMsgProvider),\r\n  );\r\n\r\n  const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(\r\n    topLevels,\r\n    tokenTypes,\r\n    errMsgProvider,\r\n  );\r\n\r\n  const tooManyAltsErrors = flatMap(topLevels, (curRule) =>\r\n    validateTooManyAlts(curRule, errMsgProvider),\r\n  );\r\n\r\n  const duplicateRulesError = flatMap(topLevels, (curRule) =>\r\n    validateRuleDoesNotAlreadyExist(\r\n      curRule,\r\n      topLevels,\r\n      grammarName,\r\n      errMsgProvider,\r\n    ),\r\n  );\r\n\r\n  return duplicateErrors.concat(\r\n    termsNamespaceConflictErrors,\r\n    tooManyAltsErrors,\r\n    duplicateRulesError,\r\n  );\r\n}\r\n\r\nfunction validateDuplicateProductions(\r\n  topLevelRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserDuplicatesDefinitionError[] {\r\n  const collectorVisitor = new OccurrenceValidationCollector();\r\n  topLevelRule.accept(collectorVisitor);\r\n  const allRuleProductions = collectorVisitor.allProductions;\r\n\r\n  const productionGroups = groupBy(\r\n    allRuleProductions,\r\n    identifyProductionForDuplicates,\r\n  );\r\n\r\n  const duplicates: any = pickBy(productionGroups, (currGroup) => {\r\n    return currGroup.length > 1;\r\n  });\r\n\r\n  const errors = map(values(duplicates), (currDuplicates: any) => {\r\n    const firstProd: any = first(currDuplicates);\r\n    const msg = errMsgProvider.buildDuplicateFoundError(\r\n      topLevelRule,\r\n      currDuplicates,\r\n    );\r\n    const dslName = getProductionDslName(firstProd);\r\n    const defError: IParserDuplicatesDefinitionError = {\r\n      message: msg,\r\n      type: ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,\r\n      ruleName: topLevelRule.name,\r\n      dslName: dslName,\r\n      occurrence: firstProd.idx,\r\n    };\r\n\r\n    const param = getExtraProductionArgument(firstProd);\r\n    if (param) {\r\n      defError.parameter = param;\r\n    }\r\n\r\n    return defError;\r\n  });\r\n  return errors;\r\n}\r\n\r\nexport function identifyProductionForDuplicates(\r\n  prod: IProductionWithOccurrence,\r\n): string {\r\n  return `${getProductionDslName(prod)}_#_${\r\n    prod.idx\r\n  }_#_${getExtraProductionArgument(prod)}`;\r\n}\r\n\r\nfunction getExtraProductionArgument(prod: IProductionWithOccurrence): string {\r\n  if (prod instanceof Terminal) {\r\n    return prod.terminalType.name;\r\n  } else if (prod instanceof NonTerminal) {\r\n    return prod.nonTerminalName;\r\n  } else {\r\n    return \"\";\r\n  }\r\n}\r\n\r\nexport class OccurrenceValidationCollector extends GAstVisitor {\r\n  public allProductions: IProductionWithOccurrence[] = [];\r\n\r\n  public visitNonTerminal(subrule: NonTerminal): void {\r\n    this.allProductions.push(subrule);\r\n  }\r\n\r\n  public visitOption(option: Option): void {\r\n    this.allProductions.push(option);\r\n  }\r\n\r\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\r\n    this.allProductions.push(manySep);\r\n  }\r\n\r\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\r\n    this.allProductions.push(atLeastOne);\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\r\n  ): void {\r\n    this.allProductions.push(atLeastOneSep);\r\n  }\r\n\r\n  public visitRepetition(many: Repetition): void {\r\n    this.allProductions.push(many);\r\n  }\r\n\r\n  public visitAlternation(or: Alternation): void {\r\n    this.allProductions.push(or);\r\n  }\r\n\r\n  public visitTerminal(terminal: Terminal): void {\r\n    this.allProductions.push(terminal);\r\n  }\r\n}\r\n\r\nexport function validateRuleDoesNotAlreadyExist(\r\n  rule: Rule,\r\n  allRules: Rule[],\r\n  className: string,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserDefinitionError[] {\r\n  const errors = [];\r\n  const occurrences = reduce(\r\n    allRules,\r\n    (result, curRule) => {\r\n      if (curRule.name === rule.name) {\r\n        return result + 1;\r\n      }\r\n      return result;\r\n    },\r\n    0,\r\n  );\r\n  if (occurrences > 1) {\r\n    const errMsg = errMsgProvider.buildDuplicateRuleNameError({\r\n      topLevelRule: rule,\r\n      grammarName: className,\r\n    });\r\n    errors.push({\r\n      message: errMsg,\r\n      type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\r\n      ruleName: rule.name,\r\n    });\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\n// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?\r\n// This is not part of the IGrammarErrorProvider because the validation cannot be performed on\r\n// The grammar structure, only at runtime.\r\nexport function validateRuleIsOverridden(\r\n  ruleName: string,\r\n  definedRulesNames: string[],\r\n  className: string,\r\n): IParserDefinitionError[] {\r\n  const errors = [];\r\n  let errMsg;\r\n\r\n  if (!includes(definedRulesNames, ruleName)) {\r\n    errMsg =\r\n      `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +\r\n      `as it is not defined in any of the super grammars `;\r\n    errors.push({\r\n      message: errMsg,\r\n      type: ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,\r\n      ruleName: ruleName,\r\n    });\r\n  }\r\n\r\n  return errors;\r\n}\r\n\r\nexport function validateNoLeftRecursion(\r\n  topRule: Rule,\r\n  currRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n  path: Rule[] = [],\r\n): IParserDefinitionError[] {\r\n  const errors: IParserDefinitionError[] = [];\r\n  const nextNonTerminals = getFirstNoneTerminal(currRule.definition);\r\n  if (isEmpty(nextNonTerminals)) {\r\n    return [];\r\n  } else {\r\n    const ruleName = topRule.name;\r\n    const foundLeftRecursion = includes(nextNonTerminals, topRule);\r\n    if (foundLeftRecursion) {\r\n      errors.push({\r\n        message: errMsgProvider.buildLeftRecursionError({\r\n          topLevelRule: topRule,\r\n          leftRecursionPath: path,\r\n        }),\r\n        type: ParserDefinitionErrorType.LEFT_RECURSION,\r\n        ruleName: ruleName,\r\n      });\r\n    }\r\n\r\n    // we are only looking for cyclic paths leading back to the specific topRule\r\n    // other cyclic paths are ignored, we still need this difference to avoid infinite loops...\r\n    const validNextSteps = difference(nextNonTerminals, path.concat([topRule]));\r\n    const errorsFromNextSteps = flatMap(validNextSteps, (currRefRule) => {\r\n      const newPath = clone(path);\r\n      newPath.push(currRefRule);\r\n      return validateNoLeftRecursion(\r\n        topRule,\r\n        currRefRule,\r\n        errMsgProvider,\r\n        newPath,\r\n      );\r\n    });\r\n\r\n    return errors.concat(errorsFromNextSteps);\r\n  }\r\n}\r\n\r\nexport function getFirstNoneTerminal(definition: IProduction[]): Rule[] {\r\n  let result: Rule[] = [];\r\n  if (isEmpty(definition)) {\r\n    return result;\r\n  }\r\n  const firstProd = first(definition);\r\n\r\n  /* istanbul ignore else */\r\n  if (firstProd instanceof NonTerminal) {\r\n    result.push(firstProd.referencedRule);\r\n  } else if (\r\n    firstProd instanceof AlternativeGAST ||\r\n    firstProd instanceof Option ||\r\n    firstProd instanceof RepetitionMandatory ||\r\n    firstProd instanceof RepetitionMandatoryWithSeparator ||\r\n    firstProd instanceof RepetitionWithSeparator ||\r\n    firstProd instanceof Repetition\r\n  ) {\r\n    result = result.concat(\r\n      getFirstNoneTerminal(<IProduction[]>firstProd.definition),\r\n    );\r\n  } else if (firstProd instanceof Alternation) {\r\n    // each sub definition in alternation is a FLAT\r\n    result = flatten(\r\n      map(firstProd.definition, (currSubDef) =>\r\n        getFirstNoneTerminal((<AlternativeGAST>currSubDef).definition),\r\n      ),\r\n    );\r\n  } else if (firstProd instanceof Terminal) {\r\n    // nothing to see, move along\r\n  } else {\r\n    throw Error(\"non exhaustive match\");\r\n  }\r\n\r\n  const isFirstOptional = isOptionalProd(firstProd);\r\n  const hasMore = definition.length > 1;\r\n  if (isFirstOptional && hasMore) {\r\n    const rest = drop(definition);\r\n    return result.concat(getFirstNoneTerminal(rest));\r\n  } else {\r\n    return result;\r\n  }\r\n}\r\n\r\nclass OrCollector extends GAstVisitor {\r\n  public alternations: Alternation[] = [];\r\n\r\n  public visitAlternation(node: Alternation): void {\r\n    this.alternations.push(node);\r\n  }\r\n}\r\n\r\nexport function validateEmptyOrAlternative(\r\n  topLevelRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserEmptyAlternativeDefinitionError[] {\r\n  const orCollector = new OrCollector();\r\n  topLevelRule.accept(orCollector);\r\n  const ors = orCollector.alternations;\r\n\r\n  const errors = flatMap<Alternation, IParserEmptyAlternativeDefinitionError>(\r\n    ors,\r\n    (currOr) => {\r\n      const exceptLast = dropRight(currOr.definition);\r\n      return flatMap(exceptLast, (currAlternative, currAltIdx) => {\r\n        const possibleFirstInAlt = nextPossibleTokensAfter(\r\n          [currAlternative],\r\n          [],\r\n          tokenStructuredMatcher,\r\n          1,\r\n        );\r\n        if (isEmpty(possibleFirstInAlt)) {\r\n          return [\r\n            {\r\n              message: errMsgProvider.buildEmptyAlternationError({\r\n                topLevelRule: topLevelRule,\r\n                alternation: currOr,\r\n                emptyChoiceIdx: currAltIdx,\r\n              }),\r\n              type: ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,\r\n              ruleName: topLevelRule.name,\r\n              occurrence: currOr.idx,\r\n              alternative: currAltIdx + 1,\r\n            },\r\n          ];\r\n        } else {\r\n          return [];\r\n        }\r\n      });\r\n    },\r\n  );\r\n\r\n  return errors;\r\n}\r\n\r\nexport function validateAmbiguousAlternationAlternatives(\r\n  topLevelRule: Rule,\r\n  globalMaxLookahead: number,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserAmbiguousAlternativesDefinitionError[] {\r\n  const orCollector = new OrCollector();\r\n  topLevelRule.accept(orCollector);\r\n  let ors = orCollector.alternations;\r\n\r\n  // New Handling of ignoring ambiguities\r\n  // - https://github.com/chevrotain/chevrotain/issues/869\r\n  ors = reject(ors, (currOr) => currOr.ignoreAmbiguities === true);\r\n\r\n  const errors = flatMap(ors, (currOr: Alternation) => {\r\n    const currOccurrence = currOr.idx;\r\n    const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;\r\n    const alternatives = getLookaheadPathsForOr(\r\n      currOccurrence,\r\n      topLevelRule,\r\n      actualMaxLookahead,\r\n      currOr,\r\n    );\r\n    const altsAmbiguityErrors = checkAlternativesAmbiguities(\r\n      alternatives,\r\n      currOr,\r\n      topLevelRule,\r\n      errMsgProvider,\r\n    );\r\n    const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(\r\n      alternatives,\r\n      currOr,\r\n      topLevelRule,\r\n      errMsgProvider,\r\n    );\r\n\r\n    return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport class RepetitionCollector extends GAstVisitor {\r\n  public allProductions: (IProductionWithOccurrence & {\r\n    maxLookahead?: number;\r\n  })[] = [];\r\n\r\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\r\n    this.allProductions.push(manySep);\r\n  }\r\n\r\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\r\n    this.allProductions.push(atLeastOne);\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\r\n  ): void {\r\n    this.allProductions.push(atLeastOneSep);\r\n  }\r\n\r\n  public visitRepetition(many: Repetition): void {\r\n    this.allProductions.push(many);\r\n  }\r\n}\r\n\r\nexport function validateTooManyAlts(\r\n  topLevelRule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserDefinitionError[] {\r\n  const orCollector = new OrCollector();\r\n  topLevelRule.accept(orCollector);\r\n  const ors = orCollector.alternations;\r\n\r\n  const errors = flatMap(ors, (currOr) => {\r\n    if (currOr.definition.length > 255) {\r\n      return [\r\n        {\r\n          message: errMsgProvider.buildTooManyAlternativesError({\r\n            topLevelRule: topLevelRule,\r\n            alternation: currOr,\r\n          }),\r\n          type: ParserDefinitionErrorType.TOO_MANY_ALTS,\r\n          ruleName: topLevelRule.name,\r\n          occurrence: currOr.idx,\r\n        },\r\n      ];\r\n    } else {\r\n      return [];\r\n    }\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport function validateSomeNonEmptyLookaheadPath(\r\n  topLevelRules: Rule[],\r\n  maxLookahead: number,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserDefinitionError[] {\r\n  const errors: IParserDefinitionError[] = [];\r\n  forEach(topLevelRules, (currTopRule) => {\r\n    const collectorVisitor = new RepetitionCollector();\r\n    currTopRule.accept(collectorVisitor);\r\n    const allRuleProductions = collectorVisitor.allProductions;\r\n    forEach(allRuleProductions, (currProd) => {\r\n      const prodType = getProdType(currProd);\r\n      const actualMaxLookahead = currProd.maxLookahead || maxLookahead;\r\n      const currOccurrence = currProd.idx;\r\n      const paths = getLookaheadPathsForOptionalProd(\r\n        currOccurrence,\r\n        currTopRule,\r\n        prodType,\r\n        actualMaxLookahead,\r\n      );\r\n      const pathsInsideProduction = paths[0];\r\n      if (isEmpty(flatten(pathsInsideProduction))) {\r\n        const errMsg = errMsgProvider.buildEmptyRepetitionError({\r\n          topLevelRule: currTopRule,\r\n          repetition: currProd,\r\n        });\r\n        errors.push({\r\n          message: errMsg,\r\n          type: ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,\r\n          ruleName: currTopRule.name,\r\n        });\r\n      }\r\n    });\r\n  });\r\n\r\n  return errors;\r\n}\r\n\r\nexport interface IAmbiguityDescriptor {\r\n  alts: number[];\r\n  path: TokenType[];\r\n}\r\n\r\nfunction checkAlternativesAmbiguities(\r\n  alternatives: Alternative[],\r\n  alternation: Alternation,\r\n  rule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserAmbiguousAlternativesDefinitionError[] {\r\n  const foundAmbiguousPaths: Alternative = [];\r\n  const identicalAmbiguities = reduce(\r\n    alternatives,\r\n    (result, currAlt, currAltIdx) => {\r\n      // ignore (skip) ambiguities with this alternative\r\n      if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {\r\n        return result;\r\n      }\r\n\r\n      forEach(currAlt, (currPath) => {\r\n        const altsCurrPathAppearsIn = [currAltIdx];\r\n        forEach(alternatives, (currOtherAlt, currOtherAltIdx) => {\r\n          if (\r\n            currAltIdx !== currOtherAltIdx &&\r\n            containsPath(currOtherAlt, currPath) &&\r\n            // ignore (skip) ambiguities with this \"other\" alternative\r\n            alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true\r\n          ) {\r\n            altsCurrPathAppearsIn.push(currOtherAltIdx);\r\n          }\r\n        });\r\n\r\n        if (\r\n          altsCurrPathAppearsIn.length > 1 &&\r\n          !containsPath(foundAmbiguousPaths, currPath)\r\n        ) {\r\n          foundAmbiguousPaths.push(currPath);\r\n          result.push({\r\n            alts: altsCurrPathAppearsIn,\r\n            path: currPath,\r\n          });\r\n        }\r\n      });\r\n      return result;\r\n    },\r\n    [] as { alts: number[]; path: TokenType[] }[],\r\n  );\r\n\r\n  const currErrors = map(identicalAmbiguities, (currAmbDescriptor) => {\r\n    const ambgIndices = map(\r\n      currAmbDescriptor.alts,\r\n      (currAltIdx) => currAltIdx + 1,\r\n    );\r\n\r\n    const currMessage = errMsgProvider.buildAlternationAmbiguityError({\r\n      topLevelRule: rule,\r\n      alternation: alternation,\r\n      ambiguityIndices: ambgIndices,\r\n      prefixPath: currAmbDescriptor.path,\r\n    });\r\n\r\n    return {\r\n      message: currMessage,\r\n      type: ParserDefinitionErrorType.AMBIGUOUS_ALTS,\r\n      ruleName: rule.name,\r\n      occurrence: alternation.idx,\r\n      alternatives: currAmbDescriptor.alts,\r\n    };\r\n  });\r\n\r\n  return currErrors;\r\n}\r\n\r\nexport function checkPrefixAlternativesAmbiguities(\r\n  alternatives: Alternative[],\r\n  alternation: Alternation,\r\n  rule: Rule,\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserAmbiguousAlternativesDefinitionError[] {\r\n  // flatten\r\n  const pathsAndIndices = reduce(\r\n    alternatives,\r\n    (result, currAlt, idx) => {\r\n      const currPathsAndIdx = map(currAlt, (currPath) => {\r\n        return { idx: idx, path: currPath };\r\n      });\r\n      return result.concat(currPathsAndIdx);\r\n    },\r\n    [] as { idx: number; path: TokenType[] }[],\r\n  );\r\n\r\n  const errors = compact(\r\n    flatMap(pathsAndIndices, (currPathAndIdx) => {\r\n      const alternativeGast = alternation.definition[currPathAndIdx.idx];\r\n      // ignore (skip) ambiguities with this alternative\r\n      if (alternativeGast.ignoreAmbiguities === true) {\r\n        return [];\r\n      }\r\n      const targetIdx = currPathAndIdx.idx;\r\n      const targetPath = currPathAndIdx.path;\r\n\r\n      const prefixAmbiguitiesPathsAndIndices = filter(\r\n        pathsAndIndices,\r\n        (searchPathAndIdx) => {\r\n          // prefix ambiguity can only be created from lower idx (higher priority) path\r\n          return (\r\n            // ignore (skip) ambiguities with this \"other\" alternative\r\n            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==\r\n              true &&\r\n            searchPathAndIdx.idx < targetIdx &&\r\n            // checking for strict prefix because identical lookaheads\r\n            // will be be detected using a different validation.\r\n            isStrictPrefixOfPath(searchPathAndIdx.path, targetPath)\r\n          );\r\n        },\r\n      );\r\n\r\n      const currPathPrefixErrors = map(\r\n        prefixAmbiguitiesPathsAndIndices,\r\n        (currAmbPathAndIdx): IParserAmbiguousAlternativesDefinitionError => {\r\n          const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];\r\n          const occurrence = alternation.idx === 0 ? \"\" : alternation.idx;\r\n\r\n          const message = errMsgProvider.buildAlternationPrefixAmbiguityError({\r\n            topLevelRule: rule,\r\n            alternation: alternation,\r\n            ambiguityIndices: ambgIndices,\r\n            prefixPath: currAmbPathAndIdx.path,\r\n          });\r\n          return {\r\n            message: message,\r\n            type: ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,\r\n            ruleName: rule.name,\r\n            occurrence: occurrence,\r\n            alternatives: ambgIndices,\r\n          };\r\n        },\r\n      );\r\n\r\n      return currPathPrefixErrors;\r\n    }),\r\n  );\r\n\r\n  return errors;\r\n}\r\n\r\nfunction checkTerminalAndNoneTerminalsNameSpace(\r\n  topLevels: Rule[],\r\n  tokenTypes: TokenType[],\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider,\r\n): IParserDefinitionError[] {\r\n  const errors: IParserDefinitionError[] = [];\r\n\r\n  const tokenNames = map(tokenTypes, (currToken) => currToken.name);\r\n\r\n  forEach(topLevels, (currRule) => {\r\n    const currRuleName = currRule.name;\r\n    if (includes(tokenNames, currRuleName)) {\r\n      const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);\r\n\r\n      errors.push({\r\n        message: errMsg,\r\n        type: ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,\r\n        ruleName: currRuleName,\r\n      });\r\n    }\r\n  });\r\n\r\n  return errors;\r\n}\r\n", "import { Rule } from \"@chevrotain/gast\";\r\nimport { defaults, forEach } from \"lodash-es\";\r\nimport { resolveGrammar as orgResolveGrammar } from \"../resolver.js\";\r\nimport { validateGrammar as orgValidateGrammar } from \"../checks.js\";\r\nimport {\r\n  defaultGrammarResolverErrorProvider,\r\n  defaultGrammarValidatorErrorProvider,\r\n} from \"../../errors_public.js\";\r\nimport { TokenType } from \"@chevrotain/types\";\r\nimport {\r\n  IGrammarResolverErrorMessageProvider,\r\n  IGrammarValidatorErrorMessageProvider,\r\n  IParserDefinitionError,\r\n} from \"../types.js\";\r\n\r\ntype ResolveGrammarOpts = {\r\n  rules: Rule[];\r\n  errMsgProvider?: IGrammarResolverErrorMessageProvider;\r\n};\r\nexport function resolveGrammar(\r\n  options: ResolveGrammarOpts,\r\n): IParserDefinitionError[] {\r\n  const actualOptions: Required<ResolveGrammarOpts> = defaults(options, {\r\n    errMsgProvider: defaultGrammarResolverErrorProvider,\r\n  });\r\n\r\n  const topRulesTable: { [ruleName: string]: Rule } = {};\r\n  forEach(options.rules, (rule) => {\r\n    topRulesTable[rule.name] = rule;\r\n  });\r\n  return orgResolveGrammar(topRulesTable, actualOptions.errMsgProvider);\r\n}\r\n\r\nexport function validateGrammar(options: {\r\n  rules: Rule[];\r\n  tokenTypes: TokenType[];\r\n  grammarName: string;\r\n  errMsgProvider: IGrammarValidatorErrorMessageProvider;\r\n}): IParserDefinitionError[] {\r\n  options = defaults(options, {\r\n    errMsgProvider: defaultGrammarValidatorErrorProvider,\r\n  });\r\n\r\n  return orgValidateGrammar(\r\n    options.rules,\r\n    options.tokenTypes,\r\n    options.errMsgProvider,\r\n    options.grammarName,\r\n  );\r\n}\r\n", "import { includes } from \"lodash-es\";\r\nimport {\r\n  IRecognitionException,\r\n  IRecognizerContext,\r\n  IToken,\r\n} from \"@chevrotain/types\";\r\n\r\nconst MISMATCHED_TOKEN_EXCEPTION = \"MismatchedTokenException\";\r\nconst NO_VIABLE_ALT_EXCEPTION = \"NoViableAltException\";\r\nconst EARLY_EXIT_EXCEPTION = \"EarlyExitException\";\r\nconst NOT_ALL_INPUT_PARSED_EXCEPTION = \"NotAllInputParsedException\";\r\n\r\nconst RECOGNITION_EXCEPTION_NAMES = [\r\n  MISMATCHED_TOKEN_EXCEPTION,\r\n  NO_VIABLE_ALT_EXCEPTION,\r\n  EARLY_EXIT_EXCEPTION,\r\n  NOT_ALL_INPUT_PARSED_EXCEPTION,\r\n];\r\n\r\nObject.freeze(RECOGNITION_EXCEPTION_NAMES);\r\n\r\n// hacks to bypass no support for custom Errors in javascript/typescript\r\nexport function isRecognitionException(error: Error) {\r\n  // can't do instanceof on hacked custom js exceptions\r\n  return includes(RECOGNITION_EXCEPTION_NAMES, error.name);\r\n}\r\n\r\nabstract class RecognitionException\r\n  extends Error\r\n  implements IRecognitionException\r\n{\r\n  context: IRecognizerContext;\r\n  resyncedTokens: IToken[] = [];\r\n\r\n  protected constructor(\r\n    message: string,\r\n    public token: IToken,\r\n  ) {\r\n    super(message);\r\n\r\n    // fix prototype chain when typescript target is ES5\r\n    Object.setPrototypeOf(this, new.target.prototype);\r\n\r\n    /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */\r\n    if (Error.captureStackTrace) {\r\n      Error.captureStackTrace(this, this.constructor);\r\n    }\r\n  }\r\n}\r\n\r\nexport class MismatchedTokenException extends RecognitionException {\r\n  constructor(\r\n    message: string,\r\n    token: IToken,\r\n    public previousToken: IToken,\r\n  ) {\r\n    super(message, token);\r\n    this.name = MISMATCHED_TOKEN_EXCEPTION;\r\n  }\r\n}\r\n\r\nexport class NoViableAltException extends RecognitionException {\r\n  constructor(\r\n    message: string,\r\n    token: IToken,\r\n    public previousToken: IToken,\r\n  ) {\r\n    super(message, token);\r\n    this.name = NO_VIABLE_ALT_EXCEPTION;\r\n  }\r\n}\r\n\r\nexport class NotAllInputParsedException extends RecognitionException {\r\n  constructor(message: string, token: IToken) {\r\n    super(message, token);\r\n    this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;\r\n  }\r\n}\r\n\r\nexport class EarlyExitException extends RecognitionException {\r\n  constructor(\r\n    message: string,\r\n    token: IToken,\r\n    public previousToken: IToken,\r\n  ) {\r\n    super(message, token);\r\n    this.name = EARLY_EXIT_EXCEPTION;\r\n  }\r\n}\r\n", "import {\r\n  createTokenInstance,\r\n  EOF,\r\n  tokenMatcher,\r\n} from \"../../../scan/tokens_public.js\";\r\nimport {\r\n  AbstractNextTerminalAfterProductionWalker,\r\n  IFirstAfterRepetition,\r\n} from \"../../grammar/interpreter.js\";\r\nimport {\r\n  clone,\r\n  dropRight,\r\n  find,\r\n  flatten,\r\n  has,\r\n  includes,\r\n  isEmpty,\r\n  map,\r\n} from \"lodash-es\";\r\nimport {\r\n  IParserConfig,\r\n  IToken,\r\n  ITokenGrammarPath,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport { MismatchedTokenException } from \"../../exceptions_public.js\";\r\nimport { IN } from \"../../constants.js\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\r\n\r\nexport const EOF_FOLLOW_KEY: any = {};\r\n\r\nexport interface IFollowKey {\r\n  ruleName: string;\r\n  idxInCallingRule: number;\r\n  inRule: string;\r\n}\r\n\r\nexport const IN_RULE_RECOVERY_EXCEPTION = \"InRuleRecoveryException\";\r\n\r\nexport class InRuleRecoveryException extends Error {\r\n  constructor(message: string) {\r\n    super(message);\r\n    this.name = IN_RULE_RECOVERY_EXCEPTION;\r\n  }\r\n}\r\n\r\n/**\r\n * This trait is responsible for the error recovery and fault tolerant logic\r\n */\r\nexport class Recoverable {\r\n  recoveryEnabled: boolean;\r\n  firstAfterRepMap: Record<string, IFirstAfterRepetition>;\r\n  resyncFollows: Record<string, TokenType[]>;\r\n\r\n  initRecoverable(config: IParserConfig) {\r\n    this.firstAfterRepMap = {};\r\n    this.resyncFollows = {};\r\n\r\n    this.recoveryEnabled = has(config, \"recoveryEnabled\")\r\n      ? (config.recoveryEnabled as boolean) // assumes end user provides the correct config value/type\r\n      : DEFAULT_PARSER_CONFIG.recoveryEnabled;\r\n\r\n    // performance optimization, NOOP will be inlined which\r\n    // effectively means that this optional feature does not exist\r\n    // when not used.\r\n    if (this.recoveryEnabled) {\r\n      this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;\r\n    }\r\n  }\r\n\r\n  public getTokenToInsert(tokType: TokenType): IToken {\r\n    const tokToInsert = createTokenInstance(\r\n      tokType,\r\n      \"\",\r\n      NaN,\r\n      NaN,\r\n      NaN,\r\n      NaN,\r\n      NaN,\r\n      NaN,\r\n    );\r\n    tokToInsert.isInsertedInRecovery = true;\r\n    return tokToInsert;\r\n  }\r\n\r\n  public canTokenTypeBeInsertedInRecovery(tokType: TokenType): boolean {\r\n    return true;\r\n  }\r\n\r\n  public canTokenTypeBeDeletedInRecovery(tokType: TokenType): boolean {\r\n    return true;\r\n  }\r\n\r\n  tryInRepetitionRecovery(\r\n    this: MixedInParser,\r\n    grammarRule: Function,\r\n    grammarRuleArgs: any[],\r\n    lookAheadFunc: () => boolean,\r\n    expectedTokType: TokenType,\r\n  ): void {\r\n    // TODO: can the resyncTokenType be cached?\r\n    const reSyncTokType = this.findReSyncTokenType();\r\n    const savedLexerState = this.exportLexerState();\r\n    const resyncedTokens: IToken[] = [];\r\n    let passedResyncPoint = false;\r\n\r\n    const nextTokenWithoutResync = this.LA(1);\r\n    let currToken = this.LA(1);\r\n\r\n    const generateErrorMessage = () => {\r\n      const previousToken = this.LA(0);\r\n      // we are preemptively re-syncing before an error has been detected, therefor we must reproduce\r\n      // the error that would have been thrown\r\n      const msg = this.errorMessageProvider.buildMismatchTokenMessage({\r\n        expected: expectedTokType,\r\n        actual: nextTokenWithoutResync,\r\n        previous: previousToken,\r\n        ruleName: this.getCurrRuleFullName(),\r\n      });\r\n      const error = new MismatchedTokenException(\r\n        msg,\r\n        nextTokenWithoutResync,\r\n        this.LA(0),\r\n      );\r\n      // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.\r\n      error.resyncedTokens = dropRight(resyncedTokens);\r\n      this.SAVE_ERROR(error);\r\n    };\r\n\r\n    while (!passedResyncPoint) {\r\n      // re-synced to a point where we can safely exit the repetition/\r\n      if (this.tokenMatcher(currToken, expectedTokType)) {\r\n        generateErrorMessage();\r\n        return; // must return here to avoid reverting the inputIdx\r\n      } else if (lookAheadFunc.call(this)) {\r\n        // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule\r\n        generateErrorMessage();\r\n        // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule\r\n        grammarRule.apply(this, grammarRuleArgs);\r\n        return; // must return here to avoid reverting the inputIdx\r\n      } else if (this.tokenMatcher(currToken, reSyncTokType)) {\r\n        passedResyncPoint = true;\r\n      } else {\r\n        currToken = this.SKIP_TOKEN();\r\n        this.addToResyncTokens(currToken, resyncedTokens);\r\n      }\r\n    }\r\n\r\n    // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.\r\n    // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by\r\n    // \"between rules\" resync recovery later in the flow.\r\n    this.importLexerState(savedLexerState);\r\n  }\r\n\r\n  shouldInRepetitionRecoveryBeTried(\r\n    this: MixedInParser,\r\n    expectTokAfterLastMatch: TokenType,\r\n    nextTokIdx: number,\r\n    notStuck: boolean | undefined,\r\n  ): boolean {\r\n    // Edge case of arriving from a MANY repetition which is stuck\r\n    // Attempting recovery in this case could cause an infinite loop\r\n    if (notStuck === false) {\r\n      return false;\r\n    }\r\n\r\n    // no need to recover, next token is what we expect...\r\n    if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {\r\n      return false;\r\n    }\r\n\r\n    // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path\r\n    // and prefer some backtracking path that includes recovered errors.\r\n    if (this.isBackTracking()) {\r\n      return false;\r\n    }\r\n\r\n    // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm\r\n    // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)\r\n    //noinspection RedundantIfStatementJS\r\n    if (\r\n      this.canPerformInRuleRecovery(\r\n        expectTokAfterLastMatch,\r\n        this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx),\r\n      )\r\n    ) {\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  // Error Recovery functionality\r\n  getFollowsForInRuleRecovery(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    tokIdxInRule: number,\r\n  ): TokenType[] {\r\n    const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);\r\n    const follows = this.getNextPossibleTokenTypes(grammarPath);\r\n    return follows;\r\n  }\r\n\r\n  tryInRuleRecovery(\r\n    this: MixedInParser,\r\n    expectedTokType: TokenType,\r\n    follows: TokenType[],\r\n  ): IToken {\r\n    if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {\r\n      const tokToInsert = this.getTokenToInsert(expectedTokType);\r\n      return tokToInsert;\r\n    }\r\n\r\n    if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {\r\n      const nextTok = this.SKIP_TOKEN();\r\n      this.consumeToken();\r\n      return nextTok;\r\n    }\r\n\r\n    throw new InRuleRecoveryException(\"sad sad panda\");\r\n  }\r\n\r\n  canPerformInRuleRecovery(\r\n    this: MixedInParser,\r\n    expectedToken: TokenType,\r\n    follows: TokenType[],\r\n  ): boolean {\r\n    return (\r\n      this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||\r\n      this.canRecoverWithSingleTokenDeletion(expectedToken)\r\n    );\r\n  }\r\n\r\n  canRecoverWithSingleTokenInsertion(\r\n    this: MixedInParser,\r\n    expectedTokType: TokenType,\r\n    follows: TokenType[],\r\n  ): boolean {\r\n    if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {\r\n      return false;\r\n    }\r\n\r\n    // must know the possible following tokens to perform single token insertion\r\n    if (isEmpty(follows)) {\r\n      return false;\r\n    }\r\n\r\n    const mismatchedTok = this.LA(1);\r\n    const isMisMatchedTokInFollows =\r\n      find(follows, (possibleFollowsTokType: TokenType) => {\r\n        return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);\r\n      }) !== undefined;\r\n\r\n    return isMisMatchedTokInFollows;\r\n  }\r\n\r\n  canRecoverWithSingleTokenDeletion(\r\n    this: MixedInParser,\r\n    expectedTokType: TokenType,\r\n  ): boolean {\r\n    if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {\r\n      return false;\r\n    }\r\n\r\n    const isNextTokenWhatIsExpected = this.tokenMatcher(\r\n      this.LA(2),\r\n      expectedTokType,\r\n    );\r\n    return isNextTokenWhatIsExpected;\r\n  }\r\n\r\n  isInCurrentRuleReSyncSet(\r\n    this: MixedInParser,\r\n    tokenTypeIdx: TokenType,\r\n  ): boolean {\r\n    const followKey = this.getCurrFollowKey();\r\n    const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);\r\n    return includes(currentRuleReSyncSet, tokenTypeIdx);\r\n  }\r\n\r\n  findReSyncTokenType(this: MixedInParser): TokenType {\r\n    const allPossibleReSyncTokTypes = this.flattenFollowSet();\r\n    // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input\r\n    let nextToken = this.LA(1);\r\n    let k = 2;\r\n    while (true) {\r\n      const foundMatch = find(allPossibleReSyncTokTypes, (resyncTokType) => {\r\n        const canMatch = tokenMatcher(nextToken, resyncTokType);\r\n        return canMatch;\r\n      });\r\n      if (foundMatch !== undefined) {\r\n        return foundMatch;\r\n      }\r\n      nextToken = this.LA(k);\r\n      k++;\r\n    }\r\n  }\r\n\r\n  getCurrFollowKey(this: MixedInParser): IFollowKey {\r\n    // the length is at least one as we always add the ruleName to the stack before invoking the rule.\r\n    if (this.RULE_STACK.length === 1) {\r\n      return EOF_FOLLOW_KEY;\r\n    }\r\n    const currRuleShortName = this.getLastExplicitRuleShortName();\r\n    const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();\r\n    const prevRuleShortName = this.getPreviousExplicitRuleShortName();\r\n\r\n    return {\r\n      ruleName: this.shortRuleNameToFullName(currRuleShortName),\r\n      idxInCallingRule: currRuleIdx,\r\n      inRule: this.shortRuleNameToFullName(prevRuleShortName),\r\n    };\r\n  }\r\n\r\n  buildFullFollowKeyStack(this: MixedInParser): IFollowKey[] {\r\n    const explicitRuleStack = this.RULE_STACK;\r\n    const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;\r\n\r\n    return map(explicitRuleStack, (ruleName, idx) => {\r\n      if (idx === 0) {\r\n        return EOF_FOLLOW_KEY;\r\n      }\r\n      return {\r\n        ruleName: this.shortRuleNameToFullName(ruleName),\r\n        idxInCallingRule: explicitOccurrenceStack[idx],\r\n        inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),\r\n      };\r\n    });\r\n  }\r\n\r\n  flattenFollowSet(this: MixedInParser): TokenType[] {\r\n    const followStack = map(this.buildFullFollowKeyStack(), (currKey) => {\r\n      return this.getFollowSetFromFollowKey(currKey);\r\n    });\r\n    return <any>flatten(followStack);\r\n  }\r\n\r\n  getFollowSetFromFollowKey(\r\n    this: MixedInParser,\r\n    followKey: IFollowKey,\r\n  ): TokenType[] {\r\n    if (followKey === EOF_FOLLOW_KEY) {\r\n      return [EOF];\r\n    }\r\n\r\n    const followName =\r\n      followKey.ruleName + followKey.idxInCallingRule + IN + followKey.inRule;\r\n\r\n    return this.resyncFollows[followName];\r\n  }\r\n\r\n  // It does not make any sense to include a virtual EOF token in the list of resynced tokens\r\n  // as EOF does not really exist and thus does not contain any useful information (line/column numbers)\r\n  addToResyncTokens(\r\n    this: MixedInParser,\r\n    token: IToken,\r\n    resyncTokens: IToken[],\r\n  ): IToken[] {\r\n    if (!this.tokenMatcher(token, EOF)) {\r\n      resyncTokens.push(token);\r\n    }\r\n    return resyncTokens;\r\n  }\r\n\r\n  reSyncTo(this: MixedInParser, tokType: TokenType): IToken[] {\r\n    const resyncedTokens: IToken[] = [];\r\n    let nextTok = this.LA(1);\r\n    while (this.tokenMatcher(nextTok, tokType) === false) {\r\n      nextTok = this.SKIP_TOKEN();\r\n      this.addToResyncTokens(nextTok, resyncedTokens);\r\n    }\r\n    // the last token is not part of the error.\r\n    return dropRight(resyncedTokens);\r\n  }\r\n\r\n  attemptInRepetitionRecovery(\r\n    this: MixedInParser,\r\n    prodFunc: Function,\r\n    args: any[],\r\n    lookaheadFunc: () => boolean,\r\n    dslMethodIdx: number,\r\n    prodOccurrence: number,\r\n    nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\r\n    notStuck?: boolean,\r\n  ): void {\r\n    // by default this is a NO-OP\r\n    // The actual implementation is with the function(not method) below\r\n  }\r\n\r\n  getCurrentGrammarPath(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    tokIdxInRule: number,\r\n  ): ITokenGrammarPath {\r\n    const pathRuleStack: string[] = this.getHumanReadableRuleStack();\r\n    const pathOccurrenceStack: number[] = clone(this.RULE_OCCURRENCE_STACK);\r\n    const grammarPath: any = {\r\n      ruleStack: pathRuleStack,\r\n      occurrenceStack: pathOccurrenceStack,\r\n      lastTok: tokType,\r\n      lastTokOccurrence: tokIdxInRule,\r\n    };\r\n\r\n    return grammarPath;\r\n  }\r\n  getHumanReadableRuleStack(this: MixedInParser): string[] {\r\n    return map(this.RULE_STACK, (currShortName) =>\r\n      this.shortRuleNameToFullName(currShortName),\r\n    );\r\n  }\r\n}\r\n\r\nexport function attemptInRepetitionRecovery(\r\n  this: MixedInParser,\r\n  prodFunc: Function,\r\n  args: any[],\r\n  lookaheadFunc: () => boolean,\r\n  dslMethodIdx: number,\r\n  prodOccurrence: number,\r\n  nextToksWalker: typeof AbstractNextTerminalAfterProductionWalker,\r\n  notStuck?: boolean,\r\n): void {\r\n  const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);\r\n  let firstAfterRepInfo = this.firstAfterRepMap[key];\r\n  if (firstAfterRepInfo === undefined) {\r\n    const currRuleName = this.getCurrRuleFullName();\r\n    const ruleGrammar = this.getGAstProductions()[currRuleName];\r\n    const walker: AbstractNextTerminalAfterProductionWalker =\r\n      new nextToksWalker(ruleGrammar, prodOccurrence);\r\n    firstAfterRepInfo = walker.startWalking();\r\n    this.firstAfterRepMap[key] = firstAfterRepInfo;\r\n  }\r\n\r\n  let expectTokAfterLastMatch = firstAfterRepInfo.token;\r\n  let nextTokIdx = firstAfterRepInfo.occurrence;\r\n  const isEndOfRule = firstAfterRepInfo.isEndOfRule;\r\n\r\n  // special edge case of a TOP most repetition after which the input should END.\r\n  // this will force an attempt for inRule recovery in that scenario.\r\n  if (\r\n    this.RULE_STACK.length === 1 &&\r\n    isEndOfRule &&\r\n    expectTokAfterLastMatch === undefined\r\n  ) {\r\n    expectTokAfterLastMatch = EOF;\r\n    nextTokIdx = 1;\r\n  }\r\n\r\n  // We don't have anything to re-sync to...\r\n  // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard\r\n  if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {\r\n    return;\r\n  }\r\n\r\n  if (\r\n    this.shouldInRepetitionRecoveryBeTried(\r\n      expectTokAfterLastMatch,\r\n      nextTokIdx,\r\n      notStuck,\r\n    )\r\n  ) {\r\n    // TODO: performance optimization: instead of passing the original args here, we modify\r\n    // the args param (or create a new one) and make sure the lookahead func is explicitly provided\r\n    // to avoid searching the cache for it once more.\r\n    this.tryInRepetitionRecovery(\r\n      prodFunc,\r\n      args,\r\n      lookaheadFunc,\r\n      expectTokAfterLastMatch,\r\n    );\r\n  }\r\n}\r\n", "// Lookahead keys are 32Bit integers in the form\r\n// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX\r\n// XXXX -> Occurrence Index bitmap.\r\n// YYYY -> DSL Method Type bitmap.\r\n// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.\r\n// TTTTTTTTT -> alternation alternative index bitmap\r\n\r\nexport const BITS_FOR_METHOD_TYPE = 4;\r\nexport const BITS_FOR_OCCURRENCE_IDX = 8;\r\nexport const BITS_FOR_RULE_IDX = 12;\r\n// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.\r\nexport const BITS_FOR_ALT_IDX = 8;\r\n\r\n// short string used as part of mapping keys.\r\n// being short improves the performance when composing KEYS for maps out of these\r\n// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)\r\nexport const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;\r\nexport const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;\r\nexport const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;\r\nexport const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;\r\nexport const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;\r\nexport const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;\r\n\r\n// this actually returns a number, but it is always used as a string (object prop key)\r\nexport function getKeyForAutomaticLookahead(\r\n  ruleIdx: number,\r\n  dslMethodIdx: number,\r\n  occurrence: number,\r\n): number {\r\n  return occurrence | dslMethodIdx | ruleIdx;\r\n}\r\n\r\nconst BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;\r\n", "import {\r\n  ILookaheadStrategy,\r\n  ILookaheadValidationError,\r\n  IOrAlt,\r\n  OptionalProductionType,\r\n  Rule,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport { flatMap, isEmpty } from \"lodash-es\";\r\nimport { defaultGrammarValidatorErrorProvider } from \"../errors_public.js\";\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser/parser.js\";\r\nimport {\r\n  validateAmbiguousAlternationAlternatives,\r\n  validateEmptyOrAlternative,\r\n  validateNoLeftRecursion,\r\n  validateSomeNonEmptyLookaheadPath,\r\n} from \"./checks.js\";\r\nimport {\r\n  buildAlternativesLookAheadFunc,\r\n  buildLookaheadFuncForOptionalProd,\r\n  buildLookaheadFuncForOr,\r\n  buildSingleAlternativeLookaheadFunction,\r\n  getProdType,\r\n} from \"./lookahead.js\";\r\nimport { IParserDefinitionError } from \"./types.js\";\r\n\r\nexport class LLkLookaheadStrategy implements ILookaheadStrategy {\r\n  readonly maxLookahead: number;\r\n\r\n  constructor(options?: { maxLookahead?: number }) {\r\n    this.maxLookahead =\r\n      options?.maxLookahead ?? DEFAULT_PARSER_CONFIG.maxLookahead;\r\n  }\r\n\r\n  validate(options: {\r\n    rules: Rule[];\r\n    tokenTypes: TokenType[];\r\n    grammarName: string;\r\n  }): ILookaheadValidationError[] {\r\n    const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);\r\n\r\n    if (isEmpty(leftRecursionErrors)) {\r\n      const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);\r\n      const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(\r\n        options.rules,\r\n        this.maxLookahead,\r\n      );\r\n      const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(\r\n        options.rules,\r\n        this.maxLookahead,\r\n      );\r\n      const allErrors = [\r\n        ...leftRecursionErrors,\r\n        ...emptyAltErrors,\r\n        ...ambiguousAltsErrors,\r\n        ...emptyRepetitionErrors,\r\n      ];\r\n      return allErrors;\r\n    }\r\n    return leftRecursionErrors;\r\n  }\r\n\r\n  validateNoLeftRecursion(rules: Rule[]): IParserDefinitionError[] {\r\n    return flatMap(rules, (currTopRule) =>\r\n      validateNoLeftRecursion(\r\n        currTopRule,\r\n        currTopRule,\r\n        defaultGrammarValidatorErrorProvider,\r\n      ),\r\n    );\r\n  }\r\n\r\n  validateEmptyOrAlternatives(rules: Rule[]): IParserDefinitionError[] {\r\n    return flatMap(rules, (currTopRule) =>\r\n      validateEmptyOrAlternative(\r\n        currTopRule,\r\n        defaultGrammarValidatorErrorProvider,\r\n      ),\r\n    );\r\n  }\r\n\r\n  validateAmbiguousAlternationAlternatives(\r\n    rules: Rule[],\r\n    maxLookahead: number,\r\n  ): IParserDefinitionError[] {\r\n    return flatMap(rules, (currTopRule) =>\r\n      validateAmbiguousAlternationAlternatives(\r\n        currTopRule,\r\n        maxLookahead,\r\n        defaultGrammarValidatorErrorProvider,\r\n      ),\r\n    );\r\n  }\r\n\r\n  validateSomeNonEmptyLookaheadPath(\r\n    rules: Rule[],\r\n    maxLookahead: number,\r\n  ): IParserDefinitionError[] {\r\n    return validateSomeNonEmptyLookaheadPath(\r\n      rules,\r\n      maxLookahead,\r\n      defaultGrammarValidatorErrorProvider,\r\n    );\r\n  }\r\n\r\n  buildLookaheadForAlternation(options: {\r\n    prodOccurrence: number;\r\n    rule: Rule;\r\n    maxLookahead: number;\r\n    hasPredicates: boolean;\r\n    dynamicTokensEnabled: boolean;\r\n  }): (orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\r\n    return buildLookaheadFuncForOr(\r\n      options.prodOccurrence,\r\n      options.rule,\r\n      options.maxLookahead,\r\n      options.hasPredicates,\r\n      options.dynamicTokensEnabled,\r\n      buildAlternativesLookAheadFunc,\r\n    );\r\n  }\r\n\r\n  buildLookaheadForOptional(options: {\r\n    prodOccurrence: number;\r\n    prodType: OptionalProductionType;\r\n    rule: Rule;\r\n    maxLookahead: number;\r\n    dynamicTokensEnabled: boolean;\r\n  }): () => boolean {\r\n    return buildLookaheadFuncForOptionalProd(\r\n      options.prodOccurrence,\r\n      options.rule,\r\n      options.maxLookahead,\r\n      options.dynamicTokensEnabled,\r\n      getProdType(options.prodType),\r\n      buildSingleAlternativeLookaheadFunction,\r\n    );\r\n  }\r\n}\r\n", "import { forEach, has } from \"lodash-es\";\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\r\nimport {\r\n  ILookaheadStrategy,\r\n  IParserConfig,\r\n  OptionalProductionType,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  AT_LEAST_ONE_IDX,\r\n  AT_LEAST_ONE_SEP_IDX,\r\n  getKeyForAutomaticLookahead,\r\n  MANY_IDX,\r\n  MANY_SEP_IDX,\r\n  OPTION_IDX,\r\n  OR_IDX,\r\n} from \"../../grammar/keys.js\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport {\r\n  Alternation,\r\n  GAstVisitor,\r\n  getProductionDslName,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n} from \"@chevrotain/gast\";\r\nimport { LLkLookaheadStrategy } from \"../../grammar/llk_lookahead.js\";\r\n\r\n/**\r\n * Trait responsible for the lookahead related utilities and optimizations.\r\n */\r\nexport class LooksAhead {\r\n  maxLookahead: number;\r\n  lookAheadFuncsCache: any;\r\n  dynamicTokensEnabled: boolean;\r\n  lookaheadStrategy: ILookaheadStrategy;\r\n\r\n  initLooksAhead(config: IParserConfig) {\r\n    this.dynamicTokensEnabled = has(config, \"dynamicTokensEnabled\")\r\n      ? (config.dynamicTokensEnabled as boolean) // assumes end user provides the correct config value/type\r\n      : DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;\r\n\r\n    this.maxLookahead = has(config, \"maxLookahead\")\r\n      ? (config.maxLookahead as number) // assumes end user provides the correct config value/type\r\n      : DEFAULT_PARSER_CONFIG.maxLookahead;\r\n\r\n    this.lookaheadStrategy = has(config, \"lookaheadStrategy\")\r\n      ? (config.lookaheadStrategy as ILookaheadStrategy) // assumes end user provides the correct config value/type\r\n      : new LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });\r\n\r\n    this.lookAheadFuncsCache = new Map();\r\n  }\r\n\r\n  preComputeLookaheadFunctions(this: MixedInParser, rules: Rule[]): void {\r\n    forEach(rules, (currRule) => {\r\n      this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {\r\n        const {\r\n          alternation,\r\n          repetition,\r\n          option,\r\n          repetitionMandatory,\r\n          repetitionMandatoryWithSeparator,\r\n          repetitionWithSeparator,\r\n        } = collectMethods(currRule);\r\n\r\n        forEach(alternation, (currProd) => {\r\n          const prodIdx = currProd.idx === 0 ? \"\" : currProd.idx;\r\n          this.TRACE_INIT(`${getProductionDslName(currProd)}${prodIdx}`, () => {\r\n            const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({\r\n              prodOccurrence: currProd.idx,\r\n              rule: currRule,\r\n              maxLookahead: currProd.maxLookahead || this.maxLookahead,\r\n              hasPredicates: currProd.hasPredicates,\r\n              dynamicTokensEnabled: this.dynamicTokensEnabled,\r\n            });\r\n\r\n            const key = getKeyForAutomaticLookahead(\r\n              this.fullRuleNameToShort[currRule.name],\r\n              OR_IDX,\r\n              currProd.idx,\r\n            );\r\n            this.setLaFuncCache(key, laFunc);\r\n          });\r\n        });\r\n\r\n        forEach(repetition, (currProd) => {\r\n          this.computeLookaheadFunc(\r\n            currRule,\r\n            currProd.idx,\r\n            MANY_IDX,\r\n            \"Repetition\",\r\n            currProd.maxLookahead,\r\n            getProductionDslName(currProd),\r\n          );\r\n        });\r\n\r\n        forEach(option, (currProd) => {\r\n          this.computeLookaheadFunc(\r\n            currRule,\r\n            currProd.idx,\r\n            OPTION_IDX,\r\n            \"Option\",\r\n            currProd.maxLookahead,\r\n            getProductionDslName(currProd),\r\n          );\r\n        });\r\n\r\n        forEach(repetitionMandatory, (currProd) => {\r\n          this.computeLookaheadFunc(\r\n            currRule,\r\n            currProd.idx,\r\n            AT_LEAST_ONE_IDX,\r\n            \"RepetitionMandatory\",\r\n            currProd.maxLookahead,\r\n            getProductionDslName(currProd),\r\n          );\r\n        });\r\n\r\n        forEach(repetitionMandatoryWithSeparator, (currProd) => {\r\n          this.computeLookaheadFunc(\r\n            currRule,\r\n            currProd.idx,\r\n            AT_LEAST_ONE_SEP_IDX,\r\n            \"RepetitionMandatoryWithSeparator\",\r\n            currProd.maxLookahead,\r\n            getProductionDslName(currProd),\r\n          );\r\n        });\r\n\r\n        forEach(repetitionWithSeparator, (currProd) => {\r\n          this.computeLookaheadFunc(\r\n            currRule,\r\n            currProd.idx,\r\n            MANY_SEP_IDX,\r\n            \"RepetitionWithSeparator\",\r\n            currProd.maxLookahead,\r\n            getProductionDslName(currProd),\r\n          );\r\n        });\r\n      });\r\n    });\r\n  }\r\n\r\n  computeLookaheadFunc(\r\n    this: MixedInParser,\r\n    rule: Rule,\r\n    prodOccurrence: number,\r\n    prodKey: number,\r\n    prodType: OptionalProductionType,\r\n    prodMaxLookahead: number | undefined,\r\n    dslMethodName: string,\r\n  ): void {\r\n    this.TRACE_INIT(\r\n      `${dslMethodName}${prodOccurrence === 0 ? \"\" : prodOccurrence}`,\r\n      () => {\r\n        const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({\r\n          prodOccurrence,\r\n          rule,\r\n          maxLookahead: prodMaxLookahead || this.maxLookahead,\r\n          dynamicTokensEnabled: this.dynamicTokensEnabled,\r\n          prodType,\r\n        });\r\n        const key = getKeyForAutomaticLookahead(\r\n          this.fullRuleNameToShort[rule.name],\r\n          prodKey,\r\n          prodOccurrence,\r\n        );\r\n        this.setLaFuncCache(key, laFunc);\r\n      },\r\n    );\r\n  }\r\n\r\n  // this actually returns a number, but it is always used as a string (object prop key)\r\n  getKeyForAutomaticLookahead(\r\n    this: MixedInParser,\r\n    dslMethodIdx: number,\r\n    occurrence: number,\r\n  ): number {\r\n    const currRuleShortName: any = this.getLastExplicitRuleShortName();\r\n    return getKeyForAutomaticLookahead(\r\n      currRuleShortName,\r\n      dslMethodIdx,\r\n      occurrence,\r\n    );\r\n  }\r\n\r\n  getLaFuncFromCache(this: MixedInParser, key: number): Function {\r\n    return this.lookAheadFuncsCache.get(key);\r\n  }\r\n\r\n  /* istanbul ignore next */\r\n  setLaFuncCache(this: MixedInParser, key: number, value: Function): void {\r\n    this.lookAheadFuncsCache.set(key, value);\r\n  }\r\n}\r\n\r\nclass DslMethodsCollectorVisitor extends GAstVisitor {\r\n  public dslMethods: {\r\n    option: Option[];\r\n    alternation: Alternation[];\r\n    repetition: Repetition[];\r\n    repetitionWithSeparator: RepetitionWithSeparator[];\r\n    repetitionMandatory: RepetitionMandatory[];\r\n    repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[];\r\n  } = {\r\n    option: [],\r\n    alternation: [],\r\n    repetition: [],\r\n    repetitionWithSeparator: [],\r\n    repetitionMandatory: [],\r\n    repetitionMandatoryWithSeparator: [],\r\n  };\r\n\r\n  reset() {\r\n    this.dslMethods = {\r\n      option: [],\r\n      alternation: [],\r\n      repetition: [],\r\n      repetitionWithSeparator: [],\r\n      repetitionMandatory: [],\r\n      repetitionMandatoryWithSeparator: [],\r\n    };\r\n  }\r\n\r\n  public visitOption(option: Option): void {\r\n    this.dslMethods.option.push(option);\r\n  }\r\n\r\n  public visitRepetitionWithSeparator(manySep: RepetitionWithSeparator): void {\r\n    this.dslMethods.repetitionWithSeparator.push(manySep);\r\n  }\r\n\r\n  public visitRepetitionMandatory(atLeastOne: RepetitionMandatory): void {\r\n    this.dslMethods.repetitionMandatory.push(atLeastOne);\r\n  }\r\n\r\n  public visitRepetitionMandatoryWithSeparator(\r\n    atLeastOneSep: RepetitionMandatoryWithSeparator,\r\n  ): void {\r\n    this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);\r\n  }\r\n\r\n  public visitRepetition(many: Repetition): void {\r\n    this.dslMethods.repetition.push(many);\r\n  }\r\n\r\n  public visitAlternation(or: Alternation): void {\r\n    this.dslMethods.alternation.push(or);\r\n  }\r\n}\r\n\r\nconst collectorVisitor = new DslMethodsCollectorVisitor();\r\nexport function collectMethods(rule: Rule): {\r\n  option: Option[];\r\n  alternation: Alternation[];\r\n  repetition: Repetition[];\r\n  repetitionWithSeparator: RepetitionWithSeparator[];\r\n  repetitionMandatory: RepetitionMandatory[];\r\n  repetitionMandatoryWithSeparator: RepetitionMandatoryWithSeparator[];\r\n} {\r\n  collectorVisitor.reset();\r\n  rule.accept(collectorVisitor);\r\n  const dslMethods = collectorVisitor.dslMethods;\r\n  // avoid uncleaned references\r\n  collectorVisitor.reset();\r\n  return <any>dslMethods;\r\n}\r\n", "import { CstNode, CstNodeLocation, IToken } from \"@chevrotain/types\";\r\n\r\n/**\r\n * This nodeLocation tracking is not efficient and should only be used\r\n * when error recovery is enabled or the Token Vector contains virtual Tokens\r\n * (e.g, Python Indent/Outdent)\r\n * As it executes the calculation for every single terminal/nonTerminal\r\n * and does not rely on the fact the token vector is **sorted**\r\n */\r\nexport function setNodeLocationOnlyOffset(\r\n  currNodeLocation: CstNodeLocation,\r\n  newLocationInfo: Required<Pick<IToken, \"startOffset\" | \"endOffset\">>,\r\n): void {\r\n  // First (valid) update for this cst node\r\n  if (isNaN(currNodeLocation.startOffset) === true) {\r\n    // assumption1: Token location information is either NaN or a valid number\r\n    // assumption2: Token location information is fully valid if it exist\r\n    // (both start/end offsets exist and are numbers).\r\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\r\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n  }\r\n  // Once the startOffset has been updated with a valid number it should never receive\r\n  // any farther updates as the Token vector is sorted.\r\n  // We still have to check this this condition for every new possible location info\r\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\r\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset === true) {\r\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n  }\r\n}\r\n\r\n/**\r\n * This nodeLocation tracking is not efficient and should only be used\r\n * when error recovery is enabled or the Token Vector contains virtual Tokens\r\n * (e.g, Python Indent/Outdent)\r\n * As it executes the calculation for every single terminal/nonTerminal\r\n * and does not rely on the fact the token vector is **sorted**\r\n */\r\nexport function setNodeLocationFull(\r\n  currNodeLocation: CstNodeLocation,\r\n  newLocationInfo: CstNodeLocation,\r\n): void {\r\n  // First (valid) update for this cst node\r\n  if (isNaN(currNodeLocation.startOffset) === true) {\r\n    // assumption1: Token location information is either NaN or a valid number\r\n    // assumption2: Token location information is fully valid if it exist\r\n    // (all start/end props exist and are numbers).\r\n    currNodeLocation.startOffset = newLocationInfo.startOffset;\r\n    currNodeLocation.startColumn = newLocationInfo.startColumn;\r\n    currNodeLocation.startLine = newLocationInfo.startLine;\r\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\r\n    currNodeLocation.endLine = newLocationInfo.endLine;\r\n  }\r\n  // Once the start props has been updated with a valid number it should never receive\r\n  // any farther updates as the Token vector is sorted.\r\n  // We still have to check this this condition for every new possible location info\r\n  // because with error recovery enabled we may encounter invalid tokens (NaN location props)\r\n  else if (currNodeLocation.endOffset! < newLocationInfo.endOffset! === true) {\r\n    currNodeLocation.endOffset = newLocationInfo.endOffset;\r\n    currNodeLocation.endColumn = newLocationInfo.endColumn;\r\n    currNodeLocation.endLine = newLocationInfo.endLine;\r\n  }\r\n}\r\n\r\nexport function addTerminalToCst(\r\n  node: CstNode,\r\n  token: IToken,\r\n  tokenTypeName: string,\r\n): void {\r\n  if (node.children[tokenTypeName] === undefined) {\r\n    node.children[tokenTypeName] = [token];\r\n  } else {\r\n    node.children[tokenTypeName].push(token);\r\n  }\r\n}\r\n\r\nexport function addNoneTerminalToCst(\r\n  node: CstNode,\r\n  ruleName: string,\r\n  ruleResult: any,\r\n): void {\r\n  if (node.children[ruleName] === undefined) {\r\n    node.children[ruleName] = [ruleResult];\r\n  } else {\r\n    node.children[ruleName].push(ruleResult);\r\n  }\r\n}\r\n", "const NAME = \"name\";\r\n\r\nexport function defineNameProp(obj: {}, nameValue: string): void {\r\n  Object.defineProperty(obj, NAME, {\r\n    enumerable: false,\r\n    configurable: true,\r\n    writable: false,\r\n    value: nameValue,\r\n  });\r\n}\r\n", "import {\r\n  compact,\r\n  filter,\r\n  forEach,\r\n  isArray,\r\n  isEmpty,\r\n  isFunction,\r\n  isUndefined,\r\n  keys,\r\n  map,\r\n} from \"lodash-es\";\r\nimport { defineNameProp } from \"../../lang/lang_extensions.js\";\r\nimport { CstNode, ICstVisitor } from \"@chevrotain/types\";\r\n\r\nexport function defaultVisit<IN>(ctx: any, param: IN): void {\r\n  const childrenNames = keys(ctx);\r\n  const childrenNamesLength = childrenNames.length;\r\n  for (let i = 0; i < childrenNamesLength; i++) {\r\n    const currChildName = childrenNames[i];\r\n    const currChildArray = ctx[currChildName];\r\n    const currChildArrayLength = currChildArray.length;\r\n    for (let j = 0; j < currChildArrayLength; j++) {\r\n      const currChild: any = currChildArray[j];\r\n      // distinction between Tokens Children and CstNode children\r\n      if (currChild.tokenTypeIdx === undefined) {\r\n        this[currChild.name](currChild.children, param);\r\n      }\r\n    }\r\n  }\r\n  // defaultVisit does not support generic out param\r\n}\r\n\r\nexport function createBaseSemanticVisitorConstructor(\r\n  grammarName: string,\r\n  ruleNames: string[],\r\n): {\r\n  new (...args: any[]): ICstVisitor<any, any>;\r\n} {\r\n  const derivedConstructor: any = function () {};\r\n\r\n  // can be overwritten according to:\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\r\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\r\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemantics\");\r\n\r\n  const semanticProto = {\r\n    visit: function (cstNode: CstNode | CstNode[], param: any) {\r\n      // enables writing more concise visitor methods when CstNode has only a single child\r\n      if (isArray(cstNode)) {\r\n        // A CST Node's children dictionary can never have empty arrays as values\r\n        // If a key is defined there will be at least one element in the corresponding value array.\r\n        cstNode = cstNode[0];\r\n      }\r\n\r\n      // enables passing optional CstNodes concisely.\r\n      if (isUndefined(cstNode)) {\r\n        return undefined;\r\n      }\r\n\r\n      return this[cstNode.name](cstNode.children, param);\r\n    },\r\n\r\n    validateVisitor: function () {\r\n      const semanticDefinitionErrors = validateVisitor(this, ruleNames);\r\n      if (!isEmpty(semanticDefinitionErrors)) {\r\n        const errorMessages = map(\r\n          semanticDefinitionErrors,\r\n          (currDefError) => currDefError.msg,\r\n        );\r\n        throw Error(\r\n          `Errors Detected in CST Visitor <${this.constructor.name}>:\\n\\t` +\r\n            `${errorMessages.join(\"\\n\\n\").replace(/\\n/g, \"\\n\\t\")}`,\r\n        );\r\n      }\r\n    },\r\n  };\r\n\r\n  derivedConstructor.prototype = semanticProto;\r\n  derivedConstructor.prototype.constructor = derivedConstructor;\r\n\r\n  derivedConstructor._RULE_NAMES = ruleNames;\r\n\r\n  return derivedConstructor;\r\n}\r\n\r\nexport function createBaseVisitorConstructorWithDefaults(\r\n  grammarName: string,\r\n  ruleNames: string[],\r\n  baseConstructor: Function,\r\n): {\r\n  new (...args: any[]): ICstVisitor<any, any>;\r\n} {\r\n  const derivedConstructor: any = function () {};\r\n\r\n  // can be overwritten according to:\r\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/\r\n  // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname\r\n  defineNameProp(derivedConstructor, grammarName + \"BaseSemanticsWithDefaults\");\r\n\r\n  const withDefaultsProto = Object.create(baseConstructor.prototype);\r\n  forEach(ruleNames, (ruleName) => {\r\n    withDefaultsProto[ruleName] = defaultVisit;\r\n  });\r\n\r\n  derivedConstructor.prototype = withDefaultsProto;\r\n  derivedConstructor.prototype.constructor = derivedConstructor;\r\n\r\n  return derivedConstructor;\r\n}\r\n\r\nexport enum CstVisitorDefinitionError {\r\n  REDUNDANT_METHOD,\r\n  MISSING_METHOD,\r\n}\r\n\r\nexport interface IVisitorDefinitionError {\r\n  msg: string;\r\n  type: CstVisitorDefinitionError;\r\n  methodName: string;\r\n}\r\n\r\nexport function validateVisitor(\r\n  visitorInstance: ICstVisitor<unknown, unknown>,\r\n  ruleNames: string[],\r\n): IVisitorDefinitionError[] {\r\n  const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);\r\n\r\n  return missingErrors;\r\n}\r\n\r\nexport function validateMissingCstMethods(\r\n  visitorInstance: ICstVisitor<unknown, unknown>,\r\n  ruleNames: string[],\r\n): IVisitorDefinitionError[] {\r\n  const missingRuleNames = filter(ruleNames, (currRuleName) => {\r\n    return isFunction((visitorInstance as any)[currRuleName]) === false;\r\n  });\r\n\r\n  const errors: IVisitorDefinitionError[] = map(\r\n    missingRuleNames,\r\n    (currRuleName) => {\r\n      return {\r\n        msg: `Missing visitor method: <${currRuleName}> on ${<any>(\r\n          visitorInstance.constructor.name\r\n        )} CST Visitor.`,\r\n        type: CstVisitorDefinitionError.MISSING_METHOD,\r\n        methodName: currRuleName,\r\n      };\r\n    },\r\n  );\r\n\r\n  return compact<IVisitorDefinitionError>(errors);\r\n}\r\n", "import {\r\n  addNoneTerminalToCst,\r\n  addTerminalToCst,\r\n  setNodeLocationFull,\r\n  setNodeLocationOnlyOffset,\r\n} from \"../../cst/cst.js\";\r\nimport { has, isUndefined, keys, noop } from \"lodash-es\";\r\nimport {\r\n  createBaseSemanticVisitorConstructor,\r\n  createBaseVisitorConstructorWithDefaults,\r\n} from \"../../cst/cst_visitor.js\";\r\nimport {\r\n  CstNode,\r\n  CstNodeLocation,\r\n  ICstVisitor,\r\n  IParserConfig,\r\n  IToken,\r\n  nodeLocationTrackingOptions,\r\n} from \"@chevrotain/types\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\r\n\r\n/**\r\n * This trait is responsible for the CST building logic.\r\n */\r\nexport class TreeBuilder {\r\n  outputCst: boolean;\r\n  CST_STACK: CstNode[];\r\n  baseCstVisitorConstructor: Function;\r\n  baseCstVisitorWithDefaultsConstructor: Function;\r\n\r\n  // dynamically assigned Methods\r\n  setNodeLocationFromNode: (\r\n    nodeLocation: CstNodeLocation,\r\n    locationInformation: CstNodeLocation,\r\n  ) => void;\r\n  setNodeLocationFromToken: (\r\n    nodeLocation: CstNodeLocation,\r\n    locationInformation: CstNodeLocation,\r\n  ) => void;\r\n  cstPostRule: (this: MixedInParser, ruleCstNode: CstNode) => void;\r\n\r\n  setInitialNodeLocation: (cstNode: CstNode) => void;\r\n  nodeLocationTracking: nodeLocationTrackingOptions;\r\n\r\n  initTreeBuilder(this: MixedInParser, config: IParserConfig) {\r\n    this.CST_STACK = [];\r\n\r\n    // outputCst is no longer exposed/defined in the pubic API\r\n    this.outputCst = (config as any).outputCst;\r\n\r\n    this.nodeLocationTracking = has(config, \"nodeLocationTracking\")\r\n      ? (config.nodeLocationTracking as nodeLocationTrackingOptions) // assumes end user provides the correct config value/type\r\n      : DEFAULT_PARSER_CONFIG.nodeLocationTracking;\r\n\r\n    if (!this.outputCst) {\r\n      this.cstInvocationStateUpdate = noop;\r\n      this.cstFinallyStateUpdate = noop;\r\n      this.cstPostTerminal = noop;\r\n      this.cstPostNonTerminal = noop;\r\n      this.cstPostRule = noop;\r\n    } else {\r\n      if (/full/i.test(this.nodeLocationTracking)) {\r\n        if (this.recoveryEnabled) {\r\n          this.setNodeLocationFromToken = setNodeLocationFull;\r\n          this.setNodeLocationFromNode = setNodeLocationFull;\r\n          this.cstPostRule = noop;\r\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;\r\n        } else {\r\n          this.setNodeLocationFromToken = noop;\r\n          this.setNodeLocationFromNode = noop;\r\n          this.cstPostRule = this.cstPostRuleFull;\r\n          this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;\r\n        }\r\n      } else if (/onlyOffset/i.test(this.nodeLocationTracking)) {\r\n        if (this.recoveryEnabled) {\r\n          this.setNodeLocationFromToken = <any>setNodeLocationOnlyOffset;\r\n          this.setNodeLocationFromNode = <any>setNodeLocationOnlyOffset;\r\n          this.cstPostRule = noop;\r\n          this.setInitialNodeLocation =\r\n            this.setInitialNodeLocationOnlyOffsetRecovery;\r\n        } else {\r\n          this.setNodeLocationFromToken = noop;\r\n          this.setNodeLocationFromNode = noop;\r\n          this.cstPostRule = this.cstPostRuleOnlyOffset;\r\n          this.setInitialNodeLocation =\r\n            this.setInitialNodeLocationOnlyOffsetRegular;\r\n        }\r\n      } else if (/none/i.test(this.nodeLocationTracking)) {\r\n        this.setNodeLocationFromToken = noop;\r\n        this.setNodeLocationFromNode = noop;\r\n        this.cstPostRule = noop;\r\n        this.setInitialNodeLocation = noop;\r\n      } else {\r\n        throw Error(\r\n          `Invalid <nodeLocationTracking> config option: \"${config.nodeLocationTracking}\"`,\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  setInitialNodeLocationOnlyOffsetRecovery(\r\n    this: MixedInParser,\r\n    cstNode: any,\r\n  ): void {\r\n    cstNode.location = {\r\n      startOffset: NaN,\r\n      endOffset: NaN,\r\n    };\r\n  }\r\n\r\n  setInitialNodeLocationOnlyOffsetRegular(\r\n    this: MixedInParser,\r\n    cstNode: any,\r\n  ): void {\r\n    cstNode.location = {\r\n      // without error recovery the starting Location of a new CstNode is guaranteed\r\n      // To be the next Token's startOffset (for valid inputs).\r\n      // For invalid inputs there won't be any CSTOutput so this potential\r\n      // inaccuracy does not matter\r\n      startOffset: this.LA(1).startOffset,\r\n      endOffset: NaN,\r\n    };\r\n  }\r\n\r\n  setInitialNodeLocationFullRecovery(this: MixedInParser, cstNode: any): void {\r\n    cstNode.location = {\r\n      startOffset: NaN,\r\n      startLine: NaN,\r\n      startColumn: NaN,\r\n      endOffset: NaN,\r\n      endLine: NaN,\r\n      endColumn: NaN,\r\n    };\r\n  }\r\n\r\n  /**\r\n     *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work\r\n\r\n     * @param cstNode\r\n     */\r\n  setInitialNodeLocationFullRegular(this: MixedInParser, cstNode: any): void {\r\n    const nextToken = this.LA(1);\r\n    cstNode.location = {\r\n      startOffset: nextToken.startOffset,\r\n      startLine: nextToken.startLine,\r\n      startColumn: nextToken.startColumn,\r\n      endOffset: NaN,\r\n      endLine: NaN,\r\n      endColumn: NaN,\r\n    };\r\n  }\r\n\r\n  cstInvocationStateUpdate(this: MixedInParser, fullRuleName: string): void {\r\n    const cstNode: CstNode = {\r\n      name: fullRuleName,\r\n      children: Object.create(null),\r\n    };\r\n\r\n    this.setInitialNodeLocation(cstNode);\r\n    this.CST_STACK.push(cstNode);\r\n  }\r\n\r\n  cstFinallyStateUpdate(this: MixedInParser): void {\r\n    this.CST_STACK.pop();\r\n  }\r\n\r\n  cstPostRuleFull(this: MixedInParser, ruleCstNode: CstNode): void {\r\n    // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled\r\n    const prevToken = this.LA(0) as Required<CstNodeLocation>;\r\n    const loc = ruleCstNode.location as Required<CstNodeLocation>;\r\n\r\n    // If this condition is true it means we consumed at least one Token\r\n    // In this CstNode.\r\n    if (loc.startOffset <= prevToken.startOffset === true) {\r\n      loc.endOffset = prevToken.endOffset;\r\n      loc.endLine = prevToken.endLine;\r\n      loc.endColumn = prevToken.endColumn;\r\n    }\r\n    // \"empty\" CstNode edge case\r\n    else {\r\n      loc.startOffset = NaN;\r\n      loc.startLine = NaN;\r\n      loc.startColumn = NaN;\r\n    }\r\n  }\r\n\r\n  cstPostRuleOnlyOffset(this: MixedInParser, ruleCstNode: CstNode): void {\r\n    const prevToken = this.LA(0);\r\n    // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.\r\n    const loc = ruleCstNode.location!;\r\n\r\n    // If this condition is true it means we consumed at least one Token\r\n    // In this CstNode.\r\n    if (loc.startOffset <= prevToken.startOffset === true) {\r\n      loc.endOffset = prevToken.endOffset;\r\n    }\r\n    // \"empty\" CstNode edge case\r\n    else {\r\n      loc.startOffset = NaN;\r\n    }\r\n  }\r\n\r\n  cstPostTerminal(\r\n    this: MixedInParser,\r\n    key: string,\r\n    consumedToken: IToken,\r\n  ): void {\r\n    const rootCst = this.CST_STACK[this.CST_STACK.length - 1];\r\n    addTerminalToCst(rootCst, consumedToken, key);\r\n    // This is only used when **both** error recovery and CST Output are enabled.\r\n    this.setNodeLocationFromToken(rootCst.location!, <any>consumedToken);\r\n  }\r\n\r\n  cstPostNonTerminal(\r\n    this: MixedInParser,\r\n    ruleCstResult: CstNode,\r\n    ruleName: string,\r\n  ): void {\r\n    const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];\r\n    addNoneTerminalToCst(preCstNode, ruleName, ruleCstResult);\r\n    // This is only used when **both** error recovery and CST Output are enabled.\r\n    this.setNodeLocationFromNode(preCstNode.location!, ruleCstResult.location!);\r\n  }\r\n\r\n  getBaseCstVisitorConstructor<IN = any, OUT = any>(\r\n    this: MixedInParser,\r\n  ): {\r\n    new (...args: any[]): ICstVisitor<IN, OUT>;\r\n  } {\r\n    if (isUndefined(this.baseCstVisitorConstructor)) {\r\n      const newBaseCstVisitorConstructor = createBaseSemanticVisitorConstructor(\r\n        this.className,\r\n        keys(this.gastProductionsCache),\r\n      );\r\n      this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;\r\n      return newBaseCstVisitorConstructor;\r\n    }\r\n\r\n    return <any>this.baseCstVisitorConstructor;\r\n  }\r\n\r\n  getBaseCstVisitorConstructorWithDefaults<IN = any, OUT = any>(\r\n    this: MixedInParser,\r\n  ): {\r\n    new (...args: any[]): ICstVisitor<IN, OUT>;\r\n  } {\r\n    if (isUndefined(this.baseCstVisitorWithDefaultsConstructor)) {\r\n      const newConstructor = createBaseVisitorConstructorWithDefaults(\r\n        this.className,\r\n        keys(this.gastProductionsCache),\r\n        this.getBaseCstVisitorConstructor(),\r\n      );\r\n      this.baseCstVisitorWithDefaultsConstructor = newConstructor;\r\n      return newConstructor;\r\n    }\r\n\r\n    return <any>this.baseCstVisitorWithDefaultsConstructor;\r\n  }\r\n\r\n  getLastExplicitRuleShortName(this: MixedInParser): number {\r\n    const ruleStack = this.RULE_STACK;\r\n    return ruleStack[ruleStack.length - 1];\r\n  }\r\n\r\n  getPreviousExplicitRuleShortName(this: MixedInParser): number {\r\n    const ruleStack = this.RULE_STACK;\r\n    return ruleStack[ruleStack.length - 2];\r\n  }\r\n\r\n  getLastExplicitRuleOccurrenceIndex(this: MixedInParser): number {\r\n    const occurrenceStack = this.RULE_OCCURRENCE_STACK;\r\n    return occurrenceStack[occurrenceStack.length - 1];\r\n  }\r\n}\r\n", "import { END_OF_FILE } from \"../parser.js\";\r\nimport { IToken } from \"@chevrotain/types\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\n\r\n/**\r\n * Trait responsible abstracting over the interaction with Lexer output (Token vector).\r\n *\r\n * This could be generalized to support other kinds of lexers, e.g.\r\n * - Just in Time Lexing / Lexer-Less parsing.\r\n * - Streaming Lexer.\r\n */\r\nexport class LexerAdapter {\r\n  tokVector: IToken[];\r\n  tokVectorLength: number;\r\n  currIdx: number;\r\n\r\n  initLexerAdapter() {\r\n    this.tokVector = [];\r\n    this.tokVectorLength = 0;\r\n    this.currIdx = -1;\r\n  }\r\n\r\n  set input(newInput: IToken[]) {\r\n    // @ts-ignore - `this parameter` not supported in setters/getters\r\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\r\n    if (this.selfAnalysisDone !== true) {\r\n      throw Error(\r\n        `Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`,\r\n      );\r\n    }\r\n    // @ts-ignore - `this parameter` not supported in setters/getters\r\n    //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters\r\n    this.reset();\r\n    this.tokVector = newInput;\r\n    this.tokVectorLength = newInput.length;\r\n  }\r\n\r\n  get input(): IToken[] {\r\n    return this.tokVector;\r\n  }\r\n\r\n  // skips a token and returns the next token\r\n  SKIP_TOKEN(this: MixedInParser): IToken {\r\n    if (this.currIdx <= this.tokVector.length - 2) {\r\n      this.consumeToken();\r\n      return this.LA(1);\r\n    } else {\r\n      return END_OF_FILE;\r\n    }\r\n  }\r\n\r\n  // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers\r\n  // or lexers dependent on parser context.\r\n  LA(this: MixedInParser, howMuch: number): IToken {\r\n    const soughtIdx = this.currIdx + howMuch;\r\n    if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {\r\n      return END_OF_FILE;\r\n    } else {\r\n      return this.tokVector[soughtIdx];\r\n    }\r\n  }\r\n\r\n  consumeToken(this: MixedInParser) {\r\n    this.currIdx++;\r\n  }\r\n\r\n  exportLexerState(this: MixedInParser): number {\r\n    return this.currIdx;\r\n  }\r\n\r\n  importLexerState(this: MixedInParser, newState: number) {\r\n    this.currIdx = newState;\r\n  }\r\n\r\n  resetLexerState(this: MixedInParser): void {\r\n    this.currIdx = -1;\r\n  }\r\n\r\n  moveToTerminatedState(this: MixedInParser): void {\r\n    this.currIdx = this.tokVector.length - 1;\r\n  }\r\n\r\n  getLexerPosition(this: MixedInParser): number {\r\n    return this.exportLexerState();\r\n  }\r\n}\r\n", "import {\r\n  AtLeastOneSepMethodOpts,\r\n  ConsumeMethodOpts,\r\n  DSLMethodOpts,\r\n  DSLMethodOptsWithErr,\r\n  GrammarAction,\r\n  IOrAlt,\r\n  IRuleConfig,\r\n  ISerializedGast,\r\n  IToken,\r\n  ManySepMethodOpts,\r\n  OrMethodOpts,\r\n  SubruleMethodOpts,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport { includes, values } from \"lodash-es\";\r\nimport { isRecognitionException } from \"../../exceptions_public.js\";\r\nimport { DEFAULT_RULE_CONFIG, ParserDefinitionErrorType } from \"../parser.js\";\r\nimport { defaultGrammarValidatorErrorProvider } from \"../../errors_public.js\";\r\nimport { validateRuleIsOverridden } from \"../../grammar/checks.js\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport { Rule, serializeGrammar } from \"@chevrotain/gast\";\r\nimport { IParserDefinitionError } from \"../../grammar/types.js\";\r\nimport { ParserMethodInternal } from \"../types.js\";\r\n\r\n/**\r\n * This trait is responsible for implementing the public API\r\n * for defining Chevrotain parsers, i.e:\r\n * - CONSUME\r\n * - RULE\r\n * - OPTION\r\n * - ...\r\n */\r\nexport class RecognizerApi {\r\n  ACTION<T>(this: MixedInParser, impl: () => T): T {\r\n    return impl.call(this);\r\n  }\r\n\r\n  consume(\r\n    this: MixedInParser,\r\n    idx: number,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, idx, options);\r\n  }\r\n\r\n  subrule<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    idx: number,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, idx, options);\r\n  }\r\n\r\n  option<OUT>(\r\n    this: MixedInParser,\r\n    idx: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, idx);\r\n  }\r\n\r\n  or(\r\n    this: MixedInParser,\r\n    idx: number,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<any>,\r\n  ): any {\r\n    return this.orInternal(altsOrOpts, idx);\r\n  }\r\n\r\n  many(\r\n    this: MixedInParser,\r\n    idx: number,\r\n    actionORMethodDef: GrammarAction<any> | DSLMethodOpts<any>,\r\n  ): void {\r\n    return this.manyInternal(idx, actionORMethodDef);\r\n  }\r\n\r\n  atLeastOne(\r\n    this: MixedInParser,\r\n    idx: number,\r\n    actionORMethodDef: GrammarAction<any> | DSLMethodOptsWithErr<any>,\r\n  ): void {\r\n    return this.atLeastOneInternal(idx, actionORMethodDef);\r\n  }\r\n\r\n  CONSUME(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 0, options);\r\n  }\r\n\r\n  CONSUME1(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 1, options);\r\n  }\r\n\r\n  CONSUME2(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 2, options);\r\n  }\r\n\r\n  CONSUME3(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 3, options);\r\n  }\r\n\r\n  CONSUME4(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 4, options);\r\n  }\r\n\r\n  CONSUME5(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 5, options);\r\n  }\r\n\r\n  CONSUME6(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 6, options);\r\n  }\r\n\r\n  CONSUME7(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 7, options);\r\n  }\r\n\r\n  CONSUME8(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 8, options);\r\n  }\r\n\r\n  CONSUME9(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    return this.consumeInternal(tokType, 9, options);\r\n  }\r\n\r\n  SUBRULE<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 0, options);\r\n  }\r\n\r\n  SUBRULE1<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 1, options);\r\n  }\r\n\r\n  SUBRULE2<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 2, options);\r\n  }\r\n\r\n  SUBRULE3<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 3, options);\r\n  }\r\n\r\n  SUBRULE4<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 4, options);\r\n  }\r\n\r\n  SUBRULE5<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 5, options);\r\n  }\r\n\r\n  SUBRULE6<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 6, options);\r\n  }\r\n\r\n  SUBRULE7<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 7, options);\r\n  }\r\n\r\n  SUBRULE8<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 8, options);\r\n  }\r\n\r\n  SUBRULE9<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    return this.subruleInternal(ruleToCall, 9, options);\r\n  }\r\n\r\n  OPTION<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 0);\r\n  }\r\n\r\n  OPTION1<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 1);\r\n  }\r\n\r\n  OPTION2<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 2);\r\n  }\r\n\r\n  OPTION3<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 3);\r\n  }\r\n\r\n  OPTION4<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 4);\r\n  }\r\n\r\n  OPTION5<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 5);\r\n  }\r\n\r\n  OPTION6<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 6);\r\n  }\r\n\r\n  OPTION7<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 7);\r\n  }\r\n\r\n  OPTION8<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 8);\r\n  }\r\n\r\n  OPTION9<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): OUT | undefined {\r\n    return this.optionInternal(actionORMethodDef, 9);\r\n  }\r\n\r\n  OR<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 0);\r\n  }\r\n\r\n  OR1<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 1);\r\n  }\r\n\r\n  OR2<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 2);\r\n  }\r\n\r\n  OR3<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 3);\r\n  }\r\n\r\n  OR4<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 4);\r\n  }\r\n\r\n  OR5<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 5);\r\n  }\r\n\r\n  OR6<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 6);\r\n  }\r\n\r\n  OR7<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 7);\r\n  }\r\n\r\n  OR8<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 8);\r\n  }\r\n\r\n  OR9<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n  ): T {\r\n    return this.orInternal(altsOrOpts, 9);\r\n  }\r\n\r\n  MANY<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(0, actionORMethodDef);\r\n  }\r\n\r\n  MANY1<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(1, actionORMethodDef);\r\n  }\r\n\r\n  MANY2<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(2, actionORMethodDef);\r\n  }\r\n\r\n  MANY3<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(3, actionORMethodDef);\r\n  }\r\n\r\n  MANY4<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(4, actionORMethodDef);\r\n  }\r\n\r\n  MANY5<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(5, actionORMethodDef);\r\n  }\r\n\r\n  MANY6<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(6, actionORMethodDef);\r\n  }\r\n\r\n  MANY7<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(7, actionORMethodDef);\r\n  }\r\n\r\n  MANY8<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(8, actionORMethodDef);\r\n  }\r\n\r\n  MANY9<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    this.manyInternal(9, actionORMethodDef);\r\n  }\r\n\r\n  MANY_SEP<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(0, options);\r\n  }\r\n\r\n  MANY_SEP1<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(1, options);\r\n  }\r\n\r\n  MANY_SEP2<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(2, options);\r\n  }\r\n\r\n  MANY_SEP3<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(3, options);\r\n  }\r\n\r\n  MANY_SEP4<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(4, options);\r\n  }\r\n\r\n  MANY_SEP5<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(5, options);\r\n  }\r\n\r\n  MANY_SEP6<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(6, options);\r\n  }\r\n\r\n  MANY_SEP7<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(7, options);\r\n  }\r\n\r\n  MANY_SEP8<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(8, options);\r\n  }\r\n\r\n  MANY_SEP9<OUT>(this: MixedInParser, options: ManySepMethodOpts<OUT>): void {\r\n    this.manySepFirstInternal(9, options);\r\n  }\r\n\r\n  AT_LEAST_ONE<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(0, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE1<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    return this.atLeastOneInternal(1, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE2<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(2, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE3<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(3, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE4<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(4, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE5<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(5, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE6<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(6, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE7<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(7, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE8<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(8, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE9<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    this.atLeastOneInternal(9, actionORMethodDef);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(0, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP1<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(1, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP2<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(2, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP3<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(3, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP4<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(4, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP5<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(5, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP6<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(6, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP7<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(7, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP8<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(8, options);\r\n  }\r\n\r\n  AT_LEAST_ONE_SEP9<OUT>(\r\n    this: MixedInParser,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    this.atLeastOneSepFirstInternal(9, options);\r\n  }\r\n\r\n  RULE<T>(\r\n    this: MixedInParser,\r\n    name: string,\r\n    implementation: (...implArgs: any[]) => T,\r\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG,\r\n  ): (idxInCallingRule?: number, ...args: any[]) => T | any {\r\n    if (includes(this.definedRulesNames, name)) {\r\n      const errMsg =\r\n        defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({\r\n          topLevelRule: name,\r\n          grammarName: this.className,\r\n        });\r\n\r\n      const error = {\r\n        message: errMsg,\r\n        type: ParserDefinitionErrorType.DUPLICATE_RULE_NAME,\r\n        ruleName: name,\r\n      };\r\n      this.definitionErrors.push(error);\r\n    }\r\n\r\n    this.definedRulesNames.push(name);\r\n\r\n    const ruleImplementation = this.defineRule(name, implementation, config);\r\n    (this as any)[name] = ruleImplementation;\r\n    return ruleImplementation;\r\n  }\r\n\r\n  OVERRIDE_RULE<T>(\r\n    this: MixedInParser,\r\n    name: string,\r\n    impl: (...implArgs: any[]) => T,\r\n    config: IRuleConfig<T> = DEFAULT_RULE_CONFIG,\r\n  ): (idxInCallingRule?: number, ...args: any[]) => T {\r\n    const ruleErrors: IParserDefinitionError[] = validateRuleIsOverridden(\r\n      name,\r\n      this.definedRulesNames,\r\n      this.className,\r\n    );\r\n    this.definitionErrors = this.definitionErrors.concat(ruleErrors);\r\n\r\n    const ruleImplementation = this.defineRule(name, impl, config);\r\n    (this as any)[name] = ruleImplementation;\r\n    return ruleImplementation;\r\n  }\r\n\r\n  BACKTRACK<T>(\r\n    this: MixedInParser,\r\n    grammarRule: (...args: any[]) => T,\r\n    args?: any[],\r\n  ): () => boolean {\r\n    return function () {\r\n      // save org state\r\n      this.isBackTrackingStack.push(1);\r\n      const orgState = this.saveRecogState();\r\n      try {\r\n        grammarRule.apply(this, args);\r\n        // if no exception was thrown we have succeed parsing the rule.\r\n        return true;\r\n      } catch (e) {\r\n        if (isRecognitionException(e)) {\r\n          return false;\r\n        } else {\r\n          throw e;\r\n        }\r\n      } finally {\r\n        this.reloadRecogState(orgState);\r\n        this.isBackTrackingStack.pop();\r\n      }\r\n    };\r\n  }\r\n\r\n  // GAST export APIs\r\n  public getGAstProductions(this: MixedInParser): Record<string, Rule> {\r\n    return this.gastProductionsCache;\r\n  }\r\n\r\n  public getSerializedGastProductions(this: MixedInParser): ISerializedGast[] {\r\n    return serializeGrammar(values(this.gastProductionsCache));\r\n  }\r\n}\r\n", "import {\r\n  AtLeastOneSepMethodOpts,\r\n  ConsumeMethodOpts,\r\n  DSLMethodOpts,\r\n  DSLMethodOptsWithErr,\r\n  GrammarAction,\r\n  IOrAlt,\r\n  IParserConfig,\r\n  IRuleConfig,\r\n  IToken,\r\n  ManySepMethodOpts,\r\n  OrMethodOpts,\r\n  ParserMethod,\r\n  SubruleMethodOpts,\r\n  TokenType,\r\n  TokenTypeDictionary,\r\n  TokenVocabulary,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  clone,\r\n  every,\r\n  flatten,\r\n  has,\r\n  isArray,\r\n  isEmpty,\r\n  isObject,\r\n  reduce,\r\n  uniq,\r\n  values,\r\n} from \"lodash-es\";\r\nimport {\r\n  AT_LEAST_ONE_IDX,\r\n  AT_LEAST_ONE_SEP_IDX,\r\n  BITS_FOR_METHOD_TYPE,\r\n  BITS_FOR_OCCURRENCE_IDX,\r\n  MANY_IDX,\r\n  MANY_SEP_IDX,\r\n  OPTION_IDX,\r\n  OR_IDX,\r\n} from \"../../grammar/keys.js\";\r\nimport {\r\n  isRecognitionException,\r\n  MismatchedTokenException,\r\n  NotAllInputParsedException,\r\n} from \"../../exceptions_public.js\";\r\nimport { PROD_TYPE } from \"../../grammar/lookahead.js\";\r\nimport {\r\n  AbstractNextTerminalAfterProductionWalker,\r\n  NextTerminalAfterAtLeastOneSepWalker,\r\n  NextTerminalAfterAtLeastOneWalker,\r\n  NextTerminalAfterManySepWalker,\r\n  NextTerminalAfterManyWalker,\r\n} from \"../../grammar/interpreter.js\";\r\nimport { DEFAULT_RULE_CONFIG, IParserState, TokenMatcher } from \"../parser.js\";\r\nimport { IN_RULE_RECOVERY_EXCEPTION } from \"./recoverable.js\";\r\nimport { EOF } from \"../../../scan/tokens_public.js\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport {\r\n  augmentTokenTypes,\r\n  isTokenType,\r\n  tokenStructuredMatcher,\r\n  tokenStructuredMatcherNoCategories,\r\n} from \"../../../scan/tokens.js\";\r\nimport { Rule } from \"@chevrotain/gast\";\r\nimport { ParserMethodInternal } from \"../types.js\";\r\n\r\n/**\r\n * This trait is responsible for the runtime parsing engine\r\n * Used by the official API (recognizer_api.ts)\r\n */\r\nexport class RecognizerEngine {\r\n  isBackTrackingStack: boolean[];\r\n  className: string;\r\n  RULE_STACK: number[];\r\n  RULE_OCCURRENCE_STACK: number[];\r\n  definedRulesNames: string[];\r\n  tokensMap: { [fqn: string]: TokenType };\r\n  gastProductionsCache: Record<string, Rule>;\r\n  shortRuleNameToFull: Record<string, string>;\r\n  fullRuleNameToShort: Record<string, number>;\r\n  // The shortName Index must be coded \"after\" the first 8bits to enable building unique lookahead keys\r\n  ruleShortNameIdx: number;\r\n  tokenMatcher: TokenMatcher;\r\n  subruleIdx: number;\r\n\r\n  initRecognizerEngine(\r\n    tokenVocabulary: TokenVocabulary,\r\n    config: IParserConfig,\r\n  ) {\r\n    this.className = this.constructor.name;\r\n    // TODO: would using an ES6 Map or plain object be faster (CST building scenario)\r\n    this.shortRuleNameToFull = {};\r\n    this.fullRuleNameToShort = {};\r\n    this.ruleShortNameIdx = 256;\r\n    this.tokenMatcher = tokenStructuredMatcherNoCategories;\r\n    this.subruleIdx = 0;\r\n\r\n    this.definedRulesNames = [];\r\n    this.tokensMap = {};\r\n    this.isBackTrackingStack = [];\r\n    this.RULE_STACK = [];\r\n    this.RULE_OCCURRENCE_STACK = [];\r\n    this.gastProductionsCache = {};\r\n\r\n    if (has(config, \"serializedGrammar\")) {\r\n      throw Error(\r\n        \"The Parser's configuration can no longer contain a <serializedGrammar> property.\\n\" +\r\n          \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\\n\" +\r\n          \"\\tFor Further details.\",\r\n      );\r\n    }\r\n\r\n    if (isArray(tokenVocabulary)) {\r\n      // This only checks for Token vocabularies provided as arrays.\r\n      // That is good enough because the main objective is to detect users of pre-V4.0 APIs\r\n      // rather than all edge cases of empty Token vocabularies.\r\n      if (isEmpty(tokenVocabulary as any[])) {\r\n        throw Error(\r\n          \"A Token Vocabulary cannot be empty.\\n\" +\r\n            \"\\tNote that the first argument for the parser constructor\\n\" +\r\n            \"\\tis no longer a Token vector (since v4.0).\",\r\n        );\r\n      }\r\n\r\n      if (typeof (tokenVocabulary as any[])[0].startOffset === \"number\") {\r\n        throw Error(\r\n          \"The Parser constructor no longer accepts a token vector as the first argument.\\n\" +\r\n            \"\\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\\n\" +\r\n            \"\\tFor Further details.\",\r\n        );\r\n      }\r\n    }\r\n\r\n    if (isArray(tokenVocabulary)) {\r\n      this.tokensMap = reduce(\r\n        tokenVocabulary,\r\n        (acc, tokType: TokenType) => {\r\n          acc[tokType.name] = tokType;\r\n          return acc;\r\n        },\r\n        {} as { [tokenName: string]: TokenType },\r\n      );\r\n    } else if (\r\n      has(tokenVocabulary, \"modes\") &&\r\n      every(flatten(values((<any>tokenVocabulary).modes)), isTokenType)\r\n    ) {\r\n      const allTokenTypes = flatten(values((<any>tokenVocabulary).modes));\r\n      const uniqueTokens = uniq(allTokenTypes);\r\n      this.tokensMap = <any>reduce(\r\n        uniqueTokens,\r\n        (acc, tokType: TokenType) => {\r\n          acc[tokType.name] = tokType;\r\n          return acc;\r\n        },\r\n        {} as { [tokenName: string]: TokenType },\r\n      );\r\n    } else if (isObject(tokenVocabulary)) {\r\n      this.tokensMap = clone(tokenVocabulary as TokenTypeDictionary);\r\n    } else {\r\n      throw new Error(\r\n        \"<tokensDictionary> argument must be An Array of Token constructors,\" +\r\n          \" A dictionary of Token constructors or an IMultiModeLexerDefinition\",\r\n      );\r\n    }\r\n\r\n    // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been\r\n    // parsed with a clear error message (\"expecting EOF but found ...\")\r\n    this.tokensMap[\"EOF\"] = EOF;\r\n\r\n    const allTokenTypes = has(tokenVocabulary, \"modes\")\r\n      ? flatten(values((<any>tokenVocabulary).modes))\r\n      : values(tokenVocabulary);\r\n    const noTokenCategoriesUsed = every(allTokenTypes, (tokenConstructor) =>\r\n      isEmpty(tokenConstructor.categoryMatches),\r\n    );\r\n\r\n    this.tokenMatcher = noTokenCategoriesUsed\r\n      ? tokenStructuredMatcherNoCategories\r\n      : tokenStructuredMatcher;\r\n\r\n    // Because ES2015+ syntax should be supported for creating Token classes\r\n    // We cannot assume that the Token classes were created using the \"extendToken\" utilities\r\n    // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization\r\n    augmentTokenTypes(values(this.tokensMap));\r\n  }\r\n\r\n  defineRule<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleName: string,\r\n    impl: (...args: ARGS) => R,\r\n    config: IRuleConfig<R>,\r\n  ): ParserMethodInternal<ARGS, R> {\r\n    if (this.selfAnalysisDone) {\r\n      throw Error(\r\n        `Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\\n` +\r\n          `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`,\r\n      );\r\n    }\r\n    const resyncEnabled: boolean = has(config, \"resyncEnabled\")\r\n      ? (config.resyncEnabled as boolean) // assumes end user provides the correct config value/type\r\n      : DEFAULT_RULE_CONFIG.resyncEnabled;\r\n    const recoveryValueFunc = has(config, \"recoveryValueFunc\")\r\n      ? (config.recoveryValueFunc as () => R) // assumes end user provides the correct config value/type\r\n      : DEFAULT_RULE_CONFIG.recoveryValueFunc;\r\n\r\n    // performance optimization: Use small integers as keys for the longer human readable \"full\" rule names.\r\n    // this greatly improves Map access time (as much as 8% for some performance benchmarks).\r\n    const shortName =\r\n      this.ruleShortNameIdx << (BITS_FOR_METHOD_TYPE + BITS_FOR_OCCURRENCE_IDX);\r\n\r\n    this.ruleShortNameIdx++;\r\n    this.shortRuleNameToFull[shortName] = ruleName;\r\n    this.fullRuleNameToShort[ruleName] = shortName;\r\n\r\n    let invokeRuleWithTry: ParserMethod<ARGS, R>;\r\n\r\n    // Micro optimization, only check the condition **once** on rule definition\r\n    // instead of **every single** rule invocation.\r\n    if (this.outputCst === true) {\r\n      invokeRuleWithTry = function invokeRuleWithTry(\r\n        this: MixedInParser,\r\n        ...args: ARGS\r\n      ): R {\r\n        try {\r\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\r\n          impl.apply(this, args);\r\n          const cst = this.CST_STACK[this.CST_STACK.length - 1];\r\n          this.cstPostRule(cst);\r\n          return cst as unknown as R;\r\n        } catch (e) {\r\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R;\r\n        } finally {\r\n          this.ruleFinallyStateUpdate();\r\n        }\r\n      };\r\n    } else {\r\n      invokeRuleWithTry = function invokeRuleWithTryCst(\r\n        this: MixedInParser,\r\n        ...args: ARGS\r\n      ): R {\r\n        try {\r\n          this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);\r\n          return impl.apply(this, args);\r\n        } catch (e) {\r\n          return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc) as R;\r\n        } finally {\r\n          this.ruleFinallyStateUpdate();\r\n        }\r\n      };\r\n    }\r\n\r\n    const wrappedGrammarRule: ParserMethodInternal<ARGS, R> = Object.assign(\r\n      invokeRuleWithTry as any,\r\n      { ruleName, originalGrammarAction: impl },\r\n    );\r\n\r\n    return wrappedGrammarRule;\r\n  }\r\n\r\n  invokeRuleCatch(\r\n    this: MixedInParser,\r\n    e: Error,\r\n    resyncEnabledConfig: boolean,\r\n    recoveryValueFunc: Function,\r\n  ): unknown {\r\n    const isFirstInvokedRule = this.RULE_STACK.length === 1;\r\n    // note the reSync is always enabled for the first rule invocation, because we must always be able to\r\n    // reSync with EOF and just output some INVALID ParseTree\r\n    // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking\r\n    // path is really the most valid one\r\n    const reSyncEnabled =\r\n      resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;\r\n\r\n    if (isRecognitionException(e)) {\r\n      const recogError: any = e;\r\n      if (reSyncEnabled) {\r\n        const reSyncTokType = this.findReSyncTokenType();\r\n        if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {\r\n          recogError.resyncedTokens = this.reSyncTo(reSyncTokType);\r\n          if (this.outputCst) {\r\n            const partialCstResult: any =\r\n              this.CST_STACK[this.CST_STACK.length - 1];\r\n            partialCstResult.recoveredNode = true;\r\n            return partialCstResult;\r\n          } else {\r\n            return recoveryValueFunc(e);\r\n          }\r\n        } else {\r\n          if (this.outputCst) {\r\n            const partialCstResult: any =\r\n              this.CST_STACK[this.CST_STACK.length - 1];\r\n            partialCstResult.recoveredNode = true;\r\n            recogError.partialCstResult = partialCstResult;\r\n          }\r\n          // to be handled Further up the call stack\r\n          throw recogError;\r\n        }\r\n      } else if (isFirstInvokedRule) {\r\n        // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case\r\n        this.moveToTerminatedState();\r\n        // the parser should never throw one of its own errors outside its flow.\r\n        // even if error recovery is disabled\r\n        return recoveryValueFunc(e);\r\n      } else {\r\n        // to be recovered Further up the call stack\r\n        throw recogError;\r\n      }\r\n    } else {\r\n      // some other Error type which we don't know how to handle (for example a built in JavaScript Error)\r\n      throw e;\r\n    }\r\n  }\r\n\r\n  // Implementation of parsing DSL\r\n  optionInternal<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n    occurrence: number,\r\n  ): OUT | undefined {\r\n    const key = this.getKeyForAutomaticLookahead(OPTION_IDX, occurrence);\r\n    return this.optionInternalLogic(actionORMethodDef, occurrence, key);\r\n  }\r\n\r\n  optionInternalLogic<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n    occurrence: number,\r\n    key: number,\r\n  ): OUT | undefined {\r\n    let lookAheadFunc = this.getLaFuncFromCache(key);\r\n    let action: GrammarAction<OUT>;\r\n    if (typeof actionORMethodDef !== \"function\") {\r\n      action = actionORMethodDef.DEF;\r\n      const predicate = actionORMethodDef.GATE;\r\n      // predicate present\r\n      if (predicate !== undefined) {\r\n        const orgLookaheadFunction = lookAheadFunc;\r\n        lookAheadFunc = () => {\r\n          return predicate.call(this) && orgLookaheadFunction.call(this);\r\n        };\r\n      }\r\n    } else {\r\n      action = actionORMethodDef;\r\n    }\r\n\r\n    if (lookAheadFunc.call(this) === true) {\r\n      return action.call(this);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  atLeastOneInternal<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    const laKey = this.getKeyForAutomaticLookahead(\r\n      AT_LEAST_ONE_IDX,\r\n      prodOccurrence,\r\n    );\r\n    return this.atLeastOneInternalLogic(\r\n      prodOccurrence,\r\n      actionORMethodDef,\r\n      laKey,\r\n    );\r\n  }\r\n\r\n  atLeastOneInternalLogic<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n    key: number,\r\n  ): void {\r\n    let lookAheadFunc = this.getLaFuncFromCache(key);\r\n    let action;\r\n    if (typeof actionORMethodDef !== \"function\") {\r\n      action = actionORMethodDef.DEF;\r\n      const predicate = actionORMethodDef.GATE;\r\n      // predicate present\r\n      if (predicate !== undefined) {\r\n        const orgLookaheadFunction = lookAheadFunc;\r\n        lookAheadFunc = () => {\r\n          return predicate.call(this) && orgLookaheadFunction.call(this);\r\n        };\r\n      }\r\n    } else {\r\n      action = actionORMethodDef;\r\n    }\r\n\r\n    if ((<Function>lookAheadFunc).call(this) === true) {\r\n      let notStuck = this.doSingleRepetition(action);\r\n      while (\r\n        (<Function>lookAheadFunc).call(this) === true &&\r\n        notStuck === true\r\n      ) {\r\n        notStuck = this.doSingleRepetition(action);\r\n      }\r\n    } else {\r\n      throw this.raiseEarlyExitException(\r\n        prodOccurrence,\r\n        PROD_TYPE.REPETITION_MANDATORY,\r\n        (<DSLMethodOptsWithErr<OUT>>actionORMethodDef).ERR_MSG,\r\n      );\r\n    }\r\n\r\n    // note that while it may seem that this can cause an error because by using a recursive call to\r\n    // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call\r\n    // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.\r\n\r\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\r\n    this.attemptInRepetitionRecovery(\r\n      this.atLeastOneInternal,\r\n      [prodOccurrence, actionORMethodDef],\r\n      <any>lookAheadFunc,\r\n      AT_LEAST_ONE_IDX,\r\n      prodOccurrence,\r\n      NextTerminalAfterAtLeastOneWalker,\r\n    );\r\n  }\r\n\r\n  atLeastOneSepFirstInternal<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    const laKey = this.getKeyForAutomaticLookahead(\r\n      AT_LEAST_ONE_SEP_IDX,\r\n      prodOccurrence,\r\n    );\r\n    this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);\r\n  }\r\n\r\n  atLeastOneSepFirstInternalLogic<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n    key: number,\r\n  ): void {\r\n    const action = options.DEF;\r\n    const separator = options.SEP;\r\n\r\n    const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);\r\n\r\n    // 1st iteration\r\n    if (firstIterationLookaheadFunc.call(this) === true) {\r\n      (<GrammarAction<OUT>>action).call(this);\r\n\r\n      //  TODO: Optimization can move this function construction into \"attemptInRepetitionRecovery\"\r\n      //  because it is only needed in error recovery scenarios.\r\n      const separatorLookAheadFunc = () => {\r\n        return this.tokenMatcher(this.LA(1), separator);\r\n      };\r\n\r\n      // 2nd..nth iterations\r\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\r\n        // note that this CONSUME will never enter recovery because\r\n        // the separatorLookAheadFunc checks that the separator really does exist.\r\n        this.CONSUME(separator);\r\n        // No need for checking infinite loop here due to consuming the separator.\r\n        (<GrammarAction<OUT>>action).call(this);\r\n      }\r\n\r\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\r\n      this.attemptInRepetitionRecovery(\r\n        this.repetitionSepSecondInternal,\r\n        [\r\n          prodOccurrence,\r\n          separator,\r\n          separatorLookAheadFunc,\r\n          action,\r\n          NextTerminalAfterAtLeastOneSepWalker,\r\n        ],\r\n        separatorLookAheadFunc,\r\n        AT_LEAST_ONE_SEP_IDX,\r\n        prodOccurrence,\r\n        NextTerminalAfterAtLeastOneSepWalker,\r\n      );\r\n    } else {\r\n      throw this.raiseEarlyExitException(\r\n        prodOccurrence,\r\n        PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR,\r\n        options.ERR_MSG,\r\n      );\r\n    }\r\n  }\r\n\r\n  manyInternal<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    const laKey = this.getKeyForAutomaticLookahead(MANY_IDX, prodOccurrence);\r\n    return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);\r\n  }\r\n\r\n  manyInternalLogic<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n    key: number,\r\n  ) {\r\n    let lookaheadFunction = this.getLaFuncFromCache(key);\r\n    let action;\r\n    if (typeof actionORMethodDef !== \"function\") {\r\n      action = actionORMethodDef.DEF;\r\n      const predicate = actionORMethodDef.GATE;\r\n      // predicate present\r\n      if (predicate !== undefined) {\r\n        const orgLookaheadFunction = lookaheadFunction;\r\n        lookaheadFunction = () => {\r\n          return predicate.call(this) && orgLookaheadFunction.call(this);\r\n        };\r\n      }\r\n    } else {\r\n      action = actionORMethodDef;\r\n    }\r\n\r\n    let notStuck = true;\r\n    while (lookaheadFunction.call(this) === true && notStuck === true) {\r\n      notStuck = this.doSingleRepetition(action);\r\n    }\r\n\r\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\r\n    this.attemptInRepetitionRecovery(\r\n      this.manyInternal,\r\n      [prodOccurrence, actionORMethodDef],\r\n      <any>lookaheadFunction,\r\n      MANY_IDX,\r\n      prodOccurrence,\r\n      NextTerminalAfterManyWalker,\r\n      // The notStuck parameter is only relevant when \"attemptInRepetitionRecovery\"\r\n      // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]\r\n      // An infinite loop cannot occur as:\r\n      // - Either the lookahead is guaranteed to consume something (Single Token Separator)\r\n      // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).\r\n      notStuck,\r\n    );\r\n  }\r\n\r\n  manySepFirstInternal<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    options: ManySepMethodOpts<OUT>,\r\n  ): void {\r\n    const laKey = this.getKeyForAutomaticLookahead(\r\n      MANY_SEP_IDX,\r\n      prodOccurrence,\r\n    );\r\n    this.manySepFirstInternalLogic(prodOccurrence, options, laKey);\r\n  }\r\n\r\n  manySepFirstInternalLogic<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    options: ManySepMethodOpts<OUT>,\r\n    key: number,\r\n  ): void {\r\n    const action = options.DEF;\r\n    const separator = options.SEP;\r\n    const firstIterationLaFunc = this.getLaFuncFromCache(key);\r\n\r\n    // 1st iteration\r\n    if (firstIterationLaFunc.call(this) === true) {\r\n      action.call(this);\r\n\r\n      const separatorLookAheadFunc = () => {\r\n        return this.tokenMatcher(this.LA(1), separator);\r\n      };\r\n      // 2nd..nth iterations\r\n      while (this.tokenMatcher(this.LA(1), separator) === true) {\r\n        // note that this CONSUME will never enter recovery because\r\n        // the separatorLookAheadFunc checks that the separator really does exist.\r\n        this.CONSUME(separator);\r\n        // No need for checking infinite loop here due to consuming the separator.\r\n        action.call(this);\r\n      }\r\n\r\n      // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\r\n      this.attemptInRepetitionRecovery(\r\n        this.repetitionSepSecondInternal,\r\n        [\r\n          prodOccurrence,\r\n          separator,\r\n          separatorLookAheadFunc,\r\n          action,\r\n          NextTerminalAfterManySepWalker,\r\n        ],\r\n        separatorLookAheadFunc,\r\n        MANY_SEP_IDX,\r\n        prodOccurrence,\r\n        NextTerminalAfterManySepWalker,\r\n      );\r\n    }\r\n  }\r\n\r\n  repetitionSepSecondInternal<OUT>(\r\n    this: MixedInParser,\r\n    prodOccurrence: number,\r\n    separator: TokenType,\r\n    separatorLookAheadFunc: () => boolean,\r\n    action: GrammarAction<OUT>,\r\n    nextTerminalAfterWalker: typeof AbstractNextTerminalAfterProductionWalker,\r\n  ): void {\r\n    while (separatorLookAheadFunc()) {\r\n      // note that this CONSUME will never enter recovery because\r\n      // the separatorLookAheadFunc checks that the separator really does exist.\r\n      this.CONSUME(separator);\r\n      action.call(this);\r\n    }\r\n\r\n    // we can only arrive to this function after an error\r\n    // has occurred (hence the name 'second') so the following\r\n    // IF will always be entered, its possible to remove it...\r\n    // however it is kept to avoid confusion and be consistent.\r\n    // Performance optimization: \"attemptInRepetitionRecovery\" will be defined as NOOP unless recovery is enabled\r\n    /* istanbul ignore else */\r\n    this.attemptInRepetitionRecovery(\r\n      this.repetitionSepSecondInternal,\r\n      [\r\n        prodOccurrence,\r\n        separator,\r\n        separatorLookAheadFunc,\r\n        action,\r\n        nextTerminalAfterWalker,\r\n      ],\r\n      separatorLookAheadFunc,\r\n      AT_LEAST_ONE_SEP_IDX,\r\n      prodOccurrence,\r\n      nextTerminalAfterWalker,\r\n    );\r\n  }\r\n\r\n  doSingleRepetition(this: MixedInParser, action: Function): any {\r\n    const beforeIteration = this.getLexerPosition();\r\n    action.call(this);\r\n    const afterIteration = this.getLexerPosition();\r\n\r\n    // This boolean will indicate if this repetition progressed\r\n    // or if we are \"stuck\" (potential infinite loop in the repetition).\r\n    return afterIteration > beforeIteration;\r\n  }\r\n\r\n  orInternal<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n    occurrence: number,\r\n  ): T {\r\n    const laKey = this.getKeyForAutomaticLookahead(OR_IDX, occurrence);\r\n    const alts = isArray(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;\r\n\r\n    const laFunc = this.getLaFuncFromCache(laKey);\r\n    const altIdxToTake = laFunc.call(this, alts);\r\n    if (altIdxToTake !== undefined) {\r\n      const chosenAlternative: any = alts[altIdxToTake];\r\n      return chosenAlternative.ALT.call(this);\r\n    }\r\n    this.raiseNoAltException(\r\n      occurrence,\r\n      (altsOrOpts as OrMethodOpts<unknown>).ERR_MSG,\r\n    );\r\n  }\r\n\r\n  ruleFinallyStateUpdate(this: MixedInParser): void {\r\n    this.RULE_STACK.pop();\r\n    this.RULE_OCCURRENCE_STACK.pop();\r\n\r\n    // NOOP when cst is disabled\r\n    this.cstFinallyStateUpdate();\r\n\r\n    if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {\r\n      const firstRedundantTok = this.LA(1);\r\n      const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({\r\n        firstRedundant: firstRedundantTok,\r\n        ruleName: this.getCurrRuleFullName(),\r\n      });\r\n      this.SAVE_ERROR(\r\n        new NotAllInputParsedException(errMsg, firstRedundantTok),\r\n      );\r\n    }\r\n  }\r\n\r\n  subruleInternal<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    idx: number,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R {\r\n    let ruleResult;\r\n    try {\r\n      const args = options !== undefined ? options.ARGS : undefined;\r\n      this.subruleIdx = idx;\r\n      ruleResult = ruleToCall.apply(this, args);\r\n      this.cstPostNonTerminal(\r\n        ruleResult,\r\n        options !== undefined && options.LABEL !== undefined\r\n          ? options.LABEL\r\n          : ruleToCall.ruleName,\r\n      );\r\n      return ruleResult;\r\n    } catch (e) {\r\n      throw this.subruleInternalError(e, options, ruleToCall.ruleName);\r\n    }\r\n  }\r\n\r\n  subruleInternalError(\r\n    this: MixedInParser,\r\n    e: any,\r\n    options: SubruleMethodOpts<unknown[]> | undefined,\r\n    ruleName: string,\r\n  ): void {\r\n    if (isRecognitionException(e) && e.partialCstResult !== undefined) {\r\n      this.cstPostNonTerminal(\r\n        e.partialCstResult,\r\n        options !== undefined && options.LABEL !== undefined\r\n          ? options.LABEL\r\n          : ruleName,\r\n      );\r\n\r\n      delete e.partialCstResult;\r\n    }\r\n    throw e;\r\n  }\r\n\r\n  consumeInternal(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    idx: number,\r\n    options: ConsumeMethodOpts | undefined,\r\n  ): IToken {\r\n    let consumedToken!: IToken;\r\n    try {\r\n      const nextToken = this.LA(1);\r\n      if (this.tokenMatcher(nextToken, tokType) === true) {\r\n        this.consumeToken();\r\n        consumedToken = nextToken;\r\n      } else {\r\n        this.consumeInternalError(tokType, nextToken, options);\r\n      }\r\n    } catch (eFromConsumption) {\r\n      consumedToken = this.consumeInternalRecovery(\r\n        tokType,\r\n        idx,\r\n        eFromConsumption,\r\n      );\r\n    }\r\n\r\n    this.cstPostTerminal(\r\n      options !== undefined && options.LABEL !== undefined\r\n        ? options.LABEL\r\n        : tokType.name,\r\n      consumedToken,\r\n    );\r\n    return consumedToken;\r\n  }\r\n\r\n  consumeInternalError(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    nextToken: IToken,\r\n    options: ConsumeMethodOpts | undefined,\r\n  ): void {\r\n    let msg;\r\n    const previousToken = this.LA(0);\r\n    if (options !== undefined && options.ERR_MSG) {\r\n      msg = options.ERR_MSG;\r\n    } else {\r\n      msg = this.errorMessageProvider.buildMismatchTokenMessage({\r\n        expected: tokType,\r\n        actual: nextToken,\r\n        previous: previousToken,\r\n        ruleName: this.getCurrRuleFullName(),\r\n      });\r\n    }\r\n    throw this.SAVE_ERROR(\r\n      new MismatchedTokenException(msg, nextToken, previousToken),\r\n    );\r\n  }\r\n\r\n  consumeInternalRecovery(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    idx: number,\r\n    eFromConsumption: Error,\r\n  ): IToken {\r\n    // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it\r\n    // but the original syntax could have been parsed successfully without any backtracking + recovery\r\n    if (\r\n      this.recoveryEnabled &&\r\n      // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?\r\n      eFromConsumption.name === \"MismatchedTokenException\" &&\r\n      !this.isBackTracking()\r\n    ) {\r\n      const follows = this.getFollowsForInRuleRecovery(<any>tokType, idx);\r\n      try {\r\n        return this.tryInRuleRecovery(<any>tokType, follows);\r\n      } catch (eFromInRuleRecovery) {\r\n        if (eFromInRuleRecovery.name === IN_RULE_RECOVERY_EXCEPTION) {\r\n          // failed in RuleRecovery.\r\n          // throw the original error in order to trigger reSync error recovery\r\n          throw eFromConsumption;\r\n        } else {\r\n          throw eFromInRuleRecovery;\r\n        }\r\n      }\r\n    } else {\r\n      throw eFromConsumption;\r\n    }\r\n  }\r\n\r\n  saveRecogState(this: MixedInParser): IParserState {\r\n    // errors is a getter which will clone the errors array\r\n    const savedErrors = this.errors;\r\n    const savedRuleStack = clone(this.RULE_STACK);\r\n    return {\r\n      errors: savedErrors,\r\n      lexerState: this.exportLexerState(),\r\n      RULE_STACK: savedRuleStack,\r\n      CST_STACK: this.CST_STACK,\r\n    };\r\n  }\r\n\r\n  reloadRecogState(this: MixedInParser, newState: IParserState) {\r\n    this.errors = newState.errors;\r\n    this.importLexerState(newState.lexerState);\r\n    this.RULE_STACK = newState.RULE_STACK;\r\n  }\r\n\r\n  ruleInvocationStateUpdate(\r\n    this: MixedInParser,\r\n    shortName: number,\r\n    fullName: string,\r\n    idxInCallingRule: number,\r\n  ): void {\r\n    this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);\r\n    this.RULE_STACK.push(shortName);\r\n    // NOOP when cst is disabled\r\n    this.cstInvocationStateUpdate(fullName);\r\n  }\r\n\r\n  isBackTracking(this: MixedInParser): boolean {\r\n    return this.isBackTrackingStack.length !== 0;\r\n  }\r\n\r\n  getCurrRuleFullName(this: MixedInParser): string {\r\n    const shortName = this.getLastExplicitRuleShortName();\r\n    return this.shortRuleNameToFull[shortName];\r\n  }\r\n\r\n  shortRuleNameToFullName(this: MixedInParser, shortName: number) {\r\n    return this.shortRuleNameToFull[shortName];\r\n  }\r\n\r\n  public isAtEndOfInput(this: MixedInParser): boolean {\r\n    return this.tokenMatcher(this.LA(1), EOF);\r\n  }\r\n\r\n  public reset(this: MixedInParser): void {\r\n    this.resetLexerState();\r\n    this.subruleIdx = 0;\r\n    this.isBackTrackingStack = [];\r\n    this.errors = [];\r\n    this.RULE_STACK = [];\r\n    // TODO: extract a specific reset for TreeBuilder trait\r\n    this.CST_STACK = [];\r\n    this.RULE_OCCURRENCE_STACK = [];\r\n  }\r\n}\r\n", "import {\r\n  IParserConfig,\r\n  IParserErrorMessageProvider,\r\n  IRecognitionException,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  EarlyExitException,\r\n  isRecognitionException,\r\n  NoViableAltException,\r\n} from \"../../exceptions_public.js\";\r\nimport { clone, has } from \"lodash-es\";\r\nimport {\r\n  getLookaheadPathsForOptionalProd,\r\n  getLookaheadPathsForOr,\r\n  PROD_TYPE,\r\n} from \"../../grammar/lookahead.js\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\r\n\r\n/**\r\n * Trait responsible for runtime parsing errors.\r\n */\r\nexport class ErrorHandler {\r\n  _errors: IRecognitionException[];\r\n  errorMessageProvider: IParserErrorMessageProvider;\r\n\r\n  initErrorHandler(config: IParserConfig) {\r\n    this._errors = [];\r\n    this.errorMessageProvider = has(config, \"errorMessageProvider\")\r\n      ? (config.errorMessageProvider as IParserErrorMessageProvider) // assumes end user provides the correct config value/type\r\n      : DEFAULT_PARSER_CONFIG.errorMessageProvider;\r\n  }\r\n\r\n  SAVE_ERROR(\r\n    this: MixedInParser,\r\n    error: IRecognitionException,\r\n  ): IRecognitionException {\r\n    if (isRecognitionException(error)) {\r\n      error.context = {\r\n        ruleStack: this.getHumanReadableRuleStack(),\r\n        ruleOccurrenceStack: clone(this.RULE_OCCURRENCE_STACK),\r\n      };\r\n      this._errors.push(error);\r\n      return error;\r\n    } else {\r\n      throw Error(\r\n        \"Trying to save an Error which is not a RecognitionException\",\r\n      );\r\n    }\r\n  }\r\n\r\n  get errors(): IRecognitionException[] {\r\n    return clone(this._errors);\r\n  }\r\n\r\n  set errors(newErrors: IRecognitionException[]) {\r\n    this._errors = newErrors;\r\n  }\r\n\r\n  // TODO: consider caching the error message computed information\r\n  raiseEarlyExitException(\r\n    this: MixedInParser,\r\n    occurrence: number,\r\n    prodType: PROD_TYPE,\r\n    userDefinedErrMsg: string | undefined,\r\n  ): never {\r\n    const ruleName = this.getCurrRuleFullName();\r\n    const ruleGrammar = this.getGAstProductions()[ruleName];\r\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOptionalProd(\r\n      occurrence,\r\n      ruleGrammar,\r\n      prodType,\r\n      this.maxLookahead,\r\n    );\r\n    const insideProdPaths = lookAheadPathsPerAlternative[0];\r\n    const actualTokens = [];\r\n    for (let i = 1; i <= this.maxLookahead; i++) {\r\n      actualTokens.push(this.LA(i));\r\n    }\r\n    const msg = this.errorMessageProvider.buildEarlyExitMessage({\r\n      expectedIterationPaths: insideProdPaths,\r\n      actual: actualTokens,\r\n      previous: this.LA(0),\r\n      customUserDescription: userDefinedErrMsg,\r\n      ruleName: ruleName,\r\n    });\r\n\r\n    throw this.SAVE_ERROR(new EarlyExitException(msg, this.LA(1), this.LA(0)));\r\n  }\r\n\r\n  // TODO: consider caching the error message computed information\r\n  raiseNoAltException(\r\n    this: MixedInParser,\r\n    occurrence: number,\r\n    errMsgTypes: string | undefined,\r\n  ): never {\r\n    const ruleName = this.getCurrRuleFullName();\r\n    const ruleGrammar = this.getGAstProductions()[ruleName];\r\n    // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?\r\n    const lookAheadPathsPerAlternative = getLookaheadPathsForOr(\r\n      occurrence,\r\n      ruleGrammar,\r\n      this.maxLookahead,\r\n    );\r\n\r\n    const actualTokens = [];\r\n    for (let i = 1; i <= this.maxLookahead; i++) {\r\n      actualTokens.push(this.LA(i));\r\n    }\r\n    const previousToken = this.LA(0);\r\n\r\n    const errMsg = this.errorMessageProvider.buildNoViableAltMessage({\r\n      expectedPathsPerAlt: lookAheadPathsPerAlternative,\r\n      actual: actualTokens,\r\n      previous: previousToken,\r\n      customUserDescription: errMsgTypes,\r\n      ruleName: this.getCurrRuleFullName(),\r\n    });\r\n\r\n    throw this.SAVE_ERROR(\r\n      new NoViableAltException(errMsg, this.LA(1), previousToken),\r\n    );\r\n  }\r\n}\r\n", "import {\r\n  ISyntacticContentAssistPath,\r\n  IToken,\r\n  ITokenGrammarPath,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  NextAfterTokenWalker,\r\n  nextPossibleTokensAfter,\r\n} from \"../../grammar/interpreter.js\";\r\nimport { first, isUndefined } from \"lodash-es\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\n\r\nexport class ContentAssist {\r\n  initContentAssist() {}\r\n\r\n  public computeContentAssist(\r\n    this: MixedInParser,\r\n    startRuleName: string,\r\n    precedingInput: IToken[],\r\n  ): ISyntacticContentAssistPath[] {\r\n    const startRuleGast = this.gastProductionsCache[startRuleName];\r\n\r\n    if (isUndefined(startRuleGast)) {\r\n      throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);\r\n    }\r\n\r\n    return nextPossibleTokensAfter(\r\n      [startRuleGast],\r\n      precedingInput,\r\n      this.tokenMatcher,\r\n      this.maxLookahead,\r\n    );\r\n  }\r\n\r\n  // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...\r\n  // TODO: should this be more explicitly part of the public API?\r\n  public getNextPossibleTokenTypes(\r\n    this: MixedInParser,\r\n    grammarPath: ITokenGrammarPath,\r\n  ): TokenType[] {\r\n    const topRuleName = first(grammarPath.ruleStack)!;\r\n    const gastProductions = this.getGAstProductions();\r\n    const topProduction = gastProductions[topRuleName];\r\n    const nextPossibleTokenTypes = new NextAfterTokenWalker(\r\n      topProduction,\r\n      grammarPath,\r\n    ).startWalking();\r\n    return nextPossibleTokenTypes;\r\n  }\r\n}\r\n", "import {\r\n  AtLeastOneSepMethodOpts,\r\n  ConsumeMethodOpts,\r\n  CstNode,\r\n  DSLMethodOpts,\r\n  DSLMethodOptsWithErr,\r\n  GrammarAction,\r\n  IOrAlt,\r\n  IParserConfig,\r\n  IProduction,\r\n  IToken,\r\n  ManySepMethodOpts,\r\n  OrMethodOpts,\r\n  SubruleMethodOpts,\r\n  TokenType,\r\n} from \"@chevrotain/types\";\r\nimport {\r\n  forEach,\r\n  has,\r\n  isArray,\r\n  isFunction,\r\n  last as peek,\r\n  some,\r\n} from \"lodash-es\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport {\r\n  Alternation,\r\n  Alternative,\r\n  NonTerminal,\r\n  Option,\r\n  Repetition,\r\n  RepetitionMandatory,\r\n  RepetitionMandatoryWithSeparator,\r\n  RepetitionWithSeparator,\r\n  Rule,\r\n  Terminal,\r\n} from \"@chevrotain/gast\";\r\nimport { Lexer } from \"../../../scan/lexer_public.js\";\r\nimport {\r\n  augmentTokenTypes,\r\n  hasShortKeyProperty,\r\n} from \"../../../scan/tokens.js\";\r\nimport {\r\n  createToken,\r\n  createTokenInstance,\r\n} from \"../../../scan/tokens_public.js\";\r\nimport { END_OF_FILE } from \"../parser.js\";\r\nimport { BITS_FOR_OCCURRENCE_IDX } from \"../../grammar/keys.js\";\r\nimport { ParserMethodInternal } from \"../types.js\";\r\n\r\ntype ProdWithDef = IProduction & { definition?: IProduction[] };\r\nconst RECORDING_NULL_OBJECT = {\r\n  description: \"This Object indicates the Parser is during Recording Phase\",\r\n};\r\nObject.freeze(RECORDING_NULL_OBJECT);\r\n\r\nconst HANDLE_SEPARATOR = true;\r\nconst MAX_METHOD_IDX = Math.pow(2, BITS_FOR_OCCURRENCE_IDX) - 1;\r\n\r\nconst RFT = createToken({ name: \"RECORDING_PHASE_TOKEN\", pattern: Lexer.NA });\r\naugmentTokenTypes([RFT]);\r\nconst RECORDING_PHASE_TOKEN = createTokenInstance(\r\n  RFT,\r\n  \"This IToken indicates the Parser is in Recording Phase\\n\\t\" +\r\n    \"\" +\r\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\r\n  // Using \"-1\" instead of NaN (as in EOF) because an actual number is less likely to\r\n  // cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.\r\n  -1,\r\n  -1,\r\n  -1,\r\n  -1,\r\n  -1,\r\n  -1,\r\n);\r\nObject.freeze(RECORDING_PHASE_TOKEN);\r\n\r\nconst RECORDING_PHASE_CSTNODE: CstNode = {\r\n  name:\r\n    \"This CSTNode indicates the Parser is in Recording Phase\\n\\t\" +\r\n    \"See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details\",\r\n  children: {},\r\n};\r\n\r\n/**\r\n * This trait handles the creation of the GAST structure for Chevrotain Grammars\r\n */\r\nexport class GastRecorder {\r\n  recordingProdStack: ProdWithDef[];\r\n  RECORDING_PHASE: boolean;\r\n\r\n  initGastRecorder(this: MixedInParser, config: IParserConfig): void {\r\n    this.recordingProdStack = [];\r\n    this.RECORDING_PHASE = false;\r\n  }\r\n\r\n  enableRecording(this: MixedInParser): void {\r\n    this.RECORDING_PHASE = true;\r\n\r\n    this.TRACE_INIT(\"Enable Recording\", () => {\r\n      /**\r\n       * Warning Dark Voodoo Magic upcoming!\r\n       * We are \"replacing\" the public parsing DSL methods API\r\n       * With **new** alternative implementations on the Parser **instance**\r\n       *\r\n       * So far this is the only way I've found to avoid performance regressions during parsing time.\r\n       * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the \"internal\"\r\n       *   implementations directly instead.\r\n       */\r\n      for (let i = 0; i < 10; i++) {\r\n        const idx = i > 0 ? i : \"\";\r\n        this[`CONSUME${idx}` as \"CONSUME\"] = function (arg1, arg2) {\r\n          return this.consumeInternalRecord(arg1, i, arg2);\r\n        };\r\n        this[`SUBRULE${idx}` as \"SUBRULE\"] = function (arg1, arg2) {\r\n          return this.subruleInternalRecord(arg1, i, arg2) as any;\r\n        };\r\n        this[`OPTION${idx}` as \"OPTION\"] = function (arg1) {\r\n          return this.optionInternalRecord(arg1, i);\r\n        };\r\n        this[`OR${idx}` as \"OR\"] = function (arg1) {\r\n          return this.orInternalRecord(arg1, i);\r\n        };\r\n        this[`MANY${idx}` as \"MANY\"] = function (arg1) {\r\n          this.manyInternalRecord(i, arg1);\r\n        };\r\n        this[`MANY_SEP${idx}` as \"MANY_SEP\"] = function (arg1) {\r\n          this.manySepFirstInternalRecord(i, arg1);\r\n        };\r\n        this[`AT_LEAST_ONE${idx}` as \"AT_LEAST_ONE\"] = function (arg1) {\r\n          this.atLeastOneInternalRecord(i, arg1);\r\n        };\r\n        this[`AT_LEAST_ONE_SEP${idx}` as \"AT_LEAST_ONE_SEP\"] = function (arg1) {\r\n          this.atLeastOneSepFirstInternalRecord(i, arg1);\r\n        };\r\n      }\r\n\r\n      // DSL methods with the idx(suffix) as an argument\r\n      this[`consume`] = function (idx, arg1, arg2) {\r\n        return this.consumeInternalRecord(arg1, idx, arg2);\r\n      };\r\n      this[`subrule`] = function (idx, arg1, arg2) {\r\n        return this.subruleInternalRecord(arg1, idx, arg2) as any;\r\n      };\r\n      this[`option`] = function (idx, arg1) {\r\n        return this.optionInternalRecord(arg1, idx);\r\n      };\r\n      this[`or`] = function (idx, arg1) {\r\n        return this.orInternalRecord(arg1, idx);\r\n      };\r\n      this[`many`] = function (idx, arg1) {\r\n        this.manyInternalRecord(idx, arg1);\r\n      };\r\n      this[`atLeastOne`] = function (idx, arg1) {\r\n        this.atLeastOneInternalRecord(idx, arg1);\r\n      };\r\n\r\n      this.ACTION = this.ACTION_RECORD;\r\n      this.BACKTRACK = this.BACKTRACK_RECORD;\r\n      this.LA = this.LA_RECORD;\r\n    });\r\n  }\r\n\r\n  disableRecording(this: MixedInParser) {\r\n    this.RECORDING_PHASE = false;\r\n    // By deleting these **instance** properties, any future invocation\r\n    // will be deferred to the original methods on the **prototype** object\r\n    // This seems to get rid of any incorrect optimizations that V8 may\r\n    // do during the recording phase.\r\n    this.TRACE_INIT(\"Deleting Recording methods\", () => {\r\n      const that: any = this;\r\n\r\n      for (let i = 0; i < 10; i++) {\r\n        const idx = i > 0 ? i : \"\";\r\n        delete that[`CONSUME${idx}`];\r\n        delete that[`SUBRULE${idx}`];\r\n        delete that[`OPTION${idx}`];\r\n        delete that[`OR${idx}`];\r\n        delete that[`MANY${idx}`];\r\n        delete that[`MANY_SEP${idx}`];\r\n        delete that[`AT_LEAST_ONE${idx}`];\r\n        delete that[`AT_LEAST_ONE_SEP${idx}`];\r\n      }\r\n\r\n      delete that[`consume`];\r\n      delete that[`subrule`];\r\n      delete that[`option`];\r\n      delete that[`or`];\r\n      delete that[`many`];\r\n      delete that[`atLeastOne`];\r\n\r\n      delete that.ACTION;\r\n      delete that.BACKTRACK;\r\n      delete that.LA;\r\n    });\r\n  }\r\n\r\n  //   Parser methods are called inside an ACTION?\r\n  //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?\r\n  // @ts-expect-error -- noop place holder\r\n  ACTION_RECORD<T>(this: MixedInParser, impl: () => T): T {\r\n    // NO-OP during recording\r\n  }\r\n\r\n  // Executing backtracking logic will break our recording logic assumptions\r\n  BACKTRACK_RECORD<T>(\r\n    grammarRule: (...args: any[]) => T,\r\n    args?: any[],\r\n  ): () => boolean {\r\n    return () => true;\r\n  }\r\n\r\n  // LA is part of the official API and may be used for custom lookahead logic\r\n  // by end users who may forget to wrap it in ACTION or inside a GATE\r\n  LA_RECORD(howMuch: number): IToken {\r\n    // We cannot use the RECORD_PHASE_TOKEN here because someone may depend\r\n    // On LA return EOF at the end of the input so an infinite loop may occur.\r\n    return END_OF_FILE;\r\n  }\r\n\r\n  topLevelRuleRecord(name: string, def: Function): Rule {\r\n    try {\r\n      const newTopLevelRule = new Rule({ definition: [], name: name });\r\n      newTopLevelRule.name = name;\r\n      this.recordingProdStack.push(newTopLevelRule);\r\n      def.call(this);\r\n      this.recordingProdStack.pop();\r\n      return newTopLevelRule;\r\n    } catch (originalError) {\r\n      if (originalError.KNOWN_RECORDER_ERROR !== true) {\r\n        try {\r\n          originalError.message =\r\n            originalError.message +\r\n            '\\n\\t This error was thrown during the \"grammar recording phase\" For more info see:\\n\\t' +\r\n            \"https://chevrotain.io/docs/guide/internals.html#grammar-recording\";\r\n        } catch (mutabilityError) {\r\n          // We may not be able to modify the original error object\r\n          throw originalError;\r\n        }\r\n      }\r\n      throw originalError;\r\n    }\r\n  }\r\n\r\n  // Implementation of parsing DSL\r\n  optionInternalRecord<OUT>(\r\n    this: MixedInParser,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n    occurrence: number,\r\n  ): OUT {\r\n    return recordProd.call(this, Option, actionORMethodDef, occurrence);\r\n  }\r\n\r\n  atLeastOneInternalRecord<OUT>(\r\n    this: MixedInParser,\r\n    occurrence: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOptsWithErr<OUT>,\r\n  ): void {\r\n    recordProd.call(this, RepetitionMandatory, actionORMethodDef, occurrence);\r\n  }\r\n\r\n  atLeastOneSepFirstInternalRecord<OUT>(\r\n    this: MixedInParser,\r\n    occurrence: number,\r\n    options: AtLeastOneSepMethodOpts<OUT>,\r\n  ): void {\r\n    recordProd.call(\r\n      this,\r\n      RepetitionMandatoryWithSeparator,\r\n      options,\r\n      occurrence,\r\n      HANDLE_SEPARATOR,\r\n    );\r\n  }\r\n\r\n  manyInternalRecord<OUT>(\r\n    this: MixedInParser,\r\n    occurrence: number,\r\n    actionORMethodDef: GrammarAction<OUT> | DSLMethodOpts<OUT>,\r\n  ): void {\r\n    recordProd.call(this, Repetition, actionORMethodDef, occurrence);\r\n  }\r\n\r\n  manySepFirstInternalRecord<OUT>(\r\n    this: MixedInParser,\r\n    occurrence: number,\r\n    options: ManySepMethodOpts<OUT>,\r\n  ): void {\r\n    recordProd.call(\r\n      this,\r\n      RepetitionWithSeparator,\r\n      options,\r\n      occurrence,\r\n      HANDLE_SEPARATOR,\r\n    );\r\n  }\r\n\r\n  orInternalRecord<T>(\r\n    this: MixedInParser,\r\n    altsOrOpts: IOrAlt<any>[] | OrMethodOpts<unknown>,\r\n    occurrence: number,\r\n  ): T {\r\n    return recordOrProd.call(this, altsOrOpts, occurrence);\r\n  }\r\n\r\n  subruleInternalRecord<ARGS extends unknown[], R>(\r\n    this: MixedInParser,\r\n    ruleToCall: ParserMethodInternal<ARGS, R>,\r\n    occurrence: number,\r\n    options?: SubruleMethodOpts<ARGS>,\r\n  ): R | CstNode {\r\n    assertMethodIdxIsValid(occurrence);\r\n    if (!ruleToCall || has(ruleToCall, \"ruleName\") === false) {\r\n      const error: any = new Error(\r\n        `<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +\r\n          ` expecting a Parser method reference but got: <${JSON.stringify(\r\n            ruleToCall,\r\n          )}>` +\r\n          `\\n inside top level rule: <${\r\n            (<Rule>this.recordingProdStack[0]).name\r\n          }>`,\r\n      );\r\n      error.KNOWN_RECORDER_ERROR = true;\r\n      throw error;\r\n    }\r\n\r\n    const prevProd: any = peek(this.recordingProdStack);\r\n    const ruleName = ruleToCall.ruleName;\r\n    const newNoneTerminal = new NonTerminal({\r\n      idx: occurrence,\r\n      nonTerminalName: ruleName,\r\n      label: options?.LABEL,\r\n      // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created\r\n      referencedRule: undefined,\r\n    });\r\n    prevProd.definition.push(newNoneTerminal);\r\n\r\n    return this.outputCst\r\n      ? RECORDING_PHASE_CSTNODE\r\n      : <any>RECORDING_NULL_OBJECT;\r\n  }\r\n\r\n  consumeInternalRecord(\r\n    this: MixedInParser,\r\n    tokType: TokenType,\r\n    occurrence: number,\r\n    options?: ConsumeMethodOpts,\r\n  ): IToken {\r\n    assertMethodIdxIsValid(occurrence);\r\n    if (!hasShortKeyProperty(tokType)) {\r\n      const error: any = new Error(\r\n        `<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +\r\n          ` expecting a TokenType reference but got: <${JSON.stringify(\r\n            tokType,\r\n          )}>` +\r\n          `\\n inside top level rule: <${\r\n            (<Rule>this.recordingProdStack[0]).name\r\n          }>`,\r\n      );\r\n      error.KNOWN_RECORDER_ERROR = true;\r\n      throw error;\r\n    }\r\n    const prevProd: any = peek(this.recordingProdStack);\r\n    const newNoneTerminal = new Terminal({\r\n      idx: occurrence,\r\n      terminalType: tokType,\r\n      label: options?.LABEL,\r\n    });\r\n    prevProd.definition.push(newNoneTerminal);\r\n\r\n    return RECORDING_PHASE_TOKEN;\r\n  }\r\n}\r\n\r\nfunction recordProd(\r\n  prodConstructor: any,\r\n  mainProdArg: any,\r\n  occurrence: number,\r\n  handleSep: boolean = false,\r\n): any {\r\n  assertMethodIdxIsValid(occurrence);\r\n  const prevProd: any = peek(this.recordingProdStack);\r\n  const grammarAction = isFunction(mainProdArg) ? mainProdArg : mainProdArg.DEF;\r\n\r\n  const newProd = new prodConstructor({ definition: [], idx: occurrence });\r\n  if (handleSep) {\r\n    newProd.separator = mainProdArg.SEP;\r\n  }\r\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\r\n    newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\r\n  }\r\n\r\n  this.recordingProdStack.push(newProd);\r\n  grammarAction.call(this);\r\n  prevProd.definition.push(newProd);\r\n  this.recordingProdStack.pop();\r\n\r\n  return RECORDING_NULL_OBJECT;\r\n}\r\n\r\nfunction recordOrProd(mainProdArg: any, occurrence: number): any {\r\n  assertMethodIdxIsValid(occurrence);\r\n  const prevProd: any = peek(this.recordingProdStack);\r\n  // Only an array of alternatives\r\n  const hasOptions = isArray(mainProdArg) === false;\r\n  const alts: IOrAlt<unknown>[] =\r\n    hasOptions === false ? mainProdArg : mainProdArg.DEF;\r\n\r\n  const newOrProd = new Alternation({\r\n    definition: [],\r\n    idx: occurrence,\r\n    ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,\r\n  });\r\n  if (has(mainProdArg, \"MAX_LOOKAHEAD\")) {\r\n    newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;\r\n  }\r\n\r\n  const hasPredicates = some(alts, (currAlt: any) => isFunction(currAlt.GATE));\r\n  newOrProd.hasPredicates = hasPredicates;\r\n\r\n  prevProd.definition.push(newOrProd);\r\n\r\n  forEach(alts, (currAlt) => {\r\n    const currAltFlat = new Alternative({ definition: [] });\r\n    newOrProd.definition.push(currAltFlat);\r\n    if (has(currAlt, \"IGNORE_AMBIGUITIES\")) {\r\n      currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES as boolean; // assumes end user provides the correct config value/type\r\n    }\r\n    // **implicit** ignoreAmbiguities due to usage of gate\r\n    else if (has(currAlt, \"GATE\")) {\r\n      currAltFlat.ignoreAmbiguities = true;\r\n    }\r\n    this.recordingProdStack.push(currAltFlat);\r\n    currAlt.ALT.call(this);\r\n    this.recordingProdStack.pop();\r\n  });\r\n  return RECORDING_NULL_OBJECT;\r\n}\r\n\r\nfunction getIdxSuffix(idx: number): string {\r\n  return idx === 0 ? \"\" : `${idx}`;\r\n}\r\n\r\nfunction assertMethodIdxIsValid(idx: number): void {\r\n  if (idx < 0 || idx > MAX_METHOD_IDX) {\r\n    const error: any = new Error(\r\n      // The stack trace will contain all the needed details\r\n      `Invalid DSL Method idx value: <${idx}>\\n\\t` +\r\n        `Idx value must be a none negative value smaller than ${\r\n          MAX_METHOD_IDX + 1\r\n        }`,\r\n    );\r\n    error.KNOWN_RECORDER_ERROR = true;\r\n    throw error;\r\n  }\r\n}\r\n", "import { IParserConfig } from \"@chevrotain/types\";\r\nimport { has } from \"lodash-es\";\r\nimport { timer } from \"@chevrotain/utils\";\r\nimport { MixedInParser } from \"./parser_traits.js\";\r\nimport { DEFAULT_PARSER_CONFIG } from \"../parser.js\";\r\n\r\n/**\r\n * Trait responsible for runtime parsing errors.\r\n */\r\nexport class PerformanceTracer {\r\n  traceInitPerf: boolean | number;\r\n  traceInitMaxIdent: number;\r\n  traceInitIndent: number;\r\n\r\n  initPerformanceTracer(config: IParserConfig) {\r\n    if (has(config, \"traceInitPerf\")) {\r\n      const userTraceInitPerf = config.traceInitPerf;\r\n      const traceIsNumber = typeof userTraceInitPerf === \"number\";\r\n      this.traceInitMaxIdent = traceIsNumber\r\n        ? <number>userTraceInitPerf\r\n        : Infinity;\r\n      this.traceInitPerf = traceIsNumber\r\n        ? userTraceInitPerf > 0\r\n        : (userTraceInitPerf as boolean); // assumes end user provides the correct config value/type\r\n    } else {\r\n      this.traceInitMaxIdent = 0;\r\n      this.traceInitPerf = DEFAULT_PARSER_CONFIG.traceInitPerf;\r\n    }\r\n\r\n    this.traceInitIndent = -1;\r\n  }\r\n\r\n  TRACE_INIT<T>(this: MixedInParser, phaseDesc: string, phaseImpl: () => T): T {\r\n    // No need to optimize this using NOOP pattern because\r\n    // It is not called in a hot spot...\r\n    if (this.traceInitPerf === true) {\r\n      this.traceInitIndent++;\r\n      const indent = new Array(this.traceInitIndent + 1).join(\"\\t\");\r\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\r\n        console.log(`${indent}--> <${phaseDesc}>`);\r\n      }\r\n      const { time, value } = timer(phaseImpl);\r\n      /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */\r\n      const traceMethod = time > 10 ? console.warn : console.log;\r\n      if (this.traceInitIndent < this.traceInitMaxIdent) {\r\n        traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);\r\n      }\r\n      this.traceInitIndent--;\r\n      return value;\r\n    } else {\r\n      return phaseImpl();\r\n    }\r\n  }\r\n}\r\n", "export function applyMixins(derivedCtor: any, baseCtors: any[]) {\r\n  baseCtors.forEach((baseCtor) => {\r\n    const baseProto = baseCtor.prototype;\r\n    Object.getOwnPropertyNames(baseProto).forEach((propName) => {\r\n      if (propName === \"constructor\") {\r\n        return;\r\n      }\r\n\r\n      const basePropDescriptor = Object.getOwnPropertyDescriptor(\r\n        baseProto,\r\n        propName,\r\n      );\r\n      // Handle Accessors\r\n      if (\r\n        basePropDescriptor &&\r\n        (basePropDescriptor.get || basePropDescriptor.set)\r\n      ) {\r\n        Object.defineProperty(\r\n          derivedCtor.prototype,\r\n          propName,\r\n          basePropDescriptor,\r\n        );\r\n      } else {\r\n        derivedCtor.prototype[propName] = baseCtor.prototype[propName];\r\n      }\r\n    });\r\n  });\r\n}\r\n", "import { clone, forEach, has, isEmpty, map, values } from \"lodash-es\";\r\nimport { toFastProperties } from \"@chevrotain/utils\";\r\nimport { computeAllProdsFollows } from \"../grammar/follow.js\";\r\nimport { createTokenInstance, EOF } from \"../../scan/tokens_public.js\";\r\nimport {\r\n  defaultGrammarValidatorErrorProvider,\r\n  defaultParserErrorProvider,\r\n} from \"../errors_public.js\";\r\nimport {\r\n  resolveGrammar,\r\n  validateGrammar,\r\n} from \"../grammar/gast/gast_resolver_public.js\";\r\nimport {\r\n  CstNode,\r\n  IParserConfig,\r\n  IRecognitionException,\r\n  IRuleConfig,\r\n  IToken,\r\n  TokenType,\r\n  TokenVocabulary,\r\n} from \"@chevrotain/types\";\r\nimport { Recoverable } from \"./traits/recoverable.js\";\r\nimport { LooksAhead } from \"./traits/looksahead.js\";\r\nimport { TreeBuilder } from \"./traits/tree_builder.js\";\r\nimport { LexerAdapter } from \"./traits/lexer_adapter.js\";\r\nimport { RecognizerApi } from \"./traits/recognizer_api.js\";\r\nimport { RecognizerEngine } from \"./traits/recognizer_engine.js\";\r\n\r\nimport { ErrorHandler } from \"./traits/error_handler.js\";\r\nimport { MixedInParser } from \"./traits/parser_traits.js\";\r\nimport { ContentAssist } from \"./traits/context_assist.js\";\r\nimport { GastRecorder } from \"./traits/gast_recorder.js\";\r\nimport { PerformanceTracer } from \"./traits/perf_tracer.js\";\r\nimport { applyMixins } from \"./utils/apply_mixins.js\";\r\nimport { IParserDefinitionError } from \"../grammar/types.js\";\r\nimport { Rule } from \"@chevrotain/gast\";\r\nimport { IParserConfigInternal, ParserMethodInternal } from \"./types.js\";\r\nimport { validateLookahead } from \"../grammar/checks.js\";\r\n\r\nexport const END_OF_FILE = createTokenInstance(\r\n  EOF,\r\n  \"\",\r\n  NaN,\r\n  NaN,\r\n  NaN,\r\n  NaN,\r\n  NaN,\r\n  NaN,\r\n);\r\nObject.freeze(END_OF_FILE);\r\n\r\nexport type TokenMatcher = (token: IToken, tokType: TokenType) => boolean;\r\n\r\nexport const DEFAULT_PARSER_CONFIG: Required<\r\n  Omit<IParserConfigInternal, \"lookaheadStrategy\">\r\n> = Object.freeze({\r\n  recoveryEnabled: false,\r\n  maxLookahead: 3,\r\n  dynamicTokensEnabled: false,\r\n  outputCst: true,\r\n  errorMessageProvider: defaultParserErrorProvider,\r\n  nodeLocationTracking: \"none\",\r\n  traceInitPerf: false,\r\n  skipValidations: false,\r\n});\r\n\r\nexport const DEFAULT_RULE_CONFIG: Required<IRuleConfig<any>> = Object.freeze({\r\n  recoveryValueFunc: () => undefined,\r\n  resyncEnabled: true,\r\n});\r\n\r\nexport enum ParserDefinitionErrorType {\r\n  INVALID_RULE_NAME = 0,\r\n  DUPLICATE_RULE_NAME = 1,\r\n  INVALID_RULE_OVERRIDE = 2,\r\n  DUPLICATE_PRODUCTIONS = 3,\r\n  UNRESOLVED_SUBRULE_REF = 4,\r\n  LEFT_RECURSION = 5,\r\n  NONE_LAST_EMPTY_ALT = 6,\r\n  AMBIGUOUS_ALTS = 7,\r\n  CONFLICT_TOKENS_RULES_NAMESPACE = 8,\r\n  INVALID_TOKEN_NAME = 9,\r\n  NO_NON_EMPTY_LOOKAHEAD = 10,\r\n  AMBIGUOUS_PREFIX_ALTS = 11,\r\n  TOO_MANY_ALTS = 12,\r\n  CUSTOM_LOOKAHEAD_VALIDATION = 13,\r\n}\r\n\r\nexport interface IParserDuplicatesDefinitionError\r\n  extends IParserDefinitionError {\r\n  dslName: string;\r\n  occurrence: number;\r\n  parameter?: string;\r\n}\r\n\r\nexport interface IParserEmptyAlternativeDefinitionError\r\n  extends IParserDefinitionError {\r\n  occurrence: number;\r\n  alternative: number;\r\n}\r\n\r\nexport interface IParserAmbiguousAlternativesDefinitionError\r\n  extends IParserDefinitionError {\r\n  occurrence: number | string;\r\n  alternatives: number[];\r\n}\r\n\r\nexport interface IParserUnresolvedRefDefinitionError\r\n  extends IParserDefinitionError {\r\n  unresolvedRefName: string;\r\n}\r\n\r\nexport interface IParserState {\r\n  errors: IRecognitionException[];\r\n  lexerState: any;\r\n  RULE_STACK: number[];\r\n  CST_STACK: CstNode[];\r\n}\r\n\r\nexport type Predicate = () => boolean;\r\n\r\nexport function EMPTY_ALT(): () => undefined;\r\nexport function EMPTY_ALT<T>(value: T): () => T;\r\nexport function EMPTY_ALT(value: any = undefined) {\r\n  return function () {\r\n    return value;\r\n  };\r\n}\r\n\r\nexport class Parser {\r\n  // Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.\r\n  // (normally during the parser's constructor).\r\n  // This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,\r\n  // for example: duplicate rule names, referencing an unresolved subrule, ect...\r\n  // This flag should not be enabled during normal usage, it is used in special situations, for example when\r\n  // needing to display the parser definition errors in some GUI(online playground).\r\n  static DEFER_DEFINITION_ERRORS_HANDLING: boolean = false;\r\n\r\n  /**\r\n   *  @deprecated use the **instance** method with the same name instead\r\n   */\r\n  static performSelfAnalysis(parserInstance: Parser): void {\r\n    throw Error(\r\n      \"The **static** `performSelfAnalysis` method has been deprecated.\" +\r\n        \"\\t\\nUse the **instance** method with the same name instead.\",\r\n    );\r\n  }\r\n\r\n  public performSelfAnalysis(this: MixedInParser): void {\r\n    this.TRACE_INIT(\"performSelfAnalysis\", () => {\r\n      let defErrorsMsgs;\r\n\r\n      this.selfAnalysisDone = true;\r\n      const className = this.className;\r\n\r\n      this.TRACE_INIT(\"toFastProps\", () => {\r\n        // Without this voodoo magic the parser would be x3-x4 slower\r\n        // It seems it is better to invoke `toFastProperties` **before**\r\n        // Any manipulations of the `this` object done during the recording phase.\r\n        toFastProperties(this);\r\n      });\r\n\r\n      this.TRACE_INIT(\"Grammar Recording\", () => {\r\n        try {\r\n          this.enableRecording();\r\n          // Building the GAST\r\n          forEach(this.definedRulesNames, (currRuleName) => {\r\n            const wrappedRule = (this as any)[\r\n              currRuleName\r\n            ] as ParserMethodInternal<unknown[], unknown>;\r\n            const originalGrammarAction = wrappedRule[\"originalGrammarAction\"];\r\n            let recordedRuleGast!: Rule;\r\n            this.TRACE_INIT(`${currRuleName} Rule`, () => {\r\n              recordedRuleGast = this.topLevelRuleRecord(\r\n                currRuleName,\r\n                originalGrammarAction,\r\n              );\r\n            });\r\n            this.gastProductionsCache[currRuleName] = recordedRuleGast;\r\n          });\r\n        } finally {\r\n          this.disableRecording();\r\n        }\r\n      });\r\n\r\n      let resolverErrors: IParserDefinitionError[] = [];\r\n      this.TRACE_INIT(\"Grammar Resolving\", () => {\r\n        resolverErrors = resolveGrammar({\r\n          rules: values(this.gastProductionsCache),\r\n        });\r\n        this.definitionErrors = this.definitionErrors.concat(resolverErrors);\r\n      });\r\n\r\n      this.TRACE_INIT(\"Grammar Validations\", () => {\r\n        // only perform additional grammar validations IFF no resolving errors have occurred.\r\n        // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.\r\n        if (isEmpty(resolverErrors) && this.skipValidations === false) {\r\n          const validationErrors = validateGrammar({\r\n            rules: values(this.gastProductionsCache),\r\n            tokenTypes: values(this.tokensMap),\r\n            errMsgProvider: defaultGrammarValidatorErrorProvider,\r\n            grammarName: className,\r\n          });\r\n          const lookaheadValidationErrors = validateLookahead({\r\n            lookaheadStrategy: this.lookaheadStrategy,\r\n            rules: values(this.gastProductionsCache),\r\n            tokenTypes: values(this.tokensMap),\r\n            grammarName: className,\r\n          });\r\n          this.definitionErrors = this.definitionErrors.concat(\r\n            validationErrors,\r\n            lookaheadValidationErrors,\r\n          );\r\n        }\r\n      });\r\n\r\n      // this analysis may fail if the grammar is not perfectly valid\r\n      if (isEmpty(this.definitionErrors)) {\r\n        // The results of these computations are not needed unless error recovery is enabled.\r\n        if (this.recoveryEnabled) {\r\n          this.TRACE_INIT(\"computeAllProdsFollows\", () => {\r\n            const allFollows = computeAllProdsFollows(\r\n              values(this.gastProductionsCache),\r\n            );\r\n            this.resyncFollows = allFollows;\r\n          });\r\n        }\r\n\r\n        this.TRACE_INIT(\"ComputeLookaheadFunctions\", () => {\r\n          this.lookaheadStrategy.initialize?.({\r\n            rules: values(this.gastProductionsCache),\r\n          });\r\n          this.preComputeLookaheadFunctions(values(this.gastProductionsCache));\r\n        });\r\n      }\r\n\r\n      if (\r\n        !Parser.DEFER_DEFINITION_ERRORS_HANDLING &&\r\n        !isEmpty(this.definitionErrors)\r\n      ) {\r\n        defErrorsMsgs = map(\r\n          this.definitionErrors,\r\n          (defError) => defError.message,\r\n        );\r\n        throw new Error(\r\n          `Parser Definition Errors detected:\\n ${defErrorsMsgs.join(\r\n            \"\\n-------------------------------\\n\",\r\n          )}`,\r\n        );\r\n      }\r\n    });\r\n  }\r\n\r\n  definitionErrors: IParserDefinitionError[] = [];\r\n  selfAnalysisDone = false;\r\n  protected skipValidations: boolean;\r\n\r\n  constructor(tokenVocabulary: TokenVocabulary, config: IParserConfig) {\r\n    const that: MixedInParser = this as any;\r\n    that.initErrorHandler(config);\r\n    that.initLexerAdapter();\r\n    that.initLooksAhead(config);\r\n    that.initRecognizerEngine(tokenVocabulary, config);\r\n    that.initRecoverable(config);\r\n    that.initTreeBuilder(config);\r\n    that.initContentAssist();\r\n    that.initGastRecorder(config);\r\n    that.initPerformanceTracer(config);\r\n\r\n    if (has(config, \"ignoredIssues\")) {\r\n      throw new Error(\r\n        \"The <ignoredIssues> IParserConfig property has been deprecated.\\n\\t\" +\r\n          \"Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\\n\\t\" +\r\n          \"See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\\n\\t\" +\r\n          \"For further details.\",\r\n      );\r\n    }\r\n\r\n    this.skipValidations = has(config, \"skipValidations\")\r\n      ? (config.skipValidations as boolean) // casting assumes the end user passing the correct type\r\n      : DEFAULT_PARSER_CONFIG.skipValidations;\r\n  }\r\n}\r\n\r\napplyMixins(Parser, [\r\n  Recoverable,\r\n  LooksAhead,\r\n  TreeBuilder,\r\n  LexerAdapter,\r\n  RecognizerEngine,\r\n  RecognizerApi,\r\n  ErrorHandler,\r\n  ContentAssist,\r\n  GastRecorder,\r\n  PerformanceTracer,\r\n]);\r\n\r\nexport class CstParser extends Parser {\r\n  constructor(\r\n    tokenVocabulary: TokenVocabulary,\r\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG,\r\n  ) {\r\n    const configClone = clone(config);\r\n    configClone.outputCst = true;\r\n    super(tokenVocabulary, configClone);\r\n  }\r\n}\r\n\r\nexport class EmbeddedActionsParser extends Parser {\r\n  constructor(\r\n    tokenVocabulary: TokenVocabulary,\r\n    config: IParserConfigInternal = DEFAULT_PARSER_CONFIG,\r\n  ) {\r\n    const configClone = clone(config);\r\n    configClone.outputCst = false;\r\n    super(tokenVocabulary, configClone);\r\n  }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport map from \"lodash-es/map.js\"\r\nimport filter from \"lodash-es/filter.js\"\r\nimport {\r\n    IProduction,\r\n    IProductionWithOccurrence,\r\n    TokenType,\r\n    Alternation,\r\n    NonTerminal,\r\n    Rule,\r\n    Option,\r\n    RepetitionMandatory,\r\n    Repetition,\r\n    Terminal,\r\n    Alternative,\r\n    RepetitionWithSeparator,\r\n    RepetitionMandatoryWithSeparator,\r\n    LookaheadProductionType\r\n} from \"chevrotain\"\r\n\r\nexport function buildATNKey(rule: Rule, type: LookaheadProductionType, occurrence: number): string {\r\n    return `${rule.name}_${type}_${occurrence}`;\r\n}\r\n\r\nexport interface ATN {\r\n    decisionMap: Record<string, DecisionState>\r\n    states: ATNState[]\r\n    decisionStates: DecisionState[]\r\n    ruleToStartState: Map<Rule, RuleStartState>\r\n    ruleToStopState: Map<Rule, RuleStopState>\r\n}\r\n\r\nexport const ATN_INVALID_TYPE = 0\r\nexport const ATN_BASIC = 1\r\nexport const ATN_RULE_START = 2\r\nexport const ATN_PLUS_BLOCK_START = 4\r\nexport const ATN_STAR_BLOCK_START = 5\r\n// Currently unused as the ATN is not used for lexing\r\nexport const ATN_TOKEN_START = 6\r\nexport const ATN_RULE_STOP = 7\r\nexport const ATN_BLOCK_END = 8\r\nexport const ATN_STAR_LOOP_BACK = 9\r\nexport const ATN_STAR_LOOP_ENTRY = 10\r\nexport const ATN_PLUS_LOOP_BACK = 11\r\nexport const ATN_LOOP_END = 12\r\n\r\nexport type ATNState =\r\n    | BasicState\r\n    | BasicBlockStartState\r\n    | PlusBlockStartState\r\n    | PlusLoopbackState\r\n    | StarBlockStartState\r\n    | StarLoopbackState\r\n    | StarLoopEntryState\r\n    | BlockEndState\r\n    | RuleStartState\r\n    | RuleStopState\r\n    | LoopEndState\r\n\r\nexport interface ATNBaseState {\r\n    atn: ATN\r\n    production: IProductionWithOccurrence\r\n    stateNumber: number\r\n    rule: Rule\r\n    epsilonOnlyTransitions: boolean\r\n    transitions: Transition[]\r\n    nextTokenWithinRule: number[]\r\n}\r\n\r\nexport interface BasicState extends ATNBaseState {\r\n    type: typeof ATN_BASIC\r\n}\r\n\r\nexport interface BlockStartState extends DecisionState {\r\n    end: BlockEndState\r\n}\r\n\r\nexport interface BasicBlockStartState extends BlockStartState {\r\n    type: typeof ATN_BASIC\r\n}\r\n\r\nexport interface PlusBlockStartState extends BlockStartState {\r\n    loopback: PlusLoopbackState\r\n    type: typeof ATN_PLUS_BLOCK_START\r\n}\r\n\r\nexport interface PlusLoopbackState extends DecisionState {\r\n    type: typeof ATN_PLUS_LOOP_BACK\r\n}\r\n\r\nexport interface StarBlockStartState extends BlockStartState {\r\n    type: typeof ATN_STAR_BLOCK_START\r\n}\r\n\r\nexport interface StarLoopbackState extends ATNBaseState {\r\n    type: typeof ATN_STAR_LOOP_BACK\r\n}\r\n\r\nexport interface StarLoopEntryState extends DecisionState {\r\n    loopback: StarLoopbackState\r\n    type: typeof ATN_STAR_LOOP_ENTRY\r\n}\r\n\r\nexport interface BlockEndState extends ATNBaseState {\r\n    start: BlockStartState\r\n    type: typeof ATN_BLOCK_END\r\n}\r\n\r\nexport interface DecisionState extends ATNBaseState {\r\n    decision: number\r\n}\r\n\r\nexport interface LoopEndState extends ATNBaseState {\r\n    loopback: ATNState\r\n    type: typeof ATN_LOOP_END\r\n}\r\n\r\nexport interface RuleStartState extends ATNBaseState {\r\n    stop: RuleStopState\r\n    type: typeof ATN_RULE_START\r\n}\r\n\r\nexport interface RuleStopState extends ATNBaseState {\r\n    type: typeof ATN_RULE_STOP\r\n}\r\n\r\nexport interface Transition {\r\n    target: ATNState\r\n    isEpsilon(): boolean\r\n}\r\n\r\nexport abstract class AbstractTransition implements Transition {\r\n    target: ATNState\r\n\r\n    constructor(target: ATNState) {\r\n        this.target = target\r\n    }\r\n\r\n    isEpsilon() {\r\n        return false\r\n    }\r\n}\r\n\r\nexport class AtomTransition extends AbstractTransition {\r\n    tokenType: TokenType\r\n\r\n    constructor(target: ATNState, tokenType: TokenType) {\r\n        super(target)\r\n        this.tokenType = tokenType\r\n    }\r\n}\r\n\r\nexport class EpsilonTransition extends AbstractTransition {\r\n    constructor(target: ATNState) {\r\n        super(target)\r\n    }\r\n\r\n    isEpsilon() {\r\n        return true\r\n    }\r\n}\r\n\r\nexport class RuleTransition extends AbstractTransition {\r\n    rule: Rule\r\n    followState: ATNState\r\n\r\n    constructor(ruleStart: RuleStartState, rule: Rule, followState: ATNState) {\r\n        super(ruleStart)\r\n        this.rule = rule\r\n        this.followState = followState\r\n    }\r\n\r\n    isEpsilon() {\r\n        return true\r\n    }\r\n}\r\n\r\ninterface ATNHandle {\r\n    left: ATNState\r\n    right: ATNState\r\n}\r\n\r\nexport function createATN(rules: Rule[]): ATN {\r\n    const atn: ATN = {\r\n        decisionMap: {},\r\n        decisionStates: [],\r\n        ruleToStartState: new Map(),\r\n        ruleToStopState: new Map(),\r\n        states: []\r\n    }\r\n    createRuleStartAndStopATNStates(atn, rules)\r\n    const ruleLength = rules.length\r\n    for (let i = 0; i < ruleLength; i++) {\r\n        const rule = rules[i]\r\n        const ruleBlock = block(atn, rule, rule)\r\n        if (ruleBlock === undefined) {\r\n            continue\r\n        }\r\n        buildRuleHandle(atn, rule, ruleBlock)\r\n    }\r\n    return atn\r\n}\r\n\r\nfunction createRuleStartAndStopATNStates(atn: ATN, rules: Rule[]): void {\r\n    const ruleLength = rules.length\r\n    for (let i = 0; i < ruleLength; i++) {\r\n        const rule = rules[i]\r\n        const start = newState<RuleStartState>(atn, rule, undefined, {\r\n            type: ATN_RULE_START\r\n        })\r\n        const stop = newState<RuleStopState>(atn, rule, undefined, {\r\n            type: ATN_RULE_STOP\r\n        })\r\n        start.stop = stop\r\n        atn.ruleToStartState.set(rule, start)\r\n        atn.ruleToStopState.set(rule, stop)\r\n    }\r\n}\r\n\r\nfunction atom(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    production: IProduction\r\n): ATNHandle | undefined {\r\n    if (production instanceof Terminal) {\r\n        return tokenRef(atn, rule, production.terminalType, production)\r\n    } else if (production instanceof NonTerminal) {\r\n        return ruleRef(atn, rule, production)\r\n    } else if (production instanceof Alternation) {\r\n        return alternation(atn, rule, production)\r\n    } else if (production instanceof Option) {\r\n        return option(atn, rule, production)\r\n    } else if (production instanceof Repetition) {\r\n        return repetition(atn, rule, production)\r\n    } else if (production instanceof RepetitionWithSeparator) {\r\n        return repetitionSep(atn, rule, production)\r\n    } else if (production instanceof RepetitionMandatory) {\r\n        return repetitionMandatory(atn, rule, production)\r\n    } else if (production instanceof RepetitionMandatoryWithSeparator) {\r\n        return repetitionMandatorySep(atn, rule, production)\r\n    } else {\r\n        return block(atn, rule, production as Alternative)\r\n    }\r\n}\r\n\r\nfunction repetition(atn: ATN, rule: Rule, repetition: Repetition): ATNHandle {\r\n    const starState = newState<StarBlockStartState>(atn, rule, repetition, {\r\n        type: ATN_STAR_BLOCK_START\r\n    })\r\n    defineDecisionState(atn, starState)\r\n    const handle = makeAlts(\r\n        atn,\r\n        rule,\r\n        starState,\r\n        repetition,\r\n        block(atn, rule, repetition)\r\n    )\r\n    return star(atn, rule, repetition, handle)\r\n}\r\n\r\nfunction repetitionSep(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    repetition: RepetitionWithSeparator\r\n): ATNHandle {\r\n    const starState = newState<StarBlockStartState>(atn, rule, repetition, {\r\n        type: ATN_STAR_BLOCK_START\r\n    })\r\n    defineDecisionState(atn, starState)\r\n    const handle = makeAlts(\r\n        atn,\r\n        rule,\r\n        starState,\r\n        repetition,\r\n        block(atn, rule, repetition)\r\n    )\r\n    const sep = tokenRef(atn, rule, repetition.separator, repetition)\r\n    return star(atn, rule, repetition, handle, sep)\r\n}\r\n\r\nfunction repetitionMandatory(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    repetition: RepetitionMandatory\r\n): ATNHandle {\r\n    const plusState = newState<PlusBlockStartState>(atn, rule, repetition, {\r\n        type: ATN_PLUS_BLOCK_START\r\n    })\r\n    defineDecisionState(atn, plusState)\r\n    const handle = makeAlts(\r\n        atn,\r\n        rule,\r\n        plusState,\r\n        repetition,\r\n        block(atn, rule, repetition)\r\n    )\r\n    return plus(atn, rule, repetition, handle)\r\n}\r\n\r\nfunction repetitionMandatorySep(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    repetition: RepetitionMandatoryWithSeparator\r\n): ATNHandle {\r\n    const plusState = newState<PlusBlockStartState>(atn, rule, repetition, {\r\n        type: ATN_PLUS_BLOCK_START\r\n    })\r\n    defineDecisionState(atn, plusState)\r\n    const handle = makeAlts(\r\n        atn,\r\n        rule,\r\n        plusState,\r\n        repetition,\r\n        block(atn, rule, repetition)\r\n    )\r\n    const sep = tokenRef(atn, rule, repetition.separator, repetition)\r\n    return plus(atn, rule, repetition, handle, sep)\r\n}\r\n\r\nfunction alternation(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    alternation: Alternation\r\n): ATNHandle {\r\n    const start = newState<BasicBlockStartState>(atn, rule, alternation, {\r\n        type: ATN_BASIC\r\n    })\r\n    defineDecisionState(atn, start)\r\n    const alts = map(alternation.definition, (e) => atom(atn, rule, e))\r\n    const handle = makeAlts(atn, rule, start, alternation, ...alts)\r\n    return handle\r\n}\r\n\r\nfunction option(atn: ATN, rule: Rule, option: Option): ATNHandle {\r\n    const start = newState<BasicBlockStartState>(atn, rule, option, {\r\n        type: ATN_BASIC\r\n    })\r\n    defineDecisionState(atn, start)\r\n    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option))\r\n    return optional(atn, rule, option, handle)\r\n}\r\n\r\nfunction block(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    block: { definition: IProduction[] }\r\n): ATNHandle | undefined {\r\n    const handles = filter(\r\n        map(block.definition, (e) => atom(atn, rule, e)),\r\n        (e) => e !== undefined\r\n    ) as ATNHandle[]\r\n    if (handles.length === 1) {\r\n        return handles[0]\r\n    } else if (handles.length === 0) {\r\n        return undefined\r\n    } else {\r\n        return makeBlock(atn, handles)\r\n    }\r\n}\r\n\r\nfunction plus(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    plus: IProductionWithOccurrence,\r\n    handle: ATNHandle,\r\n    sep?: ATNHandle\r\n): ATNHandle {\r\n    const blkStart = handle.left as PlusBlockStartState\r\n    const blkEnd = handle.right\r\n\r\n    const loop = newState<PlusLoopbackState>(atn, rule, plus, {\r\n        type: ATN_PLUS_LOOP_BACK\r\n    })\r\n    defineDecisionState(atn, loop)\r\n    const end = newState<LoopEndState>(atn, rule, plus, {\r\n        type: ATN_LOOP_END\r\n    })\r\n    blkStart.loopback = loop\r\n    end.loopback = loop\r\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;\r\n    epsilon(blkEnd, loop) // block can see loop back\r\n\r\n    // Depending on whether we have a separator we put the exit transition at index 1 or 0\r\n    // This influences the chosen option in the lookahead DFA\r\n    if (sep === undefined) {\r\n        epsilon(loop, blkStart) // loop back to start\r\n        epsilon(loop, end) // exit\r\n    } else {\r\n        epsilon(loop, end) // exit\r\n        // loop back to start with separator\r\n        epsilon(loop, sep.left)\r\n        epsilon(sep.right, blkStart)\r\n    }\r\n\r\n    return {\r\n        left: blkStart,\r\n        right: end\r\n    }\r\n}\r\n\r\nfunction star(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    star: IProductionWithOccurrence,\r\n    handle: ATNHandle,\r\n    sep?: ATNHandle\r\n): ATNHandle {\r\n    const start = handle.left\r\n    const end = handle.right\r\n\r\n    const entry = newState<StarLoopEntryState>(atn, rule, star, {\r\n        type: ATN_STAR_LOOP_ENTRY\r\n    })\r\n    defineDecisionState(atn, entry)\r\n    const loopEnd = newState<LoopEndState>(atn, rule, star, {\r\n        type: ATN_LOOP_END\r\n    })\r\n    const loop = newState<StarLoopbackState>(atn, rule, star, {\r\n        type: ATN_STAR_LOOP_BACK\r\n    })\r\n    entry.loopback = loop\r\n    loopEnd.loopback = loop\r\n\r\n    epsilon(entry, start) // loop enter edge (alt 2)\r\n    epsilon(entry, loopEnd) // bypass loop edge (alt 1)\r\n    epsilon(end, loop) // block end hits loop back\r\n\r\n    if (sep !== undefined) {\r\n        epsilon(loop, loopEnd) // end loop\r\n        // loop back to start of handle using separator\r\n        epsilon(loop, sep.left)\r\n        epsilon(sep.right, start)\r\n    } else {\r\n        epsilon(loop, entry) // loop back to entry/exit decision\r\n    }\r\n\r\n    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;\r\n    return {\r\n        left: entry,\r\n        right: loopEnd\r\n    }\r\n}\r\n\r\nfunction optional(atn: ATN, rule: Rule, optional: Option, handle: ATNHandle): ATNHandle {\r\n    const start = handle.left as DecisionState\r\n    const end = handle.right\r\n\r\n    epsilon(start, end)\r\n\r\n    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;\r\n    return handle\r\n}\r\n\r\nfunction defineDecisionState(atn: ATN, state: DecisionState): number {\r\n    atn.decisionStates.push(state)\r\n    state.decision = atn.decisionStates.length - 1\r\n    return state.decision\r\n}\r\n\r\nfunction makeAlts(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    start: BlockStartState,\r\n    production: IProductionWithOccurrence,\r\n    ...alts: (ATNHandle | undefined)[]\r\n): ATNHandle {\r\n    const end = newState<BlockEndState>(atn, rule, production, {\r\n        type: ATN_BLOCK_END,\r\n        start\r\n    })\r\n    start.end = end\r\n    for (const alt of alts) {\r\n        if (alt !== undefined) {\r\n            // hook alts up to decision block\r\n            epsilon(start, alt.left)\r\n            epsilon(alt.right, end)\r\n        } else {\r\n            epsilon(start, end)\r\n        }\r\n    }\r\n\r\n    const handle: ATNHandle = {\r\n        left: start as ATNState,\r\n        right: end\r\n    }\r\n    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start\r\n    return handle\r\n}\r\n\r\nfunction getProdType(production: IProduction): LookaheadProductionType {\r\n    if (production instanceof Alternation) {\r\n        return 'Alternation';\r\n    } else if (production instanceof Option) {\r\n        return 'Option';\r\n    } else if (production instanceof Repetition) {\r\n        return 'Repetition';\r\n    } else if (production instanceof RepetitionWithSeparator) {\r\n        return 'RepetitionWithSeparator';\r\n    } else if (production instanceof RepetitionMandatory) {\r\n        return 'RepetitionMandatory';\r\n    } else if (production instanceof RepetitionMandatoryWithSeparator) {\r\n        return 'RepetitionMandatoryWithSeparator';\r\n    } else {\r\n        throw new Error('Invalid production type encountered');\r\n    }\r\n}\r\n\r\nfunction makeBlock(atn: ATN, alts: ATNHandle[]): ATNHandle {\r\n    const altsLength = alts.length\r\n    for (let i = 0; i < altsLength - 1; i++) {\r\n        const handle = alts[i]\r\n        let transition: Transition | undefined\r\n        if (handle.left.transitions.length === 1) {\r\n            transition = handle.left.transitions[0]\r\n        }\r\n        const isRuleTransition = transition instanceof RuleTransition\r\n        const ruleTransition = transition as RuleTransition\r\n        const next = alts[i + 1].left\r\n        if (\r\n            handle.left.type === ATN_BASIC &&\r\n            handle.right.type === ATN_BASIC &&\r\n            transition !== undefined &&\r\n            ((isRuleTransition && ruleTransition.followState === handle.right) ||\r\n                transition.target === handle.right)\r\n        ) {\r\n            // we can avoid epsilon edge to next element\r\n            if (isRuleTransition) {\r\n                ruleTransition.followState = next\r\n            } else {\r\n                transition.target = next\r\n            }\r\n            removeState(atn, handle.right) // we skipped over this state\r\n        } else {\r\n            // need epsilon if previous block's right end node is complex\r\n            epsilon(handle.right, next)\r\n        }\r\n    }\r\n\r\n    const first = alts[0]\r\n    const last = alts[altsLength - 1]\r\n    return {\r\n        left: first.left,\r\n        right: last.right\r\n    }\r\n}\r\n\r\nfunction tokenRef(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    tokenType: TokenType,\r\n    production: IProductionWithOccurrence\r\n): ATNHandle {\r\n    const left = newState<BasicState>(atn, rule, production, {\r\n        type: ATN_BASIC\r\n    })\r\n    const right = newState<BasicState>(atn, rule, production, {\r\n        type: ATN_BASIC\r\n    })\r\n    addTransition(left, new AtomTransition(right, tokenType))\r\n    return {\r\n        left,\r\n        right\r\n    }\r\n}\r\n\r\nfunction ruleRef(\r\n    atn: ATN,\r\n    currentRule: Rule,\r\n    nonTerminal: NonTerminal\r\n): ATNHandle {\r\n    const rule = nonTerminal.referencedRule\r\n    const start = atn.ruleToStartState.get(rule)!\r\n    const left = newState<BasicBlockStartState>(atn, currentRule, nonTerminal, {\r\n        type: ATN_BASIC\r\n    })\r\n    const right = newState<BasicBlockStartState>(atn, currentRule, nonTerminal, {\r\n        type: ATN_BASIC\r\n    })\r\n\r\n    const call = new RuleTransition(start, rule, right)\r\n    addTransition(left, call)\r\n\r\n    return {\r\n        left,\r\n        right\r\n    }\r\n}\r\n\r\nfunction buildRuleHandle(atn: ATN, rule: Rule, block: ATNHandle): ATNHandle {\r\n    const start = atn.ruleToStartState.get(rule)!\r\n    epsilon(start, block.left)\r\n    const stop = atn.ruleToStopState.get(rule)!\r\n    epsilon(block.right, stop)\r\n    const handle: ATNHandle = {\r\n        left: start,\r\n        right: stop\r\n    }\r\n    return handle\r\n}\r\n\r\nfunction epsilon(a: ATNBaseState, b: ATNBaseState): void {\r\n    const transition = new EpsilonTransition(b as ATNState)\r\n    addTransition(a, transition)\r\n}\r\n\r\nfunction newState<T extends ATNState>(\r\n    atn: ATN,\r\n    rule: Rule,\r\n    production: IProductionWithOccurrence | undefined,\r\n    partial: Partial<T>\r\n): T {\r\n    const t: T = {\r\n        atn,\r\n        production,\r\n        epsilonOnlyTransitions: false,\r\n        rule,\r\n        transitions: [],\r\n        nextTokenWithinRule: [],\r\n        stateNumber: atn.states.length,\r\n        ...partial\r\n    } as unknown as T\r\n    atn.states.push(t)\r\n    return t\r\n}\r\n\r\nfunction addTransition(state: ATNBaseState, transition: Transition) {\r\n    // A single ATN state can only contain epsilon transitions or non-epsilon transitions\r\n    // Because they are never mixed, only setting the property for the first transition is fine\r\n    if (state.transitions.length === 0) {\r\n        state.epsilonOnlyTransitions = transition.isEpsilon()\r\n    }\r\n    state.transitions.push(transition)\r\n}\r\n\r\nfunction removeState(atn: ATN, state: ATNState): void {\r\n    atn.states.splice(atn.states.indexOf(state), 1)\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport map from \"lodash-es/map.js\"\r\nimport { ATNState, DecisionState } from \"./atn.js\"\r\n\r\nexport interface DFA {\r\n  start?: DFAState\r\n  states: Record<string, DFAState>\r\n  decision: number\r\n  atnStartState: DecisionState\r\n}\r\n\r\nexport interface DFAState {\r\n  configs: ATNConfigSet\r\n  edges: Record<number, DFAState>\r\n  isAcceptState: boolean\r\n  prediction: number\r\n}\r\n\r\nexport const DFA_ERROR = {} as DFAState\r\n\r\nexport interface ATNConfig {\r\n  state: ATNState\r\n  alt: number\r\n  stack: ATNState[]\r\n}\r\n\r\nexport class ATNConfigSet {\r\n  private map: Record<string, number> = {}\r\n  private configs: ATNConfig[] = []\r\n\r\n  uniqueAlt: number | undefined\r\n\r\n  get size(): number {\r\n    return this.configs.length\r\n  }\r\n\r\n  finalize(): void {\r\n    // Empties the map to free up memory\r\n    this.map = {}\r\n  }\r\n\r\n  add(config: ATNConfig): void {\r\n    const key = getATNConfigKey(config)\r\n    // Only add configs which don't exist in our map already\r\n    // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption\r\n    if (!(key in this.map)) {\r\n      this.map[key] = this.configs.length\r\n      this.configs.push(config)\r\n    }\r\n  }\r\n\r\n  get elements(): readonly ATNConfig[] {\r\n    return this.configs\r\n  }\r\n\r\n  get alts(): number[] {\r\n    return map(this.configs, (e) => e.alt)\r\n  }\r\n\r\n  get key(): string {\r\n    let value = \"\"\r\n    for (const k in this.map) {\r\n      value += k + \":\"\r\n    }\r\n    return value\r\n  }\r\n}\r\n\r\nexport function getATNConfigKey(config: ATNConfig, alt = true) {\r\n  return `${alt ? `a${config.alt}` : \"\"}s${\r\n    config.state.stateNumber\r\n  }:${config.stack.map((e) => e.stateNumber.toString()).join(\"_\")}`\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport {\r\n    IToken,\r\n    TokenType,\r\n    tokenMatcher,\r\n    tokenLabel,\r\n    Rule,\r\n    IProductionWithOccurrence,\r\n    NonTerminal,\r\n    Alternation,\r\n    Option,\r\n    RepetitionMandatory,\r\n    RepetitionMandatoryWithSeparator,\r\n    RepetitionWithSeparator,\r\n    Repetition,\r\n    Terminal,\r\n    BaseParser,\r\n    LLkLookaheadStrategy,\r\n    ILookaheadValidationError,\r\n    IOrAlt,\r\n    getLookaheadPaths,\r\n    OptionalProductionType\r\n} from \"chevrotain\";\r\nimport {\r\n    ATN,\r\n    ATNState,\r\n    ATN_RULE_STOP,\r\n    AtomTransition,\r\n    buildATNKey,\r\n    createATN,\r\n    DecisionState,\r\n    EpsilonTransition,\r\n    RuleTransition,\r\n    Transition\r\n} from \"./atn.js\";\r\nimport {\r\n    ATNConfig,\r\n    ATNConfigSet,\r\n    DFA,\r\n    DFAState,\r\n    DFA_ERROR,\r\n    getATNConfigKey\r\n} from \"./dfa.js\";\r\nimport min from \"lodash-es/min.js\";\r\nimport flatMap from \"lodash-es/flatMap.js\";\r\nimport uniqBy from \"lodash-es/uniqBy.js\";\r\nimport map from \"lodash-es/map.js\";\r\nimport flatten from \"lodash-es/flatten.js\";\r\nimport forEach from \"lodash-es/forEach.js\";\r\nimport isEmpty from \"lodash-es/isEmpty.js\";\r\nimport reduce from \"lodash-es/reduce.js\";\r\n\r\ntype DFACache = (predicateSet: PredicateSet) => DFA\r\n\r\nexport type AmbiguityReport = (message: string) => void;\r\n\r\nfunction createDFACache(startState: DecisionState, decision: number): DFACache {\r\n    const map: Record<string, DFA | undefined> = {}\r\n    return (predicateSet) => {\r\n        const key = predicateSet.toString()\r\n        let existing = map[key]\r\n        if (existing !== undefined) {\r\n            return existing\r\n        } else {\r\n            existing = {\r\n                atnStartState: startState,\r\n                decision,\r\n                states: {}\r\n            }\r\n            map[key] = existing\r\n            return existing\r\n        }\r\n    }\r\n}\r\n\r\nclass PredicateSet {\r\n    private predicates: boolean[] = []\r\n\r\n    is(index: number): boolean {\r\n        return index >= this.predicates.length || this.predicates[index]\r\n    }\r\n\r\n    set(index: number, value: boolean) {\r\n        this.predicates[index] = value\r\n    }\r\n\r\n    toString(): string {\r\n        let value = \"\"\r\n        const size = this.predicates.length\r\n        for (let i = 0; i < size; i++) {\r\n            value += this.predicates[i] === true ? \"1\" : \"0\"\r\n        }\r\n        return value\r\n    }\r\n}\r\n\r\ninterface AdaptivePredictError {\r\n    tokenPath: IToken[]\r\n    possibleTokenTypes: TokenType[]\r\n    actualToken: IToken\r\n}\r\n\r\nconst EMPTY_PREDICATES = new PredicateSet()\r\n\r\nexport interface LLStarLookaheadOptions {\r\n    logging?: AmbiguityReport\r\n}\r\n\r\nexport class LLStarLookaheadStrategy extends LLkLookaheadStrategy {\r\n\r\n    private atn: ATN;\r\n    private dfas: DFACache[];\r\n    private logging: AmbiguityReport;\r\n\r\n    constructor(options?: LLStarLookaheadOptions) {\r\n        super();\r\n        this.logging = options?.logging ?? ((message) => console.log(message));\r\n    }\r\n\r\n    override initialize(options: { rules: Rule[] }): void {\r\n        this.atn = createATN(options.rules);\r\n        this.dfas = initATNSimulator(this.atn);\r\n    }\r\n\r\n    override validateAmbiguousAlternationAlternatives(): ILookaheadValidationError[] {\r\n        return [];\r\n    }\r\n\r\n    override validateEmptyOrAlternatives(): ILookaheadValidationError[] {\r\n        return [];\r\n    }\r\n\r\n    override buildLookaheadForAlternation(options: {\r\n        prodOccurrence: number;\r\n        rule: Rule;\r\n        maxLookahead: number;\r\n        hasPredicates: boolean;\r\n        dynamicTokensEnabled: boolean\r\n    }): (this: BaseParser, orAlts?: IOrAlt<any>[] | undefined) => number | undefined {\r\n        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;\r\n        const dfas = this.dfas;\r\n        const logging = this.logging;\r\n        const key = buildATNKey(rule, 'Alternation', prodOccurrence);\r\n        const decisionState = this.atn.decisionMap[key];\r\n        const decisionIndex = decisionState.decision;\r\n        const partialAlts: (TokenType | undefined)[][] = map(\r\n            getLookaheadPaths({\r\n                maxLookahead: 1,\r\n                occurrence: prodOccurrence,\r\n                prodType: \"Alternation\",\r\n                rule: rule\r\n            }),\r\n            (currAlt) => map(currAlt, (path) => path[0])\r\n        )\r\n\r\n        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {\r\n            const choiceToAlt = reduce(\r\n                partialAlts,\r\n                (result, currAlt, idx) => {\r\n                    forEach(currAlt, (currTokType) => {\r\n                        if (currTokType) {\r\n                            result[currTokType.tokenTypeIdx!] = idx\r\n                            forEach(currTokType.categoryMatches!, (currExtendingType) => {\r\n                                result[currExtendingType] = idx\r\n                            })\r\n                        }\r\n                    })\r\n                    return result\r\n                },\r\n                {} as Record<number, number>\r\n            )\r\n\r\n            if (hasPredicates) {\r\n                return function (this: BaseParser, orAlts) {\r\n                    const nextToken = this.LA(1)\r\n                    const prediction: number | undefined = choiceToAlt[nextToken.tokenTypeIdx]\r\n                    if (orAlts !== undefined && prediction !== undefined) {\r\n                        const gate = orAlts[prediction]?.GATE\r\n                        if (gate !== undefined && gate.call(this) === false) {\r\n                            return undefined;\r\n                        }\r\n                    }\r\n                    return prediction\r\n                }\r\n            } else {\r\n                return function (this: BaseParser): number | undefined {\r\n                    const nextToken = this.LA(1)\r\n                    return choiceToAlt[nextToken.tokenTypeIdx];\r\n                }\r\n            }\r\n        } else if (hasPredicates) {\r\n            return function (this: BaseParser, orAlts) {\r\n                const predicates = new PredicateSet()\r\n                const length = orAlts === undefined ? 0 : orAlts.length\r\n                for (let i = 0; i < length; i++) {\r\n                    const gate = orAlts?.[i].GATE\r\n                    predicates.set(i, gate === undefined || gate.call(this))\r\n                }\r\n                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);\r\n                return typeof result === 'number' ? result : undefined;\r\n            }\r\n        } else {\r\n            return function (this: BaseParser) {\r\n                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);\r\n                return typeof result === 'number' ? result : undefined;\r\n            }\r\n        }\r\n    }\r\n\r\n    override buildLookaheadForOptional(options: {\r\n        prodOccurrence: number;\r\n        prodType: OptionalProductionType;\r\n        rule: Rule;\r\n        maxLookahead: number;\r\n        dynamicTokensEnabled: boolean\r\n    }): (this: BaseParser) => boolean {\r\n        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;\r\n        const dfas = this.dfas;\r\n        const logging = this.logging;\r\n        const key = buildATNKey(rule, prodType, prodOccurrence);\r\n        const decisionState = this.atn.decisionMap[key];\r\n        const decisionIndex = decisionState.decision;\r\n        const alts = map(\r\n            getLookaheadPaths({\r\n                maxLookahead: 1,\r\n                occurrence: prodOccurrence,\r\n                prodType,\r\n                rule\r\n            }),\r\n            (e) => {\r\n              return map(e, (g) => g[0])\r\n            }\r\n          )\r\n        \r\n          if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {\r\n            const alt = alts[0]\r\n            const singleTokensTypes = flatten(alt)\r\n        \r\n            if (\r\n              singleTokensTypes.length === 1 &&\r\n              isEmpty(singleTokensTypes[0].categoryMatches)\r\n            ) {\r\n              const expectedTokenType = singleTokensTypes[0]\r\n              const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx\r\n        \r\n              return function (this: BaseParser): boolean {\r\n                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey\r\n              }\r\n            } else {\r\n              const choiceToAlt = reduce(\r\n                singleTokensTypes,\r\n                (result, currTokType) => {\r\n                  if (currTokType !== undefined) {\r\n                    result[currTokType.tokenTypeIdx!] = true\r\n                    forEach(currTokType.categoryMatches, (currExtendingType) => {\r\n                      result[currExtendingType] = true\r\n                    })\r\n                  }\r\n                  return result\r\n                },\r\n                {} as Record<number, boolean>\r\n              )\r\n        \r\n              return function (this: BaseParser): boolean {\r\n                const nextToken = this.LA(1)\r\n                return choiceToAlt[nextToken.tokenTypeIdx] === true\r\n              }\r\n            }\r\n          }\r\n          return function (this: BaseParser) {\r\n            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging)\r\n              return typeof result === \"object\" ? false : result === 0;\r\n          }\r\n    }\r\n\r\n}\r\n\r\nfunction isLL1Sequence(sequences: (TokenType | undefined)[][], allowEmpty = true): boolean {\r\n    const fullSet = new Set<number>()\r\n\r\n    for (const alt of sequences) {\r\n        const altSet = new Set<number>()\r\n        for (const tokType of alt) {\r\n            if (tokType === undefined) {\r\n                if (allowEmpty) {\r\n                    // Epsilon production encountered\r\n                    break\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n            const indices = [tokType.tokenTypeIdx!].concat(tokType.categoryMatches!)\r\n            for (const index of indices) {\r\n                if (fullSet.has(index)) {\r\n                    if (!altSet.has(index)) {\r\n                        return false\r\n                    }\r\n                } else {\r\n                    fullSet.add(index)\r\n                    altSet.add(index)\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nfunction initATNSimulator(atn: ATN): DFACache[] {\r\n    const decisionLength = atn.decisionStates.length\r\n    const decisionToDFA: DFACache[] = Array(decisionLength)\r\n    for (let i = 0; i < decisionLength; i++) {\r\n        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i)\r\n    }\r\n    return decisionToDFA;\r\n}\r\n\r\nfunction adaptivePredict(\r\n    this: BaseParser,\r\n    dfaCaches: DFACache[],\r\n    decision: number,\r\n    predicateSet: PredicateSet,\r\n    logging: AmbiguityReport\r\n): number | AdaptivePredictError {\r\n    const dfa = dfaCaches[decision](predicateSet)\r\n    let start = dfa.start\r\n    if (start === undefined) {\r\n        const closure = computeStartState(dfa.atnStartState as ATNState)\r\n        start = addDFAState(dfa, newDFAState(closure))\r\n        dfa.start = start\r\n    }\r\n\r\n    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging])\r\n    return alt\r\n}\r\n\r\nfunction performLookahead(\r\n    this: BaseParser,\r\n    dfa: DFA,\r\n    s0: DFAState,\r\n    predicateSet: PredicateSet,\r\n    logging: AmbiguityReport\r\n): number | AdaptivePredictError {\r\n    let previousD = s0\r\n\r\n    let i = 1\r\n    const path: IToken[] = []\r\n    let t = this.LA(i++)\r\n\r\n    while (true) {\r\n        let d = getExistingTargetState(previousD, t)\r\n        if (d === undefined) {\r\n            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging])\r\n        }\r\n\r\n        if (d === DFA_ERROR) {\r\n            return buildAdaptivePredictError(path, previousD, t)\r\n        }\r\n\r\n        if (d.isAcceptState === true) {\r\n            return d.prediction\r\n        }\r\n\r\n        previousD = d\r\n        path.push(t)\r\n        t = this.LA(i++)\r\n    }\r\n}\r\n\r\nfunction computeLookaheadTarget(\r\n    this: BaseParser,\r\n    dfa: DFA,\r\n    previousD: DFAState,\r\n    token: IToken,\r\n    lookahead: number,\r\n    predicateSet: PredicateSet,\r\n    logging: AmbiguityReport\r\n): DFAState {\r\n    const reach = computeReachSet(previousD.configs, token, predicateSet)\r\n    if (reach.size === 0) {\r\n        addDFAEdge(dfa, previousD, token, DFA_ERROR)\r\n        return DFA_ERROR\r\n    }\r\n\r\n    let newState = newDFAState(reach)\r\n    const predictedAlt = getUniqueAlt(reach, predicateSet)\r\n\r\n    if (predictedAlt !== undefined) {\r\n        newState.isAcceptState = true\r\n        newState.prediction = predictedAlt\r\n        newState.configs.uniqueAlt = predictedAlt\r\n    } else if (hasConflictTerminatingPrediction(reach)) {\r\n        const prediction = min(reach.alts)!\r\n        newState.isAcceptState = true\r\n        newState.prediction = prediction\r\n        newState.configs.uniqueAlt = prediction\r\n        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging])\r\n    }\r\n\r\n    newState = addDFAEdge(dfa, previousD, token, newState)\r\n    return newState\r\n}\r\n\r\nfunction reportLookaheadAmbiguity(\r\n    this: BaseParser,\r\n    dfa: DFA,\r\n    lookahead: number,\r\n    ambiguityIndices: number[],\r\n    logging: AmbiguityReport\r\n) {\r\n    const prefixPath: TokenType[] = []\r\n    for (let i = 1; i <= lookahead; i++) {\r\n        prefixPath.push(this.LA(i).tokenType)\r\n    }\r\n    const atnState = dfa.atnStartState\r\n    const topLevelRule = atnState.rule\r\n    const production = atnState.production\r\n    const message = buildAmbiguityError({\r\n        topLevelRule,\r\n        ambiguityIndices,\r\n        production,\r\n        prefixPath\r\n    })\r\n    logging(message)\r\n}\r\n\r\nfunction buildAmbiguityError(options: {\r\n    topLevelRule: Rule\r\n    prefixPath: TokenType[]\r\n    ambiguityIndices: number[]\r\n    production: IProductionWithOccurrence\r\n}): string {\r\n    const pathMsg = map(options.prefixPath, (currtok) =>\r\n        tokenLabel(currtok)\r\n    ).join(\", \")\r\n    const occurrence =\r\n        options.production.idx === 0 ? \"\" : options.production.idx\r\n    let currMessage =\r\n        `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(\r\n            \", \"\r\n        )}> in <${getProductionDslName(options.production)}${occurrence}>` +\r\n        ` inside <${options.topLevelRule.name}> Rule,\\n` +\r\n        `<${pathMsg}> may appears as a prefix path in all these alternatives.\\n`\r\n\r\n    currMessage =\r\n        currMessage +\r\n        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\\n` +\r\n        `For Further details.`\r\n    return currMessage\r\n}\r\n\r\nfunction getProductionDslName(prod: IProductionWithOccurrence): string {\r\n    if (prod instanceof NonTerminal) {\r\n        return \"SUBRULE\"\r\n    } else if (prod instanceof Option) {\r\n        return \"OPTION\"\r\n    } else if (prod instanceof Alternation) {\r\n        return \"OR\"\r\n    } else if (prod instanceof RepetitionMandatory) {\r\n        return \"AT_LEAST_ONE\"\r\n    } else if (prod instanceof RepetitionMandatoryWithSeparator) {\r\n        return \"AT_LEAST_ONE_SEP\"\r\n    } else if (prod instanceof RepetitionWithSeparator) {\r\n        return \"MANY_SEP\"\r\n    } else if (prod instanceof Repetition) {\r\n        return \"MANY\"\r\n    } else if (prod instanceof Terminal) {\r\n        return \"CONSUME\"\r\n    } else {\r\n        throw Error(\"non exhaustive match\")\r\n    }\r\n}\r\n\r\nfunction buildAdaptivePredictError(\r\n    path: IToken[],\r\n    previous: DFAState,\r\n    current: IToken\r\n): AdaptivePredictError {\r\n    const nextTransitions = flatMap(\r\n        previous.configs.elements,\r\n        (e) => e.state.transitions\r\n    )\r\n    const nextTokenTypes = uniqBy(\r\n        nextTransitions\r\n            .filter((e): e is AtomTransition => e instanceof AtomTransition)\r\n            .map((e) => e.tokenType),\r\n        (e) => e.tokenTypeIdx\r\n    )\r\n    return {\r\n        actualToken: current,\r\n        possibleTokenTypes: nextTokenTypes,\r\n        tokenPath: path\r\n    }\r\n}\r\n\r\nfunction getExistingTargetState(\r\n    state: DFAState,\r\n    token: IToken\r\n): DFAState | undefined {\r\n    return state.edges[token.tokenTypeIdx]\r\n}\r\n\r\nfunction computeReachSet(\r\n    configs: ATNConfigSet,\r\n    token: IToken,\r\n    predicateSet: PredicateSet\r\n): ATNConfigSet {\r\n    const intermediate = new ATNConfigSet()\r\n    const skippedStopStates: ATNConfig[] = []\r\n\r\n    for (const c of configs.elements) {\r\n        if (predicateSet.is(c.alt) === false) {\r\n            continue\r\n        }\r\n        if (c.state.type === ATN_RULE_STOP) {\r\n            skippedStopStates.push(c)\r\n            continue\r\n        }\r\n        const transitionLength = c.state.transitions.length\r\n        for (let i = 0; i < transitionLength; i++) {\r\n            const transition = c.state.transitions[i]\r\n            const target = getReachableTarget(transition, token)\r\n            if (target !== undefined) {\r\n                intermediate.add({\r\n                    state: target,\r\n                    alt: c.alt,\r\n                    stack: c.stack\r\n                })\r\n            }\r\n        }\r\n    }\r\n\r\n    let reach: ATNConfigSet | undefined\r\n\r\n    if (skippedStopStates.length === 0 && intermediate.size === 1) {\r\n        reach = intermediate\r\n    }\r\n\r\n    if (reach === undefined) {\r\n        reach = new ATNConfigSet()\r\n        for (const c of intermediate.elements) {\r\n            closure(c, reach)\r\n        }\r\n    }\r\n\r\n    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {\r\n        for (const c of skippedStopStates) {\r\n            reach.add(c)\r\n        }\r\n    }\r\n\r\n    return reach\r\n}\r\n\r\nfunction getReachableTarget(\r\n    transition: Transition,\r\n    token: IToken\r\n): ATNState | undefined {\r\n    if (\r\n        transition instanceof AtomTransition &&\r\n        tokenMatcher(token, transition.tokenType)\r\n    ) {\r\n        return transition.target\r\n    }\r\n    return undefined\r\n}\r\n\r\nfunction getUniqueAlt(\r\n    configs: ATNConfigSet,\r\n    predicateSet: PredicateSet\r\n): number | undefined {\r\n    let alt: number | undefined\r\n    for (const c of configs.elements) {\r\n        if (predicateSet.is(c.alt) === true) {\r\n            if (alt === undefined) {\r\n                alt = c.alt\r\n            } else if (alt !== c.alt) {\r\n                return undefined\r\n            }\r\n        }\r\n    }\r\n    return alt\r\n}\r\n\r\nfunction newDFAState(closure: ATNConfigSet): DFAState {\r\n    return {\r\n        configs: closure,\r\n        edges: {},\r\n        isAcceptState: false,\r\n        prediction: -1\r\n    }\r\n}\r\n\r\nfunction addDFAEdge(\r\n    dfa: DFA,\r\n    from: DFAState,\r\n    token: IToken,\r\n    to: DFAState\r\n): DFAState {\r\n    to = addDFAState(dfa, to)\r\n    from.edges[token.tokenTypeIdx] = to\r\n    return to\r\n}\r\n\r\nfunction addDFAState(dfa: DFA, state: DFAState): DFAState {\r\n    if (state === DFA_ERROR) {\r\n        return state\r\n    }\r\n    // Repetitions have the same config set\r\n    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA\r\n    const mapKey = state.configs.key\r\n    const existing = dfa.states[mapKey]\r\n    if (existing !== undefined) {\r\n        return existing\r\n    }\r\n    state.configs.finalize()\r\n    dfa.states[mapKey] = state\r\n    return state\r\n}\r\n\r\nfunction computeStartState(atnState: ATNState): ATNConfigSet {\r\n    const configs = new ATNConfigSet()\r\n\r\n    const numberOfTransitions = atnState.transitions.length\r\n    for (let i = 0; i < numberOfTransitions; i++) {\r\n        const target = atnState.transitions[i].target\r\n        const config: ATNConfig = {\r\n            state: target,\r\n            alt: i,\r\n            stack: []\r\n        }\r\n        closure(config, configs)\r\n    }\r\n\r\n    return configs\r\n}\r\n\r\nfunction closure(config: ATNConfig, configs: ATNConfigSet): void {\r\n    const p = config.state\r\n\r\n    if (p.type === ATN_RULE_STOP) {\r\n        if (config.stack.length > 0) {\r\n            const atnStack = [...config.stack]\r\n            const followState = atnStack.pop()!\r\n            const followConfig: ATNConfig = {\r\n                state: followState,\r\n                alt: config.alt,\r\n                stack: atnStack\r\n            }\r\n            closure(followConfig, configs)\r\n        } else {\r\n            // Dipping into outer context, simply add the config\r\n            // This will stop computation once every config is at the rule stop state\r\n            configs.add(config)\r\n        }\r\n        return\r\n    }\r\n\r\n    if (!p.epsilonOnlyTransitions) {\r\n        configs.add(config)\r\n    }\r\n\r\n    const transitionLength = p.transitions.length\r\n    for (let i = 0; i < transitionLength; i++) {\r\n        const transition = p.transitions[i]\r\n        const c = getEpsilonTarget(config, transition)\r\n\r\n        if (c !== undefined) {\r\n            closure(c, configs)\r\n        }\r\n    }\r\n}\r\n\r\nfunction getEpsilonTarget(\r\n    config: ATNConfig,\r\n    transition: Transition\r\n): ATNConfig | undefined {\r\n    if (transition instanceof EpsilonTransition) {\r\n        return {\r\n            state: transition.target,\r\n            alt: config.alt,\r\n            stack: config.stack\r\n        }\r\n    } else if (transition instanceof RuleTransition) {\r\n        const stack = [...config.stack, transition.followState]\r\n        return {\r\n            state: transition.target,\r\n            alt: config.alt,\r\n            stack\r\n        }\r\n    }\r\n    return undefined\r\n}\r\n\r\nfunction hasConfigInRuleStopState(configs: ATNConfigSet): boolean {\r\n    for (const c of configs.elements) {\r\n        if (c.state.type === ATN_RULE_STOP) {\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nfunction allConfigsInRuleStopStates(configs: ATNConfigSet): boolean {\r\n    for (const c of configs.elements) {\r\n        if (c.state.type !== ATN_RULE_STOP) {\r\n            return false\r\n        }\r\n    }\r\n    return true\r\n}\r\n\r\nfunction hasConflictTerminatingPrediction(configs: ATNConfigSet): boolean {\r\n    if (allConfigsInRuleStopStates(configs)) {\r\n        return true\r\n    }\r\n    const altSets = getConflictingAltSets(configs.elements)\r\n    const heuristic =\r\n        hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets)\r\n    return heuristic\r\n}\r\n\r\nfunction getConflictingAltSets(\r\n    configs: readonly ATNConfig[]\r\n): Map<string, Record<number, boolean>> {\r\n    const configToAlts = new Map<string, Record<number, boolean>>()\r\n    for (const c of configs) {\r\n        const key = getATNConfigKey(c, false)\r\n        let alts = configToAlts.get(key)\r\n        if (alts === undefined) {\r\n            alts = {}\r\n            configToAlts.set(key, alts)\r\n        }\r\n        alts[c.alt] = true\r\n    }\r\n    return configToAlts\r\n}\r\n\r\nfunction hasConflictingAltSet(\r\n    altSets: Map<string, Record<number, boolean>>\r\n): boolean {\r\n    for (const value of Array.from(altSets.values())) {\r\n        if (Object.keys(value).length > 1) {\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n\r\nfunction hasStateAssociatedWithOneAlt(\r\n    altSets: Map<string, Record<number, boolean>>\r\n): boolean {\r\n    for (const value of Array.from(altSets.values())) {\r\n        if (Object.keys(value).length === 1) {\r\n            return true\r\n        }\r\n    }\r\n    return false\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IToken, TokenType } from 'chevrotain';\r\nimport type { Range } from 'vscode-languageserver-types';\r\nimport type { AbstractElement } from '../grammar/generated/ast.js';\r\nimport type { AstNode, CompositeCstNode, CstNode, LeafCstNode, RootCstNode } from '../syntax-tree.js';\r\nimport { Position } from 'vscode-languageserver-types';\r\nimport { isCompositeCstNode } from '../syntax-tree.js';\r\nimport { tokenToRange } from '../utils/cst-util.js';\r\n\r\nexport class CstNodeBuilder {\r\n\r\n    private rootNode!: RootCstNodeImpl;\r\n    private nodeStack: CompositeCstNodeImpl[] = [];\r\n\r\n    private get current(): CompositeCstNodeImpl {\r\n        return this.nodeStack[this.nodeStack.length - 1];\r\n    }\r\n\r\n    buildRootNode(input: string): RootCstNode {\r\n        this.rootNode = new RootCstNodeImpl(input);\r\n        this.nodeStack = [this.rootNode];\r\n        return this.rootNode;\r\n    }\r\n\r\n    buildCompositeNode(feature: AbstractElement): CompositeCstNode {\r\n        const compositeNode = new CompositeCstNodeImpl();\r\n        compositeNode.grammarSource = feature;\r\n        compositeNode.root = this.rootNode;\r\n        this.current.content.push(compositeNode);\r\n        this.nodeStack.push(compositeNode);\r\n        return compositeNode;\r\n    }\r\n\r\n    buildLeafNode(token: IToken, feature: AbstractElement): LeafCstNode {\r\n        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, false);\r\n        leafNode.grammarSource = feature;\r\n        leafNode.root = this.rootNode;\r\n        this.current.content.push(leafNode);\r\n        return leafNode;\r\n    }\r\n\r\n    removeNode(node: CstNode): void {\r\n        const parent = node.container;\r\n        if (parent) {\r\n            const index = parent.content.indexOf(node);\r\n            if (index >= 0) {\r\n                parent.content.splice(index, 1);\r\n            }\r\n        }\r\n    }\r\n\r\n    construct(item: { $type: string | symbol | undefined, $cstNode: CstNode }): void {\r\n        const current: CstNode = this.current;\r\n        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)\r\n        // Only if the $type is a string, we actually assign the element\r\n        if (typeof item.$type === 'string') {\r\n            this.current.astNode = <AstNode>item;\r\n        }\r\n        item.$cstNode = current;\r\n        const node = this.nodeStack.pop();\r\n        // Empty composite nodes are not valid\r\n        // Simply remove the node from the tree\r\n        if (node?.content.length === 0) {\r\n            this.removeNode(node);\r\n        }\r\n    }\r\n\r\n    addHiddenTokens(hiddenTokens: IToken[]): void {\r\n        for (const token of hiddenTokens) {\r\n            const hiddenNode = new LeafCstNodeImpl(token.startOffset, token.image.length, tokenToRange(token), token.tokenType, true);\r\n            hiddenNode.root = this.rootNode;\r\n            this.addHiddenToken(this.rootNode, hiddenNode);\r\n        }\r\n    }\r\n\r\n    private addHiddenToken(node: CompositeCstNode, token: LeafCstNode): void {\r\n        const { offset: tokenStart, end: tokenEnd } = token;\r\n\r\n        for (let i = 0; i < node.content.length; i++) {\r\n            const child = node.content[i];\r\n            const { offset: childStart, end: childEnd } = child;\r\n            if (isCompositeCstNode(child) && tokenStart > childStart && tokenEnd < childEnd) {\r\n                this.addHiddenToken(child, token);\r\n                return;\r\n            } else if (tokenEnd <= childStart) {\r\n                node.content.splice(i, 0, token);\r\n                return;\r\n            }\r\n        }\r\n\r\n        // We know that we haven't found a suited position for the token\r\n        // So we simply add it to the end of the current node\r\n        node.content.push(token);\r\n    }\r\n}\r\n\r\nexport abstract class AbstractCstNode implements CstNode {\r\n    abstract get offset(): number;\r\n    abstract get length(): number;\r\n    abstract get end(): number;\r\n    abstract get range(): Range;\r\n\r\n    container?: CompositeCstNode;\r\n    grammarSource: AbstractElement;\r\n    root: RootCstNode;\r\n    private _astNode?: AstNode;\r\n\r\n    /** @deprecated use `container` instead. */\r\n    get parent(): CompositeCstNode | undefined {\r\n        return this.container;\r\n    }\r\n\r\n    /** @deprecated use `grammarSource` instead. */\r\n    get feature(): AbstractElement {\r\n        return this.grammarSource;\r\n    }\r\n\r\n    get hidden(): boolean {\r\n        return false;\r\n    }\r\n\r\n    get astNode(): AstNode {\r\n        const node = typeof this._astNode?.$type === 'string' ? this._astNode : this.container?.astNode;\r\n        if (!node) {\r\n            throw new Error('This node has no associated AST element');\r\n        }\r\n        return node;\r\n    }\r\n\r\n    set astNode(value: AstNode) {\r\n        this._astNode = value;\r\n    }\r\n\r\n    /** @deprecated use `astNode` instead. */\r\n    get element(): AstNode {\r\n        return this.astNode;\r\n    }\r\n\r\n    get text(): string {\r\n        return this.root.fullText.substring(this.offset, this.end);\r\n    }\r\n}\r\n\r\nexport class LeafCstNodeImpl extends AbstractCstNode implements LeafCstNode {\r\n    get offset(): number {\r\n        return this._offset;\r\n    }\r\n\r\n    get length(): number {\r\n        return this._length;\r\n    }\r\n\r\n    get end(): number {\r\n        return this._offset + this._length;\r\n    }\r\n\r\n    override get hidden(): boolean {\r\n        return this._hidden;\r\n    }\r\n\r\n    get tokenType(): TokenType {\r\n        return this._tokenType;\r\n    }\r\n\r\n    get range(): Range {\r\n        return this._range;\r\n    }\r\n\r\n    private _hidden: boolean;\r\n    private _offset: number;\r\n    private _length: number;\r\n    private _range: Range;\r\n    private _tokenType: TokenType;\r\n\r\n    constructor(offset: number, length: number, range: Range, tokenType: TokenType, hidden = false) {\r\n        super();\r\n        this._hidden = hidden;\r\n        this._offset = offset;\r\n        this._tokenType = tokenType;\r\n        this._length = length;\r\n        this._range = range;\r\n    }\r\n}\r\n\r\nexport class CompositeCstNodeImpl extends AbstractCstNode implements CompositeCstNode {\r\n    readonly content: CstNode[] = new CstNodeContainer(this);\r\n    private _rangeCache?: Range;\r\n\r\n    /** @deprecated use `content` instead. */\r\n    get children(): CstNode[] {\r\n        return this.content;\r\n    }\r\n\r\n    get offset(): number {\r\n        return this.firstNonHiddenNode?.offset ?? 0;\r\n    }\r\n\r\n    get length(): number {\r\n        return this.end - this.offset;\r\n    }\r\n\r\n    get end(): number {\r\n        return this.lastNonHiddenNode?.end ?? 0;\r\n    }\r\n\r\n    get range(): Range {\r\n        const firstNode = this.firstNonHiddenNode;\r\n        const lastNode = this.lastNonHiddenNode;\r\n        if (firstNode && lastNode) {\r\n            if (this._rangeCache === undefined) {\r\n                const { range: firstRange } = firstNode;\r\n                const { range: lastRange } = lastNode;\r\n                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };\r\n            }\r\n            return this._rangeCache;\r\n        } else {\r\n            return { start: Position.create(0, 0), end: Position.create(0, 0) };\r\n        }\r\n    }\r\n\r\n    private get firstNonHiddenNode(): CstNode | undefined {\r\n        for (const child of this.content) {\r\n            if (!child.hidden) {\r\n                return child;\r\n            }\r\n        }\r\n        return this.content[0];\r\n    }\r\n\r\n    private get lastNonHiddenNode(): CstNode | undefined {\r\n        for (let i = this.content.length - 1; i >= 0; i--) {\r\n            const child = this.content[i];\r\n            if (!child.hidden) {\r\n                return child;\r\n            }\r\n        }\r\n        return this.content[this.content.length - 1];\r\n    }\r\n}\r\n\r\nclass CstNodeContainer extends Array<CstNode> {\r\n    readonly parent: CompositeCstNode;\r\n\r\n    constructor(parent: CompositeCstNode) {\r\n        super();\r\n        this.parent = parent;\r\n        Object.setPrototypeOf(this, CstNodeContainer.prototype);\r\n    }\r\n\r\n    override push(...items: CstNode[]): number {\r\n        this.addParents(items);\r\n        return super.push(...items);\r\n    }\r\n\r\n    override unshift(...items: CstNode[]): number {\r\n        this.addParents(items);\r\n        return super.unshift(...items);\r\n    }\r\n\r\n    override splice(start: number, count: number, ...items: CstNode[]): CstNode[] {\r\n        this.addParents(items);\r\n        return super.splice(start, count, ...items);\r\n    }\r\n\r\n    private addParents(items: CstNode[]): void {\r\n        for (const item of items) {\r\n            (<AbstractCstNode>item).container = this.parent;\r\n        }\r\n    }\r\n}\r\n\r\nexport class RootCstNodeImpl extends CompositeCstNodeImpl implements RootCstNode {\r\n    private _text = '';\r\n\r\n    override get text(): string {\r\n        return this._text.substring(this.offset, this.end);\r\n    }\r\n\r\n    get fullText(): string {\r\n        return this._text;\r\n    }\r\n\r\n    constructor(input?: string) {\r\n        super();\r\n        this._text = input ?? '';\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\nimport type { DSLMethodOpts, ILexingError, IOrAlt, IParserErrorMessageProvider, IRecognitionException, IToken, TokenType, TokenVocabulary } from 'chevrotain';\r\nimport type { AbstractElement, Action, Assignment, ParserRule } from '../grammar/generated/ast.js';\r\nimport type { Linker } from '../references/linker.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstReflection, CompositeCstNode, CstNode } from '../syntax-tree.js';\r\nimport type { Lexer } from './lexer.js';\r\nimport type { IParserConfig } from './parser-config.js';\r\nimport type { ValueConverter } from './value-converter.js';\r\nimport { defaultParserErrorProvider, EmbeddedActionsParser, LLkLookaheadStrategy } from 'chevrotain';\r\nimport { LLStarLookaheadStrategy } from 'chevrotain-allstar';\r\nimport { isAssignment, isCrossReference, isKeyword } from '../grammar/generated/ast.js';\r\nimport { getTypeName, isDataTypeRule } from '../grammar/internal-grammar-util.js';\r\nimport { assignMandatoryAstProperties, getContainerOfType, linkContentToContainer } from '../utils/ast-util.js';\r\nimport { CstNodeBuilder } from './cst-node-builder.js';\r\n\r\nexport type ParseResult<T = AstNode> = {\r\n    value: T,\r\n    parserErrors: IRecognitionException[],\r\n    lexerErrors: ILexingError[]\r\n}\r\n\r\nexport const DatatypeSymbol = Symbol('Datatype');\r\n\r\ninterface DataTypeNode {\r\n    $cstNode: CompositeCstNode\r\n    /** Instead of a string, this node is uniquely identified by the `Datatype` symbol */\r\n    $type: symbol\r\n    /** Used as a storage for all parsed terminals, keywords and sub-datatype rules */\r\n    value: string\r\n}\r\n\r\nfunction isDataTypeNode(node: { $type: string | symbol | undefined }): node is DataTypeNode {\r\n    return node.$type === DatatypeSymbol;\r\n}\r\n\r\ntype RuleResult = (args: Args) => any;\r\n\r\ntype Args = Record<string, boolean>;\r\n\r\ntype RuleImpl = (args: Args) => any;\r\n\r\ninterface AssignmentElement {\r\n    assignment?: Assignment\r\n    isCrossRef: boolean\r\n}\r\n\r\nexport interface BaseParser {\r\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult;\r\n    alternatives(idx: number, choices: Array<IOrAlt<any>>): void;\r\n    optional(idx: number, callback: DSLMethodOpts<unknown>): void;\r\n    many(idx: number, callback: DSLMethodOpts<unknown>): void;\r\n    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void;\r\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;\r\n    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;\r\n    action($type: string, action: Action): void;\r\n    construct(): unknown;\r\n    isRecording(): boolean;\r\n    get unorderedGroups(): Map<string, boolean[]>;\r\n    getRuleStack(): number[];\r\n}\r\n\r\nconst ruleSuffix = '\\u200B';\r\nconst withRuleSuffix = (name: string): string => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;\r\n\r\nexport abstract class AbstractLangiumParser implements BaseParser {\r\n\r\n    protected readonly lexer: Lexer;\r\n    protected readonly wrapper: ChevrotainWrapper;\r\n    protected _unorderedGroups: Map<string, boolean[]> = new Map<string, boolean[]>();\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.lexer = services.parser.Lexer;\r\n        const tokens = this.lexer.definition;\r\n        this.wrapper = new ChevrotainWrapper(tokens, {\r\n            ...services.parser.ParserConfig,\r\n            errorMessageProvider: services.parser.ParserErrorMessageProvider\r\n        });\r\n    }\r\n\r\n    alternatives(idx: number, choices: Array<IOrAlt<any>>): void {\r\n        this.wrapper.wrapOr(idx, choices);\r\n    }\r\n\r\n    optional(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.wrapper.wrapOption(idx, callback);\r\n    }\r\n\r\n    many(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.wrapper.wrapMany(idx, callback);\r\n    }\r\n\r\n    atLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.wrapper.wrapAtLeastOne(idx, callback);\r\n    }\r\n\r\n    abstract rule(rule: ParserRule, impl: RuleImpl): RuleResult;\r\n    abstract consume(idx: number, tokenType: TokenType, feature: AbstractElement): void;\r\n    abstract subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void;\r\n    abstract action($type: string, action: Action): void;\r\n    abstract construct(): unknown;\r\n\r\n    isRecording(): boolean {\r\n        return this.wrapper.IS_RECORDING;\r\n    }\r\n\r\n    get unorderedGroups(): Map<string, boolean[]> {\r\n        return this._unorderedGroups;\r\n    }\r\n\r\n    getRuleStack(): number[] {\r\n        return (this.wrapper as any).RULE_STACK;\r\n    }\r\n\r\n    finalize(): void {\r\n        this.wrapper.wrapSelfAnalysis();\r\n    }\r\n}\r\n\r\nexport class LangiumParser extends AbstractLangiumParser {\r\n    private readonly linker: Linker;\r\n    private readonly converter: ValueConverter;\r\n    private readonly astReflection: AstReflection;\r\n    private readonly nodeBuilder = new CstNodeBuilder();\r\n    private stack: any[] = [];\r\n    private mainRule!: RuleResult;\r\n    private assignmentMap = new Map<AbstractElement, AssignmentElement | undefined>();\r\n\r\n    private get current(): any {\r\n        return this.stack[this.stack.length - 1];\r\n    }\r\n\r\n    constructor(services: LangiumServices) {\r\n        super(services);\r\n        this.linker = services.references.Linker;\r\n        this.converter = services.parser.ValueConverter;\r\n        this.astReflection = services.shared.AstReflection;\r\n    }\r\n\r\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult {\r\n        const type = rule.fragment ? undefined : isDataTypeRule(rule) ? DatatypeSymbol : getTypeName(rule);\r\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));\r\n        if (rule.entry) {\r\n            this.mainRule = ruleMethod;\r\n        }\r\n        return ruleMethod;\r\n    }\r\n\r\n    parse<T extends AstNode = AstNode>(input: string): ParseResult<T> {\r\n        this.nodeBuilder.buildRootNode(input);\r\n        const lexerResult = this.lexer.tokenize(input);\r\n        this.wrapper.input = lexerResult.tokens;\r\n        const result = this.mainRule.call(this.wrapper, {});\r\n        this.nodeBuilder.addHiddenTokens(lexerResult.hidden);\r\n        this.unorderedGroups.clear();\r\n        return {\r\n            value: result,\r\n            lexerErrors: lexerResult.errors,\r\n            parserErrors: this.wrapper.errors\r\n        };\r\n    }\r\n\r\n    private startImplementation($type: string | symbol | undefined, implementation: RuleImpl): RuleImpl {\r\n        return (args) => {\r\n            if (!this.isRecording()) {\r\n                const node: any = { $type };\r\n                this.stack.push(node);\r\n                if ($type === DatatypeSymbol) {\r\n                    node.value = '';\r\n                }\r\n            }\r\n            let result: unknown;\r\n            try {\r\n                result = implementation(args);\r\n            } catch (err) {\r\n                result = undefined;\r\n            }\r\n            if (!this.isRecording() && result === undefined) {\r\n                result = this.construct();\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n\r\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void {\r\n        const token = this.wrapper.wrapConsume(idx, tokenType);\r\n        if (!this.isRecording() && this.isValidToken(token)) {\r\n            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);\r\n            const { assignment, isCrossRef } = this.getAssignment(feature);\r\n            const current = this.current;\r\n            if (assignment) {\r\n                const convertedValue = isKeyword(feature) ? token.image : this.converter.convert(token.image, leafNode);\r\n                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);\r\n            } else if (isDataTypeNode(current)) {\r\n                let text = token.image;\r\n                if (!isKeyword(feature)) {\r\n                    text = this.converter.convert(text, leafNode).toString();\r\n                }\r\n                current.value += text;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:\r\n     *\r\n     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed\r\n     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.\r\n     */\r\n    private isValidToken(token: IToken): boolean {\r\n        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);\r\n    }\r\n\r\n    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void {\r\n        let cstNode: CompositeCstNode | undefined;\r\n        if (!this.isRecording()) {\r\n            cstNode = this.nodeBuilder.buildCompositeNode(feature);\r\n        }\r\n        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args) as any;\r\n        if (!this.isRecording() && cstNode && cstNode.length > 0) {\r\n            this.performSubruleAssignment(subruleResult, feature, cstNode);\r\n        }\r\n    }\r\n\r\n    private performSubruleAssignment(result: any, feature: AbstractElement, cstNode: CompositeCstNode): void {\r\n        const { assignment, isCrossRef } = this.getAssignment(feature);\r\n        if (assignment) {\r\n            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);\r\n        } else if (!assignment) {\r\n            // If we call a subrule without an assignment\r\n            // We either append the result of the subrule (data type rule)\r\n            // Or override the current object with the newly parsed object\r\n            const current = this.current;\r\n            if (isDataTypeNode(current)) {\r\n                current.value += result.toString();\r\n            } else {\r\n                const resultKind = result.$type;\r\n                const object = this.assignWithoutOverride(result, current);\r\n                if (resultKind) {\r\n                    object.$type = resultKind;\r\n                }\r\n                const newItem = object;\r\n                this.stack.pop();\r\n                this.stack.push(newItem);\r\n            }\r\n        }\r\n    }\r\n\r\n    action($type: string, action: Action): void {\r\n        if (!this.isRecording()) {\r\n            let last = this.current;\r\n            // This branch is used for left recursive grammar rules.\r\n            // Those don't call `construct` before another action.\r\n            // Therefore, we need to call it here.\r\n            if (!last.$cstNode && action.feature && action.operator) {\r\n                last = this.construct(false);\r\n                const feature = last.$cstNode.feature;\r\n                this.nodeBuilder.buildCompositeNode(feature);\r\n            }\r\n            const newItem = { $type };\r\n            this.stack.pop();\r\n            this.stack.push(newItem);\r\n            if (action.feature && action.operator) {\r\n                this.assign(action.operator, action.feature, last, last.$cstNode, false);\r\n            }\r\n        }\r\n    }\r\n\r\n    construct(pop = true): unknown {\r\n        if (this.isRecording()) {\r\n            return undefined;\r\n        }\r\n        const obj = this.current;\r\n        linkContentToContainer(obj);\r\n        this.nodeBuilder.construct(obj);\r\n        if (pop) {\r\n            this.stack.pop();\r\n        }\r\n        if (isDataTypeNode(obj)) {\r\n            return this.converter.convert(obj.value, obj.$cstNode);\r\n        } else {\r\n            assignMandatoryAstProperties(this.astReflection, obj);\r\n        }\r\n        return obj;\r\n    }\r\n\r\n    private getAssignment(feature: AbstractElement): AssignmentElement {\r\n        if (!this.assignmentMap.has(feature)) {\r\n            const assignment = getContainerOfType(feature, isAssignment);\r\n            this.assignmentMap.set(feature, {\r\n                assignment: assignment,\r\n                isCrossRef: assignment ? isCrossReference(assignment.terminal) : false\r\n            });\r\n        }\r\n        return this.assignmentMap.get(feature)!;\r\n    }\r\n\r\n    private assign(operator: string, feature: string, value: unknown, cstNode: CstNode, isCrossRef: boolean): void {\r\n        const obj = this.current;\r\n        let item: unknown;\r\n        if (isCrossRef && typeof value === 'string') {\r\n            item = this.linker.buildReference(obj, feature, cstNode, value);\r\n        } else {\r\n            item = value;\r\n        }\r\n        switch (operator) {\r\n            case '=': {\r\n                obj[feature] = item;\r\n                break;\r\n            }\r\n            case '?=': {\r\n                obj[feature] = true;\r\n                break;\r\n            }\r\n            case '+=': {\r\n                if (!Array.isArray(obj[feature])) {\r\n                    obj[feature] = [];\r\n                }\r\n                obj[feature].push(item);\r\n            }\r\n        }\r\n    }\r\n\r\n    private assignWithoutOverride(target: any, source: any): any {\r\n        for (const [name, existingValue] of Object.entries(source)) {\r\n            const newValue = target[name];\r\n            if (newValue === undefined) {\r\n                target[name] = existingValue;\r\n            } else if (Array.isArray(newValue) && Array.isArray(existingValue)) {\r\n                existingValue.push(...newValue);\r\n                target[name] = existingValue;\r\n            }\r\n        }\r\n        return target;\r\n    }\r\n\r\n    get definitionErrors(): IParserDefinitionError[] {\r\n        return this.wrapper.definitionErrors;\r\n    }\r\n}\r\n\r\nexport interface IParserDefinitionError {\r\n    message: string\r\n    type: number\r\n    ruleName?: string\r\n}\r\n\r\nexport abstract class AbstractParserErrorMessageProvider implements IParserErrorMessageProvider {\r\n\r\n    buildMismatchTokenMessage(options: {\r\n        expected: TokenType\r\n        actual: IToken\r\n        previous: IToken\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildMismatchTokenMessage(options);\r\n    }\r\n\r\n    buildNotAllInputParsedMessage(options: {\r\n        firstRedundant: IToken\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildNotAllInputParsedMessage(options);\r\n    }\r\n\r\n    buildNoViableAltMessage(options: {\r\n        expectedPathsPerAlt: TokenType[][][]\r\n        actual: IToken[]\r\n        previous: IToken\r\n        customUserDescription: string\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildNoViableAltMessage(options);\r\n    }\r\n\r\n    buildEarlyExitMessage(options: {\r\n        expectedIterationPaths: TokenType[][]\r\n        actual: IToken[]\r\n        previous: IToken\r\n        customUserDescription: string\r\n        ruleName: string\r\n    }): string {\r\n        return defaultParserErrorProvider.buildEarlyExitMessage(options);\r\n    }\r\n\r\n}\r\n\r\nexport class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {\r\n\r\n    override buildMismatchTokenMessage({ expected, actual }: {\r\n        expected: TokenType\r\n        actual: IToken\r\n        previous: IToken\r\n        ruleName: string\r\n    }): string {\r\n        const expectedMsg = expected.LABEL\r\n            ? '`' + expected.LABEL + '`'\r\n            : expected.name.endsWith(':KW')\r\n                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`\r\n                : `token of type '${expected.name}'`;\r\n        return `Expecting ${expectedMsg} but found \\`${actual.image}\\`.`;\r\n    }\r\n\r\n    override buildNotAllInputParsedMessage({ firstRedundant }: {\r\n        firstRedundant: IToken\r\n        ruleName: string\r\n    }): string {\r\n        return `Expecting end of file but found \\`${firstRedundant.image}\\`.`;\r\n    }\r\n}\r\n\r\nexport interface CompletionParserResult {\r\n    tokens: IToken[]\r\n    elementStack: AbstractElement[]\r\n    tokenIndex: number\r\n}\r\n\r\nexport class LangiumCompletionParser extends AbstractLangiumParser {\r\n    private mainRule!: RuleResult;\r\n    private tokens: IToken[] = [];\r\n\r\n    private elementStack: AbstractElement[] = [];\r\n    private lastElementStack: AbstractElement[] = [];\r\n    private nextTokenIndex = 0;\r\n    private stackSize = 0;\r\n\r\n    action(): void {\r\n        // NOOP\r\n    }\r\n\r\n    construct(): unknown {\r\n        // NOOP\r\n        return undefined;\r\n    }\r\n\r\n    parse(input: string): CompletionParserResult {\r\n        this.resetState();\r\n        const tokens = this.lexer.tokenize(input);\r\n        this.tokens = tokens.tokens;\r\n        this.wrapper.input = [...this.tokens];\r\n        this.mainRule.call(this.wrapper, {});\r\n        this.unorderedGroups.clear();\r\n        return {\r\n            tokens: this.tokens,\r\n            elementStack: [...this.lastElementStack],\r\n            tokenIndex: this.nextTokenIndex\r\n        };\r\n    }\r\n\r\n    rule(rule: ParserRule, impl: RuleImpl): RuleResult {\r\n        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));\r\n        if (rule.entry) {\r\n            this.mainRule = ruleMethod;\r\n        }\r\n        return ruleMethod;\r\n    }\r\n\r\n    private resetState(): void {\r\n        this.elementStack = [];\r\n        this.lastElementStack = [];\r\n        this.nextTokenIndex = 0;\r\n        this.stackSize = 0;\r\n    }\r\n\r\n    private startImplementation(implementation: RuleImpl): RuleImpl {\r\n        return (args) => {\r\n            const size = this.keepStackSize();\r\n            try {\r\n                implementation(args);\r\n            } finally {\r\n                this.resetStackSize(size);\r\n            }\r\n        };\r\n    }\r\n\r\n    private removeUnexpectedElements(): void {\r\n        this.elementStack.splice(this.stackSize);\r\n    }\r\n\r\n    keepStackSize(): number {\r\n        const size = this.elementStack.length;\r\n        this.stackSize = size;\r\n        return size;\r\n    }\r\n\r\n    resetStackSize(size: number): void {\r\n        this.removeUnexpectedElements();\r\n        this.stackSize = size;\r\n    }\r\n\r\n    consume(idx: number, tokenType: TokenType, feature: AbstractElement): void {\r\n        this.wrapper.wrapConsume(idx, tokenType);\r\n        if (!this.isRecording()) {\r\n            this.lastElementStack = [...this.elementStack, feature];\r\n            this.nextTokenIndex = this.currIdx + 1;\r\n        }\r\n    }\r\n\r\n    subrule(idx: number, rule: RuleResult, feature: AbstractElement, args: Args): void {\r\n        this.before(feature);\r\n        this.wrapper.wrapSubrule(idx, rule, args);\r\n        this.after(feature);\r\n    }\r\n\r\n    before(element: AbstractElement): void {\r\n        if (!this.isRecording()) {\r\n            this.elementStack.push(element);\r\n        }\r\n    }\r\n\r\n    after(element: AbstractElement): void {\r\n        if (!this.isRecording()) {\r\n            const index = this.elementStack.lastIndexOf(element);\r\n            if (index >= 0) {\r\n                this.elementStack.splice(index);\r\n            }\r\n        }\r\n    }\r\n\r\n    get currIdx(): number {\r\n        return (this.wrapper as any).currIdx;\r\n    }\r\n}\r\n\r\nconst defaultConfig: IParserConfig = {\r\n    recoveryEnabled: true,\r\n    nodeLocationTracking: 'full',\r\n    skipValidations: true,\r\n    errorMessageProvider: new LangiumParserErrorMessageProvider()\r\n};\r\n\r\n/**\r\n * This class wraps the embedded actions parser of chevrotain and exposes protected methods.\r\n * This way, we can build the `LangiumParser` as a composition.\r\n */\r\nclass ChevrotainWrapper extends EmbeddedActionsParser {\r\n\r\n    // This array is set in the base implementation of Chevrotain.\r\n    definitionErrors: IParserDefinitionError[];\r\n\r\n    constructor(tokens: TokenVocabulary, config?: IParserConfig) {\r\n        const useDefaultLookahead = config && 'maxLookahead' in config;\r\n        super(tokens, {\r\n            ...defaultConfig,\r\n            lookaheadStrategy: useDefaultLookahead\r\n                ? new LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })\r\n                : new LLStarLookaheadStrategy(),\r\n            ...config,\r\n        });\r\n    }\r\n\r\n    get IS_RECORDING(): boolean {\r\n        return this.RECORDING_PHASE;\r\n    }\r\n\r\n    DEFINE_RULE(name: string, impl: RuleImpl): RuleResult {\r\n        return this.RULE(name, impl);\r\n    }\r\n\r\n    wrapSelfAnalysis(): void {\r\n        this.performSelfAnalysis();\r\n    }\r\n\r\n    wrapConsume(idx: number, tokenType: TokenType): IToken {\r\n        return this.consume(idx, tokenType);\r\n    }\r\n\r\n    wrapSubrule(idx: number, rule: RuleResult, args: Args): unknown {\r\n        return this.subrule(idx, rule, {\r\n            ARGS: [args]\r\n        });\r\n    }\r\n\r\n    wrapOr(idx: number, choices: Array<IOrAlt<any>>): void {\r\n        this.or(idx, choices);\r\n    }\r\n\r\n    wrapOption(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.option(idx, callback);\r\n    }\r\n\r\n    wrapMany(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.many(idx, callback);\r\n    }\r\n\r\n    wrapAtLeastOne(idx: number, callback: DSLMethodOpts<unknown>): void {\r\n        this.atLeastOne(idx, callback);\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CstNode } from '../syntax-tree.js';\r\n\r\nexport class ErrorWithLocation extends Error {\r\n    constructor(node: CstNode | undefined, message: string) {\r\n        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);\r\n    }\r\n}\r\n\r\nexport function assertUnreachable(_: never): never {\r\n    throw new Error('Error! The input value was not handled.');\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { IOrAlt, TokenType, TokenTypeDictionary } from 'chevrotain';\r\nimport type { AbstractElement, Action, Alternatives, Condition, CrossReference, Grammar, Group, Keyword, NamedArgument, ParserRule, RuleCall, UnorderedGroup } from '../grammar/generated/ast.js';\r\nimport type { BaseParser } from './langium-parser.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { Cardinality } from '../grammar/internal-grammar-util.js';\r\nimport { EMPTY_ALT, EOF } from 'chevrotain';\r\nimport { isAction, isAlternatives, isEndOfFile, isAssignment, isConjunction, isCrossReference, isDisjunction, isGroup, isKeyword, isLiteralCondition, isNegation, isParameterReference, isParserRule, isRuleCall, isTerminalRule, isUnorderedGroup } from '../grammar/generated/ast.js';\r\nimport { assertUnreachable, ErrorWithLocation } from '../utils/errors.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { getTypeName } from '../grammar/internal-grammar-util.js';\r\nimport { findNameAssignment, getAllReachableRules } from '../utils/grammar-util.js';\r\n\r\ntype RuleContext = {\r\n    optional: number,\r\n    consume: number,\r\n    subrule: number,\r\n    many: number,\r\n    or: number\r\n} & ParserContext;\r\n\r\ntype ParserContext = {\r\n    parser: BaseParser\r\n    tokens: TokenTypeDictionary\r\n    rules: Map<string, Rule>\r\n    ruleNames: Map<AstNode, string>\r\n}\r\n\r\ntype Rule = (args: Args) => unknown;\r\n\r\ntype Args = Record<string, boolean>;\r\n\r\ntype Predicate = (args: Args) => boolean;\r\n\r\ntype Method = (args: Args) => void;\r\n\r\nexport function createParser<T extends BaseParser>(grammar: Grammar, parser: T, tokens: TokenTypeDictionary): T {\r\n    const rules = new Map<string, Rule>();\r\n    const parserContext: ParserContext = {\r\n        parser,\r\n        tokens,\r\n        rules,\r\n        ruleNames: new Map()\r\n    };\r\n    buildRules(parserContext, grammar);\r\n    return parser;\r\n}\r\n\r\nfunction buildRules(parserContext: ParserContext, grammar: Grammar): void {\r\n    const reachable = getAllReachableRules(grammar, false);\r\n    const parserRules = stream(grammar.rules).filter(isParserRule).filter(rule => reachable.has(rule));\r\n    for (const rule of parserRules) {\r\n        const ctx: RuleContext = {\r\n            ...parserContext,\r\n            consume: 1,\r\n            optional: 1,\r\n            subrule: 1,\r\n            many: 1,\r\n            or: 1\r\n        };\r\n        ctx.rules.set(\r\n            rule.name,\r\n            parserContext.parser.rule(rule, buildElement(ctx, rule.definition))\r\n        );\r\n    }\r\n}\r\n\r\nfunction buildElement(ctx: RuleContext, element: AbstractElement, ignoreGuard = false): Method {\r\n    let method: Method;\r\n    if (isKeyword(element)) {\r\n        method = buildKeyword(ctx, element);\r\n    } else if (isAction(element)) {\r\n        method = buildAction(ctx, element);\r\n    } else if (isAssignment(element)) {\r\n        method = buildElement(ctx, element.terminal);\r\n    } else if (isCrossReference(element)) {\r\n        method = buildCrossReference(ctx, element);\r\n    } else if (isRuleCall(element)) {\r\n        method = buildRuleCall(ctx, element);\r\n    } else if (isAlternatives(element)) {\r\n        method = buildAlternatives(ctx, element);\r\n    } else if (isUnorderedGroup(element)) {\r\n        method = buildUnorderedGroup(ctx, element);\r\n    } else if (isGroup(element)) {\r\n        method = buildGroup(ctx, element);\r\n    } else if(isEndOfFile(element)) {\r\n        const idx = ctx.consume++;\r\n        method = () => ctx.parser.consume(idx, EOF, element);\r\n    } else {\r\n        throw new ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);\r\n    }\r\n    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);\r\n}\r\n\r\nfunction buildAction(ctx: RuleContext, action: Action): Method {\r\n    const actionType = getTypeName(action);\r\n    return () => ctx.parser.action(actionType, action);\r\n}\r\n\r\nfunction buildRuleCall(ctx: RuleContext, ruleCall: RuleCall): Method {\r\n    const rule = ruleCall.rule.ref;\r\n    if (isParserRule(rule)) {\r\n        const idx = ctx.subrule++;\r\n        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});\r\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), ruleCall, predicate(args));\r\n    } else if (isTerminalRule(rule)) {\r\n        const idx = ctx.consume++;\r\n        const method = getToken(ctx, rule.name);\r\n        return () => ctx.parser.consume(idx, method, ruleCall);\r\n    } else if (!rule) {\r\n        throw new ErrorWithLocation(ruleCall.$cstNode, `Undefined rule type: ${ruleCall.$type}`);\r\n    } else {\r\n        assertUnreachable(rule);\r\n    }\r\n}\r\n\r\nfunction buildRuleCallPredicate(rule: ParserRule, namedArgs: NamedArgument[]): (args: Args) => Args {\r\n    const predicates = namedArgs.map(e => buildPredicate(e.value));\r\n    return (args) => {\r\n        const ruleArgs: Args = {};\r\n        for (let i = 0; i < predicates.length; i++) {\r\n            const ruleTarget = rule.parameters[i];\r\n            const predicate = predicates[i];\r\n            ruleArgs[ruleTarget.name] = predicate(args);\r\n        }\r\n        return ruleArgs;\r\n    };\r\n}\r\n\r\ninterface PredicatedMethod {\r\n    ALT: Method,\r\n    GATE?: Predicate\r\n}\r\n\r\nfunction buildPredicate(condition: Condition): Predicate {\r\n    if (isDisjunction(condition)) {\r\n        const left = buildPredicate(condition.left);\r\n        const right = buildPredicate(condition.right);\r\n        return (args) => (left(args) || right(args));\r\n    } else if (isConjunction(condition)) {\r\n        const left = buildPredicate(condition.left);\r\n        const right = buildPredicate(condition.right);\r\n        return (args) => (left(args) && right(args));\r\n    } else if (isNegation(condition)) {\r\n        const value = buildPredicate(condition.value);\r\n        return (args) => !value(args);\r\n    } else if (isParameterReference(condition)) {\r\n        const name = condition.parameter.ref!.name;\r\n        return (args) => args !== undefined && args[name] === true;\r\n    } else if (isLiteralCondition(condition)) {\r\n        const value = Boolean(condition.true);\r\n        return () => value;\r\n    }\r\n    assertUnreachable(condition);\r\n}\r\n\r\nfunction buildAlternatives(ctx: RuleContext, alternatives: Alternatives): Method {\r\n    if (alternatives.elements.length === 1) {\r\n        return buildElement(ctx, alternatives.elements[0]);\r\n    } else {\r\n        const methods: PredicatedMethod[] = [];\r\n\r\n        for (const element of alternatives.elements) {\r\n            const predicatedMethod: PredicatedMethod = {\r\n                // Since we handle the guard condition in the alternative already\r\n                // We can ignore the group guard condition inside\r\n                ALT: buildElement(ctx, element, true)\r\n            };\r\n            const guard = getGuardCondition(element);\r\n            if (guard) {\r\n                predicatedMethod.GATE = buildPredicate(guard);\r\n            }\r\n            methods.push(predicatedMethod);\r\n        }\r\n\r\n        const idx = ctx.or++;\r\n        return (args) => ctx.parser.alternatives(idx, methods.map(method => {\r\n            const alt: IOrAlt<unknown> = {\r\n                ALT: () => method.ALT(args)\r\n            };\r\n            const gate = method.GATE;\r\n            if (gate) {\r\n                alt.GATE = () => gate(args);\r\n            }\r\n            return alt;\r\n        }));\r\n    }\r\n}\r\n\r\nfunction buildUnorderedGroup(ctx: RuleContext, group: UnorderedGroup): Method {\r\n    if (group.elements.length === 1) {\r\n        return buildElement(ctx, group.elements[0]);\r\n    }\r\n    const methods: PredicatedMethod[] = [];\r\n\r\n    for (const element of group.elements) {\r\n        const predicatedMethod: PredicatedMethod = {\r\n            // Since we handle the guard condition in the alternative already\r\n            // We can ignore the group guard condition inside\r\n            ALT: buildElement(ctx, element, true)\r\n        };\r\n        const guard = getGuardCondition(element);\r\n        if (guard) {\r\n            predicatedMethod.GATE = buildPredicate(guard);\r\n        }\r\n        methods.push(predicatedMethod);\r\n    }\r\n\r\n    const orIdx = ctx.or++;\r\n\r\n    const idFunc = (groupIdx: number, lParser: BaseParser) => {\r\n        const stackId = lParser.getRuleStack().join('-');\r\n        return `uGroup_${groupIdx}_${stackId}`;\r\n    };\r\n    const alternatives: Method = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {\r\n        const alt: IOrAlt<unknown> = { ALT: () => true };\r\n        const parser = ctx.parser;\r\n        alt.ALT = () => {\r\n            method.ALT(args);\r\n            if (!parser.isRecording()) {\r\n                const key = idFunc(orIdx, parser);\r\n                if (!parser.unorderedGroups.get(key)) {\r\n                    // init after clear state\r\n                    parser.unorderedGroups.set(key, []);\r\n                }\r\n                const groupState = parser.unorderedGroups.get(key)!;\r\n                if (typeof groupState?.[idx] === 'undefined') {\r\n                    // Not accessed yet\r\n                    groupState[idx] = true;\r\n                }\r\n            }\r\n        };\r\n        const gate = method.GATE;\r\n        if (gate) {\r\n            alt.GATE = () => gate(args);\r\n        } else {\r\n            alt.GATE = () => {\r\n                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));\r\n                const allow = !trackedAlternatives?.[idx];\r\n                return allow;\r\n            };\r\n        }\r\n        return alt;\r\n    }));\r\n    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');\r\n    return (args) => {\r\n        wrapped(args);\r\n        if (!ctx.parser.isRecording()) {\r\n            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));\r\n        }\r\n    };\r\n}\r\n\r\nfunction buildGroup(ctx: RuleContext, group: Group): Method {\r\n    const methods = group.elements.map(e => buildElement(ctx, e));\r\n    return (args) => methods.forEach(method => method(args));\r\n}\r\n\r\nfunction getGuardCondition(element: AbstractElement): Condition | undefined {\r\n    if (isGroup(element)) {\r\n        return element.guardCondition;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction buildCrossReference(ctx: RuleContext, crossRef: CrossReference, terminal = crossRef.terminal): Method {\r\n    if (!terminal) {\r\n        if (!crossRef.type.ref) {\r\n            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);\r\n        }\r\n        const assignment = findNameAssignment(crossRef.type.ref);\r\n        const assignTerminal = assignment?.terminal;\r\n        if (!assignTerminal) {\r\n            throw new Error('Could not find name assignment for type: ' + getTypeName(crossRef.type.ref));\r\n        }\r\n        return buildCrossReference(ctx, crossRef, assignTerminal);\r\n    } else if (isRuleCall(terminal) && isParserRule(terminal.rule.ref)) {\r\n        const idx = ctx.subrule++;\r\n        return (args) => ctx.parser.subrule(idx, getRule(ctx, terminal.rule.ref as ParserRule), crossRef, args);\r\n    } else if (isRuleCall(terminal) && isTerminalRule(terminal.rule.ref)) {\r\n        const idx = ctx.consume++;\r\n        const terminalRule = getToken(ctx, terminal.rule.ref.name);\r\n        return () => ctx.parser.consume(idx, terminalRule, crossRef);\r\n    } else if (isKeyword(terminal)) {\r\n        const idx = ctx.consume++;\r\n        const keyword = getToken(ctx, terminal.value);\r\n        return () => ctx.parser.consume(idx, keyword, crossRef);\r\n    }\r\n    else {\r\n        throw new Error('Could not build cross reference parser');\r\n    }\r\n}\r\n\r\nfunction buildKeyword(ctx: RuleContext, keyword: Keyword): Method {\r\n    const idx = ctx.consume++;\r\n    const token = ctx.tokens[keyword.value];\r\n    if (!token) {\r\n        throw new Error('Could not find token for keyword: ' + keyword.value);\r\n    }\r\n    return () => ctx.parser.consume(idx, token, keyword);\r\n}\r\n\r\nfunction wrap(ctx: RuleContext, guard: Condition | undefined, method: Method, cardinality: Cardinality): Method {\r\n    const gate = guard && buildPredicate(guard);\r\n\r\n    if (!cardinality) {\r\n        if (gate) {\r\n            const idx = ctx.or++;\r\n            return (args) => ctx.parser.alternatives(idx, [\r\n                {\r\n                    ALT: () => method(args),\r\n                    GATE: () => gate(args)\r\n                },\r\n                {\r\n                    ALT: EMPTY_ALT(),\r\n                    GATE: () => !gate(args)\r\n                }\r\n            ]);\r\n        } else {\r\n            return method;\r\n        }\r\n    }\r\n\r\n    if (cardinality === '*') {\r\n        const idx = ctx.many++;\r\n        return (args) => ctx.parser.many(idx, {\r\n            DEF: () => method(args),\r\n            GATE: gate ? () => gate(args) : undefined\r\n        });\r\n    } else if (cardinality === '+') {\r\n        const idx = ctx.many++;\r\n        if (gate) {\r\n            const orIdx = ctx.or++;\r\n            // In the case of a guard condition for the `+` group\r\n            // We combine it with an empty alternative\r\n            // If the condition returns true, it needs to parse at least a single iteration\r\n            // If its false, it is not allowed to parse anything\r\n            return (args) => ctx.parser.alternatives(orIdx, [\r\n                {\r\n                    ALT: () => ctx.parser.atLeastOne(idx, {\r\n                        DEF: () => method(args)\r\n                    }),\r\n                    GATE: () => gate(args)\r\n                },\r\n                {\r\n                    ALT: EMPTY_ALT(),\r\n                    GATE: () => !gate(args)\r\n                }\r\n            ]);\r\n        } else {\r\n            return (args) => ctx.parser.atLeastOne(idx, {\r\n                DEF: () => method(args),\r\n            });\r\n        }\r\n    } else if (cardinality === '?') {\r\n        const idx = ctx.optional++;\r\n        return (args) => ctx.parser.optional(idx, {\r\n            DEF: () => method(args),\r\n            GATE: gate ? () => gate(args) : undefined\r\n        });\r\n    } else {\r\n        assertUnreachable(cardinality);\r\n    }\r\n}\r\n\r\nfunction getRule(ctx: ParserContext, element: ParserRule | AbstractElement): Rule {\r\n    const name = getRuleName(ctx, element);\r\n    const rule = ctx.rules.get(name);\r\n    if (!rule) throw new Error(`Rule \"${name}\" not found.\"`);\r\n    return rule;\r\n}\r\n\r\nfunction getRuleName(ctx: ParserContext, element: ParserRule | AbstractElement): string {\r\n    if (isParserRule(element)) {\r\n        return element.name;\r\n    } else if (ctx.ruleNames.has(element)) {\r\n        return ctx.ruleNames.get(element)!;\r\n    } else {\r\n        let item: AstNode = element;\r\n        let parent: AstNode = item.$container!;\r\n        let ruleName: string = element.$type;\r\n        while (!isParserRule(parent)) {\r\n            if (isGroup(parent) || isAlternatives(parent) || isUnorderedGroup(parent)) {\r\n                const index = parent.elements.indexOf(item as AbstractElement);\r\n                ruleName = index.toString() + ':' + ruleName;\r\n            }\r\n            item = parent;\r\n            parent = parent.$container!;\r\n        }\r\n        const rule = parent as ParserRule;\r\n        ruleName = rule.name + ':' + ruleName;\r\n        ctx.ruleNames.set(element, ruleName);\r\n        return ruleName;\r\n    }\r\n}\r\n\r\nfunction getToken(ctx: ParserContext, name: string): TokenType {\r\n    const token = ctx.tokens[name];\r\n    if (!token) throw new Error(`Token \"${name}\" not found.\"`);\r\n    return token;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport { LangiumCompletionParser } from './langium-parser.js';\r\nimport { createParser } from './parser-builder-base.js';\r\n\r\nexport function createCompletionParser(services: LangiumServices): LangiumCompletionParser {\r\n    const grammar = services.Grammar;\r\n    const lexer = services.parser.Lexer;\r\n    const parser = new LangiumCompletionParser(services);\r\n    createParser(grammar, parser, lexer.definition);\r\n    parser.finalize();\r\n    return parser;\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport { LangiumParser } from './langium-parser.js';\r\nimport { createParser } from './parser-builder-base.js';\r\n\r\n/**\r\n * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is\r\n * available at `services.Grammar`.\r\n */\r\nexport function createLangiumParser(services: LangiumServices): LangiumParser {\r\n    const parser = prepareLangiumParser(services);\r\n    parser.finalize();\r\n    return parser;\r\n}\r\n\r\n/**\r\n * Create a Langium parser without finalizing it. This is used to extract more detailed error\r\n * information when the parser is initially validated.\r\n */\r\nexport function prepareLangiumParser(services: LangiumServices): LangiumParser {\r\n    const grammar = services.Grammar;\r\n    const lexer = services.parser.Lexer;\r\n    const parser = new LangiumParser(services);\r\n    return createParser(grammar, parser, lexer.definition);\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CustomPatternMatcherFunc, TokenPattern, TokenType, TokenVocabulary } from 'chevrotain';\r\nimport type { AbstractRule, Grammar, Keyword, TerminalRule } from '../grammar/generated/ast.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport { Lexer } from 'chevrotain';\r\nimport { isKeyword, isParserRule, isTerminalRule } from '../grammar/generated/ast.js';\r\nimport { terminalRegex } from '../grammar/internal-grammar-util.js';\r\nimport { streamAllContents } from '../utils/ast-util.js';\r\nimport { getAllReachableRules } from '../utils/grammar-util.js';\r\nimport { getCaseInsensitivePattern, isWhitespaceRegExp, partialMatches } from '../utils/regex-util.js';\r\nimport { stream } from '../utils/stream.js';\r\n\r\nexport interface TokenBuilderOptions {\r\n    caseInsensitive?: boolean\r\n}\r\n\r\nexport interface TokenBuilder {\r\n    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary;\r\n}\r\n\r\nexport class DefaultTokenBuilder implements TokenBuilder {\r\n\r\n    buildTokens(grammar: Grammar, options?: TokenBuilderOptions): TokenVocabulary {\r\n        const reachableRules = stream(getAllReachableRules(grammar, false));\r\n        const terminalTokens: TokenType[] = this.buildTerminalTokens(reachableRules);\r\n        const tokens: TokenType[] = this.buildKeywordTokens(reachableRules, terminalTokens, options);\r\n\r\n        terminalTokens.forEach(terminalToken => {\r\n            const pattern = terminalToken.PATTERN;\r\n            if (typeof pattern === 'object' && pattern && 'test' in pattern && isWhitespaceRegExp(pattern)) {\r\n                tokens.unshift(terminalToken);\r\n            } else {\r\n                tokens.push(terminalToken);\r\n            }\r\n        });\r\n        // We don't need to add the EOF token explicitly.\r\n        // It is automatically available at the end of the token stream.\r\n        return tokens;\r\n    }\r\n\r\n    protected buildTerminalTokens(rules: Stream<AbstractRule>): TokenType[] {\r\n        return rules.filter(isTerminalRule).filter(e => !e.fragment)\r\n            .map(terminal => this.buildTerminalToken(terminal)).toArray();\r\n    }\r\n\r\n    protected buildTerminalToken(terminal: TerminalRule): TokenType {\r\n        const regex = terminalRegex(terminal);\r\n        const pattern = regex.flags.includes('u') ? this.regexPatternFunction(regex) : regex;\r\n        const tokenType: TokenType = {\r\n            name: terminal.name,\r\n            PATTERN: pattern,\r\n            LINE_BREAKS: true\r\n        };\r\n        if (terminal.hidden) {\r\n            // Only skip tokens that are able to accept whitespace\r\n            tokenType.GROUP = isWhitespaceRegExp(regex) ? Lexer.SKIPPED : 'hidden';\r\n        }\r\n        return tokenType;\r\n    }\r\n\r\n    protected regexPatternFunction(regex: RegExp): CustomPatternMatcherFunc {\r\n        const stickyRegex = new RegExp(regex, regex.flags + 'y');\r\n        return (text, offset) => {\r\n            stickyRegex.lastIndex = offset;\r\n            const execResult = stickyRegex.exec(text);\r\n            return execResult;\r\n        };\r\n    }\r\n\r\n    protected buildKeywordTokens(rules: Stream<AbstractRule>, terminalTokens: TokenType[], options?: TokenBuilderOptions): TokenType[] {\r\n        return rules\r\n            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens\r\n            .filter(isParserRule)\r\n            .flatMap(rule => streamAllContents(rule).filter(isKeyword))\r\n            .distinct(e => e.value).toArray()\r\n            // Sort keywords by descending length\r\n            .sort((a, b) => b.value.length - a.value.length)\r\n            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options?.caseInsensitive)));\r\n    }\r\n\r\n    protected buildKeywordToken(keyword: Keyword, terminalTokens: TokenType[], caseInsensitive: boolean): TokenType {\r\n        return {\r\n            name: keyword.value,\r\n            PATTERN: this.buildKeywordPattern(keyword, caseInsensitive),\r\n            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)\r\n        };\r\n    }\r\n\r\n    protected buildKeywordPattern(keyword: Keyword, caseInsensitive: boolean): TokenPattern {\r\n        return caseInsensitive ?\r\n            new RegExp(getCaseInsensitivePattern(keyword.value)) :\r\n            keyword.value;\r\n    }\r\n\r\n    protected findLongerAlt(keyword: Keyword, terminalTokens: TokenType[]): TokenType[] {\r\n        return terminalTokens.reduce((longerAlts: TokenType[], token) => {\r\n            const pattern = token?.PATTERN as RegExp;\r\n            if (pattern?.source && partialMatches('^' + pattern.source + '$', keyword.value)) {\r\n                longerAlts.push(token);\r\n            }\r\n            return longerAlts;\r\n        }, []);\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AbstractElement, AbstractRule } from '../grammar/generated/ast.js';\r\nimport type { CstNode } from '../syntax-tree.js';\r\nimport { isCrossReference, isRuleCall } from '../grammar/generated/ast.js';\r\nimport { getRuleType } from '../grammar/internal-grammar-util.js';\r\nimport { getCrossReferenceTerminal } from '../utils/grammar-util.js';\r\n\r\n/**\r\n * Language-specific service for converting string values from the source text format into a value to be held in the AST.\r\n */\r\nexport interface ValueConverter {\r\n    /**\r\n     * Converts a string value from the source text format into a value to be held in the AST.\r\n     */\r\n    convert(input: string, cstNode: CstNode): ValueType;\r\n}\r\n\r\nexport type ValueType = string | number | boolean | bigint | Date;\r\n\r\nexport class DefaultValueConverter implements ValueConverter {\r\n\r\n    convert(input: string, cstNode: CstNode): ValueType {\r\n        let feature: AbstractElement | undefined = cstNode.grammarSource;\r\n        if (isCrossReference(feature)) {\r\n            feature = getCrossReferenceTerminal(feature);\r\n        }\r\n        if (isRuleCall(feature)) {\r\n            const rule = feature.rule.ref;\r\n            if (!rule) {\r\n                throw new Error('This cst node was not parsed by a rule.');\r\n            }\r\n            return this.runConverter(rule, input, cstNode);\r\n        }\r\n        return input;\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    protected runConverter(rule: AbstractRule, input: string, cstNode: CstNode): ValueType {\r\n        switch (rule.name.toUpperCase()) {\r\n            case 'INT': return convertInt(input);\r\n            case 'STRING': return convertString(input);\r\n            case 'ID': return convertID(input);\r\n        }\r\n        switch (getRuleType(rule)?.toLowerCase()) {\r\n            case 'number': return convertNumber(input);\r\n            case 'boolean': return convertBoolean(input);\r\n            case 'bigint': return convertBigint(input);\r\n            case 'date': return convertDate(input);\r\n            default: return input;\r\n        }\r\n    }\r\n}\r\n\r\nexport function convertString(input: string): string {\r\n    let result = '';\r\n    for (let i = 1; i < input.length - 1; i++) {\r\n        const c = input.charAt(i);\r\n        if (c === '\\\\') {\r\n            const c1 = input.charAt(++i);\r\n            result += convertEscapeCharacter(c1);\r\n        } else {\r\n            result += c;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\nfunction convertEscapeCharacter(char: string): string {\r\n    switch (char) {\r\n        case 'b': return '\\b';\r\n        case 'f': return '\\f';\r\n        case 'n': return '\\n';\r\n        case 'r': return '\\r';\r\n        case 't': return '\\t';\r\n        case 'v': return '\\v';\r\n        case '0': return '\\0';\r\n        default: return char;\r\n    }\r\n}\r\n\r\nexport function convertID(input: string): string {\r\n    if (input.charAt(0) === '^') {\r\n        return input.substring(1);\r\n    } else {\r\n        return input;\r\n    }\r\n}\r\n\r\nexport function convertInt(input: string): number {\r\n    return parseInt(input);\r\n}\r\n\r\nexport function convertBigint(input: string): bigint {\r\n    return BigInt(input);\r\n}\r\n\r\nexport function convertDate(input: string): Date {\r\n    return new Date(input);\r\n}\r\n\r\nexport function convertNumber(input: string): number {\r\n    return Number(input);\r\n}\r\n\r\nexport function convertBoolean(input: string): boolean {\r\n    return input.toLowerCase() === 'true';\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection, CstNode, LinkingError, Reference, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { LangiumDocument, LangiumDocuments } from '../workspace/documents.js';\r\nimport type { ScopeProvider } from './scope-provider.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { isAstNode, isAstNodeDescription, isLinkingError } from '../syntax-tree.js';\r\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-util.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\nimport { DocumentState } from '../workspace/documents.js';\r\n\r\n/**\r\n * Language-specific service for resolving cross-references in the AST.\r\n */\r\nexport interface Linker {\r\n\r\n    /**\r\n     * Links all cross-references within the specified document. The default implementation loads only target\r\n     * elements from documents that are present in the `LangiumDocuments` service. The linked references are\r\n     * stored in the document's `references` property.\r\n     *\r\n     * @param document A LangiumDocument that shall be linked.\r\n     * @param cancelToken A token for cancelling the operation.\r\n     */\r\n    link(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Unlinks all references within the specified document and removes them from the list of `references`.\r\n     *\r\n     * @param document A LangiumDocument that shall be unlinked.\r\n     */\r\n    unlink(document: LangiumDocument): void;\r\n\r\n    /**\r\n     * Determines a candidate AST node description for linking the given reference.\r\n     *\r\n     * @param node The AST node containing the reference.\r\n     * @param refId The reference identifier used to build a scope.\r\n     * @param reference The actual reference to resolve.\r\n     */\r\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError;\r\n\r\n    /**\r\n     * Creates a cross reference node being aware of its containing AstNode, the corresponding CstNode,\r\n     * the cross reference text denoting the target AstNode being already extracted of the document text,\r\n     * as well as the unique cross reference identifier.\r\n     *\r\n     * Default behavior:\r\n     *  - The returned Reference's 'ref' property pointing to the target AstNode is populated lazily on its\r\n     *    first visit.\r\n     *  - If the target AstNode cannot be resolved on the first visit, an error indicator will be installed\r\n     *    and further resolution attempts will *not* be performed.\r\n     *\r\n     * @param node The containing AST node\r\n     * @param refNode The corresponding CST node\r\n     * @param refId The cross reference identifier like '<entityTypeName>:<propertyName>'\r\n     * @param refText The cross reference text denoting the target AstNode\r\n     * @returns the desired Reference node, whose behavior wrt. resolving the cross reference is implementation specific.\r\n     */\r\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference;\r\n\r\n}\r\n\r\ninterface DefaultReference extends Reference {\r\n    _ref?: AstNode | LinkingError;\r\n    _nodeDescription?: AstNodeDescription;\r\n}\r\n\r\nexport class DefaultLinker implements Linker {\r\n    protected readonly reflection: AstReflection;\r\n    protected readonly scopeProvider: ScopeProvider;\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly langiumDocuments: () => LangiumDocuments;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.reflection = services.shared.AstReflection;\r\n        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;\r\n        this.scopeProvider = services.references.ScopeProvider;\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    async link(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        for (const node of streamAst(document.parseResult.value)) {\r\n            await interruptAndCheck(cancelToken);\r\n            streamReferences(node).forEach(ref => this.doLink(ref, document));\r\n        }\r\n    }\r\n\r\n    protected doLink(refInfo: ReferenceInfo, document: LangiumDocument): void {\r\n        const ref = refInfo.reference as DefaultReference;\r\n        // The reference may already have been resolved lazily by accessing its `ref` property.\r\n        if (ref._ref === undefined) {\r\n            try {\r\n                const description = this.getCandidate(refInfo);\r\n                if (isLinkingError(description)) {\r\n                    ref._ref = description;\r\n                } else {\r\n                    ref._nodeDescription = description;\r\n                    if (this.langiumDocuments().hasDocument(description.documentUri)) {\r\n                        // The target document is already loaded\r\n                        const linkedNode = this.loadAstNode(description);\r\n                        ref._ref = linkedNode ?? this.createLinkingError(refInfo, description);\r\n                    }\r\n                }\r\n            } catch (err) {\r\n                ref._ref = {\r\n                    ...refInfo,\r\n                    message: `An error occurred while resolving reference to '${ref.$refText}': ${err}`\r\n                };\r\n            }\r\n        }\r\n        // Add the reference to the document's array of references\r\n        document.references.push(ref);\r\n    }\r\n\r\n    unlink(document: LangiumDocument): void {\r\n        for (const ref of document.references) {\r\n            delete (ref as DefaultReference)._ref;\r\n            delete (ref as DefaultReference)._nodeDescription;\r\n        }\r\n        document.references = [];\r\n    }\r\n\r\n    getCandidate(refInfo: ReferenceInfo): AstNodeDescription | LinkingError {\r\n        const scope = this.scopeProvider.getScope(refInfo);\r\n        const description = scope.getElement(refInfo.reference.$refText);\r\n        return description ?? this.createLinkingError(refInfo);\r\n    }\r\n\r\n    buildReference(node: AstNode, property: string, refNode: CstNode | undefined, refText: string): Reference {\r\n        // See behavior description in doc of Linker, update that on changes in here.\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const linker = this;\r\n        const reference: DefaultReference = {\r\n            $refNode: refNode,\r\n            $refText: refText,\r\n\r\n            get ref() {\r\n                if (isAstNode(this._ref)) {\r\n                    // Most frequent case: the target is already resolved.\r\n                    return this._ref;\r\n                } else if (isAstNodeDescription(this._nodeDescription)) {\r\n                    // A candidate has been found before, but it is not loaded yet.\r\n                    const linkedNode = linker.loadAstNode(this._nodeDescription);\r\n                    this._ref = linkedNode ??\r\n                        linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);\r\n                } else if (this._ref === undefined) {\r\n                    // The reference has not been linked yet, so do that now.\r\n                    const refData = linker.getLinkedNode({ reference, container: node, property });\r\n                    if (refData.error && getDocument(node).state < DocumentState.ComputedScopes) {\r\n                        // Document scope is not ready, don't set `this._ref` so linker can retry later.\r\n                        return undefined;\r\n                    }\r\n                    this._ref = refData.node ?? refData.error;\r\n                    this._nodeDescription = refData.descr;\r\n                }\r\n                return isAstNode(this._ref) ? this._ref : undefined;\r\n            },\r\n            get $nodeDescription() {\r\n                return this._nodeDescription;\r\n            },\r\n            get error() {\r\n                return isLinkingError(this._ref) ? this._ref : undefined;\r\n            }\r\n        };\r\n        return reference;\r\n    }\r\n\r\n    protected getLinkedNode(refInfo: ReferenceInfo): { node?: AstNode, descr?: AstNodeDescription, error?: LinkingError } {\r\n        try {\r\n            const description = this.getCandidate(refInfo);\r\n            if (isLinkingError(description)) {\r\n                return { error: description };\r\n            }\r\n            const linkedNode = this.loadAstNode(description);\r\n            if (linkedNode) {\r\n                return { node: linkedNode, descr: description };\r\n            }\r\n            else {\r\n                return {\r\n                    descr: description,\r\n                    error:\r\n                        this.createLinkingError(refInfo, description)\r\n                };\r\n            }\r\n        } catch (err) {\r\n            return {\r\n                error: {\r\n                    ...refInfo,\r\n                    message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${err}`\r\n                }\r\n            };\r\n        }\r\n    }\r\n\r\n    protected loadAstNode(nodeDescription: AstNodeDescription): AstNode | undefined {\r\n        if (nodeDescription.node) {\r\n            return nodeDescription.node;\r\n        }\r\n        const doc = this.langiumDocuments().getOrCreateDocument(nodeDescription.documentUri);\r\n        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);\r\n    }\r\n\r\n    protected createLinkingError(refInfo: ReferenceInfo, targetDescription?: AstNodeDescription): LinkingError {\r\n        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug\r\n        // in the language implementation.\r\n        const document = getDocument(refInfo.container);\r\n        if (document.state < DocumentState.ComputedScopes) {\r\n            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);\r\n        }\r\n        const referenceType = this.reflection.getReferenceType(refInfo);\r\n        return {\r\n            ...refInfo,\r\n            message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`,\r\n            targetDescription\r\n        };\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, CstNode, GenericAstNode, Reference } from '../syntax-tree.js';\r\nimport type { Mutable } from '../utils/ast-util.js';\r\nimport type { AstNodeLocator } from '../workspace/ast-node-locator.js';\r\nimport type { DocumentSegment } from '../workspace/documents.js';\r\nimport { isAstNode, isReference } from '../syntax-tree.js';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { findNodesForProperty } from '../utils/grammar-util.js';\r\nimport type { CommentProvider } from '../documentation/comment-provider.js';\r\n\r\nexport interface JsonSerializeOptions {\r\n    space?: string | number;\r\n    refText?: boolean;\r\n    sourceText?: boolean;\r\n    textRegions?: boolean;\r\n    comments?: boolean;\r\n    replacer?: (key: string, value: unknown, defaultReplacer: (key: string, value: unknown) => unknown) => unknown\r\n}\r\n\r\n/**\r\n * {@link AstNode}s that may carry information on their definition area within the DSL text.\r\n */\r\nexport interface AstNodeWithTextRegion extends AstNode {\r\n    $sourceText?: string;\r\n    $textRegion?: AstNodeRegionWithAssignments;\r\n}\r\n\r\n/**\r\n * {@link AstNode}s that may carry a semantically relevant comment.\r\n */\r\nexport interface AstNodeWithComment extends AstNode {\r\n    $comment?: string;\r\n}\r\n\r\nexport function isAstNodeWithComment(node: AstNode): node is AstNodeWithComment {\r\n    return typeof (node as AstNodeWithComment).$comment === 'string';\r\n}\r\n\r\n/**\r\n * A {@DocumentSegment} representing the definition area of an AstNode within the DSL text.\r\n * Usually contains text region information on all assigned property values of the AstNode,\r\n * and may contain the defining file's URI as string.\r\n */\r\nexport interface AstNodeRegionWithAssignments extends DocumentSegment {\r\n    /**\r\n     * A record containing an entry for each assignd property of the AstNode.\r\n     * The key is equal to the property name and the value is an array of the property values'\r\n     * text regions, regardless of whether the property is a single value or list property.\r\n     */\r\n    assignments?: Record<string, DocumentSegment[]>;\r\n    /**\r\n     * The AstNode defining file's URI as string\r\n     */\r\n    documentURI?: string;\r\n}\r\n\r\n/**\r\n * Utility service for transforming an `AstNode` into a JSON string and vice versa.\r\n */\r\nexport interface JsonSerializer {\r\n    /**\r\n     * Serialize an `AstNode` into a JSON `string`.\r\n     * @param node The `AstNode` to be serialized.\r\n     * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.\r\n     */\r\n    serialize(node: AstNode, options?: JsonSerializeOptions): string;\r\n    /**\r\n     * Deserialize (parse) a JSON `string` into an `AstNode`.\r\n     */\r\n    deserialize(content: string): AstNode;\r\n}\r\n\r\ninterface IntermediateReference {\r\n    $refText?: string\r\n    $ref?: string\r\n    $error?: string\r\n}\r\n\r\nfunction isIntermediateReference(obj: unknown): obj is IntermediateReference {\r\n    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);\r\n}\r\n\r\nexport class DefaultJsonSerializer implements JsonSerializer {\r\n\r\n    protected ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly nameProvider: NameProvider;\r\n    protected readonly commentProvider: CommentProvider;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n        this.nameProvider = services.references.NameProvider;\r\n        this.commentProvider = services.documentation.CommentProvider;\r\n    }\r\n\r\n    serialize(node: AstNode, options?: JsonSerializeOptions): string {\r\n        const specificReplacer = options?.replacer;\r\n        const defaultReplacer = (key: string, value: unknown) => this.replacer(key, value, options);\r\n        const replacer = specificReplacer ? (key: string, value: unknown) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;\r\n\r\n        return JSON.stringify(node, replacer, options?.space);\r\n    }\r\n\r\n    deserialize(content: string): AstNode {\r\n        const root = JSON.parse(content);\r\n        this.linkNode(root, root);\r\n        return root;\r\n    }\r\n\r\n    protected replacer(key: string, value: unknown, { refText, sourceText, textRegions, comments }: JsonSerializeOptions = {}): unknown {\r\n        if (this.ignoreProperties.has(key)) {\r\n            return undefined;\r\n        } else if (isReference(value)) {\r\n            const refValue = value.ref;\r\n            const $refText = refText ? value.$refText : undefined;\r\n            if (refValue) {\r\n                return {\r\n                    $refText,\r\n                    $ref: '#' + (refValue && this.astNodeLocator.getAstNodePath(refValue))\r\n                };\r\n            } else {\r\n                return {\r\n                    $refText,\r\n                    $error: value.error?.message ?? 'Could not resolve reference'\r\n                };\r\n            }\r\n        } else {\r\n            let astNode: AstNodeWithTextRegion | undefined = undefined;\r\n            if (textRegions && isAstNode(value)) {\r\n                astNode = this.addAstNodeRegionWithAssignmentsTo({ ...value });\r\n                if ((!key || value.$document) && astNode?.$textRegion) {\r\n                    try {\r\n                        astNode.$textRegion.documentURI = getDocument(value).uri.toString();\r\n                    } catch (e) { /* do nothing */ }\r\n                }\r\n            }\r\n            if (sourceText && !key && isAstNode(value)) {\r\n                astNode ??= { ...value };\r\n                astNode.$sourceText = value.$cstNode?.text;\r\n            }\r\n            if (comments && isAstNode(value)) {\r\n                astNode ??= { ...value };\r\n                (astNode as AstNodeWithComment).$comment = this.commentProvider.getComment(value);\r\n            }\r\n            return astNode ?? value;\r\n        }\r\n    }\r\n\r\n    protected addAstNodeRegionWithAssignmentsTo(node: AstNodeWithTextRegion) {\r\n        const createDocumentSegment: (cstNode: CstNode) => AstNodeRegionWithAssignments = cstNode => <DocumentSegment>{\r\n            offset: cstNode.offset,\r\n            end: cstNode.end,\r\n            length: cstNode.length,\r\n            range: cstNode.range,\r\n        };\r\n\r\n        if (node.$cstNode) {\r\n            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);\r\n            const assignments: Record<string, DocumentSegment[]> = textRegion.assignments = {};\r\n\r\n            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {\r\n                const propertyAssignments = findNodesForProperty(node.$cstNode, key).map(createDocumentSegment);\r\n                if (propertyAssignments.length !== 0) {\r\n                    assignments[key] = propertyAssignments;\r\n                }\r\n            });\r\n\r\n            return node;\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected linkNode(node: GenericAstNode, root: AstNode, container?: AstNode, containerProperty?: string, containerIndex?: number) {\r\n        for (const [propertyName, item] of Object.entries(node)) {\r\n            if (Array.isArray(item)) {\r\n                for (let index = 0; index < item.length; index++) {\r\n                    const element = item[index];\r\n                    if (isIntermediateReference(element)) {\r\n                        item[index] = this.reviveReference(node, propertyName, root, element);\r\n                    } else if (isAstNode(element)) {\r\n                        this.linkNode(element as GenericAstNode, root, node, propertyName, index);\r\n                    }\r\n                }\r\n            } else if (isIntermediateReference(item)) {\r\n                node[propertyName] = this.reviveReference(node, propertyName, root, item);\r\n            } else if (isAstNode(item)) {\r\n                this.linkNode(item as GenericAstNode, root, node, propertyName);\r\n            }\r\n        }\r\n        const mutable = node as Mutable<GenericAstNode>;\r\n        mutable.$container = container;\r\n        mutable.$containerProperty = containerProperty;\r\n        mutable.$containerIndex = containerIndex;\r\n    }\r\n\r\n    protected reviveReference(container: AstNode, property: string, root: AstNode, reference: IntermediateReference): Reference | undefined {\r\n        let refText = reference.$refText;\r\n        if (reference.$ref) {\r\n            const ref = this.getRefNode(root, reference.$ref);\r\n            if (!refText) {\r\n                refText = this.nameProvider.getName(ref);\r\n            }\r\n            return {\r\n                $refText: refText ?? '',\r\n                ref\r\n            };\r\n        } else if (reference.$error) {\r\n            const ref: Mutable<Reference> = {\r\n                $refText: refText ?? ''\r\n            };\r\n            ref.error = {\r\n                container,\r\n                property,\r\n                message: reference.$error,\r\n                reference: ref\r\n            };\r\n            return ref;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    protected getRefNode(root: AstNode, path: string): AstNode {\r\n        return this.astNodeLocator.getAstNode(root, path.substring(1))!;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from './services.js';\r\nimport { UriUtils, type URI } from './utils/uri-util.js';\r\n\r\n/**\r\n * The service registry provides access to the language-specific services. These are resolved\r\n * via the URI of a text document.\r\n */\r\nexport interface ServiceRegistry {\r\n\r\n    /**\r\n     * Register a language via its injected services.\r\n     */\r\n    register(language: LangiumServices): void;\r\n\r\n    /**\r\n     * Retrieve the language-specific services for the given URI. In case only one language is\r\n     * registered, it may be used regardless of the URI format.\r\n     */\r\n    getServices(uri: URI): LangiumServices;\r\n\r\n    /**\r\n     * The full set of registered language services.\r\n     */\r\n    readonly all: readonly LangiumServices[];\r\n}\r\n\r\nexport class DefaultServiceRegistry implements ServiceRegistry {\r\n\r\n    protected singleton?: LangiumServices;\r\n    protected map?: Record<string, LangiumServices>;\r\n\r\n    register(language: LangiumServices): void {\r\n        if (!this.singleton && !this.map) {\r\n            // This is the first language to be registered; store it as singleton.\r\n            this.singleton = language;\r\n            return;\r\n        }\r\n        if (!this.map) {\r\n            this.map = {};\r\n            if (this.singleton) {\r\n                // Move the previous singleton instance to the new map.\r\n                for (const ext of this.singleton.LanguageMetaData.fileExtensions) {\r\n                    this.map[ext] = this.singleton;\r\n                }\r\n                this.singleton = undefined;\r\n            }\r\n        }\r\n        // Store the language services in the map.\r\n        for (const ext of language.LanguageMetaData.fileExtensions) {\r\n            if (this.map[ext] !== undefined && this.map[ext] !== language) {\r\n                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${language.LanguageMetaData.languageId}'.`);\r\n            }\r\n            this.map[ext] = language;\r\n        }\r\n    }\r\n\r\n    getServices(uri: URI): LangiumServices {\r\n        if (this.singleton !== undefined) {\r\n            return this.singleton;\r\n        }\r\n        if (this.map === undefined) {\r\n            throw new Error('The service registry is empty. Use `register` to register the services of a language.');\r\n        }\r\n        const ext = UriUtils.extname(uri);\r\n        const services = this.map[ext];\r\n        if (!services) {\r\n            throw new Error(`The service registry contains no services for the extension '${ext}'.`);\r\n        }\r\n        return services;\r\n    }\r\n\r\n    get all(): readonly LangiumServices[] {\r\n        if (this.singleton !== undefined) {\r\n            return [this.singleton];\r\n        }\r\n        if (this.map !== undefined) {\r\n            return Object.values(this.map);\r\n        }\r\n        return [];\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-util.js';\r\nimport type { NameProvider } from '../references/name-provider.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, ReferenceInfo } from '../syntax-tree.js';\r\nimport type { AstNodeLocator } from './ast-node-locator.js';\r\nimport type { DocumentSegment, LangiumDocument } from './documents.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { isLinkingError } from '../syntax-tree.js';\r\nimport { getDocument, streamAst, streamReferences } from '../utils/ast-util.js';\r\nimport { toDocumentSegment } from '../utils/cst-util.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\nimport { UriUtils } from '../utils/uri-util.js';\r\n\r\n/**\r\n * Language-specific service for creating descriptions of AST nodes to be used for cross-reference resolutions.\r\n */\r\nexport interface AstNodeDescriptionProvider {\r\n\r\n    /**\r\n     * Create a description for the given AST node. This service method is typically used while indexing\r\n     * the contents of a document and during scope computation.\r\n     *\r\n     * @param node An AST node.\r\n     * @param name The name to be used to refer to the AST node. By default, this is determined by the\r\n     *     `NameProvider` service, but alternative names may be provided according to the semantics\r\n     *     of your language.\r\n     * @param document The document containing the AST node. If omitted, it is taken from the root AST node.\r\n     */\r\n    createDescription(node: AstNode, name: string | undefined, document?: LangiumDocument): AstNodeDescription;\r\n\r\n}\r\n\r\nexport class DefaultAstNodeDescriptionProvider implements AstNodeDescriptionProvider {\r\n\r\n    protected readonly astNodeLocator: AstNodeLocator;\r\n    protected readonly nameProvider: NameProvider;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.astNodeLocator = services.workspace.AstNodeLocator;\r\n        this.nameProvider = services.references.NameProvider;\r\n    }\r\n\r\n    createDescription(node: AstNode, name: string | undefined, document: LangiumDocument = getDocument(node)): AstNodeDescription {\r\n        name ??= this.nameProvider.getName(node);\r\n        const path = this.astNodeLocator.getAstNodePath(node);\r\n        if (!name) {\r\n            throw new Error(`Node at path ${path} has no name.`);\r\n        }\r\n        let nameNodeSegment: DocumentSegment | undefined;\r\n        const nameSegmentGetter = () => nameNodeSegment ??= toDocumentSegment(this.nameProvider.getNameNode(node) ?? node.$cstNode);\r\n        return {\r\n            node,\r\n            name,\r\n            get nameSegment() {\r\n                return nameSegmentGetter();\r\n            },\r\n            selectionSegment: toDocumentSegment(node.$cstNode),\r\n            type: node.$type,\r\n            documentUri: document.uri,\r\n            path\r\n        };\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Describes a cross-reference within a document or between two documents.\r\n */\r\nexport interface ReferenceDescription {\r\n    /** URI of the document that holds a reference */\r\n    sourceUri: URI\r\n    /** Path to AstNode that holds a reference */\r\n    sourcePath: string\r\n    /** Target document uri */\r\n    targetUri: URI\r\n    /** Path to the target AstNode inside the document */\r\n    targetPath: string\r\n    /** Segment of the reference text. */\r\n    segment: DocumentSegment\r\n    /** Marks a local reference i.e. a cross reference inside a document.   */\r\n    local?: boolean\r\n}\r\n\r\n/**\r\n * Language-specific service to create descriptions of all cross-references in a document. These are used by the `IndexManager`\r\n * to determine which documents are affected and should be rebuilt when a document is changed.\r\n */\r\nexport interface ReferenceDescriptionProvider {\r\n    /**\r\n     * Create descriptions of all cross-references found in the given document. These descriptions are\r\n     * gathered by the `IndexManager` and stored in the global index so they can be considered when\r\n     * a document change is reported by the client.\r\n     *\r\n     * @param document The document in which to gather cross-references.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    createDescriptions(document: LangiumDocument, cancelToken?: CancellationToken): Promise<ReferenceDescription[]>;\r\n}\r\n\r\nexport class DefaultReferenceDescriptionProvider implements ReferenceDescriptionProvider {\r\n\r\n    protected readonly nodeLocator: AstNodeLocator;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.nodeLocator = services.workspace.AstNodeLocator;\r\n    }\r\n\r\n    async createDescriptions(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<ReferenceDescription[]> {\r\n        const descr: ReferenceDescription[] = [];\r\n        const rootNode = document.parseResult.value;\r\n        for (const astNode of streamAst(rootNode)) {\r\n            await interruptAndCheck(cancelToken);\r\n            streamReferences(astNode).filter(refInfo => !isLinkingError(refInfo)).forEach(refInfo => {\r\n                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked\r\n                const description = this.createDescription(refInfo);\r\n                if (description) {\r\n                    descr.push(description);\r\n                }\r\n            });\r\n        }\r\n        return descr;\r\n    }\r\n\r\n    protected createDescription(refInfo: ReferenceInfo): ReferenceDescription | undefined {\r\n        const targetNodeDescr = refInfo.reference.$nodeDescription;\r\n        const refCstNode = refInfo.reference.$refNode;\r\n        if (!targetNodeDescr || !refCstNode) {\r\n            return undefined;\r\n        }\r\n        const docUri = getDocument(refInfo.container).uri;\r\n        return {\r\n            sourceUri: docUri,\r\n            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),\r\n            targetUri: targetNodeDescr.documentUri,\r\n            targetPath: targetNodeDescr.path,\r\n            segment: toDocumentSegment(refCstNode),\r\n            local: UriUtils.equals(targetNodeDescr.documentUri, docUri)\r\n        };\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { AstNode } from '../syntax-tree.js';\r\n\r\n/**\r\n * Language-specific service for locating an `AstNode` in a document.\r\n */\r\nexport interface AstNodeLocator {\r\n\r\n    /**\r\n     * Creates a path represented by a `string` that identifies an `AstNode` inside its document.\r\n     * It must be possible to retrieve exactly the same `AstNode` from the document using this path.\r\n     *\r\n     * @param node The `AstNode` for which to create the path.\r\n     * @returns a path represented by a `string` that identifies `node` inside its document.\r\n     * @see AstNodeLocator.getAstNode\r\n     */\r\n    getAstNodePath(node: AstNode): string;\r\n\r\n    /**\r\n     * Locates an `AstNode` inside another node by following the given path.\r\n     *\r\n     * @param node Parent element.\r\n     * @param path Describes how to locate the `AstNode` inside the given `node`.\r\n     * @returns The `AstNode` located under the given path, or `undefined` if the path cannot be resolved.\r\n     * @see AstNodeLocator.getAstNodePath\r\n     */\r\n    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined;\r\n\r\n}\r\n\r\nexport class DefaultAstNodeLocator implements AstNodeLocator {\r\n    protected segmentSeparator = '/';\r\n    protected indexSeparator = '@';\r\n\r\n    getAstNodePath(node: AstNode): string {\r\n        if (node.$container) {\r\n            const containerPath = this.getAstNodePath(node.$container);\r\n            const newSegment = this.getPathSegment(node);\r\n            const nodePath = containerPath + this.segmentSeparator + newSegment;\r\n            return nodePath;\r\n        }\r\n        return '';\r\n    }\r\n\r\n    protected getPathSegment({ $containerProperty, $containerIndex }: AstNode): string {\r\n        if (!$containerProperty) {\r\n            throw new Error(\"Missing '$containerProperty' in AST node.\");\r\n        }\r\n        if ($containerIndex !== undefined) {\r\n            return $containerProperty + this.indexSeparator + $containerIndex;\r\n        }\r\n        return $containerProperty;\r\n    }\r\n\r\n    getAstNode<T extends AstNode = AstNode>(node: AstNode, path: string): T | undefined {\r\n        const segments = path.split(this.segmentSeparator);\r\n        return segments.reduce((previousValue, currentValue) => {\r\n            if (!previousValue || currentValue.length === 0) {\r\n                return previousValue;\r\n            }\r\n            const propertyIndex = currentValue.indexOf(this.indexSeparator);\r\n            if (propertyIndex > 0) {\r\n                const property = currentValue.substring(0, propertyIndex);\r\n                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));\r\n                const array = (previousValue as unknown as Record<string, AstNode[]>)[property];\r\n                return array?.[arrayIndex];\r\n            }\r\n            return (previousValue as unknown as Record<string, AstNode>)[currentValue];\r\n        }, node) as T;\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { Connection, DidChangeConfigurationParams } from 'vscode-languageserver';\r\nimport type { ConfigurationItem } from 'vscode-languageserver-protocol';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedServices } from '../services.js';\r\nimport { DidChangeConfigurationNotification } from 'vscode-languageserver-protocol';\r\n\r\n/* eslint-disable @typescript-eslint/no-explicit-any */\r\n\r\nexport interface ConfigurationProvider {\r\n    /**\r\n    * Returns a configuration value stored for the given language.\r\n    *\r\n    * @param language The language id\r\n    * @param configuration Configuration name\r\n    */\r\n    getConfiguration(language: string, configuration: string): Promise<any>;\r\n\r\n    /**\r\n     *  Updates the cached configurations using the `change` notification parameters.\r\n     *\r\n     * @param change The parameters of a change configuration notification.\r\n     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`\r\n     */\r\n    updateConfiguration(change: DidChangeConfigurationParams): void;\r\n}\r\n\r\nexport class DefaultConfigurationProvider implements ConfigurationProvider {\r\n\r\n    protected settings: Record<string, Record<string, any>> = {};\r\n    protected workspaceConfig = false;\r\n    protected initialized = false;\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly connection: Connection | undefined;\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.connection = services.lsp.Connection;\r\n        services.lsp.LanguageServer.onInitialize(params => {\r\n            this.workspaceConfig = params.capabilities.workspace?.configuration ?? false;\r\n        });\r\n        services.lsp.LanguageServer.onInitialized(_params => {\r\n            const languages = this.serviceRegistry.all;\r\n            services.lsp.Connection?.client.register(DidChangeConfigurationNotification.type, {\r\n                // Listen to configuration changes for all languages\r\n                section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))\r\n            });\r\n        });\r\n    }\r\n\r\n    protected async initialize(): Promise<void> {\r\n        if (this.workspaceConfig && this.connection) {\r\n            const languages = this.serviceRegistry.all;\r\n            const configToUpdate: ConfigurationItem[] = languages.map(lang => { return { section: this.toSectionName(lang.LanguageMetaData.languageId) }; });\r\n            // get workspace configurations (default scope URI)\r\n            const configs = await this.connection.workspace.getConfiguration(configToUpdate);\r\n            configToUpdate.forEach((conf, idx) => {\r\n                this.updateSectionConfiguration(conf.section!, configs[idx]);\r\n            });\r\n        }\r\n        this.initialized = true;\r\n    }\r\n\r\n    updateConfiguration(change: DidChangeConfigurationParams): void {\r\n        if (!change.settings) {\r\n            return;\r\n        }\r\n        Object.keys(change.settings).forEach(section => {\r\n            this.updateSectionConfiguration(section, change.settings[section]);\r\n        });\r\n    }\r\n\r\n    protected updateSectionConfiguration(section: string, configuration: any): void {\r\n        this.settings[section] = configuration;\r\n    }\r\n\r\n    async getConfiguration(language: string, configuration: string): Promise<any> {\r\n        if (!this.initialized) {\r\n            await this.initialize();\r\n        }\r\n        const sectionName = this.toSectionName(language);\r\n        if (this.settings[sectionName]) {\r\n            return this.settings[sectionName][configuration];\r\n        }\r\n    }\r\n\r\n    protected toSectionName(languageId: string): string {\r\n        return `${languageId}`;\r\n    }\r\n}\r\n\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-util.js';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport type { MaybePromise } from '../utils/promise-util.js';\r\nimport type { ValidationOptions } from '../validation/document-validator.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { LangiumDocument, LangiumDocuments, LangiumDocumentFactory } from './documents.js';\r\nimport { CancellationToken, Disposable } from 'vscode-languageserver';\r\nimport { MultiMap } from '../utils/collections.js';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { ValidationCategory } from '../validation/validation-registry.js';\r\nimport { DocumentState } from './documents.js';\r\n\r\nexport interface BuildOptions {\r\n    /**\r\n     * Control the validation phase with this option:\r\n     *  - `true` enables all validation checks and forces revalidating the documents\r\n     *  - `false` or `undefined` disables all validation checks\r\n     *  - An object runs only the necessary validation checks; the `categories` property restricts this to a specific subset\r\n     */\r\n    validation?: boolean | ValidationOptions\r\n}\r\n\r\nexport interface DocumentBuildState {\r\n    /** Whether a document has completed its last build process. */\r\n    completed: boolean\r\n    /** The options used for the last build process. */\r\n    options: BuildOptions\r\n    /** Additional information about the last build result. */\r\n    result?: {\r\n        validationChecks?: ValidationCategory[]\r\n    }\r\n}\r\n\r\n/**\r\n * Shared-service for building and updating `LangiumDocument`s.\r\n */\r\nexport interface DocumentBuilder {\r\n\r\n    /** The options used for rebuilding documents after an update. */\r\n    updateBuildOptions: BuildOptions;\r\n\r\n    /**\r\n     * Execute all necessary build steps for the given documents.\r\n     *\r\n     * @param documents Set of documents to be built.\r\n     * @param options Options for the document builder.\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options?: BuildOptions, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * This method is called when a document change is detected. It updates the state of all\r\n     * affected documents, including those with references to the changed ones, so they are rebuilt.\r\n     *\r\n     * @param changed URIs of changed or created documents\r\n     * @param deleted URIs of deleted documents\r\n     * @param cancelToken allows to cancel the current operation\r\n     * @throws `OperationCancelled` if cancellation is detected during execution\r\n     */\r\n    update(changed: URI[], deleted: URI[], cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Notify the given callback when a document update was triggered, but before any document\r\n     * is rebuilt. Listeners to this event should not perform any long-running task.\r\n     */\r\n    onUpdate(callback: DocumentUpdateListener): Disposable;\r\n\r\n    /**\r\n     * Notify the given callback when a set of documents has been built reaching a desired target state.\r\n     */\r\n    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable;\r\n}\r\n\r\nexport type DocumentUpdateListener = (changed: URI[], deleted: URI[]) => void | Promise<void>\r\nexport type DocumentBuildListener = (built: LangiumDocument[], cancelToken: CancellationToken) => void | Promise<void>\r\nexport class DefaultDocumentBuilder implements DocumentBuilder {\r\n\r\n    updateBuildOptions: BuildOptions = {\r\n        // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)\r\n        validation: {\r\n            categories: ['built-in', 'fast']\r\n        }\r\n    };\r\n\r\n    protected readonly langiumDocuments: LangiumDocuments;\r\n    protected readonly langiumDocumentFactory: LangiumDocumentFactory;\r\n    protected readonly indexManager: IndexManager;\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly updateListeners: DocumentUpdateListener[] = [];\r\n    protected readonly buildPhaseListeners: MultiMap<DocumentState, DocumentBuildListener> = new MultiMap();\r\n    protected readonly buildState: Map<string, DocumentBuildState> = new Map();\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.langiumDocuments = services.workspace.LangiumDocuments;\r\n        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;\r\n        this.indexManager = services.workspace.IndexManager;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n    }\r\n\r\n    async build<T extends AstNode>(documents: Array<LangiumDocument<T>>, options: BuildOptions = {}, cancelToken = CancellationToken.None): Promise<void> {\r\n        for (const document of documents) {\r\n            const key = document.uri.toString();\r\n            if (document.state === DocumentState.Validated) {\r\n                if (typeof options.validation === 'boolean' && options.validation) {\r\n                    // Force re-running all validation checks\r\n                    document.state = DocumentState.IndexedReferences;\r\n                    document.diagnostics = undefined;\r\n                    this.buildState.delete(key);\r\n                } else if (typeof options.validation === 'object') {\r\n                    const buildState = this.buildState.get(key);\r\n                    const previousCategories = buildState?.result?.validationChecks;\r\n                    if (previousCategories) {\r\n                        // Validation with explicit options was requested for a document that has already been partly validated.\r\n                        // In this case, we need to merge the previous validation categories with the new ones.\r\n                        const newCategories = options.validation.categories ?? ValidationCategory.all as ValidationCategory[];\r\n                        const categories = newCategories.filter(c => !previousCategories.includes(c));\r\n                        if (categories.length > 0) {\r\n                            this.buildState.set(key, {\r\n                                completed: false,\r\n                                options: {\r\n                                    validation: {\r\n                                        ...options.validation,\r\n                                        categories\r\n                                    }\r\n                                },\r\n                                result: buildState.result\r\n                            });\r\n                            document.state = DocumentState.IndexedReferences;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // Default: forget any previous build options\r\n                this.buildState.delete(key);\r\n            }\r\n        }\r\n        await this.emitUpdate(documents.map(e => e.uri), []);\r\n        await this.buildDocuments(documents, options, cancelToken);\r\n    }\r\n\r\n    async update(changed: URI[], deleted: URI[], cancelToken = CancellationToken.None): Promise<void> {\r\n        // Remove all metadata of documents that are reported as deleted\r\n        for (const deletedUri of deleted) {\r\n            this.langiumDocuments.deleteDocument(deletedUri);\r\n            this.buildState.delete(deletedUri.toString());\r\n        }\r\n        this.indexManager.remove(deleted);\r\n        // Set the state of all changed documents to `Changed` so they are completely rebuilt\r\n        for (const changedUri of changed) {\r\n            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);\r\n            if (!invalidated) {\r\n                this.langiumDocuments.getOrCreateDocument(changedUri);\r\n            }\r\n            this.buildState.delete(changedUri.toString());\r\n        }\r\n        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)\r\n        const allChangedUris = stream(changed).concat(deleted).map(uri => uri.toString()).toSet();\r\n        this.langiumDocuments.all\r\n            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))\r\n            .forEach(doc => {\r\n                const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\r\n                linker.unlink(doc);\r\n                doc.state = Math.min(doc.state, DocumentState.ComputedScopes);\r\n                doc.diagnostics = undefined;\r\n            });\r\n        // Notify listeners of the update\r\n        await this.emitUpdate(changed, deleted);\r\n        // Only allow interrupting the execution after all state changes are done\r\n        await interruptAndCheck(cancelToken);\r\n\r\n        // Collect all documents that we should rebuild\r\n        const rebuildDocuments = this.langiumDocuments.all\r\n            .filter(doc =>\r\n                // This includes those that were reported as changed and those that we selected for relinking\r\n                doc.state < DocumentState.Linked\r\n                // This includes those for which a previous build has been cancelled\r\n                || !this.buildState.get(doc.uri.toString())?.completed\r\n            )\r\n            .toArray();\r\n        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);\r\n    }\r\n\r\n    protected async emitUpdate(changed: URI[], deleted: URI[]): Promise<void> {\r\n        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));\r\n    }\r\n\r\n    /**\r\n     * Check whether the given document should be relinked after changes were found in the given URIs.\r\n     */\r\n    protected shouldRelink(document: LangiumDocument, changedUris: Set<string>): boolean {\r\n        // Relink documents with linking errors -- maybe those references can be resolved now\r\n        if (document.references.some(ref => ref.error !== undefined)) {\r\n            return true;\r\n        }\r\n        // Check whether the document is affected by any of the changed URIs\r\n        return this.indexManager.isAffected(document, changedUris);\r\n    }\r\n\r\n    onUpdate(callback: DocumentUpdateListener): Disposable {\r\n        this.updateListeners.push(callback);\r\n        return Disposable.create(() => {\r\n            const index = this.updateListeners.indexOf(callback);\r\n            if (index >= 0) {\r\n                this.updateListeners.splice(index, 1);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Build the given documents by stepping through all build phases. If a document's state indicates\r\n     * that a certain build phase is already done, the phase is skipped for that document.\r\n     */\r\n    protected async buildDocuments(documents: LangiumDocument[], options: BuildOptions, cancelToken: CancellationToken): Promise<void> {\r\n        this.prepareBuild(documents, options);\r\n        // 0. Parse content\r\n        await this.runCancelable(documents, DocumentState.Parsed, cancelToken, doc => {\r\n            this.langiumDocumentFactory.update(doc);\r\n        });\r\n        // 1. Index content\r\n        await this.runCancelable(documents, DocumentState.IndexedContent, cancelToken, doc =>\r\n            this.indexManager.updateContent(doc, cancelToken)\r\n        );\r\n        // 2. Compute scopes\r\n        await this.runCancelable(documents, DocumentState.ComputedScopes, cancelToken, async doc => {\r\n            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;\r\n            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);\r\n        });\r\n        // 3. Linking\r\n        await this.runCancelable(documents, DocumentState.Linked, cancelToken, doc => {\r\n            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;\r\n            return linker.link(doc, cancelToken);\r\n        });\r\n        // 4. Index references\r\n        await this.runCancelable(documents, DocumentState.IndexedReferences, cancelToken, doc =>\r\n            this.indexManager.updateReferences(doc, cancelToken)\r\n        );\r\n        // 5. Validation\r\n        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));\r\n        await this.runCancelable(toBeValidated, DocumentState.Validated, cancelToken, doc =>\r\n            this.validate(doc, cancelToken)\r\n        );\r\n\r\n        // If we've made it to this point without being cancelled, we can mark the build state as completed.\r\n        for (const doc of documents) {\r\n            const state = this.buildState.get(doc.uri.toString());\r\n            if (state) {\r\n                state.completed = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    protected prepareBuild(documents: LangiumDocument[], options: BuildOptions): void {\r\n        for (const doc of documents) {\r\n            const key = doc.uri.toString();\r\n            const state = this.buildState.get(key);\r\n            // If the document has no previous build state, we set it. If it has one, but it's already marked\r\n            // as completed, we overwrite it. If the previous build was not completed, we keep its state\r\n            // and continue where it was cancelled.\r\n            if (!state || state.completed) {\r\n                this.buildState.set(key, {\r\n                    completed: false,\r\n                    options,\r\n                    result: state?.result\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    protected async runCancelable(documents: LangiumDocument[], targetState: DocumentState, cancelToken: CancellationToken,\r\n        callback: (document: LangiumDocument) => MaybePromise<void>): Promise<void> {\r\n        const filtered = documents.filter(e => e.state < targetState);\r\n        for (const document of filtered) {\r\n            await interruptAndCheck(cancelToken);\r\n            await callback(document);\r\n            document.state = targetState;\r\n        }\r\n        await this.notifyBuildPhase(filtered, targetState, cancelToken);\r\n    }\r\n\r\n    onBuildPhase(targetState: DocumentState, callback: DocumentBuildListener): Disposable {\r\n        this.buildPhaseListeners.add(targetState, callback);\r\n        return Disposable.create(() => {\r\n            this.buildPhaseListeners.delete(targetState, callback);\r\n        });\r\n    }\r\n\r\n    protected async notifyBuildPhase(documents: LangiumDocument[], state: DocumentState, cancelToken: CancellationToken): Promise<void> {\r\n        if (documents.length === 0) {\r\n            // Don't notify when no document has been processed\r\n            return;\r\n        }\r\n        const listeners = this.buildPhaseListeners.get(state);\r\n        for (const listener of listeners) {\r\n            await interruptAndCheck(cancelToken);\r\n            await listener(documents, cancelToken);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determine whether the given document should be validated during a build. The default\r\n     * implementation checks the `validation` property of the build options. If it's set to `true`\r\n     * or a `ValidationOptions` object, the document is included in the validation phase.\r\n     */\r\n    protected shouldValidate(document: LangiumDocument): boolean {\r\n        return Boolean(this.getBuildOptions(document).validation);\r\n    }\r\n\r\n    /**\r\n     * Run validation checks on the given document and store the resulting diagnostics in the document.\r\n     * If the document already contains diagnostics, the new ones are added to the list.\r\n     */\r\n    protected async validate(document: LangiumDocument, cancelToken: CancellationToken): Promise<void> {\r\n        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;\r\n        const validationSetting = this.getBuildOptions(document).validation;\r\n        const options = typeof validationSetting === 'object' ? validationSetting : undefined;\r\n        const diagnostics = await validator.validateDocument(document, options, cancelToken);\r\n        if (document.diagnostics) {\r\n            document.diagnostics.push(...diagnostics);\r\n        } else {\r\n            document.diagnostics = diagnostics;\r\n        }\r\n\r\n        // Store information about the executed validation in the build state\r\n        const state = this.buildState.get(document.uri.toString());\r\n        if (state) {\r\n            state.result ??= {};\r\n            const newCategories = options?.categories ?? ValidationCategory.all;\r\n            if (state.result.validationChecks) {\r\n                state.result.validationChecks.push(...newCategories);\r\n            } else {\r\n                state.result.validationChecks = [...newCategories];\r\n            }\r\n        }\r\n    }\r\n\r\n    protected getBuildOptions(document: LangiumDocument): BuildOptions {\r\n        return this.buildState.get(document.uri.toString())?.options ?? {};\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-util.js';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription, AstReflection } from '../syntax-tree.js';\r\nimport type { Stream } from '../utils/stream.js';\r\nimport type { ReferenceDescription } from './ast-descriptions.js';\r\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { stream } from '../utils/stream.js';\r\nimport { UriUtils } from '../utils/uri-util.js';\r\nimport { ContextCache } from '../utils/caching.js';\r\n\r\n/**\r\n * The index manager is responsible for keeping metadata about symbols and cross-references\r\n * in the workspace. It is used to look up symbols in the global scope, mostly during linking\r\n * and completion. This service is shared between all languages of a language server.\r\n */\r\nexport interface IndexManager {\r\n\r\n    /**\r\n     * Deletes the specified document uris from the index.\r\n     * Necessary when documents are deleted and not referenceable anymore.\r\n     *\r\n     * @param uris The document uris to delete.\r\n     */\r\n    remove(uris: URI[]): void;\r\n\r\n    /**\r\n     * Updates the information about the exportable content of a document inside the index.\r\n     *\r\n     * @param document Document to be updated\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    updateContent(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Updates the information about the cross-references of a document inside the index.\r\n     *\r\n     * @param document Document to be updated\r\n     * @param cancelToken Indicates when to cancel the current operation.\r\n     * @throws `OperationCanceled` if a user action occurs during execution\r\n     */\r\n    updateReferences(document: LangiumDocument, cancelToken?: CancellationToken): Promise<void>;\r\n\r\n    /**\r\n     * Determine whether the given document could be affected by changes of the documents\r\n     * identified by the given URIs (second parameter). The document is typically regarded as\r\n     * affected if it contains a reference to any of the changed files.\r\n     *\r\n     * @param document Document to check whether it's affected\r\n     * @param changedUris URIs of the changed documents\r\n     */\r\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean;\r\n\r\n    /**\r\n     * Compute a list of all exported elements, optionally filtered using a type identifier and document URIs.\r\n     *\r\n     * @param nodeType The type to filter with, or `undefined` to return descriptions of all types.\r\n     * @param uris If specified, only returns elements from the given URIs.\r\n     * @returns a `Stream` containing all globally visible nodes (of a given type).\r\n     */\r\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription>;\r\n\r\n    /**\r\n     * Returns all known references that are pointing to the given `targetNode`.\r\n     *\r\n     * @param targetNode the `AstNode` to look up references for\r\n     * @param astNodePath the path that points to the `targetNode` inside the document. See also `AstNodeLocator`\r\n     *\r\n     * @returns a `Stream` of references that are targeting the `targetNode`\r\n     */\r\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription>;\r\n\r\n}\r\n\r\nexport class DefaultIndexManager implements IndexManager {\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly documents: LangiumDocuments;\r\n    protected readonly astReflection: AstReflection;\r\n\r\n    /**\r\n     * The `simpleIndex` stores all `AstNodeDescription` items exported by a document.\r\n     * The key used in this map is the string representation of the specific document URI.\r\n     */\r\n    protected readonly simpleIndex = new Map<string, AstNodeDescription[]>();\r\n    /**\r\n     * This is a cache for the `allElements()` method.\r\n     * It caches the descriptions from `simpleIndex` grouped by types.\r\n     */\r\n    protected readonly simpleTypeIndex = new ContextCache<string, string, AstNodeDescription[]>();\r\n    /**\r\n     * This index keeps track of all `ReferenceDescription` items exported by a document.\r\n     * This is used to compute which elements are affected by a document change\r\n     * and for finding references to an AST node.\r\n     */\r\n    protected readonly referenceIndex = new Map<string, ReferenceDescription[]>();\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.documents = services.workspace.LangiumDocuments;\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.astReflection = services.AstReflection;\r\n    }\r\n\r\n    findAllReferences(targetNode: AstNode, astNodePath: string): Stream<ReferenceDescription> {\r\n        const targetDocUri = getDocument(targetNode).uri;\r\n        const result: ReferenceDescription[] = [];\r\n        this.referenceIndex.forEach(docRefs => {\r\n            docRefs.forEach(refDescr => {\r\n                if (UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {\r\n                    result.push(refDescr);\r\n                }\r\n            });\r\n        });\r\n        return stream(result);\r\n    }\r\n\r\n    allElements(nodeType?: string, uris?: Set<string>): Stream<AstNodeDescription> {\r\n        let documentUris = stream(this.simpleIndex.keys());\r\n        if (uris) {\r\n            documentUris = documentUris.filter(uri => !uris || uris.has(uri));\r\n        }\r\n        return documentUris\r\n            .map(uri => this.getFileDescriptions(uri, nodeType))\r\n            .flat();\r\n    }\r\n\r\n    protected getFileDescriptions(uri: string, nodeType?: string): AstNodeDescription[] {\r\n        if (!nodeType) {\r\n            return this.simpleIndex.get(uri) ?? [];\r\n        }\r\n        const descriptions = this.simpleTypeIndex.get(uri, nodeType, () => {\r\n            const allFileDescriptions = this.simpleIndex.get(uri) ?? [];\r\n            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));\r\n        });\r\n        return descriptions;\r\n    }\r\n\r\n    remove(uris: URI[]): void {\r\n        for (const uri of uris) {\r\n            const uriString = uri.toString();\r\n            this.simpleIndex.delete(uriString);\r\n            this.simpleTypeIndex.clear(uriString);\r\n            this.referenceIndex.delete(uriString);\r\n        }\r\n    }\r\n\r\n    async updateContent(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        const services = this.serviceRegistry.getServices(document.uri);\r\n        const exports: AstNodeDescription[] = await services.references.ScopeComputation.computeExports(document, cancelToken);\r\n        for (const data of exports) {\r\n            data.node = undefined; // clear reference to the AST Node\r\n        }\r\n        const uri = document.uri.toString();\r\n        this.simpleIndex.set(uri, exports);\r\n        this.simpleTypeIndex.clear(uri);\r\n    }\r\n\r\n    async updateReferences(document: LangiumDocument, cancelToken = CancellationToken.None): Promise<void> {\r\n        const services = this.serviceRegistry.getServices(document.uri);\r\n        const indexData: ReferenceDescription[] = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);\r\n        this.referenceIndex.set(document.uri.toString(), indexData);\r\n    }\r\n\r\n    isAffected(document: LangiumDocument, changedUris: Set<string>): boolean {\r\n        const references = this.referenceIndex.get(document.uri.toString());\r\n        if (!references) {\r\n            return false;\r\n        }\r\n        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport { CancellationToken } from 'vscode-languageserver';\r\nimport { interruptAndCheck } from '../utils/promise-util.js';\r\nimport { URI, UriUtils } from '../utils/uri-util.js';\r\nimport type { WorkspaceFolder } from 'vscode-languageserver';\r\nimport type { ServiceRegistry } from '../service-registry.js';\r\nimport type { LangiumSharedServices } from '../services.js';\r\nimport type { MutexLock } from '../utils/promise-util.js';\r\nimport type { BuildOptions, DocumentBuilder } from './document-builder.js';\r\nimport type { LangiumDocument, LangiumDocuments } from './documents.js';\r\nimport type { FileSystemNode, FileSystemProvider } from './file-system-provider.js';\r\n\r\n/**\r\n * The workspace manager is responsible for finding source files in the workspace.\r\n * This service is shared between all languages of a language server.\r\n */\r\nexport interface WorkspaceManager {\r\n\r\n    /** The options used for the initial workspace build. */\r\n    initialBuildOptions: BuildOptions | undefined;\r\n\r\n    /**\r\n     * Does the initial indexing of workspace folders.\r\n     * Collects information about exported and referenced AstNodes in\r\n     * each language file and stores it locally.\r\n     *\r\n     * @param folders The set of workspace folders to be indexed.\r\n     */\r\n    initializeWorkspace(folders: WorkspaceFolder[], cancelToken?: CancellationToken): Promise<void>;\r\n\r\n}\r\n\r\nexport class DefaultWorkspaceManager implements WorkspaceManager {\r\n\r\n    initialBuildOptions: BuildOptions = {};\r\n\r\n    protected readonly serviceRegistry: ServiceRegistry;\r\n    protected readonly langiumDocuments: LangiumDocuments;\r\n    protected readonly documentBuilder: DocumentBuilder;\r\n    protected readonly fileSystemProvider: FileSystemProvider;\r\n    protected readonly mutex: MutexLock;\r\n    protected folders?: WorkspaceFolder[];\r\n\r\n    constructor(services: LangiumSharedServices) {\r\n        this.serviceRegistry = services.ServiceRegistry;\r\n        this.langiumDocuments = services.workspace.LangiumDocuments;\r\n        this.documentBuilder = services.workspace.DocumentBuilder;\r\n        this.fileSystemProvider = services.workspace.FileSystemProvider;\r\n        this.mutex = services.workspace.MutexLock;\r\n\r\n        services.lsp.LanguageServer.onInitialize(params => {\r\n            this.folders = params.workspaceFolders ?? undefined;\r\n        });\r\n\r\n        services.lsp.LanguageServer.onInitialized(_params => {\r\n            // Initialize the workspace even if there are no workspace folders\r\n            // We still want to load additional documents (language library or similar) during initialization\r\n            this.mutex.lock(token => this.initializeWorkspace(this.folders ?? [], token));\r\n        });\r\n    }\r\n\r\n    async initializeWorkspace(folders: WorkspaceFolder[], cancelToken = CancellationToken.None): Promise<void> {\r\n        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);\r\n        const documents: LangiumDocument[] = [];\r\n        const collector = (document: LangiumDocument) => {\r\n            documents.push(document);\r\n            if (!this.langiumDocuments.hasDocument(document.uri)) {\r\n                this.langiumDocuments.addDocument(document);\r\n            }\r\n        };\r\n        // Even though we don't await the initialization of the workspace manager,\r\n        // we can still assume that all library documents and file documents are loaded by the time we start building documents.\r\n        // The mutex prevents anything from performing a workspace build until we check the cancellation token\r\n        await this.loadAdditionalDocuments(folders, collector);\r\n        await Promise.all(\r\n            folders.map(wf => [wf, this.getRootFolder(wf)] as [WorkspaceFolder, URI])\r\n                .map(async entry => this.traverseFolder(...entry, fileExtensions, collector))\r\n        );\r\n        // Only after creating all documents do we check whether we need to cancel the initialization\r\n        // The document builder will later pick up on all unprocessed documents\r\n        await interruptAndCheck(cancelToken);\r\n        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);\r\n    }\r\n\r\n    /**\r\n     * Load all additional documents that shall be visible in the context of the given workspace\r\n     * folders and add them to the collector. This can be used to include built-in libraries of\r\n     * your language, which can be either loaded from provided files or constructed in memory.\r\n     */\r\n    protected loadAdditionalDocuments(_folders: WorkspaceFolder[], _collector: (document: LangiumDocument) => void): Promise<void> {\r\n        return Promise.resolve();\r\n    }\r\n\r\n    /**\r\n     * Determine the root folder of the source documents in the given workspace folder.\r\n     * The default implementation returns the URI of the workspace folder, but you can override\r\n     * this to return a subfolder like `src` instead.\r\n     */\r\n    protected getRootFolder(workspaceFolder: WorkspaceFolder): URI {\r\n        return URI.parse(workspaceFolder.uri);\r\n    }\r\n\r\n    /**\r\n     * Traverse the file system folder identified by the given URI and its subfolders. All\r\n     * contained files that match the file extensions are added to the collector.\r\n     */\r\n    protected async traverseFolder(workspaceFolder: WorkspaceFolder, folderPath: URI, fileExtensions: string[], collector: (document: LangiumDocument) => void): Promise<void> {\r\n        const content = await this.fileSystemProvider.readDirectory(folderPath);\r\n        await Promise.all(content.map(async entry => {\r\n            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {\r\n                if (entry.isDirectory) {\r\n                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);\r\n                } else if (entry.isFile) {\r\n                    const document = this.langiumDocuments.getOrCreateDocument(entry.uri);\r\n                    collector(document);\r\n                }\r\n            }\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Determine whether the given folder entry shall be included while indexing the workspace.\r\n     */\r\n    protected includeEntry(workspaceFolder: WorkspaceFolder, entry: FileSystemNode, fileExtensions: string[]): boolean {\r\n        const name = UriUtils.basename(entry.uri);\r\n        if (name.startsWith('.')) {\r\n            return false;\r\n        }\r\n        if (entry.isDirectory) {\r\n            return name !== 'node_modules' && name !== 'out';\r\n        } else if (entry.isFile) {\r\n            const extname = UriUtils.extname(entry.uri);\r\n            return fileExtensions.includes(extname);\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { ILexingError, IMultiModeLexerDefinition, IToken, TokenType, TokenTypeDictionary, TokenVocabulary } from 'chevrotain';\r\nimport type { LangiumServices } from '../services.js';\r\nimport { Lexer as ChevrotainLexer } from 'chevrotain';\r\n\r\nexport interface LexerResult {\r\n    /**\r\n     * A list of all tokens that were lexed from the input.\r\n     *\r\n     * Note that Langium requires the optional properties\r\n     * `startLine`, `startColumn`, `endOffset`, `endLine` and `endColumn` to be set on each token.\r\n     */\r\n    tokens: IToken[];\r\n    /**\r\n     * Contains hidden tokens, usually comments.\r\n     */\r\n    hidden: IToken[];\r\n    errors: ILexingError[];\r\n}\r\n\r\nexport interface Lexer {\r\n    readonly definition: TokenTypeDictionary;\r\n    tokenize(text: string): LexerResult;\r\n}\r\n\r\nexport class DefaultLexer implements Lexer {\r\n\r\n    protected chevrotainLexer: ChevrotainLexer;\r\n    protected tokenTypes: TokenTypeDictionary;\r\n\r\n    constructor(services: LangiumServices) {\r\n        const tokens = services.parser.TokenBuilder.buildTokens(services.Grammar, {\r\n            caseInsensitive: services.LanguageMetaData.caseInsensitive\r\n        });\r\n        this.tokenTypes = this.toTokenTypeDictionary(tokens);\r\n        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;\r\n        this.chevrotainLexer = new ChevrotainLexer(lexerTokens, {\r\n            positionTracking: 'full'\r\n        });\r\n    }\r\n\r\n    get definition(): TokenTypeDictionary {\r\n        return this.tokenTypes;\r\n    }\r\n\r\n    tokenize(text: string): LexerResult {\r\n        const chevrotainResult = this.chevrotainLexer.tokenize(text);\r\n        return {\r\n            tokens: chevrotainResult.tokens,\r\n            errors: chevrotainResult.errors,\r\n            hidden: chevrotainResult.groups.hidden ?? []\r\n        };\r\n    }\r\n\r\n    protected toTokenTypeDictionary(buildTokens: TokenVocabulary): TokenTypeDictionary {\r\n        if (isTokenTypeDictionary(buildTokens)) return buildTokens;\r\n        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;\r\n        const res: TokenTypeDictionary = {};\r\n        tokens.forEach(token => res[token.name] = token);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a check whether the given TokenVocabulary is TokenType array\r\n */\r\nexport function isTokenTypeArray(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenType[] {\r\n    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);\r\n}\r\n\r\n/**\r\n * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition\r\n */\r\nexport function isIMultiModeLexerDefinition(tokenVocabulary: TokenVocabulary): tokenVocabulary is IMultiModeLexerDefinition {\r\n    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;\r\n}\r\n\r\n/**\r\n * Returns a check whether the given TokenVocabulary is TokenTypeDictionary\r\n */\r\nexport function isTokenTypeDictionary(tokenVocabulary: TokenVocabulary): tokenVocabulary is TokenTypeDictionary {\r\n    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { CstNode } from '../syntax-tree.js';\r\nimport { Position, Range } from 'vscode-languageserver';\r\nimport { NEWLINE_REGEXP } from '../generator/template-string.js';\r\nimport { escapeRegExp } from '../utils/regex-util.js';\r\nimport { URI } from '../utils/uri-util.js';\r\n\r\nexport interface JSDocComment extends JSDocValue {\r\n    readonly elements: JSDocElement[]\r\n    getTag(name: string): JSDocTag | undefined\r\n    getTags(name: string): JSDocTag[]\r\n}\r\n\r\nexport type JSDocElement = JSDocParagraph | JSDocTag;\r\n\r\nexport type JSDocInline = JSDocTag | JSDocLine;\r\n\r\nexport interface JSDocValue {\r\n    /**\r\n     * Represents the range that this JSDoc element occupies.\r\n     * If the JSDoc was parsed from a `CstNode`, the range will represent the location in the source document.\r\n     */\r\n    readonly range: Range\r\n    /**\r\n     * Renders this JSDoc element to a plain text representation.\r\n     */\r\n    toString(): string\r\n    /**\r\n     * Renders this JSDoc element to a markdown representation.\r\n     *\r\n     * @param options Rendering options to customize the markdown result.\r\n     */\r\n    toMarkdown(options?: JSDocRenderOptions): string\r\n}\r\n\r\nexport interface JSDocParagraph extends JSDocValue {\r\n    readonly inlines: JSDocInline[]\r\n}\r\n\r\nexport interface JSDocLine extends JSDocValue {\r\n    readonly text: string\r\n}\r\n\r\nexport interface JSDocTag extends JSDocValue {\r\n    readonly name: string\r\n    readonly content: JSDocParagraph\r\n    readonly inline: boolean\r\n}\r\n\r\nexport interface JSDocParseOptions {\r\n    /**\r\n     * The start symbol of your comment format. Defaults to `/**`.\r\n     */\r\n    readonly start?: RegExp | string\r\n    /**\r\n     * The symbol that start a line of your comment format. Defaults to `*`.\r\n     */\r\n    readonly line?: RegExp | string\r\n    /**\r\n     * The end symbol of your comment format. Defaults to `*\\/`.\r\n     */\r\n    readonly end?: RegExp | string\r\n}\r\n\r\nexport interface JSDocRenderOptions {\r\n    /**\r\n     * Determines the style for rendering tags. Defaults to `italic`.\r\n     */\r\n    tag?: 'plain' | 'italic' | 'bold' | 'bold-italic'\r\n    /**\r\n     * Determines the default for rendering `@link` tags. Defaults to `plain`.\r\n     */\r\n    link?: 'code' | 'plain'\r\n    /**\r\n     * Custom tag rendering function.\r\n     * Return a markdown formatted tag or `undefined` to fall back to the default rendering.\r\n     */\r\n    renderTag?(tag: JSDocTag): string | undefined\r\n    /**\r\n     * Custom link rendering function. Accepts a link target and a display value for the link.\r\n     * Return a markdown formatted link with the format `[$display]($link)` or `undefined` if the link is not a valid target.\r\n     */\r\n    renderLink?(link: string, display: string): string | undefined\r\n}\r\n\r\n/**\r\n * Parses a JSDoc from a `CstNode` containing a comment.\r\n *\r\n * @param node A `CstNode` from a parsed Langium document.\r\n * @param options Parsing options specialized to your language. See {@link JSDocParseOptions}.\r\n */\r\nexport function parseJSDoc(node: CstNode, options?: JSDocParseOptions): JSDocComment;\r\n/**\r\n * Parses a JSDoc from a string comment.\r\n *\r\n * @param content A string containing the source of the JSDoc comment.\r\n * @param start The start position the comment occupies in the source document.\r\n * @param options Parsing options specialized to your language. See {@link JSDocParseOptions}.\r\n */\r\nexport function parseJSDoc(content: string, start?: Position, options?: JSDocParseOptions): JSDocComment;\r\nexport function parseJSDoc(node: CstNode | string, start?: Position | JSDocParseOptions, options?: JSDocParseOptions): JSDocComment {\r\n    let opts: JSDocParseOptions | undefined;\r\n    let position: Position | undefined;\r\n    if (typeof node === 'string') {\r\n        position = start as Position | undefined;\r\n        opts = options as JSDocParseOptions | undefined;\r\n    } else {\r\n        position = node.range.start;\r\n        opts = start as JSDocParseOptions | undefined;\r\n    }\r\n    if (!position) {\r\n        position = Position.create(0, 0);\r\n    }\r\n\r\n    const lines = getLines(node);\r\n    const normalizedOptions = normalizeOptions(opts);\r\n\r\n    const tokens = tokenize({\r\n        lines,\r\n        position,\r\n        options: normalizedOptions\r\n    });\r\n\r\n    return parseJSDocComment({\r\n        index: 0,\r\n        tokens,\r\n        position\r\n    });\r\n}\r\n\r\nexport function isJSDoc(node: CstNode | string, options?: JSDocParseOptions): boolean {\r\n    const normalizedOptions = normalizeOptions(options);\r\n    const lines = getLines(node);\r\n    if (lines.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    const first = lines[0];\r\n    const last = lines[lines.length - 1];\r\n    const firstRegex = normalizedOptions.start;\r\n    const lastRegex = normalizedOptions.end;\r\n\r\n    return Boolean(firstRegex?.exec(first)) && Boolean(lastRegex?.exec(last));\r\n}\r\n\r\nfunction getLines(node: CstNode | string): string[] {\r\n    let content = '';\r\n    if (typeof node === 'string') {\r\n        content = node;\r\n    } else {\r\n        content = node.text;\r\n    }\r\n    const lines = content.split(NEWLINE_REGEXP);\r\n    return lines;\r\n}\r\n\r\n// Tokenization\r\n\r\ninterface JSDocToken {\r\n    type: 'text' | 'tag' | 'inline-tag' | 'break'\r\n    content: string\r\n    range: Range\r\n}\r\n\r\nconst tagRegex = /\\s*(@([\\p{L}][\\p{L}\\p{N}]*)?)/uy;\r\nconst inlineTagRegex = /\\{(@[\\p{L}][\\p{L}\\p{N}]*)(\\s*)([^\\r\\n}]+)?\\}/gu;\r\n\r\nfunction tokenize(context: TokenizationContext): JSDocToken[] {\r\n    const tokens: JSDocToken[] = [];\r\n    let currentLine = context.position.line;\r\n    let currentCharacter = context.position.character;\r\n    for (let i = 0; i < context.lines.length; i++) {\r\n        const first = i === 0;\r\n        const last = i === context.lines.length - 1;\r\n        let line = context.lines[i];\r\n        let index = 0;\r\n\r\n        if (first && context.options.start) {\r\n            const match = context.options.start?.exec(line);\r\n            if (match) {\r\n                index = match.index + match[0].length;\r\n            }\r\n        } else {\r\n            const match = context.options.line?.exec(line);\r\n            if (match) {\r\n                index = match.index + match[0].length;\r\n            }\r\n        }\r\n        if (last) {\r\n            const match = context.options.end?.exec(line);\r\n            if (match) {\r\n                line = line.substring(0, match.index);\r\n            }\r\n        }\r\n\r\n        line = line.substring(0, lastCharacter(line));\r\n        const whitespaceEnd = skipWhitespace(line, index);\r\n\r\n        if (whitespaceEnd >= line.length) {\r\n            // Only create a break token when we already have previous tokens\r\n            if (tokens.length > 0) {\r\n                const position = Position.create(currentLine, currentCharacter);\r\n                tokens.push({\r\n                    type: 'break',\r\n                    content: '',\r\n                    range: Range.create(position, position)\r\n                });\r\n            }\r\n        } else {\r\n            tagRegex.lastIndex = index;\r\n            const tagMatch = tagRegex.exec(line);\r\n            if (tagMatch) {\r\n                const fullMatch = tagMatch[0];\r\n                const value = tagMatch[1];\r\n                const start = Position.create(currentLine, currentCharacter + index);\r\n                const end = Position.create(currentLine, currentCharacter + index + fullMatch.length);\r\n                tokens.push({\r\n                    type: 'tag',\r\n                    content: value,\r\n                    range: Range.create(start, end)\r\n                });\r\n                index += fullMatch.length;\r\n                index = skipWhitespace(line, index);\r\n            }\r\n\r\n            if (index < line.length) {\r\n                const rest = line.substring(index);\r\n                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));\r\n                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));\r\n            }\r\n        }\r\n\r\n        currentLine++;\r\n        currentCharacter = 0;\r\n    }\r\n\r\n    // Remove last break token if there is one\r\n    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {\r\n        return tokens.slice(0, -1);\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\nfunction buildInlineTokens(tags: RegExpMatchArray[], line: string, lineIndex: number, characterIndex: number): JSDocToken[] {\r\n    const tokens: JSDocToken[] = [];\r\n\r\n    if (tags.length === 0) {\r\n        const start = Position.create(lineIndex, characterIndex);\r\n        const end = Position.create(lineIndex, characterIndex + line.length);\r\n        tokens.push({\r\n            type: 'text',\r\n            content: line,\r\n            range: Range.create(start, end)\r\n        });\r\n    } else {\r\n        let lastIndex = 0;\r\n        for (const match of tags) {\r\n            const matchIndex = match.index!;\r\n            const startContent = line.substring(lastIndex, matchIndex);\r\n            if (startContent.length > 0) {\r\n                tokens.push({\r\n                    type: 'text',\r\n                    content: line.substring(lastIndex, matchIndex),\r\n                    range: Range.create(\r\n                        Position.create(lineIndex, lastIndex + characterIndex),\r\n                        Position.create(lineIndex, matchIndex + characterIndex)\r\n                    )\r\n                });\r\n            }\r\n            let offset = startContent.length + 1;\r\n            const tagName = match[1];\r\n            tokens.push({\r\n                type: 'inline-tag',\r\n                content: tagName,\r\n                range: Range.create(\r\n                    Position.create(lineIndex, lastIndex + offset + characterIndex),\r\n                    Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex)\r\n                )\r\n            });\r\n            offset += tagName.length;\r\n            if (match.length === 4) {\r\n                offset += match[2].length;\r\n                const value = match[3];\r\n                tokens.push({\r\n                    type: 'text',\r\n                    content: value,\r\n                    range: Range.create(\r\n                        Position.create(lineIndex, lastIndex + offset + characterIndex),\r\n                        Position.create(lineIndex, lastIndex + offset + value.length + characterIndex)\r\n                    )\r\n                });\r\n            } else {\r\n                tokens.push({\r\n                    type: 'text',\r\n                    content: '',\r\n                    range: Range.create(\r\n                        Position.create(lineIndex, lastIndex + offset + characterIndex),\r\n                        Position.create(lineIndex, lastIndex + offset + characterIndex)\r\n                    )\r\n                });\r\n            }\r\n            lastIndex = matchIndex + match[0].length;\r\n        }\r\n        const endContent = line.substring(lastIndex);\r\n        if (endContent.length > 0) {\r\n            tokens.push({\r\n                type: 'text',\r\n                content: endContent,\r\n                range: Range.create(\r\n                    Position.create(lineIndex, lastIndex + characterIndex),\r\n                    Position.create(lineIndex, lastIndex + characterIndex + endContent.length)\r\n                )\r\n            });\r\n        }\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\nconst nonWhitespaceRegex = /\\S/;\r\nconst whitespaceEndRegex = /\\s*$/;\r\n\r\nfunction skipWhitespace(line: string, index: number): number {\r\n    const match = line.substring(index).match(nonWhitespaceRegex);\r\n    if (match) {\r\n        return index + match.index!;\r\n    } else {\r\n        return line.length;\r\n    }\r\n}\r\n\r\nfunction lastCharacter(line: string): number | undefined {\r\n    const match = line.match(whitespaceEndRegex);\r\n    if (match && typeof match.index === 'number') {\r\n        return match.index;\r\n    }\r\n    return undefined;\r\n}\r\n\r\n// Parsing\r\n\r\nfunction parseJSDocComment(context: ParseContext): JSDocComment {\r\n    const startPosition: Position = Position.create(context.position.line, context.position.character);\r\n    if (context.tokens.length === 0) {\r\n        return new JSDocCommentImpl([], Range.create(startPosition, startPosition));\r\n    }\r\n    const elements: JSDocElement[] = [];\r\n    while (context.index < context.tokens.length) {\r\n        const element = parseJSDocElement(context, elements[elements.length - 1]);\r\n        if (element) {\r\n            elements.push(element);\r\n        }\r\n    }\r\n    const start = elements[0]?.range.start ?? startPosition;\r\n    const end = elements[elements.length - 1]?.range.end ?? startPosition;\r\n    return new JSDocCommentImpl(elements, Range.create(start, end));\r\n}\r\n\r\nfunction parseJSDocElement(context: ParseContext, last?: JSDocElement): JSDocElement | undefined {\r\n    const next = context.tokens[context.index];\r\n    if (next.type === 'tag') {\r\n        return parseJSDocTag(context, false);\r\n    } else if (next.type === 'text' || next.type === 'inline-tag') {\r\n        return parseJSDocText(context);\r\n    } else {\r\n        appendEmptyLine(next, last);\r\n        context.index++;\r\n        return undefined;\r\n    }\r\n}\r\n\r\nfunction appendEmptyLine(token: JSDocToken, element?: JSDocElement): void {\r\n    if (element) {\r\n        const line = new JSDocLineImpl('', token.range);\r\n        if ('inlines' in element) {\r\n            element.inlines.push(line);\r\n        } else {\r\n            element.content.inlines.push(line);\r\n        }\r\n    }\r\n}\r\n\r\nfunction parseJSDocText(context: ParseContext): JSDocParagraph {\r\n    let token = context.tokens[context.index];\r\n    const firstToken = token;\r\n    let lastToken = token;\r\n    const lines: JSDocInline[] = [];\r\n    while (token && token.type !== 'break' && token.type !== 'tag') {\r\n        lines.push(parseJSDocInline(context));\r\n        lastToken = token;\r\n        token = context.tokens[context.index];\r\n    }\r\n    return new JSDocTextImpl(lines, Range.create(firstToken.range.start, lastToken.range.end));\r\n}\r\n\r\nfunction parseJSDocInline(context: ParseContext): JSDocInline {\r\n    const token = context.tokens[context.index];\r\n    if (token.type === 'inline-tag') {\r\n        return parseJSDocTag(context, true);\r\n    } else {\r\n        return parseJSDocLine(context);\r\n    }\r\n}\r\n\r\nfunction parseJSDocTag(context: ParseContext, inline: boolean): JSDocTag {\r\n    const tagToken = context.tokens[context.index++];\r\n    const name = tagToken.content.substring(1);\r\n    const nextToken = context.tokens[context.index];\r\n    if (nextToken?.type === 'text') {\r\n        if (inline) {\r\n            const docLine = parseJSDocLine(context);\r\n            return new JSDocTagImpl(\r\n                name,\r\n                new JSDocTextImpl([docLine], docLine.range),\r\n                inline,\r\n                Range.create(tagToken.range.start, docLine.range.end)\r\n            );\r\n        } else {\r\n            const textDoc = parseJSDocText(context);\r\n            return new JSDocTagImpl(\r\n                name,\r\n                textDoc,\r\n                inline,\r\n                Range.create(tagToken.range.start, textDoc.range.end)\r\n            );\r\n        }\r\n    } else {\r\n        const range = tagToken.range;\r\n        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);\r\n    }\r\n}\r\n\r\nfunction parseJSDocLine(context: ParseContext): JSDocLine {\r\n    const token = context.tokens[context.index++];\r\n    return new JSDocLineImpl(token.content, token.range);\r\n}\r\n\r\ninterface NormalizedOptions {\r\n    start?: RegExp\r\n    end?: RegExp\r\n    line?: RegExp\r\n}\r\n\r\ninterface TokenizationContext {\r\n    position: Position\r\n    lines: string[]\r\n    options: NormalizedOptions\r\n}\r\n\r\ninterface ParseContext {\r\n    position: Position\r\n    tokens: JSDocToken[]\r\n    index: number\r\n}\r\n\r\nfunction normalizeOptions(options?: JSDocParseOptions): NormalizedOptions {\r\n    if (!options) {\r\n        return normalizeOptions({\r\n            start: '/**',\r\n            end: '*/',\r\n            line: '*'\r\n        });\r\n    }\r\n    const { start, end, line } = options;\r\n    return {\r\n        start: normalizeOption(start, true),\r\n        end: normalizeOption(end, false),\r\n        line: normalizeOption(line, true)\r\n    };\r\n}\r\n\r\nfunction normalizeOption(option: RegExp | string | undefined, start: boolean): RegExp | undefined {\r\n    if (typeof option === 'string' || typeof option === 'object') {\r\n        const escaped = typeof option === 'string' ? escapeRegExp(option) : option.source;\r\n        if (start) {\r\n            return new RegExp(`^\\\\s*${escaped}`);\r\n        } else {\r\n            return new RegExp(`\\\\s*${escaped}\\\\s*$`);\r\n        }\r\n    } else {\r\n        return option;\r\n    }\r\n}\r\n\r\nclass JSDocCommentImpl implements JSDocComment {\r\n\r\n    readonly elements: JSDocElement[];\r\n    readonly range: Range;\r\n\r\n    constructor(elements: JSDocElement[], range: Range) {\r\n        this.elements = elements;\r\n        this.range = range;\r\n    }\r\n\r\n    getTag(name: string): JSDocTag | undefined {\r\n        return this.getAllTags().find(e => e.name === name);\r\n    }\r\n\r\n    getTags(name: string): JSDocTag[] {\r\n        return this.getAllTags().filter(e => e.name === name);\r\n    }\r\n\r\n    private getAllTags(): JSDocTag[] {\r\n        return this.elements.filter((e): e is JSDocTag => 'name' in e);\r\n    }\r\n\r\n    toString(): string {\r\n        let value = '';\r\n        for (const element of this.elements) {\r\n            if (value.length === 0) {\r\n                value = element.toString();\r\n            } else {\r\n                const text = element.toString();\r\n                value += fillNewlines(value) + text;\r\n            }\r\n        }\r\n        return value.trim();\r\n    }\r\n\r\n    toMarkdown(options?: JSDocRenderOptions): string {\r\n        let value = '';\r\n        for (const element of this.elements) {\r\n            if (value.length === 0) {\r\n                value = element.toMarkdown(options);\r\n            } else {\r\n                const text = element.toMarkdown(options);\r\n                value += fillNewlines(value) + text;\r\n            }\r\n        }\r\n        return value.trim();\r\n    }\r\n}\r\n\r\nclass JSDocTagImpl implements JSDocTag {\r\n    name: string;\r\n    content: JSDocParagraph;\r\n    range: Range;\r\n    inline: boolean;\r\n\r\n    constructor(name: string, content: JSDocParagraph, inline: boolean, range: Range) {\r\n        this.name = name;\r\n        this.content = content;\r\n        this.inline = inline;\r\n        this.range = range;\r\n    }\r\n\r\n    toString(): string {\r\n        let text = `@${this.name}`;\r\n        const content = this.content.toString();\r\n        if (this.content.inlines.length === 1) {\r\n            text = `${text} ${content}`;\r\n        } else if (this.content.inlines.length > 1) {\r\n            text = `${text}\\n${content}`;\r\n        }\r\n        if (this.inline) {\r\n            // Inline tags are surrounded by curly braces\r\n            return `{${text}}`;\r\n        } else {\r\n            return text;\r\n        }\r\n    }\r\n\r\n    toMarkdown(options?: JSDocRenderOptions): string {\r\n        return options?.renderTag?.(this) ?? this.toMarkdownDefault(options);\r\n    }\r\n\r\n    private toMarkdownDefault(options?: JSDocRenderOptions): string {\r\n        const content = this.content.toMarkdown(options);\r\n        if (this.inline) {\r\n            const rendered = renderInlineTag(this.name, content, options ?? {});\r\n            if (typeof rendered === 'string') {\r\n                return rendered;\r\n            }\r\n        }\r\n        let marker = '';\r\n        if (options?.tag === 'italic' || options?.tag === undefined) {\r\n            marker = '*';\r\n        } else if (options?.tag === 'bold') {\r\n            marker = '**';\r\n        } else if (options?.tag === 'bold-italic') {\r\n            marker = '***';\r\n        }\r\n        let text = `${marker}@${this.name}${marker}`;\r\n        if (this.content.inlines.length === 1) {\r\n            text = `${text} \u2014 ${content}`;\r\n        } else if (this.content.inlines.length > 1) {\r\n            text = `${text}\\n${content}`;\r\n        }\r\n        if (this.inline) {\r\n            // Inline tags are surrounded by curly braces\r\n            return `{${text}}`;\r\n        } else {\r\n            return text;\r\n        }\r\n    }\r\n}\r\n\r\nfunction renderInlineTag(tag: string, content: string, options: JSDocRenderOptions): string | undefined {\r\n    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {\r\n        const index = content.indexOf(' ');\r\n        let display = content;\r\n        if (index > 0) {\r\n            const displayStart = skipWhitespace(content, index);\r\n            display = content.substring(displayStart);\r\n            content = content.substring(0, index);\r\n        }\r\n        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {\r\n            // Surround the display value in a markdown inline code block\r\n            display = `\\`${display}\\``;\r\n        }\r\n        const renderedLink = options.renderLink?.(content, display) ?? renderLinkDefault(content, display);\r\n        return renderedLink;\r\n    }\r\n    return undefined;\r\n}\r\n\r\nfunction renderLinkDefault(content: string, display: string): string {\r\n    try {\r\n        URI.parse(content, true);\r\n        return `[${display}](${content})`;\r\n    } catch {\r\n        return content;\r\n    }\r\n}\r\n\r\nclass JSDocTextImpl implements JSDocParagraph {\r\n    inlines: JSDocInline[];\r\n    range: Range;\r\n\r\n    constructor(lines: JSDocInline[], range: Range) {\r\n        this.inlines = lines;\r\n        this.range = range;\r\n    }\r\n\r\n    toString(): string {\r\n        let text = '';\r\n        for (let i = 0; i < this.inlines.length; i++) {\r\n            const inline = this.inlines[i];\r\n            const next = this.inlines[i + 1];\r\n            text += inline.toString();\r\n            if (next && next.range.start.line > inline.range.start.line) {\r\n                text += '\\n';\r\n            }\r\n        }\r\n        return text;\r\n    }\r\n\r\n    toMarkdown(options?: JSDocRenderOptions): string {\r\n        let text = '';\r\n        for (let i = 0; i < this.inlines.length; i++) {\r\n            const inline = this.inlines[i];\r\n            const next = this.inlines[i + 1];\r\n            text += inline.toMarkdown(options);\r\n            if (next && next.range.start.line > inline.range.start.line) {\r\n                text += '\\n';\r\n            }\r\n        }\r\n        return text;\r\n    }\r\n}\r\n\r\nclass JSDocLineImpl implements JSDocLine {\r\n    text: string;\r\n    range: Range;\r\n\r\n    constructor(text: string, range: Range) {\r\n        this.text = text;\r\n        this.range = range;\r\n    }\r\n\r\n    toString(): string {\r\n        return this.text;\r\n    }\r\n    toMarkdown(): string {\r\n        return this.text;\r\n    }\r\n\r\n}\r\n\r\nfunction fillNewlines(text: string): string {\r\n    if (text.endsWith('\\n')) {\r\n        return '\\n';\r\n    } else {\r\n        return '\\n\\n';\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode, AstNodeDescription } from '../syntax-tree.js';\r\nimport type { IndexManager } from '../workspace/index-manager.js';\r\nimport type { CommentProvider } from './comment-provider.js';\r\nimport type { JSDocTag } from './jsdoc.js';\r\nimport { getDocument } from '../utils/ast-util.js';\r\nimport { isJSDoc, parseJSDoc } from './jsdoc.js';\r\n\r\n/**\r\n * Provides documentation for AST nodes.\r\n */\r\nexport interface DocumentationProvider {\r\n    /**\r\n     * Returns a markdown documentation string for the specified AST node.\r\n     *\r\n     * The default implementation `JSDocDocumentationProvider` will inspect the comment associated with the specified node.\r\n     */\r\n    getDocumentation(node: AstNode): string | undefined;\r\n}\r\n\r\nexport class JSDocDocumentationProvider implements DocumentationProvider {\r\n\r\n    protected readonly indexManager: IndexManager;\r\n    protected readonly commentProvider: CommentProvider;\r\n\r\n    constructor(services: LangiumServices) {\r\n        this.indexManager = services.shared.workspace.IndexManager;\r\n        this.commentProvider = services.documentation.CommentProvider;\r\n    }\r\n\r\n    getDocumentation(node: AstNode): string | undefined {\r\n        const comment = this.commentProvider.getComment(node);\r\n        if (comment && isJSDoc(comment)) {\r\n            const parsedJSDoc = parseJSDoc(comment);\r\n            return parsedJSDoc.toMarkdown({\r\n                renderLink: (link, display) => {\r\n                    return this.documentationLinkRenderer(node, link, display);\r\n                },\r\n                renderTag: (tag) => {\r\n                    return this.documentationTagRenderer(node, tag);\r\n                }\r\n            });\r\n        }\r\n        return undefined;\r\n    }\r\n\r\n    protected documentationLinkRenderer(node: AstNode, name: string, display: string): string | undefined {\r\n        const description = this.findNameInPrecomputedScopes(node, name) ?? this.findNameInGlobalScope(node, name);\r\n        if (description && description.nameSegment) {\r\n            const line = description.nameSegment.range.start.line + 1;\r\n            const character = description.nameSegment.range.start.character + 1;\r\n            const uri = description.documentUri.with({ fragment: `L${line},${character}` });\r\n            return `[${display}](${uri.toString()})`;\r\n        } else {\r\n            return undefined;\r\n        }\r\n    }\r\n\r\n    protected documentationTagRenderer(_node: AstNode, _tag: JSDocTag): string | undefined {\r\n        // Fall back to the default tag rendering\r\n        return undefined;\r\n    }\r\n\r\n    protected findNameInPrecomputedScopes(node: AstNode, name: string): AstNodeDescription | undefined {\r\n        const document = getDocument(node);\r\n        const precomputed = document.precomputedScopes;\r\n        if (!precomputed) {\r\n            return undefined;\r\n        }\r\n        let currentNode: AstNode | undefined = node;\r\n        do {\r\n            const allDescriptions = precomputed.get(currentNode);\r\n            const description = allDescriptions.find(e => e.name === name);\r\n            if (description) {\r\n                return description;\r\n            }\r\n            currentNode = currentNode.$container;\r\n        } while (currentNode);\r\n\r\n        return undefined;\r\n    }\r\n\r\n    protected findNameInGlobalScope(node: AstNode, name: string): AstNodeDescription | undefined {\r\n        const description = this.indexManager.allElements().find(e => e.name === name);\r\n        return description;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2023 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { GrammarConfig } from '../grammar/grammar-config.js';\r\nimport { isAstNodeWithComment } from '../serializer/json-serializer.js';\r\nimport type { LangiumServices } from '../services.js';\r\nimport type { AstNode } from '../syntax-tree.js';\r\nimport { findCommentNode } from '../utils/cst-util.js';\r\n\r\n/**\r\n * Provides comments for AST nodes.\r\n */\r\nexport interface CommentProvider {\r\n    /**\r\n     * Returns the comment associated with the specified AST node.\r\n     * @param node The AST node to get the comment for.\r\n     * @returns The comment associated with the specified AST node or `undefined` if there is no comment.\r\n     */\r\n    getComment(node: AstNode): string | undefined;\r\n}\r\n\r\nexport class DefaultCommentProvider implements CommentProvider {\r\n    protected readonly grammarConfig: () => GrammarConfig;\r\n    constructor(services: LangiumServices) {\r\n        this.grammarConfig = () => services.parser.GrammarConfig;\r\n    }\r\n    getComment(node: AstNode): string | undefined {\r\n        if(isAstNodeWithComment(node)) {\r\n            return node.$comment;\r\n        }\r\n        return findCommentNode(node.$cstNode, this.grammarConfig().multilineCommentRules)?.text;\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2021 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nexport interface Disposable {\r\n    /**\r\n     * Dispose this object.\r\n     */\r\n    dispose(): void;\r\n}\r\n\r\nexport interface AsyncDisposable {\r\n    /**\r\n     * Dispose this object.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport namespace Disposable {\r\n    export function create(callback: () => Promise<void>): AsyncDisposable;\r\n    export function create(callback: () => void): Disposable;\r\n    export function create(callback: () => void | Promise<void>): Disposable | AsyncDisposable {\r\n        return {\r\n            dispose: async () => await callback()\r\n        };\r\n    }\r\n}\r\n", "/******************************************************************************\r\n * Copyright 2022 TypeFox GmbH\r\n * This program and the accompanying materials are made available under the\r\n * terms of the MIT License, which is available in the project root.\r\n ******************************************************************************/\r\n\r\nimport type { URI } from '../utils/uri-util.js';\r\nimport { UriUtils } from '../utils/uri-util.js';\r\nimport type { FileSystemNode, FileSystemProvider } from '../workspace/file-system-provider.js';\r\nimport * as fs from 'node:fs';\r\n\r\nexport type NodeTextEncoding = 'ascii' | 'utf8' | 'utf-8' | 'utf16le' | 'ucs2' | 'ucs-2' | 'latin1';\r\n\r\nexport class NodeFileSystemProvider implements FileSystemProvider {\r\n\r\n    encoding: NodeTextEncoding = 'utf-8';\r\n\r\n    readFile(uri: URI): Promise<string> {\r\n        return fs.promises.readFile(uri.fsPath, this.encoding);\r\n    }\r\n\r\n    readFileSync(uri: URI): string {\r\n        return fs.readFileSync(uri.fsPath, this.encoding);\r\n    }\r\n\r\n    async readDirectory(folderPath: URI): Promise<FileSystemNode[]> {\r\n        const dirents = await fs.promises.readdir(folderPath.fsPath, { withFileTypes: true });\r\n        return dirents.map(dirent => ({\r\n            dirent, // Include the raw entry, it may be useful...\r\n            isFile: dirent.isFile(),\r\n            isDirectory: dirent.isDirectory(),\r\n            uri: UriUtils.joinPath(folderPath, dirent.name)\r\n        }));\r\n    }\r\n}\r\n\r\nexport const NodeFileSystem = {\r\n    fileSystemProvider: () => new NodeFileSystemProvider()\r\n};\r\n", "import { startLanguageServer } from 'langium';\r\nimport { NodeFileSystem } from 'langium/node';\r\nimport { createConnection, ProposedFeatures } from 'vscode-languageserver/node.js';\r\nimport { createRobServices } from './rob-module.js';\r\n\r\n// Create a connection to the client\r\nconst connection = createConnection(ProposedFeatures.all);\r\n\r\n// Inject the shared services and language-specific services\r\nconst { shared } = createRobServices({ connection, ...NodeFileSystem });\r\n\r\n// Start the language server with the shared services\r\nstartLanguageServer(shared);\r\n", "/******************************************************************************\r\n * This file was generated by langium-cli 2.1.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\n/* eslint-disable */\r\nimport type { AstNode, Reference, ReferenceInfo, TypeMetaData } from 'langium';\r\nimport { AbstractAstReflection } from 'langium';\r\n\r\nexport const RobTerminals = {\r\n    ID: /(\\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/,\r\n    INT: /[0-9]+/,\r\n    STRING: /((\"((\\\\([\\s\\S]))|((?!(\\\\|\"))[\\s\\S]*?))*\")|('((\\\\([\\s\\S]))|((?!(\\\\|'))[\\s\\S]*?))*'))/,\r\n    ML_COMMENT: /(\\/\\*([\\s\\S]*?\\*\\/))/,\r\n    SL_COMMENT: /(\\/\\/((?!(\\n|\\r))[\\s\\S]*?)(\\r?\\n)?)/,\r\n    WS: /((( |\t)|\\r)|\\n)+/,\r\n};\r\n\r\nexport type EBoolean = boolean;\r\n\r\nexport function isEBoolean(item: unknown): item is EBoolean {\r\n    return typeof item === 'boolean';\r\n}\r\n\r\nexport type EInt = number;\r\n\r\nexport function isEInt(item: unknown): item is EInt {\r\n    return typeof item === 'number';\r\n}\r\n\r\nexport type EString = string;\r\n\r\nexport function isEString(item: unknown): item is EString {\r\n    return (typeof item === 'string' && (/((\"((\\\\([\\s\\S]))|((?!(\\\\|\"))[\\s\\S]*?))*\")|('((\\\\([\\s\\S]))|((?!(\\\\|'))[\\s\\S]*?))*'))/.test(item) || /(\\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/.test(item)));\r\n}\r\n\r\nexport type Mouvement = Mouvement_ARRIERE | Mouvement_AVANT | Mouvement_DROITE | Mouvement_GAUCHE;\r\n\r\nexport type Mouvement_ARRIERE = 'ARRIERE';\r\n\r\nexport type Mouvement_AVANT = 'AVANT';\r\n\r\nexport type Mouvement_DROITE = 'DROITE';\r\n\r\nexport type Mouvement_GAUCHE = 'GAUCHE';\r\n\r\nexport type Types = Types_Boolean | Types_Number | Types_Void;\r\n\r\nexport type Types_Boolean = 'Boolean';\r\n\r\nexport type Types_Number = 'Number';\r\n\r\nexport type Types_Void = 'Void';\r\n\r\nexport interface Expression extends AstNode {\r\n    readonly $type: 'BinaryExpression' | 'ConstantBoolean' | 'ConstantInt' | 'DistanceCaptor' | 'Expression' | 'ProcCall' | 'Sensor' | 'ValCall';\r\n}\r\n\r\nexport const Expression = 'Expression';\r\n\r\nexport function isExpression(item: unknown): item is Expression {\r\n    return reflection.isInstance(item, Expression);\r\n}\r\n\r\nexport interface ExpressionType extends AstNode {\r\n    readonly $type: 'Addition' | 'And' | 'Equality' | 'ExpressionType' | 'Greater' | 'Lower' | 'Multiplication' | 'Or' | 'Soustraction';\r\n}\r\n\r\nexport const ExpressionType = 'ExpressionType';\r\n\r\nexport function isExpressionType(item: unknown): item is ExpressionType {\r\n    return reflection.isInstance(item, ExpressionType);\r\n}\r\n\r\nexport interface ProcDeclaration extends AstNode {\r\n    readonly $container: Robot;\r\n    readonly $type: 'ProcDeclaration';\r\n    block?: Block\r\n    name: string\r\n    parameters: Array<VarDeclaration>\r\n    returnedType: Types\r\n}\r\n\r\nexport const ProcDeclaration = 'ProcDeclaration';\r\n\r\nexport function isProcDeclaration(item: unknown): item is ProcDeclaration {\r\n    return reflection.isInstance(item, ProcDeclaration);\r\n}\r\n\r\nexport interface Robot extends AstNode {\r\n    readonly $type: 'Robot';\r\n    function: Array<ProcDeclaration>\r\n}\r\n\r\nexport const Robot = 'Robot';\r\n\r\nexport function isRobot(item: unknown): item is Robot {\r\n    return reflection.isInstance(item, Robot);\r\n}\r\n\r\nexport interface Statement extends AstNode {\r\n    readonly $type: 'Assignation' | 'Block' | 'Clock' | 'ControlStructure' | 'CustomAction' | 'Deplacement' | 'If' | 'Repeat' | 'Return' | 'Speed' | 'Statement' | 'VarDeclaration' | 'While';\r\n}\r\n\r\nexport const Statement = 'Statement';\r\n\r\nexport function isStatement(item: unknown): item is Statement {\r\n    return reflection.isInstance(item, Statement);\r\n}\r\n\r\nexport interface Unite extends AstNode {\r\n    readonly $type: 'CM' | 'MM' | 'Unite';\r\n}\r\n\r\nexport const Unite = 'Unite';\r\n\r\nexport function isUnite(item: unknown): item is Unite {\r\n    return reflection.isInstance(item, Unite);\r\n}\r\n\r\nexport interface BinaryExpression extends Expression {\r\n    readonly $type: 'BinaryExpression';\r\n    left: Expression\r\n    operator: ExpressionType\r\n    right: Expression\r\n}\r\n\r\nexport const BinaryExpression = 'BinaryExpression';\r\n\r\nexport function isBinaryExpression(item: unknown): item is BinaryExpression {\r\n    return reflection.isInstance(item, BinaryExpression);\r\n}\r\n\r\nexport interface ConstantBoolean extends Expression {\r\n    readonly $type: 'ConstantBoolean';\r\n    value: boolean\r\n}\r\n\r\nexport const ConstantBoolean = 'ConstantBoolean';\r\n\r\nexport function isConstantBoolean(item: unknown): item is ConstantBoolean {\r\n    return reflection.isInstance(item, ConstantBoolean);\r\n}\r\n\r\nexport interface ConstantInt extends Expression {\r\n    readonly $type: 'ConstantInt';\r\n    IntegerValue: number\r\n}\r\n\r\nexport const ConstantInt = 'ConstantInt';\r\n\r\nexport function isConstantInt(item: unknown): item is ConstantInt {\r\n    return reflection.isInstance(item, ConstantInt);\r\n}\r\n\r\nexport interface ProcCall extends Expression {\r\n    readonly $type: 'ProcCall';\r\n    arguments: Array<Expression>\r\n    procdeclaration?: Reference<ProcDeclaration>\r\n}\r\n\r\nexport const ProcCall = 'ProcCall';\r\n\r\nexport function isProcCall(item: unknown): item is ProcCall {\r\n    return reflection.isInstance(item, ProcCall);\r\n}\r\n\r\nexport interface Sensor extends Expression {\r\n    readonly $type: 'DistanceCaptor' | 'Sensor';\r\n    unite: Unite\r\n}\r\n\r\nexport const Sensor = 'Sensor';\r\n\r\nexport function isSensor(item: unknown): item is Sensor {\r\n    return reflection.isInstance(item, Sensor);\r\n}\r\n\r\nexport interface ValCall extends Expression {\r\n    readonly $container: Assignation;\r\n    readonly $type: 'ValCall';\r\n    vardeclaration?: Reference<VarDeclaration>\r\n}\r\n\r\nexport const ValCall = 'ValCall';\r\n\r\nexport function isValCall(item: unknown): item is ValCall {\r\n    return reflection.isInstance(item, ValCall);\r\n}\r\n\r\nexport interface Addition extends ExpressionType {\r\n    readonly $type: 'Addition';\r\n}\r\n\r\nexport const Addition = 'Addition';\r\n\r\nexport function isAddition(item: unknown): item is Addition {\r\n    return reflection.isInstance(item, Addition);\r\n}\r\n\r\nexport interface And extends ExpressionType {\r\n    readonly $type: 'And';\r\n}\r\n\r\nexport const And = 'And';\r\n\r\nexport function isAnd(item: unknown): item is And {\r\n    return reflection.isInstance(item, And);\r\n}\r\n\r\nexport interface Equality extends ExpressionType {\r\n    readonly $type: 'Equality';\r\n}\r\n\r\nexport const Equality = 'Equality';\r\n\r\nexport function isEquality(item: unknown): item is Equality {\r\n    return reflection.isInstance(item, Equality);\r\n}\r\n\r\nexport interface Greater extends ExpressionType {\r\n    readonly $type: 'Greater';\r\n}\r\n\r\nexport const Greater = 'Greater';\r\n\r\nexport function isGreater(item: unknown): item is Greater {\r\n    return reflection.isInstance(item, Greater);\r\n}\r\n\r\nexport interface Lower extends ExpressionType {\r\n    readonly $type: 'Lower';\r\n}\r\n\r\nexport const Lower = 'Lower';\r\n\r\nexport function isLower(item: unknown): item is Lower {\r\n    return reflection.isInstance(item, Lower);\r\n}\r\n\r\nexport interface Multiplication extends ExpressionType {\r\n    readonly $type: 'Multiplication';\r\n}\r\n\r\nexport const Multiplication = 'Multiplication';\r\n\r\nexport function isMultiplication(item: unknown): item is Multiplication {\r\n    return reflection.isInstance(item, Multiplication);\r\n}\r\n\r\nexport interface Or extends ExpressionType {\r\n    readonly $type: 'Or';\r\n}\r\n\r\nexport const Or = 'Or';\r\n\r\nexport function isOr(item: unknown): item is Or {\r\n    return reflection.isInstance(item, Or);\r\n}\r\n\r\nexport interface Soustraction extends ExpressionType {\r\n    readonly $type: 'Soustraction';\r\n}\r\n\r\nexport const Soustraction = 'Soustraction';\r\n\r\nexport function isSoustraction(item: unknown): item is Soustraction {\r\n    return reflection.isInstance(item, Soustraction);\r\n}\r\n\r\nexport interface Assignation extends Statement {\r\n    readonly $type: 'Assignation';\r\n    expression: Expression\r\n    valcall: ValCall\r\n}\r\n\r\nexport const Assignation = 'Assignation';\r\n\r\nexport function isAssignation(item: unknown): item is Assignation {\r\n    return reflection.isInstance(item, Assignation);\r\n}\r\n\r\nexport interface Block extends Statement {\r\n    readonly $container: If | ProcDeclaration | Repeat | While;\r\n    readonly $type: 'Block';\r\n    statements: Array<Statement>\r\n}\r\n\r\nexport const Block = 'Block';\r\n\r\nexport function isBlock(item: unknown): item is Block {\r\n    return reflection.isInstance(item, Block);\r\n}\r\n\r\nexport interface ControlStructure extends Statement {\r\n    readonly $type: 'ControlStructure' | 'If' | 'Repeat' | 'While';\r\n    condition?: Expression\r\n}\r\n\r\nexport const ControlStructure = 'ControlStructure';\r\n\r\nexport function isControlStructure(item: unknown): item is ControlStructure {\r\n    return reflection.isInstance(item, ControlStructure);\r\n}\r\n\r\nexport interface CustomAction extends Statement {\r\n    readonly $type: 'Clock' | 'CustomAction' | 'Deplacement' | 'Speed';\r\n}\r\n\r\nexport const CustomAction = 'CustomAction';\r\n\r\nexport function isCustomAction(item: unknown): item is CustomAction {\r\n    return reflection.isInstance(item, CustomAction);\r\n}\r\n\r\nexport interface Return extends Statement {\r\n    readonly $type: 'Return';\r\n    expression: Expression\r\n}\r\n\r\nexport const Return = 'Return';\r\n\r\nexport function isReturn(item: unknown): item is Return {\r\n    return reflection.isInstance(item, Return);\r\n}\r\n\r\nexport interface VarDeclaration extends Statement {\r\n    readonly $container: ProcDeclaration;\r\n    readonly $type: 'VarDeclaration';\r\n    expression?: Expression\r\n    name: string\r\n    type: Types\r\n}\r\n\r\nexport const VarDeclaration = 'VarDeclaration';\r\n\r\nexport function isVarDeclaration(item: unknown): item is VarDeclaration {\r\n    return reflection.isInstance(item, VarDeclaration);\r\n}\r\n\r\nexport interface CM extends Unite {\r\n    readonly $type: 'CM';\r\n}\r\n\r\nexport const CM = 'CM';\r\n\r\nexport function isCM(item: unknown): item is CM {\r\n    return reflection.isInstance(item, CM);\r\n}\r\n\r\nexport interface MM extends Unite {\r\n    readonly $type: 'MM';\r\n}\r\n\r\nexport const MM = 'MM';\r\n\r\nexport function isMM(item: unknown): item is MM {\r\n    return reflection.isInstance(item, MM);\r\n}\r\n\r\nexport interface DistanceCaptor extends Sensor {\r\n    readonly $type: 'DistanceCaptor';\r\n}\r\n\r\nexport const DistanceCaptor = 'DistanceCaptor';\r\n\r\nexport function isDistanceCaptor(item: unknown): item is DistanceCaptor {\r\n    return reflection.isInstance(item, DistanceCaptor);\r\n}\r\n\r\nexport interface If extends ControlStructure {\r\n    readonly $type: 'If';\r\n    else?: Block\r\n    then: Block\r\n}\r\n\r\nexport const If = 'If';\r\n\r\nexport function isIf(item: unknown): item is If {\r\n    return reflection.isInstance(item, If);\r\n}\r\n\r\nexport interface Repeat extends ControlStructure {\r\n    readonly $type: 'Repeat';\r\n    block: Block\r\n}\r\n\r\nexport const Repeat = 'Repeat';\r\n\r\nexport function isRepeat(item: unknown): item is Repeat {\r\n    return reflection.isInstance(item, Repeat);\r\n}\r\n\r\nexport interface While extends ControlStructure {\r\n    readonly $type: 'While';\r\n    block: Block\r\n}\r\n\r\nexport const While = 'While';\r\n\r\nexport function isWhile(item: unknown): item is While {\r\n    return reflection.isInstance(item, While);\r\n}\r\n\r\nexport interface Clock extends CustomAction {\r\n    readonly $type: 'Clock';\r\n    time: Expression\r\n}\r\n\r\nexport const Clock = 'Clock';\r\n\r\nexport function isClock(item: unknown): item is Clock {\r\n    return reflection.isInstance(item, Clock);\r\n}\r\n\r\nexport interface Deplacement extends CustomAction {\r\n    readonly $type: 'Deplacement';\r\n    deplacement_value: Expression\r\n    mouvement?: Mouvement\r\n    unite: Unite\r\n}\r\n\r\nexport const Deplacement = 'Deplacement';\r\n\r\nexport function isDeplacement(item: unknown): item is Deplacement {\r\n    return reflection.isInstance(item, Deplacement);\r\n}\r\n\r\nexport interface Speed extends CustomAction {\r\n    readonly $type: 'Speed';\r\n    unite: Unite\r\n    value: Expression\r\n}\r\n\r\nexport const Speed = 'Speed';\r\n\r\nexport function isSpeed(item: unknown): item is Speed {\r\n    return reflection.isInstance(item, Speed);\r\n}\r\n\r\nexport type RobAstType = {\r\n    Addition: Addition\r\n    And: And\r\n    Assignation: Assignation\r\n    BinaryExpression: BinaryExpression\r\n    Block: Block\r\n    CM: CM\r\n    Clock: Clock\r\n    ConstantBoolean: ConstantBoolean\r\n    ConstantInt: ConstantInt\r\n    ControlStructure: ControlStructure\r\n    CustomAction: CustomAction\r\n    Deplacement: Deplacement\r\n    DistanceCaptor: DistanceCaptor\r\n    Equality: Equality\r\n    Expression: Expression\r\n    ExpressionType: ExpressionType\r\n    Greater: Greater\r\n    If: If\r\n    Lower: Lower\r\n    MM: MM\r\n    Multiplication: Multiplication\r\n    Or: Or\r\n    ProcCall: ProcCall\r\n    ProcDeclaration: ProcDeclaration\r\n    Repeat: Repeat\r\n    Return: Return\r\n    Robot: Robot\r\n    Sensor: Sensor\r\n    Soustraction: Soustraction\r\n    Speed: Speed\r\n    Statement: Statement\r\n    Unite: Unite\r\n    ValCall: ValCall\r\n    VarDeclaration: VarDeclaration\r\n    While: While\r\n}\r\n\r\nexport class RobAstReflection extends AbstractAstReflection {\r\n\r\n    getAllTypes(): string[] {\r\n        return ['Addition', 'And', 'Assignation', 'BinaryExpression', 'Block', 'CM', 'Clock', 'ConstantBoolean', 'ConstantInt', 'ControlStructure', 'CustomAction', 'Deplacement', 'DistanceCaptor', 'Equality', 'Expression', 'ExpressionType', 'Greater', 'If', 'Lower', 'MM', 'Multiplication', 'Or', 'ProcCall', 'ProcDeclaration', 'Repeat', 'Return', 'Robot', 'Sensor', 'Soustraction', 'Speed', 'Statement', 'Unite', 'ValCall', 'VarDeclaration', 'While'];\r\n    }\r\n\r\n    protected override computeIsSubtype(subtype: string, supertype: string): boolean {\r\n        switch (subtype) {\r\n            case Addition:\r\n            case And:\r\n            case Equality:\r\n            case Greater:\r\n            case Lower:\r\n            case Multiplication:\r\n            case Or:\r\n            case Soustraction: {\r\n                return this.isSubtype(ExpressionType, supertype);\r\n            }\r\n            case Assignation:\r\n            case Block:\r\n            case ControlStructure:\r\n            case CustomAction:\r\n            case Return:\r\n            case VarDeclaration: {\r\n                return this.isSubtype(Statement, supertype);\r\n            }\r\n            case BinaryExpression:\r\n            case ConstantBoolean:\r\n            case ConstantInt:\r\n            case ProcCall:\r\n            case Sensor:\r\n            case ValCall: {\r\n                return this.isSubtype(Expression, supertype);\r\n            }\r\n            case Clock:\r\n            case Deplacement:\r\n            case Speed: {\r\n                return this.isSubtype(CustomAction, supertype);\r\n            }\r\n            case CM:\r\n            case MM: {\r\n                return this.isSubtype(Unite, supertype);\r\n            }\r\n            case DistanceCaptor: {\r\n                return this.isSubtype(Sensor, supertype);\r\n            }\r\n            case If:\r\n            case Repeat:\r\n            case While: {\r\n                return this.isSubtype(ControlStructure, supertype);\r\n            }\r\n            default: {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    getReferenceType(refInfo: ReferenceInfo): string {\r\n        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;\r\n        switch (referenceId) {\r\n            case 'ProcCall:procdeclaration': {\r\n                return ProcDeclaration;\r\n            }\r\n            case 'ValCall:vardeclaration': {\r\n                return VarDeclaration;\r\n            }\r\n            default: {\r\n                throw new Error(`${referenceId} is not a valid reference id.`);\r\n            }\r\n        }\r\n    }\r\n\r\n    getTypeMetaData(type: string): TypeMetaData {\r\n        switch (type) {\r\n            case 'ProcDeclaration': {\r\n                return {\r\n                    name: 'ProcDeclaration',\r\n                    mandatory: [\r\n                        { name: 'parameters', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'Robot': {\r\n                return {\r\n                    name: 'Robot',\r\n                    mandatory: [\r\n                        { name: 'function', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'ConstantBoolean': {\r\n                return {\r\n                    name: 'ConstantBoolean',\r\n                    mandatory: [\r\n                        { name: 'value', type: 'boolean' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'ProcCall': {\r\n                return {\r\n                    name: 'ProcCall',\r\n                    mandatory: [\r\n                        { name: 'arguments', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            case 'Block': {\r\n                return {\r\n                    name: 'Block',\r\n                    mandatory: [\r\n                        { name: 'statements', type: 'array' }\r\n                    ]\r\n                };\r\n            }\r\n            default: {\r\n                return {\r\n                    name: type,\r\n                    mandatory: []\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nexport const reflection = new RobAstReflection();\r\n", "/******************************************************************************\r\n * This file was generated by langium-cli 2.1.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\nimport type { Grammar } from 'langium';\r\nimport { loadGrammarFromJson } from 'langium';\r\n\r\nlet loadedRobGrammar: Grammar | undefined;\r\nexport const RobGrammar = (): Grammar => loadedRobGrammar ?? (loadedRobGrammar = loadGrammarFromJson(`{\r\n  \"$type\": \"Grammar\",\r\n  \"isDeclared\": true,\r\n  \"name\": \"Rob\",\r\n  \"imports\": [],\r\n  \"rules\": [\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Robot\",\r\n      \"entry\": true,\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@0\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Assignment\",\r\n        \"feature\": \"function\",\r\n        \"operator\": \"+=\",\r\n        \"terminal\": {\r\n          \"$type\": \"RuleCall\",\r\n          \"rule\": {\r\n            \"$ref\": \"#/rules@5\"\r\n          },\r\n          \"arguments\": []\r\n        },\r\n        \"cardinality\": \"*\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Statement\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@3\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Alternatives\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@6\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@12\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@13\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@14\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@15\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@16\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@17\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@22\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@18\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@19\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@38\"\r\n                },\r\n                \"arguments\": []\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \";\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Expression\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@4\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@20\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@21\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@22\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@23\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@24\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@25\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Unite\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@5\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@35\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@36\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"ExpressionType\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@6\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@26\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@27\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@28\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@29\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@30\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@32\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@33\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@31\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"ProcDeclaration\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@1\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"fun\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"returnedType\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@8\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"name\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@7\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Group\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"Keyword\",\r\n                \"value\": \"(\"\r\n              },\r\n              {\r\n                \"$type\": \"Group\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"Assignment\",\r\n                    \"feature\": \"parameters\",\r\n                    \"operator\": \"+=\",\r\n                    \"terminal\": {\r\n                      \"$type\": \"RuleCall\",\r\n                      \"rule\": {\r\n                        \"$ref\": \"#/rules@18\"\r\n                      },\r\n                      \"arguments\": []\r\n                    }\r\n                  },\r\n                  {\r\n                    \"$type\": \"Keyword\",\r\n                    \"value\": \",\",\r\n                    \"cardinality\": \"?\"\r\n                  }\r\n                ],\r\n                \"cardinality\": \"*\"\r\n              },\r\n              {\r\n                \"$type\": \"Keyword\",\r\n                \"value\": \")\"\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"block\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@6\"\r\n              },\r\n              \"arguments\": []\r\n            },\r\n            \"cardinality\": \"?\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Block\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@2\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"{\"\r\n          },\r\n          {\r\n            \"$type\": \"Group\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"Assignment\",\r\n                \"feature\": \"statements\",\r\n                \"operator\": \"+=\",\r\n                \"terminal\": {\r\n                  \"$type\": \"RuleCall\",\r\n                  \"rule\": {\r\n                    \"$ref\": \"#/rules@1\"\r\n                  },\r\n                  \"arguments\": []\r\n                }\r\n              },\r\n              {\r\n                \"$type\": \"Assignment\",\r\n                \"feature\": \"statements\",\r\n                \"operator\": \"+=\",\r\n                \"terminal\": {\r\n                  \"$type\": \"RuleCall\",\r\n                  \"rule\": {\r\n                    \"$ref\": \"#/rules@1\"\r\n                  },\r\n                  \"arguments\": []\r\n                },\r\n                \"cardinality\": \"*\"\r\n              }\r\n            ],\r\n            \"cardinality\": \"?\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"}\"\r\n          }\r\n        ],\r\n        \"cardinality\": \"?\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"EString\",\r\n      \"dataType\": \"string\",\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@46\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@44\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Types\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@0\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@9\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@10\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@11\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Types_Number\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@1\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"Number\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Types_Void\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@2\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"Void\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Types_Boolean\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@3\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"Boolean\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"If\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@7\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"If\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"condition\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"{\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"then\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"then\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@6\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Group\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"Keyword\",\r\n                \"value\": \"else\"\r\n              },\r\n              {\r\n                \"$type\": \"Assignment\",\r\n                \"feature\": \"else\",\r\n                \"operator\": \"=\",\r\n                \"terminal\": {\r\n                  \"$type\": \"RuleCall\",\r\n                  \"rule\": {\r\n                    \"$ref\": \"#/rules@6\"\r\n                  },\r\n                  \"arguments\": []\r\n                }\r\n              }\r\n            ],\r\n            \"cardinality\": \"?\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"}\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"While\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@9\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"While\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"condition\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"block\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@6\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Repeat\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@10\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"Repeat\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"condition\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"block\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@6\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Clock\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@11\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"Clock\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"time\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Deplacement\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@13\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"Deplacement\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"mouvement\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@39\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \",\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"deplacement_value\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \",\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"unite\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@3\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Speed\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@14\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"setSpeed\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"value\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \",\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"unite\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@3\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"VarDeclaration\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@15\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"type\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@8\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"name\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@7\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Group\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"Keyword\",\r\n                \"value\": \"=\"\r\n              },\r\n              {\r\n                \"$type\": \"Assignment\",\r\n                \"feature\": \"expression\",\r\n                \"operator\": \"=\",\r\n                \"terminal\": {\r\n                  \"$type\": \"RuleCall\",\r\n                  \"rule\": {\r\n                    \"$ref\": \"#/rules@2\"\r\n                  },\r\n                  \"arguments\": []\r\n                }\r\n              }\r\n            ],\r\n            \"cardinality\": \"?\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Assignation\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@16\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"valcall\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@25\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"=\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"expression\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"BinaryExpression\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@18\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"left\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"operator\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@4\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"right\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"ConstantInt\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@19\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Assignment\",\r\n        \"feature\": \"IntegerValue\",\r\n        \"operator\": \"=\",\r\n        \"terminal\": {\r\n          \"$type\": \"RuleCall\",\r\n          \"rule\": {\r\n            \"$ref\": \"#/rules@34\"\r\n          },\r\n          \"arguments\": []\r\n        }\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"ProcCall\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@20\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"procdeclaration\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"CrossReference\",\r\n              \"type\": {\r\n                \"$ref\": \"#/interfaces@1\"\r\n              },\r\n              \"terminal\": {\r\n                \"$type\": \"RuleCall\",\r\n                \"rule\": {\r\n                  \"$ref\": \"#/rules@7\"\r\n                },\r\n                \"arguments\": []\r\n              },\r\n              \"deprecatedSyntax\": false\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Group\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"Assignment\",\r\n                \"feature\": \"arguments\",\r\n                \"operator\": \"+=\",\r\n                \"terminal\": {\r\n                  \"$type\": \"RuleCall\",\r\n                  \"rule\": {\r\n                    \"$ref\": \"#/rules@2\"\r\n                  },\r\n                  \"arguments\": []\r\n                }\r\n              },\r\n              {\r\n                \"$type\": \"Group\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"Keyword\",\r\n                    \"value\": \",\"\r\n                  },\r\n                  {\r\n                    \"$type\": \"Assignment\",\r\n                    \"feature\": \"arguments\",\r\n                    \"operator\": \"+=\",\r\n                    \"terminal\": {\r\n                      \"$type\": \"RuleCall\",\r\n                      \"rule\": {\r\n                        \"$ref\": \"#/rules@2\"\r\n                      },\r\n                      \"arguments\": []\r\n                    }\r\n                  }\r\n                ],\r\n                \"cardinality\": \"*\"\r\n              }\r\n            ],\r\n            \"cardinality\": \"?\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"DistanceCaptor\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@21\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"getDistanceFromCaptor\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"(\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"unite\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@3\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \")\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"ConstantBoolean\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@23\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Assignment\",\r\n        \"feature\": \"value\",\r\n        \"operator\": \"=\",\r\n        \"terminal\": {\r\n          \"$type\": \"RuleCall\",\r\n          \"rule\": {\r\n            \"$ref\": \"#/rules@37\"\r\n          },\r\n          \"arguments\": []\r\n        }\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"ValCall\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@17\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Assignment\",\r\n        \"feature\": \"vardeclaration\",\r\n        \"operator\": \"=\",\r\n        \"terminal\": {\r\n          \"$type\": \"CrossReference\",\r\n          \"type\": {\r\n            \"$ref\": \"#/interfaces@15\"\r\n          },\r\n          \"terminal\": {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@7\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          \"deprecatedSyntax\": false\r\n        }\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Addition\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@24\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@24\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"+\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Soustraction\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@25\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@25\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"-\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Multiplication\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@26\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@26\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"*\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Lower\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@27\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@27\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"<\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Greater\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@29\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@29\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \">\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Equality\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@28\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@28\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"==\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"And\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@30\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@30\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"and\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Or\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@31\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@31\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"or\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"EInt\",\r\n      \"dataType\": \"number\",\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"-\",\r\n            \"cardinality\": \"?\"\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@45\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"MM\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@32\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@32\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"MM\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"CM\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@33\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Action\",\r\n            \"type\": {\r\n              \"$ref\": \"#/interfaces@33\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"CM\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"EBoolean\",\r\n      \"dataType\": \"boolean\",\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"true\"\r\n          },\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"false\"\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Return\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/interfaces@34\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Group\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"Keyword\",\r\n            \"value\": \"return\"\r\n          },\r\n          {\r\n            \"$type\": \"Assignment\",\r\n            \"feature\": \"expression\",\r\n            \"operator\": \"=\",\r\n            \"terminal\": {\r\n              \"$type\": \"RuleCall\",\r\n              \"rule\": {\r\n                \"$ref\": \"#/rules@2\"\r\n              },\r\n              \"arguments\": []\r\n            }\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Mouvement\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@4\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Alternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@40\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@41\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@42\"\r\n            },\r\n            \"arguments\": []\r\n          },\r\n          {\r\n            \"$type\": \"RuleCall\",\r\n            \"rule\": {\r\n              \"$ref\": \"#/rules@43\"\r\n            },\r\n            \"arguments\": []\r\n          }\r\n        ]\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Mouvement_AVANT\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@5\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"AVANT\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Mouvement_ARRIERE\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@6\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"ARRIERE\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Mouvement_DROITE\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@7\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"DROITE\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"ParserRule\",\r\n      \"name\": \"Mouvement_GAUCHE\",\r\n      \"returnType\": {\r\n        \"$ref\": \"#/types@8\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Keyword\",\r\n        \"value\": \"GAUCHE\"\r\n      },\r\n      \"definesHiddenTokens\": false,\r\n      \"entry\": false,\r\n      \"fragment\": false,\r\n      \"hiddenTokens\": [],\r\n      \"parameters\": [],\r\n      \"wildcard\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"name\": \"ID\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"string\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"TerminalGroup\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"CharacterRange\",\r\n            \"left\": {\r\n              \"$type\": \"Keyword\",\r\n              \"value\": \"^\"\r\n            },\r\n            \"cardinality\": \"?\"\r\n          },\r\n          {\r\n            \"$type\": \"TerminalAlternatives\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"TerminalAlternatives\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"CharacterRange\",\r\n                    \"left\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \"a\"\r\n                    },\r\n                    \"right\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \"z\"\r\n                    }\r\n                  },\r\n                  {\r\n                    \"$type\": \"CharacterRange\",\r\n                    \"left\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \"A\"\r\n                    },\r\n                    \"right\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \"Z\"\r\n                    }\r\n                  }\r\n                ]\r\n              },\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"_\"\r\n                }\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            \"$type\": \"TerminalAlternatives\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"TerminalAlternatives\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"TerminalAlternatives\",\r\n                    \"elements\": [\r\n                      {\r\n                        \"$type\": \"CharacterRange\",\r\n                        \"left\": {\r\n                          \"$type\": \"Keyword\",\r\n                          \"value\": \"a\"\r\n                        },\r\n                        \"right\": {\r\n                          \"$type\": \"Keyword\",\r\n                          \"value\": \"z\"\r\n                        }\r\n                      },\r\n                      {\r\n                        \"$type\": \"CharacterRange\",\r\n                        \"left\": {\r\n                          \"$type\": \"Keyword\",\r\n                          \"value\": \"A\"\r\n                        },\r\n                        \"right\": {\r\n                          \"$type\": \"Keyword\",\r\n                          \"value\": \"Z\"\r\n                        }\r\n                      }\r\n                    ]\r\n                  },\r\n                  {\r\n                    \"$type\": \"CharacterRange\",\r\n                    \"left\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \"_\"\r\n                    }\r\n                  }\r\n                ]\r\n              },\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"0\"\r\n                },\r\n                \"right\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"9\"\r\n                }\r\n              }\r\n            ],\r\n            \"cardinality\": \"*\"\r\n          }\r\n        ]\r\n      },\r\n      \"fragment\": false,\r\n      \"hidden\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"name\": \"INT\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"number\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"CharacterRange\",\r\n        \"left\": {\r\n          \"$type\": \"Keyword\",\r\n          \"value\": \"0\"\r\n        },\r\n        \"right\": {\r\n          \"$type\": \"Keyword\",\r\n          \"value\": \"9\"\r\n        },\r\n        \"cardinality\": \"+\"\r\n      },\r\n      \"fragment\": false,\r\n      \"hidden\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"name\": \"STRING\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"string\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"TerminalAlternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"TerminalGroup\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"\\\\\"\"\r\n                }\r\n              },\r\n              {\r\n                \"$type\": \"TerminalAlternatives\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"TerminalGroup\",\r\n                    \"elements\": [\r\n                      {\r\n                        \"$type\": \"CharacterRange\",\r\n                        \"left\": {\r\n                          \"$type\": \"Keyword\",\r\n                          \"value\": \"\\\\\\\\\"\r\n                        }\r\n                      },\r\n                      {\r\n                        \"$type\": \"Wildcard\"\r\n                      }\r\n                    ]\r\n                  },\r\n                  {\r\n                    \"$type\": \"NegatedToken\",\r\n                    \"terminal\": {\r\n                      \"$type\": \"TerminalAlternatives\",\r\n                      \"elements\": [\r\n                        {\r\n                          \"$type\": \"CharacterRange\",\r\n                          \"left\": {\r\n                            \"$type\": \"Keyword\",\r\n                            \"value\": \"\\\\\\\\\"\r\n                          }\r\n                        },\r\n                        {\r\n                          \"$type\": \"CharacterRange\",\r\n                          \"left\": {\r\n                            \"$type\": \"Keyword\",\r\n                            \"value\": \"\\\\\"\"\r\n                          }\r\n                        }\r\n                      ]\r\n                    }\r\n                  }\r\n                ],\r\n                \"cardinality\": \"*\"\r\n              },\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"\\\\\"\"\r\n                }\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            \"$type\": \"TerminalGroup\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"'\"\r\n                }\r\n              },\r\n              {\r\n                \"$type\": \"TerminalAlternatives\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"TerminalGroup\",\r\n                    \"elements\": [\r\n                      {\r\n                        \"$type\": \"CharacterRange\",\r\n                        \"left\": {\r\n                          \"$type\": \"Keyword\",\r\n                          \"value\": \"\\\\\\\\\"\r\n                        }\r\n                      },\r\n                      {\r\n                        \"$type\": \"Wildcard\"\r\n                      }\r\n                    ]\r\n                  },\r\n                  {\r\n                    \"$type\": \"NegatedToken\",\r\n                    \"terminal\": {\r\n                      \"$type\": \"TerminalAlternatives\",\r\n                      \"elements\": [\r\n                        {\r\n                          \"$type\": \"CharacterRange\",\r\n                          \"left\": {\r\n                            \"$type\": \"Keyword\",\r\n                            \"value\": \"\\\\\\\\\"\r\n                          }\r\n                        },\r\n                        {\r\n                          \"$type\": \"CharacterRange\",\r\n                          \"left\": {\r\n                            \"$type\": \"Keyword\",\r\n                            \"value\": \"'\"\r\n                          }\r\n                        }\r\n                      ]\r\n                    }\r\n                  }\r\n                ],\r\n                \"cardinality\": \"*\"\r\n              },\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"'\"\r\n                }\r\n              }\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      \"fragment\": false,\r\n      \"hidden\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"hidden\": true,\r\n      \"name\": \"ML_COMMENT\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"string\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"TerminalGroup\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"CharacterRange\",\r\n            \"left\": {\r\n              \"$type\": \"Keyword\",\r\n              \"value\": \"/*\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"UntilToken\",\r\n            \"terminal\": {\r\n              \"$type\": \"CharacterRange\",\r\n              \"left\": {\r\n                \"$type\": \"Keyword\",\r\n                \"value\": \"*/\"\r\n              }\r\n            }\r\n          }\r\n        ]\r\n      },\r\n      \"fragment\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"hidden\": true,\r\n      \"name\": \"SL_COMMENT\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"string\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"TerminalGroup\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"CharacterRange\",\r\n            \"left\": {\r\n              \"$type\": \"Keyword\",\r\n              \"value\": \"//\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"NegatedToken\",\r\n            \"terminal\": {\r\n              \"$type\": \"TerminalAlternatives\",\r\n              \"elements\": [\r\n                {\r\n                  \"$type\": \"CharacterRange\",\r\n                  \"left\": {\r\n                    \"$type\": \"Keyword\",\r\n                    \"value\": \"\\\\n\"\r\n                  }\r\n                },\r\n                {\r\n                  \"$type\": \"CharacterRange\",\r\n                  \"left\": {\r\n                    \"$type\": \"Keyword\",\r\n                    \"value\": \"\\\\r\"\r\n                  }\r\n                }\r\n              ]\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"TerminalGroup\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"\\\\r\"\r\n                },\r\n                \"cardinality\": \"?\"\r\n              },\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"\\\\n\"\r\n                }\r\n              }\r\n            ],\r\n            \"cardinality\": \"?\"\r\n          }\r\n        ]\r\n      },\r\n      \"fragment\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"hidden\": true,\r\n      \"name\": \"WS\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"string\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"TerminalAlternatives\",\r\n        \"elements\": [\r\n          {\r\n            \"$type\": \"TerminalAlternatives\",\r\n            \"elements\": [\r\n              {\r\n                \"$type\": \"TerminalAlternatives\",\r\n                \"elements\": [\r\n                  {\r\n                    \"$type\": \"CharacterRange\",\r\n                    \"left\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \" \"\r\n                    }\r\n                  },\r\n                  {\r\n                    \"$type\": \"CharacterRange\",\r\n                    \"left\": {\r\n                      \"$type\": \"Keyword\",\r\n                      \"value\": \"\\\\t\"\r\n                    }\r\n                  }\r\n                ]\r\n              },\r\n              {\r\n                \"$type\": \"CharacterRange\",\r\n                \"left\": {\r\n                  \"$type\": \"Keyword\",\r\n                  \"value\": \"\\\\r\"\r\n                }\r\n              }\r\n            ]\r\n          },\r\n          {\r\n            \"$type\": \"CharacterRange\",\r\n            \"left\": {\r\n              \"$type\": \"Keyword\",\r\n              \"value\": \"\\\\n\"\r\n            }\r\n          }\r\n        ],\r\n        \"cardinality\": \"+\"\r\n      },\r\n      \"fragment\": false\r\n    },\r\n    {\r\n      \"$type\": \"TerminalRule\",\r\n      \"name\": \"ANY_OTHER\",\r\n      \"type\": {\r\n        \"$type\": \"ReturnType\",\r\n        \"name\": \"string\"\r\n      },\r\n      \"definition\": {\r\n        \"$type\": \"Wildcard\"\r\n      },\r\n      \"fragment\": false,\r\n      \"hidden\": false\r\n    }\r\n  ],\r\n  \"definesHiddenTokens\": false,\r\n  \"hiddenTokens\": [],\r\n  \"interfaces\": [\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"function\",\r\n          \"type\": {\r\n            \"$type\": \"ArrayType\",\r\n            \"elementType\": {\r\n              \"$type\": \"SimpleType\",\r\n              \"typeRef\": {\r\n                \"$ref\": \"#/interfaces@1\"\r\n              }\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Robot\",\r\n      \"superTypes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"block\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@2\"\r\n            }\r\n          }\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"name\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"primitiveType\": \"string\"\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"returnedType\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@0\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"parameters\",\r\n          \"type\": {\r\n            \"$type\": \"ArrayType\",\r\n            \"elementType\": {\r\n              \"$type\": \"SimpleType\",\r\n              \"typeRef\": {\r\n                \"$ref\": \"#/interfaces@15\"\r\n              }\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"ProcDeclaration\",\r\n      \"superTypes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"statements\",\r\n          \"type\": {\r\n            \"$type\": \"ArrayType\",\r\n            \"elementType\": {\r\n              \"$type\": \"SimpleType\",\r\n              \"typeRef\": {\r\n                \"$ref\": \"#/interfaces@3\"\r\n              }\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Block\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@3\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Statement\",\r\n      \"attributes\": [],\r\n      \"superTypes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Expression\",\r\n      \"attributes\": [],\r\n      \"superTypes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Unite\",\r\n      \"attributes\": [],\r\n      \"superTypes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"ExpressionType\",\r\n      \"attributes\": [],\r\n      \"superTypes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"else\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@2\"\r\n            }\r\n          }\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"then\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@2\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"If\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@8\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"condition\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      \"name\": \"ControlStructure\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@3\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"block\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@2\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"While\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@8\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"block\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@2\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Repeat\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@8\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"time\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Clock\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@12\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"CustomAction\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@3\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"deplacement_value\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"mouvement\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@4\"\r\n            }\r\n          }\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"unite\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@5\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Deplacement\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@12\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"value\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"unite\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@5\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Speed\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@12\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"name\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"primitiveType\": \"string\"\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"type\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@0\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"expression\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      \"name\": \"VarDeclaration\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@3\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"valcall\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@17\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"expression\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Assignation\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@3\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"vardeclaration\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"ReferenceType\",\r\n            \"referenceType\": {\r\n              \"$type\": \"SimpleType\",\r\n              \"typeRef\": {\r\n                \"$ref\": \"#/interfaces@15\"\r\n              }\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      \"name\": \"ValCall\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@4\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"left\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"right\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"operator\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@6\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"BinaryExpression\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@4\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"IntegerValue\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"primitiveType\": \"number\"\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"ConstantInt\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@4\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"arguments\",\r\n          \"type\": {\r\n            \"$type\": \"ArrayType\",\r\n            \"elementType\": {\r\n              \"$type\": \"SimpleType\",\r\n              \"typeRef\": {\r\n                \"$ref\": \"#/interfaces@4\"\r\n              }\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        },\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"procdeclaration\",\r\n          \"isOptional\": true,\r\n          \"type\": {\r\n            \"$type\": \"ReferenceType\",\r\n            \"referenceType\": {\r\n              \"$type\": \"SimpleType\",\r\n              \"typeRef\": {\r\n                \"$ref\": \"#/interfaces@1\"\r\n              }\r\n            }\r\n          }\r\n        }\r\n      ],\r\n      \"name\": \"ProcCall\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@4\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"DistanceCaptor\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@22\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"unite\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@5\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Sensor\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@4\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"value\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"primitiveType\": \"boolean\"\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"ConstantBoolean\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@4\"\r\n        }\r\n      ]\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Addition\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Soustraction\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Multiplication\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Lower\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Equality\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Greater\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"And\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"Or\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@6\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"MM\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@5\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"name\": \"CM\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@5\"\r\n        }\r\n      ],\r\n      \"attributes\": []\r\n    },\r\n    {\r\n      \"$type\": \"Interface\",\r\n      \"attributes\": [\r\n        {\r\n          \"$type\": \"TypeAttribute\",\r\n          \"name\": \"expression\",\r\n          \"type\": {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/interfaces@4\"\r\n            }\r\n          },\r\n          \"isOptional\": false\r\n        }\r\n      ],\r\n      \"name\": \"Return\",\r\n      \"superTypes\": [\r\n        {\r\n          \"$ref\": \"#/interfaces@3\"\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  \"types\": [\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Types\",\r\n      \"type\": {\r\n        \"$type\": \"UnionType\",\r\n        \"types\": [\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@1\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@2\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@3\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Types_Number\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"Number\"\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Types_Void\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"Void\"\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Types_Boolean\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"Boolean\"\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Mouvement\",\r\n      \"type\": {\r\n        \"$type\": \"UnionType\",\r\n        \"types\": [\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@5\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@6\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@7\"\r\n            }\r\n          },\r\n          {\r\n            \"$type\": \"SimpleType\",\r\n            \"typeRef\": {\r\n              \"$ref\": \"#/types@8\"\r\n            }\r\n          }\r\n        ]\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Mouvement_AVANT\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"AVANT\"\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Mouvement_ARRIERE\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"ARRIERE\"\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Mouvement_DROITE\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"DROITE\"\r\n      }\r\n    },\r\n    {\r\n      \"$type\": \"Type\",\r\n      \"name\": \"Mouvement_GAUCHE\",\r\n      \"type\": {\r\n        \"$type\": \"SimpleType\",\r\n        \"stringType\": \"GAUCHE\"\r\n      }\r\n    }\r\n  ],\r\n  \"usedGrammars\": []\r\n}`));\r\n", "/******************************************************************************\r\n * This file was generated by langium-cli 2.1.0.\r\n * DO NOT EDIT MANUALLY!\r\n ******************************************************************************/\r\n\r\nimport type { LangiumGeneratedServices, LangiumGeneratedSharedServices, LangiumSharedServices, LangiumServices, LanguageMetaData, Module } from 'langium';\r\nimport { RobAstReflection } from './ast.js';\r\nimport { RobGrammar } from './grammar.js';\r\n\r\nexport const RobLanguageMetaData = {\r\n    languageId: 'rob',\r\n    fileExtensions: ['.rob'],\r\n    caseInsensitive: false\r\n} as const satisfies LanguageMetaData;\r\n\r\nexport const RobGeneratedSharedModule: Module<LangiumSharedServices, LangiumGeneratedSharedServices> = {\r\n    AstReflection: () => new RobAstReflection()\r\n};\r\n\r\nexport const RobGeneratedModule: Module<LangiumServices, LangiumGeneratedServices> = {\r\n    Grammar: () => RobGrammar(),\r\n    LanguageMetaData: () => RobLanguageMetaData,\r\n    parser: {}\r\n};\r\n", "import type {  ValidationAcceptor, ValidationChecks } from 'langium';\r\nimport type { ProcDeclaration, RobAstType, Robot } from './generated/ast.js';\r\nimport type { RobServices } from './rob-module.js';\r\n/**\r\n * Register custom validation checks.\r\n */\r\nexport function registerValidationChecks(services: RobServices) {\r\n    const registry = services.validation.ValidationRegistry;\r\n    const validator = services.validation.RobValidator;\r\n    const checks: ValidationChecks<RobAstType> = {\r\n        ProcDeclaration: validator.checkFunctionName,\r\n        Robot: validator.checkMainFunction\r\n    };\r\n    registry.register(checks, validator);\r\n}\r\n\r\n/**\r\n * Implementation of custom validations.\r\n */\r\nexport class RobValidator {\r\n    checkFunctionName(functionDeclaration: ProcDeclaration, accept: ValidationAcceptor): void{\r\n        if(!functionDeclaration.name){\r\n            accept('warning', 'Function name should not be empty.', { node: functionDeclaration, property: 'name' });\r\n        }\r\n        const regex = /^[a-zA-Z_][a-zA-Z0-9_]*$/;\r\n        if(!regex.test(functionDeclaration.name)){\r\n            accept('warning', 'Function name should start with a _ or a letter. It should not contains special caracters', \r\n            { node: functionDeclaration, property: 'name' });\r\n        }\r\n    }\r\n\r\n    checkMainFunction(functions: Robot, accept: ValidationAcceptor): void{\r\n        if(!functions.function.find(func => func.name == \"main\")){\r\n            accept('warning', 'There is no main function', { node: functions, property: 'function' });\r\n        }\r\n    }\r\n\r\n}\r\n\r\n", "import type { ValidationAcceptor, ValidationChecks } from 'langium';\nimport type { RobAstType } from '../language/generated/ast.js';\nimport * as InterfaceAST from '../language/generated/ast.js';\nimport * as ClassAST from './visitorNode.js';\nimport { AssignationVisitor, BinaryExpressionVisitor, BlockVisitor, CM, ClockNode, ConstInt, ConstantBooleanVisitor, DeplacementVisitor, DistanceCaptor, IfNode, MM, ProcCallVisitor, ProcDeclarationVisitor, RepeatVisitor, ReturnVisitor, RobotMLVisitor, SpeedNode, ValCallVisitor, VarDeclarationVisitor } from './visitorNode.js';\nimport type { RobServices } from '../language/rob-module.js';\n/**\n * Register custom validation checks.\n * TODO : Call this function in the language module.ts file (see registerValidationChecks(...);)\n */\nexport function weaveAcceptMethods(services: RobServices) {\n    const registry = services.validation.ValidationRegistry;\n    const weaver = new RoboMlAcceptWeaver;\n    registry.register(weaver.checks, weaver);\n}\n\n/**\n * TODO :\n * You must implement a weaving function for each concrete concept of the language.\n * you will also need to fill the check data structure to map the weaving function to the Type of node\n */\nexport class RoboMlAcceptWeaver {\n   weaveRobot(node : InterfaceAST.Robot, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitRobot(node as unknown as ClassAST.RobotVisitor);}\n    }\n\n    weaveProcDeclaration(node : InterfaceAST.ProcDeclaration, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitProcDeclaration(node as unknown as ProcDeclarationVisitor);}\n    }\n\n    weaveBlock(node : InterfaceAST.Block, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitBlock(node as unknown as BlockVisitor);}\n    }\n\n    weaveIf(node : InterfaceAST.If, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitIf(node as unknown as IfNode);}\n    }\n\n    weaveClock(node : InterfaceAST.Clock, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitClock(node as unknown as ClockNode);}\n    }\n\n    weaveConstantInt(node : InterfaceAST.ConstantInt, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitConstInt(node as unknown as ConstInt);}\n    }\n\n    weaveSpeed(node : InterfaceAST.Speed, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitSpeed(node as unknown as SpeedNode);}\n    }\n\n    weaveCM(node : InterfaceAST.CM, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitCM(node as unknown as CM);}\n    }\n\n    weaveMM(node : InterfaceAST.MM, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitMM(node as unknown as MM);}\n    }\n\n    weaveDistanceCaptor(node : InterfaceAST.DistanceCaptor, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitDistanceCaptor(node as unknown as DistanceCaptor);}\n    }\n\n    weaveAssignation(node : InterfaceAST.Assignation, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitAssignation(node as unknown as AssignationVisitor);}\n    }\n\n    weaveValCall(node : InterfaceAST.ValCall, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitValCall(node as unknown as ValCallVisitor);}\n    }\n\n    weaveVarDeclaration(node : InterfaceAST.VarDeclaration, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitVarDeclaration(node as unknown as VarDeclarationVisitor);}\n    }\n\n    weaveConstantBoolean(node : InterfaceAST.ConstantBoolean, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitConstantBoolean(node as unknown as ConstantBooleanVisitor);}\n    }\n\n    weaveDeplacement(node : InterfaceAST.Deplacement, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitDeplacement(node as unknown as DeplacementVisitor);}\n    }\n\n    weaveRepeat(node : InterfaceAST.Repeat, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitRepeat(node as unknown as RepeatVisitor);}\n    }\n    \n    weaveBinaryExpression(node : InterfaceAST.BinaryExpression, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitBinaryExpression(node as unknown as BinaryExpressionVisitor)}\n    }\n\n    weaveProcCall(node : InterfaceAST.ProcCall, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitProcCall(node as unknown as ProcCallVisitor)}\n    }\n\n    weaveReturn(node : InterfaceAST.Return, accept : ValidationAcceptor) : void{\n        (<any> node).accept = (visitor: RobotMLVisitor) => {return visitor.visitReturn(node as unknown as ReturnVisitor)}\n    }\n\n    checks: ValidationChecks<RobAstType> = {\n        Robot : this.weaveRobot,\n        ProcDeclaration : this.weaveProcDeclaration,\n        Block : this.weaveBlock,\n        If : this.weaveIf,\n        Clock : this.weaveClock,\n        ConstantInt : this.weaveConstantInt,\n        Speed : this.weaveSpeed,\n        CM : this.weaveCM,\n        MM : this.weaveMM,\n        DistanceCaptor : this.weaveDistanceCaptor,\n        Assignation : this.weaveAssignation,\n        ValCall : this.weaveValCall,\n        VarDeclaration : this.weaveVarDeclaration,\n        ConstantBoolean : this.weaveConstantBoolean,\n        Deplacement : this.weaveDeplacement,\n        Repeat : this.weaveRepeat,\n        BinaryExpression : this.weaveBinaryExpression,\n        ProcCall : this.weaveProcCall,\n        Return : this.weaveReturn,\n    };\n\n}\n", "import type { DefaultSharedModuleContext, LangiumServices, LangiumSharedServices, Module, PartialLangiumServices } from 'langium';\r\nimport { createDefaultModule, createDefaultSharedModule, inject } from 'langium';\r\nimport { RobGeneratedModule, RobGeneratedSharedModule } from './generated/module.js';\r\nimport { RobValidator, registerValidationChecks } from './rob-validator.js';\r\nimport { weaveAcceptMethods } from '../semantics/accept-weaver.js';\r\n\r\n/**\r\n * Declaration of custom services - add your own service classes here.\r\n */\r\nexport type RobAddedServices = {\r\n    validation: {\r\n        RobValidator: RobValidator\r\n    }\r\n}\r\n\r\n/**\r\n * Union of Langium default services and your custom services - use this as constructor parameter\r\n * of custom service classes.\r\n */\r\nexport type RobServices = LangiumServices & RobAddedServices\r\n\r\n/**\r\n * Dependency injection module that overrides Langium default services and contributes the\r\n * declared custom services. The Langium defaults can be partially specified to override only\r\n * selected services, while the custom services must be fully specified.\r\n */\r\nexport const RobModule: Module<RobServices, PartialLangiumServices & RobAddedServices> = {\r\n    validation: {\r\n        RobValidator: () => new RobValidator()\r\n    }\r\n};\r\n\r\n/**\r\n * Create the full set of services required by Langium.\r\n *\r\n * First inject the shared services by merging two modules:\r\n *  - Langium default shared services\r\n *  - Services generated by langium-cli\r\n *\r\n * Then inject the language-specific services by merging three modules:\r\n *  - Langium default language-specific services\r\n *  - Services generated by langium-cli\r\n *  - Services specified in this file\r\n *\r\n * @param context Optional module context with the LSP connection\r\n * @returns An object wrapping the shared services and the language-specific services\r\n */\r\nexport function createRobServices(context: DefaultSharedModuleContext): {\r\n    shared: LangiumSharedServices,\r\n    Rob: RobServices\r\n} {\r\n    const shared = inject(\r\n        createDefaultSharedModule(context),\r\n        RobGeneratedSharedModule\r\n    );\r\n    const Rob = inject(\r\n        createDefaultModule({ shared }),\r\n        RobGeneratedModule,\r\n        RobModule\r\n    );\r\n    shared.ServiceRegistry.register(Rob);\r\n    registerValidationChecks(Rob);\r\n    weaveAcceptMethods(Rob);\r\n    return { shared, Rob };\r\n}\r\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["exports", "require_is", "exports", "exports", "ErrorCodes", "ResponseError", "Message", "exports", "Touch", "_a", "exports", "Disposable", "exports", "RAL", "exports", "Event", "Emitter", "exports", "Is", "CancellationToken", "CancellationTokenSource", "exports", "CancellationState", "exports", "reject", "exports", "Is", "MessageReader", "ResolvedMessageReaderOptions", "exports", "Is", "MessageWriter", "ResolvedMessageWriterOptions", "exports", "result", "exports", "Is", "CancelNotification", "ProgressToken", "ProgressNotification", "StarRequestHandler", "Trace", "TraceValues", "toString", "TraceFormat", "SetTraceNotification", "LogTraceNotification", "ConnectionErrors", "ConnectionStrategy", "IdCancellationReceiverStrategy", "RequestCancellationReceiverStrategy", "CancellationReceiverStrategy", "_", "CancellationSenderStrategy", "CancellationStrategy", "MessageStrategy", "ConnectionOptions", "ConnectionState", "timer", "startTime", "connection", "first", "last", "reject", "exports", "exports", "stream", "reject", "RIL", "exports", "process", "reject", "exports", "module", "require_main", "exports", "module", "require", "DocumentUri", "URI", "integer", "uinteger", "Position", "Is", "Range", "Location", "LocationLink", "Color", "ColorInformation", "ColorPresentation", "TextEdit", "FoldingRangeKind", "FoldingRange", "DiagnosticRelatedInformation", "DiagnosticSeverity", "DiagnosticTag", "CodeDescription", "Diagnostic", "Command", "ChangeAnnotation", "ChangeAnnotationIdentifier", "AnnotatedTextEdit", "TextDocumentEdit", "OptionalVersionedTextDocumentIdentifier", "CreateFile", "RenameFile", "DeleteFile", "WorkspaceEdit", "TextEditChangeImpl", "ChangeAnnotations", "WorkspaceChange", "TextDocumentIdentifier", "VersionedTextDocumentIdentifier", "TextDocumentItem", "MarkupKind", "MarkupContent", "CompletionItemKind", "InsertTextFormat", "CompletionItemTag", "InsertReplaceEdit", "InsertTextMode", "CompletionItemLabelDetails", "CompletionItem", "CompletionList", "MarkedString", "Hover", "ParameterInformation", "SignatureInformation", "DocumentHighlightKind", "DocumentHighlight", "SymbolKind", "SymbolTag", "SymbolInformation", "WorkspaceSymbol", "DocumentSymbol", "CodeActionKind", "CodeActionTriggerKind", "CodeActionContext", "CodeAction", "CodeLens", "FormattingOptions", "DocumentLink", "SelectionRange", "SemanticTokenTypes", "SemanticTokenModifiers", "SemanticTokens", "InlineValueText", "InlineValueVariableLookup", "InlineValueEvaluatableExpression", "InlineValueContext", "InlayHintKind", "InlayHintLabelPart", "InlayHint", "StringValue", "InlineCompletionItem", "InlineCompletionList", "InlineCompletionTriggerKind", "SelectedCompletionInfo", "InlineCompletionContext", "WorkspaceFolder", "TextDocument", "FullTextDocument", "mergeSort", "a", "toString", "undefined", "min", "require_messages", "exports", "MessageDirection", "require_is", "exports", "exports", "ImplementationRequest", "exports", "TypeDefinitionRequest", "exports", "WorkspaceFoldersRequest", "DidChangeWorkspaceFoldersNotification", "exports", "ConfigurationRequest", "exports", "DocumentColorRequest", "ColorPresentationRequest", "exports", "FoldingRangeRequest", "FoldingRangeRefreshRequest", "exports", "DeclarationRequest", "exports", "SelectionRangeRequest", "exports", "WorkDoneProgress", "WorkDoneProgressCreateRequest", "WorkDoneProgressCancelNotification", "exports", "CallHierarchyPrepareRequest", "CallHierarchyIncomingCallsRequest", "CallHierarchyOutgoingCallsRequest", "exports", "TokenFormat", "SemanticTokensRegistrationType", "SemanticTokensRequest", "SemanticTokensDeltaRequest", "SemanticTokensRangeRequest", "SemanticTokensRefreshRequest", "exports", "ShowDocumentRequest", "exports", "LinkedEditingRangeRequest", "exports", "FileOperationPatternKind", "WillCreateFilesRequest", "DidCreateFilesNotification", "WillRenameFilesRequest", "DidRenameFilesNotification", "DidDeleteFilesNotification", "WillDeleteFilesRequest", "exports", "UniquenessLevel", "MonikerKind", "MonikerRequest", "exports", "TypeHierarchyPrepareRequest", "TypeHierarchySupertypesRequest", "TypeHierarchySubtypesRequest", "exports", "InlineValueRequest", "InlineValueRefreshRequest", "exports", "InlayHintRequest", "InlayHintResolveRequest", "InlayHintRefreshRequest", "exports", "Is", "DiagnosticServerCancellationData", "DocumentDiagnosticReportKind", "DocumentDiagnosticRequest", "WorkspaceDiagnosticRequest", "DiagnosticRefreshRequest", "exports", "Is", "NotebookCellKind", "ExecutionSummary", "NotebookCell", "NotebookDocument", "NotebookDocumentSyncRegistrationType", "DidOpenNotebookDocumentNotification", "NotebookCellArrayChange", "DidChangeNotebookDocumentNotification", "DidSaveNotebookDocumentNotification", "DidCloseNotebookDocumentNotification", "exports", "InlineCompletionRequest", "exports", "Is", "TextDocumentFilter", "NotebookDocumentFilter", "NotebookCellTextDocumentFilter", "DocumentSelector", "RegistrationRequest", "UnregistrationRequest", "ResourceOperationKind", "FailureHandlingKind", "PositionEncodingKind", "StaticRegistrationOptions", "TextDocumentRegistrationOptions", "WorkDoneProgressOptions", "InitializeRequest", "InitializeErrorCodes", "InitializedNotification", "ShutdownRequest", "ExitNotification", "DidChangeConfigurationNotification", "MessageType", "ShowMessageNotification", "ShowMessageRequest", "LogMessageNotification", "TelemetryEventNotification", "TextDocumentSyncKind", "DidOpenTextDocumentNotification", "TextDocumentContentChangeEvent", "DidChangeTextDocumentNotification", "DidCloseTextDocumentNotification", "DidSaveTextDocumentNotification", "TextDocumentSaveReason", "WillSaveTextDocumentNotification", "WillSaveTextDocumentWaitUntilRequest", "DidChangeWatchedFilesNotification", "FileChangeType", "RelativePattern", "WatchKind", "PublishDiagnosticsNotification", "CompletionTriggerKind", "CompletionRequest", "CompletionResolveRequest", "HoverRequest", "SignatureHelpTriggerKind", "SignatureHelpRequest", "DefinitionRequest", "ReferencesRequest", "DocumentHighlightRequest", "DocumentSymbolRequest", "CodeActionRequest", "CodeActionResolveRequest", "WorkspaceSymbolRequest", "WorkspaceSymbolResolveRequest", "CodeLensRequest", "CodeLensResolveRequest", "CodeLensRefreshRequest", "DocumentLinkRequest", "DocumentLinkResolveRequest", "DocumentFormattingRequest", "DocumentRangeFormattingRequest", "DocumentRangesFormattingRequest", "DocumentOnTypeFormattingRequest", "PrepareSupportDefaultBehavior", "RenameRequest", "PrepareRenameRequest", "ExecuteCommandRequest", "ApplyWorkspaceEditRequest", "require_connection", "exports", "require_api", "exports", "LSPErrorCodes", "require_main", "exports", "exports", "exports", "connection", "ResultProgress", "exports", "Is", "exports", "exports", "exports", "SemanticTokensBuilder", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "exports", "TextDocuments", "connection", "exports", "connection", "change", "exports", "exports", "Is", "connection", "BulkRegistration", "BulkUnregistration", "one", "two", "createConnection", "reject", "result", "exports", "fs", "first", "resolve", "reject", "message", "FileSystem", "require_node", "exports", "module", "exports", "require_api", "exports", "ProposedFeatures", "require_main", "exports", "Is", "Files", "createConnection", "require_node", "exports", "module", "import_vscode_languageserver", "TextDocument", "a", "stream", "root", "Reduction", "a", "min", "RangeComparison", "last", "a", "module", "_", "a", "values", "property", "root", "reflection", "property", "_a", "min", "property", "toString", "property", "isReferenceType", "isArrayType", "isUnionType", "UnionType", "toString", "map", "property", "optional", "a", "values", "superType", "a", "isArrayType", "newState", "atom", "process", "assertPath", "path", "TypeError", "JSON", "stringify", "normalizeStringPosix", "allowAboveRoot", "code", "res", "lastSegmentLength", "lastSlash", "dots", "i", "length", "charCodeAt", "lastSlashIndex", "lastIndexOf", "slice", "posix", "resolve", "cwd", "resolvedPath", "resolvedAbsolute", "arguments", "process", "normalize", "isAbsolute", "trailingSeparator", "join", "joined", "arg", "relative", "from", "to", "fromStart", "fromEnd", "fromLen", "toStart", "toLen", "lastCommonSep", "fromCode", "out", "_makeLong", "dirname", "hasRoot", "end", "matchedSlash", "basename", "ext", "start", "extIdx", "firstNonSlashEnd", "extname", "startDot", "startPart", "preDotState", "format", "pathObject", "sep", "dir", "root", "base", "name", "parse", "ret", "delimiter", "win32", "module", "exports", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "d", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "isWindows", "platform", "navigator", "userAgent", "indexOf", "_schemePattern", "_singleSlashStart", "_doubleSlashStart", "_validateUri", "_strict", "scheme", "Error", "authority", "query", "fragment", "test", "_empty", "_slash", "_regexp", "URI", "schemeOrData", "this", "thing", "fsPath", "with", "toString", "uriToFsPath", "change", "Uri", "match", "exec", "percentDecode", "replace", "idx", "substring", "components", "result", "skipEncoding", "_asFormatted", "toJSON", "data", "_formatted", "external", "_fsPath", "_sep", "_pathSepMarker", "$mid", "encodeTable", "encodeURIComponentFast", "uriComponent", "isPath", "isAuthority", "nativeEncodePos", "pos", "encodeURIComponent", "charAt", "substr", "escaped", "encodeURIComponentMinimal", "uri", "keepDriveLetterCasing", "toLowerCase", "encoder", "userinfo", "String", "fromCharCode", "decodeURIComponentGraceful", "str", "decodeURIComponent", "e", "_rEncodedAsHex", "A", "posixPath", "slash", "Utils", "t", "joinPath", "paths", "resolvePath", "slashAdded", "UriUtils", "a", "DocumentUri", "URI", "integer", "uinteger", "Position", "Range", "Location", "LocationLink", "Color", "ColorInformation", "ColorPresentation", "FoldingRangeKind", "FoldingRange", "DiagnosticRelatedInformation", "DiagnosticSeverity", "DiagnosticTag", "CodeDescription", "Diagnostic", "Command", "TextEdit", "ChangeAnnotation", "ChangeAnnotationIdentifier", "AnnotatedTextEdit", "TextDocumentEdit", "CreateFile", "RenameFile", "DeleteFile", "WorkspaceEdit", "TextDocumentIdentifier", "VersionedTextDocumentIdentifier", "OptionalVersionedTextDocumentIdentifier", "TextDocumentItem", "MarkupKind", "MarkupContent", "CompletionItemKind", "InsertTextFormat", "CompletionItemTag", "InsertReplaceEdit", "InsertTextMode", "CompletionItemLabelDetails", "CompletionItem", "CompletionList", "MarkedString", "Hover", "ParameterInformation", "SignatureInformation", "DocumentHighlightKind", "DocumentHighlight", "SymbolKind", "SymbolTag", "SymbolInformation", "WorkspaceSymbol", "DocumentSymbol", "CodeActionKind", "CodeActionTriggerKind", "CodeActionContext", "CodeAction", "CodeLens", "FormattingOptions", "DocumentLink", "SelectionRange", "SemanticTokenTypes", "SemanticTokenModifiers", "SemanticTokens", "InlineValueText", "InlineValueVariableLookup", "InlineValueEvaluatableExpression", "InlineValueContext", "InlayHintKind", "InlayHintLabelPart", "InlayHint", "StringValue", "InlineCompletionItem", "InlineCompletionList", "InlineCompletionTriggerKind", "SelectedCompletionInfo", "InlineCompletionContext", "WorkspaceFolder", "URI", "TextDocument", "FullTextDocument", "mergeSort", "a", "Is", "toString", "undefined", "min", "integer", "uinteger", "ValidationCategory", "value", "isPrimitiveType", "UnionType", "property", "first", "second", "IssueCodes", "grammar", "map", "isDataType", "property", "isPrimitiveType", "isStringType", "type", "isStringType", "negate", "isPrimitiveType", "root", "optional", "property", "isPrimitiveType", "first", "a", "isDataType", "property", "isUnionType", "import_vscode_jsonrpc", "exports", "exports", "import_vscode_languageserver", "DocumentValidator", "import_vscode_languageserver", "plus", "option", "isDataTypeNode", "import_vscode_languageserver", "root", "node", "map", "last", "root", "a", "Formatting", "import_vscode_languageserver", "import_vscode_languageserver", "BaseSemanticTokensBuilder", "a", "root", "SemanticTokensDecoder", "a", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "DocumentState", "import_vscode_languageserver", "option", "_a", "connection", "services", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "import_vscode_languageserver", "node", "inferred", "map", "isReferenceType", "isUnionType", "a", "isArrayType", "shared", "property", "first", "Symbol", "objectProto", "nativeObjectToString", "symToStringTag", "INFINITY", "funcProto", "objectProto", "funcToString", "hasOwnProperty", "objectProto", "hasOwnProperty", "MAX_SAFE_INTEGER", "objectProto", "objectProto", "hasOwnProperty", "Buffer", "argsTag", "funcTag", "freeExports", "freeModule", "moduleExports", "objectProto", "hasOwnProperty", "isType", "objectProto", "hasOwnProperty", "objectProto", "hasOwnProperty", "objectProto", "hasOwnProperty", "objectProto", "hasOwnProperty", "objectProto", "hasOwnProperty", "HASH_UNDEFINED", "Map", "map", "toString", "INFINITY", "values", "freeExports", "freeModule", "moduleExports", "Buffer", "objectProto", "propertyIsEnumerable", "nativeGetSymbols", "Promise", "Set", "mapTag", "objectTag", "setTag", "weakMapTag", "dataViewTag", "objectProto", "hasOwnProperty", "Uint8Array", "symbolProto", "boolTag", "dateTag", "mapTag", "numberTag", "regexpTag", "setTag", "stringTag", "symbolTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "mapTag", "setTag", "argsTag", "arrayTag", "boolTag", "dateTag", "errorTag", "funcTag", "genTag", "mapTag", "numberTag", "objectTag", "regexpTag", "setTag", "stringTag", "symbolTag", "weakMapTag", "arrayBufferTag", "dataViewTag", "float32Tag", "float64Tag", "int8Tag", "int16Tag", "int32Tag", "uint8Tag", "uint8ClampedTag", "uint16Tag", "uint32Tag", "key", "CLONE_SYMBOLS_FLAG", "HASH_UNDEFINED", "values", "othValue", "map", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "boolTag", "dateTag", "errorTag", "mapTag", "numberTag", "regexpTag", "setTag", "stringTag", "symbolTag", "arrayBufferTag", "dataViewTag", "symbolProto", "symbolValueOf", "COMPARE_PARTIAL_FLAG", "objectProto", "hasOwnProperty", "COMPARE_PARTIAL_FLAG", "argsTag", "arrayTag", "objectTag", "objectProto", "hasOwnProperty", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "COMPARE_PARTIAL_FLAG", "COMPARE_UNORDERED_FLAG", "collection", "objectProto", "hasOwnProperty", "LARGE_ARRAY_SIZE", "values", "includes", "values", "collection", "collection", "nativeMax", "collection", "objectProto", "hasOwnProperty", "objectProto", "hasOwnProperty", "stringTag", "nativeMax", "nativeMax", "mapTag", "setTag", "objectProto", "hasOwnProperty", "regexpTag", "FUNC_ERROR_TEXT", "collection", "collection", "INFINITY", "values", "LARGE_ARRAY_SIZE", "includes", "visitor", "atom", "map", "LexerDefinitionErrorType", "msg", "currConfig", "tokenLabel", "hasTokenLabel", "hasTokenLabel", "hasTokenLabel", "tokenLabel", "getExtraProductionArgument", "PROD_TYPE", "tokenMatcher", "keys", "prefixKeys", "visitor", "collectorVisitor", "option", "alternation", "resolveGrammar", "validateGrammar", "alternation", "repetition", "option", "repetitionMandatory", "CstVisitorDefinitionError", "newState", "allTokenTypes", "invokeRuleWithTry", "newState", "ParserDefinitionErrorType", "resolveGrammar", "validateGrammar", "repetition", "alternation", "option", "block", "plus", "star", "optional", "getProdType", "first", "last", "a", "map", "closure", "newState", "tokenLabel", "getProductionDslName", "last", "_", "a", "import_vscode_languageserver", "property", "root", "property", "import_vscode_languageserver", "property", "import_vscode_languageserver", "import_vscode_languageserver", "_a", "exports", "import_vscode_languageserver", "import_vscode_languageserver", "first", "last", "option", "Disposable", "import_node", "reflection", "registerValidationChecks", "visitor", "shared", "registerValidationChecks"]
}

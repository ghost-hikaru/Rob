/******************************************************************************
 * This file was generated by langium-cli 2.1.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/
import { AbstractAstReflection } from 'langium';
export const RobTerminals = {
    ID: /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/,
    INT: /[0-9]+/,
    STRING: /(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/,
    ML_COMMENT: /(\/\*([\s\S]*?\*\/))/,
    SL_COMMENT: /(\/\/((?!(\n|\r))[\s\S]*?)(\r?\n)?)/,
    WS: /((( |	)|\r)|\n)+/,
};
export function isEBoolean(item) {
    return typeof item === 'boolean';
}
export function isEInt(item) {
    return typeof item === 'number';
}
export function isEString(item) {
    return (typeof item === 'string' && (/(("((\\([\s\S]))|((?!(\\|"))[\s\S]*?))*")|('((\\([\s\S]))|((?!(\\|'))[\s\S]*?))*'))/.test(item) || /(\^?(([a-z]|[A-Z])|_)((([a-z]|[A-Z])|_)|[0-9])*)/.test(item)));
}
export const Expression = 'Expression';
export function isExpression(item) {
    return reflection.isInstance(item, Expression);
}
export const ExpressionType = 'ExpressionType';
export function isExpressionType(item) {
    return reflection.isInstance(item, ExpressionType);
}
export const ProcDeclaration = 'ProcDeclaration';
export function isProcDeclaration(item) {
    return reflection.isInstance(item, ProcDeclaration);
}
export const Robot = 'Robot';
export function isRobot(item) {
    return reflection.isInstance(item, Robot);
}
export const Statement = 'Statement';
export function isStatement(item) {
    return reflection.isInstance(item, Statement);
}
export const Unite = 'Unite';
export function isUnite(item) {
    return reflection.isInstance(item, Unite);
}
export const BinaryExpression = 'BinaryExpression';
export function isBinaryExpression(item) {
    return reflection.isInstance(item, BinaryExpression);
}
export const ConstantBoolean = 'ConstantBoolean';
export function isConstantBoolean(item) {
    return reflection.isInstance(item, ConstantBoolean);
}
export const ConstantInt = 'ConstantInt';
export function isConstantInt(item) {
    return reflection.isInstance(item, ConstantInt);
}
export const ProcCall = 'ProcCall';
export function isProcCall(item) {
    return reflection.isInstance(item, ProcCall);
}
export const Sensor = 'Sensor';
export function isSensor(item) {
    return reflection.isInstance(item, Sensor);
}
export const ValCall = 'ValCall';
export function isValCall(item) {
    return reflection.isInstance(item, ValCall);
}
export const Addition = 'Addition';
export function isAddition(item) {
    return reflection.isInstance(item, Addition);
}
export const And = 'And';
export function isAnd(item) {
    return reflection.isInstance(item, And);
}
export const Greater = 'Greater';
export function isGreater(item) {
    return reflection.isInstance(item, Greater);
}
export const Lower = 'Lower';
export function isLower(item) {
    return reflection.isInstance(item, Lower);
}
export const Multiplication = 'Multiplication';
export function isMultiplication(item) {
    return reflection.isInstance(item, Multiplication);
}
export const Or = 'Or';
export function isOr(item) {
    return reflection.isInstance(item, Or);
}
export const Soustraction = 'Soustraction';
export function isSoustraction(item) {
    return reflection.isInstance(item, Soustraction);
}
export const Assignation = 'Assignation';
export function isAssignation(item) {
    return reflection.isInstance(item, Assignation);
}
export const Block = 'Block';
export function isBlock(item) {
    return reflection.isInstance(item, Block);
}
export const ControlStructure = 'ControlStructure';
export function isControlStructure(item) {
    return reflection.isInstance(item, ControlStructure);
}
export const CustomAction = 'CustomAction';
export function isCustomAction(item) {
    return reflection.isInstance(item, CustomAction);
}
export const VarDeclaration = 'VarDeclaration';
export function isVarDeclaration(item) {
    return reflection.isInstance(item, VarDeclaration);
}
export const CM = 'CM';
export function isCM(item) {
    return reflection.isInstance(item, CM);
}
export const MM = 'MM';
export function isMM(item) {
    return reflection.isInstance(item, MM);
}
export const DistanceCaptor = 'DistanceCaptor';
export function isDistanceCaptor(item) {
    return reflection.isInstance(item, DistanceCaptor);
}
export const If = 'If';
export function isIf(item) {
    return reflection.isInstance(item, If);
}
export const Repeat = 'Repeat';
export function isRepeat(item) {
    return reflection.isInstance(item, Repeat);
}
export const While = 'While';
export function isWhile(item) {
    return reflection.isInstance(item, While);
}
export const Clock = 'Clock';
export function isClock(item) {
    return reflection.isInstance(item, Clock);
}
export const Deplacement = 'Deplacement';
export function isDeplacement(item) {
    return reflection.isInstance(item, Deplacement);
}
export const Speed = 'Speed';
export function isSpeed(item) {
    return reflection.isInstance(item, Speed);
}
export class RobAstReflection extends AbstractAstReflection {
    getAllTypes() {
        return ['Addition', 'And', 'Assignation', 'BinaryExpression', 'Block', 'CM', 'Clock', 'ConstantBoolean', 'ConstantInt', 'ControlStructure', 'CustomAction', 'Deplacement', 'DistanceCaptor', 'Expression', 'ExpressionType', 'Greater', 'If', 'Lower', 'MM', 'Multiplication', 'Or', 'ProcCall', 'ProcDeclaration', 'Repeat', 'Robot', 'Sensor', 'Soustraction', 'Speed', 'Statement', 'Unite', 'ValCall', 'VarDeclaration', 'While'];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case Addition:
            case And:
            case Greater:
            case Lower:
            case Multiplication:
            case Or:
            case Soustraction: {
                return this.isSubtype(ExpressionType, supertype);
            }
            case Assignation:
            case Block:
            case ControlStructure:
            case CustomAction:
            case VarDeclaration: {
                return this.isSubtype(Statement, supertype);
            }
            case BinaryExpression:
            case ConstantBoolean:
            case ConstantInt:
            case ProcCall:
            case Sensor:
            case ValCall: {
                return this.isSubtype(Expression, supertype);
            }
            case Clock:
            case Deplacement:
            case Speed: {
                return this.isSubtype(CustomAction, supertype);
            }
            case CM:
            case MM: {
                return this.isSubtype(Unite, supertype);
            }
            case DistanceCaptor: {
                return this.isSubtype(Sensor, supertype);
            }
            case If:
            case Repeat:
            case While: {
                return this.isSubtype(ControlStructure, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'ProcCall:procdeclaration': {
                return ProcDeclaration;
            }
            case 'ValCall:vardeclaration': {
                return VarDeclaration;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case 'Robot': {
                return {
                    name: 'Robot',
                    mandatory: [
                        { name: 'function', type: 'array' }
                    ]
                };
            }
            case 'ConstantBoolean': {
                return {
                    name: 'ConstantBoolean',
                    mandatory: [
                        { name: 'value', type: 'boolean' }
                    ]
                };
            }
            case 'ProcCall': {
                return {
                    name: 'ProcCall',
                    mandatory: [
                        { name: 'arguments', type: 'array' }
                    ]
                };
            }
            case 'Block': {
                return {
                    name: 'Block',
                    mandatory: [
                        { name: 'statements', type: 'array' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    mandatory: []
                };
            }
        }
    }
}
export const reflection = new RobAstReflection();
//# sourceMappingURL=ast.js.map